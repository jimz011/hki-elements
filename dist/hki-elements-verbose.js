// HKI Elements Bundle
// A collection of custom Home Assistant cards by Jimz011

console.info(
  '%c HKI-ELEMENTS %c v1.4.0-dev-26 ',
  'color: white; background: #7017b8; font-weight: bold;',
  'color: #7017b8; background: white; font-weight: bold;'
);

// Import Lit once for all cards
import { LitElement, html, css } from "https://unpkg.com/lit@2.8.0/index.js?module";

// Make Lit available globally for cards that use dynamic loading
if (!window.LitElement) {
  window.LitElement = LitElement;
  window.html = html;
  window.css = css;
}

// HKI shared helpers (load once, reuse across cards)
window.HKI = window.HKI || {};

// Shared popup-related keys used across cards/editors.
window.HKI.POPUP_CONFIG_KEYS = window.HKI.POPUP_CONFIG_KEYS || [
  "custom_popup_enabled",
  "custom_popup_card",
  "popup_name",
  "popup_state",
  "popup_icon",
  "popup_use_entity_picture",
  "popup_border_radius",
  "popup_width",
  "popup_width_custom",
  "popup_height",
  "popup_height_custom",
  "popup_open_animation",
  "popup_close_animation",
  "popup_animation_duration",
  "popup_blur_enabled",
  "popup_blur_amount",
  "popup_card_blur_enabled",
  "popup_card_blur_amount",
  "popup_card_opacity",
  "popup_show_favorites",
  "popup_show_effects",
  "popup_show_presets",
  "popup_slider_radius",
  "popup_hide_button_text",
  "popup_value_font_size",
  "popup_value_font_weight",
  "popup_label_font_size",
  "popup_label_font_weight",
  "popup_time_format",
  "popup_default_view",
  "popup_default_section",
  "popup_highlight_color",
  "popup_highlight_text_color",
  "popup_highlight_radius",
  "popup_highlight_opacity",
  "popup_highlight_border_color",
  "popup_highlight_border_style",
  "popup_highlight_border_width",
  "popup_highlight_box_shadow",
  "popup_button_bg",
  "popup_button_text_color",
  "popup_button_radius",
  "popup_button_opacity",
  "popup_button_border_color",
  "popup_button_border_style",
  "popup_button_border_width",
  "popup_bottom_bar_entities",
  "popup_bottom_bar_align",
  "popup_hide_bottom_bar",
  "popup_hide_top_bar",
  "popup_show_close_button",
  "popup_close_on_action",
  "_bb_slots",
  "person_geocoded_entity",
  "sensor_graph_color",
  "sensor_graph_gradient",
  "sensor_line_width",
  "sensor_hours",
  "sensor_graph_style",
  "climate_temp_step",
  "climate_use_circular_slider",
  "climate_show_plus_minus",
  "climate_show_gradient",
  "climate_show_target_range",
  "climate_humidity_entity",
  "climate_humidity_name",
  "climate_pressure_entity",
  "climate_pressure_name",
  "climate_current_temperature_entity",
  "climate_temperature_name",
  "humidifier_humidity_step",
  "humidifier_use_circular_slider",
  "humidifier_show_plus_minus",
  "humidifier_show_gradient",
  "humidifier_fan_entity",
];

window.HKI.copyDefinedKeys = window.HKI.copyDefinedKeys || (({
  src,
  dst,
  keys,
  srcPrefix = "",
  dstPrefix = "",
  onlyIfDstMissing = false,
} = {}) => {
  if (!src || !dst || !Array.isArray(keys)) return dst;
  keys.forEach((k) => {
    const srcKey = `${srcPrefix}${k}`;
    const dstKey = `${dstPrefix}${k}`;
    if (src[srcKey] === undefined) return;
    if (onlyIfDstMissing && dst[dstKey] !== undefined) return;
    dst[dstKey] = src[srcKey];
  });
  return dst;
});

// Shared popup editor option lists to reduce duplication across card editors.
window.HKI.POPUP_EDITOR_OPTIONS = window.HKI.POPUP_EDITOR_OPTIONS || Object.freeze({
  animations: Object.freeze([
    Object.freeze({ value: "none", label: "None" }),
    Object.freeze({ value: "fade", label: "Fade" }),
    Object.freeze({ value: "scale", label: "Scale" }),
    Object.freeze({ value: "zoom", label: "Zoom" }),
    Object.freeze({ value: "slide-up", label: "Slide Up" }),
    Object.freeze({ value: "slide-down", label: "Slide Down" }),
    Object.freeze({ value: "slide-left", label: "Slide Left" }),
    Object.freeze({ value: "slide-right", label: "Slide Right" }),
    Object.freeze({ value: "flip", label: "Flip" }),
    Object.freeze({ value: "bounce", label: "Bounce" }),
    Object.freeze({ value: "rotate", label: "Rotate" }),
    Object.freeze({ value: "drop", label: "Drop" }),
    Object.freeze({ value: "swing", label: "Swing" }),
  ]),
  width: Object.freeze([
    Object.freeze({ value: "auto", label: "Auto (Responsive)" }),
    Object.freeze({ value: "default", label: "Default (400px)" }),
    Object.freeze({ value: "custom", label: "Custom" }),
  ]),
  height: Object.freeze([
    Object.freeze({ value: "auto", label: "Auto (Responsive)" }),
    Object.freeze({ value: "default", label: "Default (600px)" }),
    Object.freeze({ value: "custom", label: "Custom" }),
  ]),
  timeFormats: Object.freeze([
    Object.freeze({ value: "auto", label: "Auto" }),
    Object.freeze({ value: "12", label: "12-Hour Clock" }),
    Object.freeze({ value: "24", label: "24-Hour Clock" }),
  ]),
});

// Shared editor option lists across HKI card editors.
window.HKI.EDITOR_OPTIONS = window.HKI.EDITOR_OPTIONS || Object.freeze({
  borderStyles: Object.freeze([
    Object.freeze({ value: "solid", label: "solid" }),
    Object.freeze({ value: "dashed", label: "dashed" }),
    Object.freeze({ value: "dotted", label: "dotted" }),
    Object.freeze({ value: "double", label: "double" }),
    Object.freeze({ value: "none", label: "none" }),
  ]),
  buttonActionOptions: Object.freeze([
    Object.freeze({ value: "toggle", label: "Toggle" }),
    Object.freeze({ value: "hki-more-info", label: "More Info (HKI)" }),
    Object.freeze({ value: "more-info", label: "More Info (Native)" }),
    Object.freeze({ value: "navigate", label: "Navigate" }),
    Object.freeze({ value: "perform-action", label: "Perform Action" }),
    Object.freeze({ value: "url", label: "URL" }),
    Object.freeze({ value: "fire-dom-event", label: "Fire DOM Event" }),
    Object.freeze({ value: "none", label: "None" }),
  ]),
  headerActionOptions: Object.freeze([
    Object.freeze({ value: "none", label: "None" }),
    Object.freeze({ value: "navigate", label: "Navigate" }),
    Object.freeze({ value: "back", label: "Back" }),
    Object.freeze({ value: "menu", label: "Toggle Menu" }),
    Object.freeze({ value: "url", label: "Open URL" }),
    Object.freeze({ value: "more-info", label: "More Info" }),
    Object.freeze({ value: "hki-more-info", label: "HKI More Info" }),
    Object.freeze({ value: "toggle", label: "Toggle Entity" }),
    Object.freeze({ value: "perform-action", label: "Perform Action" }),
    Object.freeze({ value: "fire-dom-event", label: "Fire DOM Event" }),
  ]),
  popupBottomBarActionOptions: Object.freeze([
    Object.freeze({ value: "toggle", label: "Toggle" }),
    Object.freeze({ value: "more-info", label: "More Info" }),
    Object.freeze({ value: "hki-more-info", label: "HKI More Info" }),
    Object.freeze({ value: "navigate", label: "Navigate" }),
    Object.freeze({ value: "perform-action", label: "Perform Action" }),
    Object.freeze({ value: "fire-dom-event", label: "Fire DOM Event" }),
    Object.freeze({ value: "url", label: "URL" }),
    Object.freeze({ value: "none", label: "None" }),
  ]),
  popupDefaultViewOptions: Object.freeze([
    Object.freeze({ value: "main", label: "Main (Group Controls)" }),
    Object.freeze({ value: "individual", label: "Individual Entities" }),
  ]),
  popupDefaultSectionOptions: Object.freeze([
    Object.freeze({ value: "last", label: "Last Used" }),
    Object.freeze({ value: "brightness", label: "Always Brightness" }),
    Object.freeze({ value: "color", label: "Always Color" }),
    Object.freeze({ value: "temperature", label: "Always Temperature" }),
  ]),
  popupDefaultSectionOptionsTagged: Object.freeze([
    Object.freeze({ value: "last", label: "Last Used (Default)" }),
    Object.freeze({ value: "brightness", label: "Always Brightness" }),
    Object.freeze({ value: "color", label: "Always Color" }),
    Object.freeze({ value: "temperature", label: "Always Temperature" }),
  ]),
  popupBottomBarAlignOptions: Object.freeze([
    Object.freeze({ value: "spread", label: "Spread" }),
    Object.freeze({ value: "start", label: "Start" }),
    Object.freeze({ value: "center", label: "Center" }),
    Object.freeze({ value: "end", label: "End" }),
  ]),
  popupBottomBarAlignOptionsDetailed: Object.freeze([
    Object.freeze({ value: "spread", label: "Spread (space around)" }),
    Object.freeze({ value: "start", label: "Start (left aligned)" }),
    Object.freeze({ value: "center", label: "Center" }),
    Object.freeze({ value: "end", label: "End (right aligned)" }),
  ]),
});

// Resolve LitElement/html/css from HA's base elements when possible (better compatibility),
// and cache the result to avoid repeated lookups.
window.HKI.getLit = window.HKI.getLit || (() => {
  let cache = null;
  return () => {
    if (cache) return cache;
    const base =
      customElements.get("hui-masonry-view") ||
      customElements.get("ha-panel-lovelace") ||
      customElements.get("ha-app");
    const LitElementRef = base ? Object.getPrototypeOf(base) : window.LitElement;
    const htmlRef = LitElementRef?.prototype?.html || window.html;
    const cssRef = LitElementRef?.prototype?.css || window.css;
    cache = { LitElement: LitElementRef, html: htmlRef, css: cssRef };
    return cache;
  };
})();

// Inject popup animation keyframes once into the document
window.HKI.ensurePopupAnimations = window.HKI.ensurePopupAnimations || (() => {
  let done = false;
  return () => {
    if (done) return;
    done = true;
    try {
      if (document.getElementById("hki-popup-animations")) return;
      const s = document.createElement("style");
      s.id = "hki-popup-animations";
      s.textContent = `
@keyframes hki-anim-fade-in        { from { opacity: 0; } to { opacity: 1; } }
@keyframes hki-anim-fade-out       { from { opacity: 1; } to { opacity: 0; } }

@keyframes hki-anim-scale-in       { from { transform: scale(.92); opacity: 0; } to { transform: scale(1); opacity: 1; } }
@keyframes hki-anim-scale-out      { from { transform: scale(1); opacity: 1; } to { transform: scale(.92); opacity: 0; } }

@keyframes hki-anim-zoom-in        { from { transform: scale(.92); opacity: 0; } to { transform: scale(1); opacity: 1; } }
@keyframes hki-anim-zoom-out       { from { transform: scale(1); opacity: 1; } to { transform: scale(.92); opacity: 0; } }

@keyframes hki-anim-slide-up       { from { transform: translateY(14px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
@keyframes hki-anim-slide-down     { from { transform: translateY(-14px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
@keyframes hki-anim-slide-left     { from { transform: translateX(14px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }
@keyframes hki-anim-slide-right    { from { transform: translateX(-14px); opacity: 0; } to { transform: translateX(0); opacity: 1; } }

@keyframes hki-anim-slide-out-up    { from { transform: translateY(0); opacity: 1; } to { transform: translateY(-14px); opacity: 0; } }
@keyframes hki-anim-slide-out-down  { from { transform: translateY(0); opacity: 1; } to { transform: translateY(14px); opacity: 0; } }
@keyframes hki-anim-slide-out-left  { from { transform: translateX(0); opacity: 1; } to { transform: translateX(-14px); opacity: 0; } }
@keyframes hki-anim-slide-out-right { from { transform: translateX(0); opacity: 1; } to { transform: translateX(14px); opacity: 0; } }

@keyframes hki-anim-rotate-in      { from { transform: rotate(-2deg) scale(.96); opacity: 0; } to { transform: rotate(0) scale(1); opacity: 1; } }
@keyframes hki-anim-rotate-out     { from { transform: rotate(0) scale(1); opacity: 1; } to { transform: rotate(2deg) scale(.96); opacity: 0; } }

@keyframes hki-anim-drop-in        { from { transform: translateY(-18px) scale(.98); opacity: 0; } to { transform: translateY(0) scale(1); opacity: 1; } }
@keyframes hki-anim-drop-out       { from { transform: translateY(0) scale(1); opacity: 1; } to { transform: translateY(-18px) scale(.98); opacity: 0; } }

@keyframes hki-anim-bounce-in {
  0%   { transform: scale(.9); opacity: 0; }
  60%  { transform: scale(1.03); opacity: 1; }
  80%  { transform: scale(.985); }
  100% { transform: scale(1); }
}
@keyframes hki-anim-bounce-out {
  0%   { transform: scale(1); opacity: 1; }
  20%  { transform: scale(1.02); }
  100% { transform: scale(.9); opacity: 0; }
}

@keyframes hki-anim-flip-in {
  0%   { transform: perspective(800px) rotateX(14deg) scale(.98); opacity: 0; }
  100% { transform: perspective(800px) rotateX(0deg) scale(1); opacity: 1; }
}
@keyframes hki-anim-flip-out {
  0%   { transform: perspective(800px) rotateX(0deg) scale(1); opacity: 1; }
  100% { transform: perspective(800px) rotateX(-12deg) scale(.98); opacity: 0; }
}

@keyframes hki-anim-swing-in {
  0%   { transform: translateY(8px) rotate(-2deg); opacity: 0; }
  60%  { transform: translateY(0) rotate(1deg); opacity: 1; }
  100% { transform: translateY(0) rotate(0deg); }
}
@keyframes hki-anim-swing-out {
  0%   { transform: translateY(0) rotate(0deg); opacity: 1; }
  100% { transform: translateY(8px) rotate(2deg); opacity: 0; }
}
`;
      document.head.appendChild(s);
    } catch (e) {
      // no-op
    }
  };
})();

// Global scroll lock helpers (shared across cards)
window.HKI._scrollState = window.HKI._scrollState || {
  prevOverflow: null,
  prevPosition: null,
  prevTop: null,
  scrollY: 0,
};

window.HKI.lockScroll = window.HKI.lockScroll || (() => {
  const st = window.HKI._scrollState;
  return () => {
    try {
      if (st.prevOverflow !== null) return; // already locked
      st.scrollY = window.scrollY || window.pageYOffset || 0;
      st.prevOverflow = document.body.style.overflow;
      st.prevPosition = document.body.style.position;
      st.prevTop = document.body.style.top;
      document.body.style.overflow = "hidden";
      document.body.style.position = "fixed";
      document.body.style.top = `-${st.scrollY}px`;
      document.body.style.width = "100%";
    } catch (e) {
      // no-op
    }
  };
})();

window.HKI.unlockScroll = window.HKI.unlockScroll || (() => {
  const st = window.HKI._scrollState;
  return () => {
    try {
      if (st.prevOverflow === null) return;
      document.body.style.overflow = st.prevOverflow || "";
      document.body.style.position = st.prevPosition || "";
      document.body.style.top = st.prevTop || "";
      document.body.style.width = "";
      window.scrollTo(0, st.scrollY || 0);
    } catch (e) {
      // no-op
    } finally {
      st.prevOverflow = null;
      st.prevPosition = null;
      st.prevTop = null;
      st.scrollY = 0;
    }
  };
})();

// Shared popup style/dimension helpers used by multiple HKI cards
window.HKI.getPopupBackdropStyle = window.HKI.getPopupBackdropStyle || ((config = {}) => {
  const blurEnabled = config.popup_blur_enabled !== false;
  const blurAmount = config.popup_blur_amount !== undefined ? Number(config.popup_blur_amount) : 10;
  const blur = blurEnabled && blurAmount > 0
    ? `backdrop-filter: blur(${blurAmount}px); -webkit-backdrop-filter: blur(${blurAmount}px); will-change: backdrop-filter;`
    : "";
  return `background: rgba(0,0,0,0.7); ${blur}`;
});

window.HKI.getPopupCardStyle = window.HKI.getPopupCardStyle || ((config = {}) => {
  const cardBlurEnabled = config.popup_card_blur_enabled !== false;
  const cardBlurAmount = config.popup_card_blur_amount !== undefined ? Number(config.popup_card_blur_amount) : 40;
  let cardOpacity = config.popup_card_opacity !== undefined ? Number(config.popup_card_opacity) : 0.4;

  // Keep transparency when blur is on so the glass effect remains visible.
  if (cardBlurEnabled && cardOpacity === 1) cardOpacity = 0.7;

  const bg = (cardOpacity < 1 || cardBlurEnabled)
    ? `background: rgba(28, 28, 28, ${cardOpacity});`
    : `background: var(--card-background-color, #1c1c1c);`;

  const blur = cardBlurEnabled && cardBlurAmount > 0
    ? `backdrop-filter: blur(${cardBlurAmount}px); -webkit-backdrop-filter: blur(${cardBlurAmount}px);`
    : "";

  return bg + (blur ? ` ${blur}` : "");
});

window.HKI.getPopupDimensions = window.HKI.getPopupDimensions || ((config = {}) => {
  const widthCfg = config.popup_width || "auto";
  const heightCfg = config.popup_height || "auto";

  let width = "95vw; max-width: 500px";
  let height = "90vh; max-height: 800px";

  if (widthCfg === "custom") {
    width = `${config.popup_width_custom ?? 400}px`;
  } else if (widthCfg === "default") {
    width = "90%; max-width: 400px";
  } else if (!isNaN(Number(widthCfg))) {
    width = `${Number(widthCfg)}px`;
  }

  if (heightCfg === "custom") {
    height = `${config.popup_height_custom ?? 600}px`;
  } else if (heightCfg === "default") {
    height = "600px";
  } else if (!isNaN(Number(heightCfg))) {
    height = `${Number(heightCfg)}px`;
  }

  return { width, height };
});

window.HKI.getPopupOpenKeyframe = window.HKI.getPopupOpenKeyframe || ((anim) => {
  const map = {
    fade: "hki-anim-fade-in",
    scale: "hki-anim-scale-in",
    "slide-up": "hki-anim-slide-up",
    "slide-down": "hki-anim-slide-down",
    "slide-left": "hki-anim-slide-left",
    "slide-right": "hki-anim-slide-right",
    flip: "hki-anim-flip-in",
    bounce: "hki-anim-bounce-in",
    zoom: "hki-anim-zoom-in",
    rotate: "hki-anim-rotate-in",
    drop: "hki-anim-drop-in",
    swing: "hki-anim-swing-in",
  };
  return map[anim] || "hki-anim-fade-in";
});

window.HKI.getPopupCloseKeyframe = window.HKI.getPopupCloseKeyframe || ((anim) => {
  const map = {
    fade: "hki-anim-fade-out",
    scale: "hki-anim-scale-out",
    "slide-up": "hki-anim-slide-out-down",
    "slide-down": "hki-anim-slide-out-up",
    "slide-left": "hki-anim-slide-out-right",
    "slide-right": "hki-anim-slide-out-left",
    flip: "hki-anim-flip-out",
    bounce: "hki-anim-scale-out",
    zoom: "hki-anim-zoom-out",
    rotate: "hki-anim-rotate-out",
    drop: "hki-anim-drop-out",
    swing: "hki-anim-swing-out",
  };
  return map[anim] || "hki-anim-fade-out";
});

window.HKI.animatePopupOpen = window.HKI.animatePopupOpen || (({
  portal,
  config = {},
  selector = ".hki-popup-container",
} = {}) => {
  if (!portal) return false;
  const anim = config.popup_open_animation || "scale";
  if (anim === "none") return false;
  const dur = config.popup_animation_duration ?? 300;
  const container = portal.querySelector(selector);
  if (!container) return false;
  window.HKI?.ensurePopupAnimations?.();
  container.style.animation = "none";
  void container.offsetWidth;
  container.style.animation = `${window.HKI.getPopupOpenKeyframe(anim)} ${dur}ms ease forwards`;
  return true;
});

window.HKI.animatePopupClose = window.HKI.animatePopupClose || (({
  portal,
  config = {},
  selector = ".hki-popup-container",
  onDone,
  fallbackDelayMs = 100,
} = {}) => {
  const done = (() => {
    let called = false;
    return () => {
      if (called) return;
      called = true;
      onDone?.();
    };
  })();

  if (!portal) {
    done();
    return;
  }

  const anim = config.popup_close_animation || config.popup_open_animation || "scale";
  const dur = config.popup_animation_duration ?? 300;
  if (anim === "none") {
    done();
    return;
  }

  const container = portal.querySelector(selector);
  if (!container) {
    done();
    return;
  }

  window.HKI?.ensurePopupAnimations?.();
  container.style.animation = "none";
  void container.offsetWidth;
  container.style.animation = `${window.HKI.getPopupCloseKeyframe(anim)} ${dur}ms ease forwards`;
  container.addEventListener("animationend", done, { once: true });
  setTimeout(done, dur + fallbackDelayMs);
});

// HKI global card defaults (shared across card types)
window.HKI.GLOBAL_SETTINGS_STORAGE_KEY = window.HKI.GLOBAL_SETTINGS_STORAGE_KEY || "hki_elements_global_settings_v1";
window.HKI._globalSettingsCache = window.HKI._globalSettingsCache || null;

window.HKI.isUnsetValue = window.HKI.isUnsetValue || ((value) => {
  if (value === undefined || value === null) return true;
  if (typeof value === "string" && value.trim() === "") return true;
  return false;
});

window.HKI.getGlobalSettings = window.HKI.getGlobalSettings || (() => {
  const key = window.HKI.GLOBAL_SETTINGS_STORAGE_KEY;
  if (window.HKI._globalSettingsCache) return window.HKI._globalSettingsCache;
  try {
    const raw = window.localStorage?.getItem(key);
    if (!raw) {
      window.HKI._globalSettingsCache = { button: {}, header: {}, navigation: {}, popup: {} };
      return window.HKI._globalSettingsCache;
    }
    const parsed = JSON.parse(raw);
    const next = {
      button: (parsed?.button && typeof parsed.button === "object") ? parsed.button : {},
      header: (parsed?.header && typeof parsed.header === "object") ? parsed.header : {},
      navigation: (parsed?.navigation && typeof parsed.navigation === "object") ? parsed.navigation : {},
      popup: (parsed?.popup && typeof parsed.popup === "object") ? parsed.popup : {},
    };
    window.HKI._globalSettingsCache = next;
    return next;
  } catch (_) {
    window.HKI._globalSettingsCache = { button: {}, header: {}, navigation: {}, popup: {} };
    return window.HKI._globalSettingsCache;
  }
});

window.HKI.setGlobalSettings = window.HKI.setGlobalSettings || ((settings = {}) => {
  const current = window.HKI.getGlobalSettings();
  const hasOwn = (obj, key) => Object.prototype.hasOwnProperty.call(obj || {}, key);
  const next = {
    ...current,
    ...(settings || {}),
    button: hasOwn(settings, "button")
      ? (((settings && settings.button) && typeof settings.button === "object") ? { ...settings.button } : {})
      : { ...(current.button || {}) },
    header: hasOwn(settings, "header")
      ? (((settings && settings.header) && typeof settings.header === "object") ? { ...settings.header } : {})
      : { ...(current.header || {}) },
    navigation: hasOwn(settings, "navigation")
      ? (((settings && settings.navigation) && typeof settings.navigation === "object") ? { ...settings.navigation } : {})
      : { ...(current.navigation || {}) },
    popup: hasOwn(settings, "popup")
      ? (((settings && settings.popup) && typeof settings.popup === "object") ? { ...settings.popup } : {})
      : { ...(current.popup || {}) },
  };
  window.HKI._globalSettingsCache = next;
  try {
    window.localStorage?.setItem(window.HKI.GLOBAL_SETTINGS_STORAGE_KEY, JSON.stringify(next));
  } catch (_) {
    // Ignore storage write failures (private mode / quota / restricted env).
  }
  try {
    window.dispatchEvent(new CustomEvent("hki-global-settings-changed", { detail: { settings: next } }));
  } catch (_) {
    // Ignore event dispatch failures.
  }
  return next;
});

window.HKI.getGlobalDefaultsFor = window.HKI.getGlobalDefaultsFor || ((scope) => {
  const settings = window.HKI.getGlobalSettings();
  if (!scope) return {};
  const scoped = settings?.[scope];
  return (scoped && typeof scoped === "object") ? scoped : {};
});

window.HKI.applyGlobalDefaultsToConfig = window.HKI.applyGlobalDefaultsToConfig || (({
  scope,
  config,
  sourceConfig = {},
  fields = [],
} = {}) => {
  if (!scope || !config || typeof config !== "object" || !Array.isArray(fields) || !fields.length) return config;
  const scopedDefaults = window.HKI.getGlobalDefaultsFor(scope);
  if (!scopedDefaults || typeof scopedDefaults !== "object") return config;

  fields.forEach((entry) => {
    const targetKey = (typeof entry === "string") ? entry : entry?.target;
    const sourceKey = (typeof entry === "string") ? entry : (entry?.source || entry?.target);
    const globalKey = (typeof entry === "string") ? entry : (entry?.global || entry?.target);
    if (!targetKey || !globalKey) return;

    const sourceValue = sourceConfig ? sourceConfig[sourceKey] : undefined;
    if (!window.HKI.isUnsetValue(sourceValue)) return;

    const globalValue = scopedDefaults[globalKey];
    if (window.HKI.isUnsetValue(globalValue)) return;
    config[targetKey] = globalValue;
  });

  return config;
});

// ============================================================
// hki-header-card
// ============================================================

(() => {
// HKI Header Card
const { LitElement, html, css } = window.HKI.getLit();
const CARD_NAME = "hki-header-card";

const clamp = (n, min, max) => (Number.isFinite(n) ? Math.min(Math.max(n, min), max) : min);
const toNum = (v, fallback) => { const n = +v; return Number.isFinite(n) ? n : fallback; };

const WEIGHT_MAP = Object.freeze({
  light: 300, regular: 400, medium: 500, semibold: 600, bold: 700, black: 900,
});

const BG_SIZE_PRESETS = Object.freeze(["cover", "contain", "auto"]);

const FONT_FAMILY_MAP = Object.freeze({
  inherit: "inherit",
  system: "system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif",
  roboto: "Roboto, system-ui, sans-serif",
  inter: "Inter, system-ui, sans-serif",
  arial: "Arial, Helvetica, sans-serif",
  georgia: "Georgia, 'Times New Roman', serif",
  mono: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
});

const WEATHER_ICON_MAP = Object.freeze({
  "clear-night": "mdi:weather-night",
  cloudy: "mdi:weather-cloudy",
  fog: "mdi:weather-fog",
  hail: "mdi:weather-hail",
  lightning: "mdi:weather-lightning",
  "lightning-rainy": "mdi:weather-lightning-rainy",
  partlycloudy: "mdi:weather-partly-cloudy",
  pouring: "mdi:weather-pouring",
  rainy: "mdi:weather-rainy",
  snowy: "mdi:weather-snowy",
  "snowy-rainy": "mdi:weather-snowy-rainy",
  sunny: "mdi:weather-sunny",
  windy: "mdi:weather-windy",
  "windy-variant": "mdi:weather-windy-variant",
  exceptional: "mdi:alert-circle-outline",
});

const WEATHER_COLOR_MAP = Object.freeze({
  sunny: "var(--hki-weather-color-sunny, #fdd835)",
  "clear-night": "var(--hki-weather-color-clear-night, #90caf9)",
  partlycloudy: "var(--hki-weather-color-partlycloudy, #ffe082)",
  cloudy: "var(--hki-weather-color-cloudy, #b0bec5)",
  fog: "var(--hki-weather-color-fog, #cfd8dc)",
  rainy: "var(--hki-weather-color-rainy, #4fc3f7)",
  pouring: "var(--hki-weather-color-pouring, #0288d1)",
  lightning: "var(--hki-weather-color-lightning, #ffca28)",
  "lightning-rainy": "var(--hki-weather-color-lightning-rainy, #ffb300)",
  snowy: "var(--hki-weather-color-snowy, #e1f5fe)",
  "snowy-rainy": "var(--hki-weather-color-snowy-rainy, #81d4fa)",
  windy: "var(--hki-weather-color-windy, #a5d6a7)",
  "windy-variant": "var(--hki-weather-color-windy-variant, #81c784)",
  hail: "var(--hki-weather-color-hail, #80deea)",
  exceptional: "var(--hki-weather-color-exceptional, #ef9a9a)",
});

const HKI_POPUP_CONFIG_KEYS = window.HKI?.POPUP_CONFIG_KEYS || [];
const copyDefinedKeys = window.HKI?.copyDefinedKeys || (({ src, dst, keys }) => {
  if (!src || !dst || !Array.isArray(keys)) return dst;
  keys.forEach((k) => {
    if (src[k] !== undefined) dst[k] = src[k];
  });
  return dst;
});
const HKI_POPUP_EDITOR_OPTIONS = window.HKI?.POPUP_EDITOR_OPTIONS || {
  animations: [
    { value: "none", label: "None" },
    { value: "fade", label: "Fade" },
    { value: "scale", label: "Scale" },
    { value: "zoom", label: "Zoom" },
    { value: "slide-up", label: "Slide Up" },
    { value: "slide-down", label: "Slide Down" },
    { value: "slide-left", label: "Slide Left" },
    { value: "slide-right", label: "Slide Right" },
    { value: "flip", label: "Flip" },
    { value: "bounce", label: "Bounce" },
    { value: "rotate", label: "Rotate" },
    { value: "drop", label: "Drop" },
    { value: "swing", label: "Swing" },
  ],
  width: [
    { value: "auto", label: "Auto (Responsive)" },
    { value: "default", label: "Default (400px)" },
    { value: "custom", label: "Custom" },
  ],
  height: [
    { value: "auto", label: "Auto (Responsive)" },
    { value: "default", label: "Default (600px)" },
    { value: "custom", label: "Custom" },
  ],
  timeFormats: [
    { value: "auto", label: "Auto" },
    { value: "12", label: "12-Hour Clock" },
    { value: "24", label: "24-Hour Clock" },
  ],
};
const HKI_EDITOR_OPTIONS = window.HKI?.EDITOR_OPTIONS || {
  borderStyles: [
    { value: "solid", label: "solid" },
    { value: "dashed", label: "dashed" },
    { value: "dotted", label: "dotted" },
    { value: "double", label: "double" },
    { value: "none", label: "none" },
  ],
  buttonActionOptions: [
    { value: "toggle", label: "Toggle" },
    { value: "hki-more-info", label: "More Info (HKI)" },
    { value: "more-info", label: "More Info (Native)" },
    { value: "navigate", label: "Navigate" },
    { value: "perform-action", label: "Perform Action" },
    { value: "url", label: "URL" },
    { value: "fire-dom-event", label: "Fire DOM Event" },
    { value: "none", label: "None" },
  ],
  headerActionOptions: [
    { value: "none", label: "None" },
    { value: "navigate", label: "Navigate" },
    { value: "back", label: "Back" },
    { value: "menu", label: "Toggle Menu" },
    { value: "url", label: "Open URL" },
    { value: "more-info", label: "More Info" },
    { value: "hki-more-info", label: "HKI More Info" },
    { value: "toggle", label: "Toggle Entity" },
    { value: "perform-action", label: "Perform Action" },
    { value: "fire-dom-event", label: "Fire DOM Event" },
  ],
  popupBottomBarActionOptions: [
    { value: "toggle", label: "Toggle" },
    { value: "more-info", label: "More Info" },
    { value: "hki-more-info", label: "HKI More Info" },
    { value: "navigate", label: "Navigate" },
    { value: "perform-action", label: "Perform Action" },
    { value: "fire-dom-event", label: "Fire DOM Event" },
    { value: "url", label: "URL" },
    { value: "none", label: "None" },
  ],
  popupDefaultViewOptions: [
    { value: "main", label: "Main (Group Controls)" },
    { value: "individual", label: "Individual Entities" },
  ],
  popupDefaultSectionOptions: [
    { value: "last", label: "Last Used" },
    { value: "brightness", label: "Always Brightness" },
    { value: "color", label: "Always Color" },
    { value: "temperature", label: "Always Temperature" },
  ],
  popupDefaultSectionOptionsTagged: [
    { value: "last", label: "Last Used (Default)" },
    { value: "brightness", label: "Always Brightness" },
    { value: "color", label: "Always Color" },
    { value: "temperature", label: "Always Temperature" },
  ],
  popupBottomBarAlignOptions: [
    { value: "spread", label: "Spread" },
    { value: "start", label: "Start" },
    { value: "center", label: "Center" },
    { value: "end", label: "End" },
  ],
  popupBottomBarAlignOptionsDetailed: [
    { value: "spread", label: "Spread (space around)" },
    { value: "start", label: "Start (left aligned)" },
    { value: "center", label: "Center" },
    { value: "end", label: "End (right aligned)" },
  ],
};
const applyGlobalDefaultsToConfig = window.HKI?.applyGlobalDefaultsToConfig || (({ config }) => config);

const SLOT_BUTTON_TEMPLATE_FIELDS = Object.freeze([
  "icon",
  "icon_animation",
  "name",
  "state",
  "card_color",
  "text_color",
  "button_border_style",
  "button_border_color",
  "button_box_shadow",
  "icon_color",
  "name_color",
  "state_color",
  "text_shadow",
  "icon_shadow",
  "badge_color",
  "badge_text_color",
  "badge_border_style",
  "badge_border_color",
  "badge_box_shadow",
  "badge_font_family",
  "badge_font_custom",
  "badge_font_weight",
  "badge_template",
  "visibility_state",
  "visibility_attribute_value",
]);
const SLOT_BUTTON_STYLE_FIELDS = Object.freeze([
  "card_color",
  "text_color",
  "button_border_radius",
  "button_box_shadow",
  "button_border_style",
  "button_border_width",
  "button_border_color",
  "icon_color",
  "name_color",
  "state_color",
  "text_shadow",
  "icon_shadow",
  "name_offset_x",
  "name_offset_y",
  "state_offset_x",
  "state_offset_y",
  "badge_border_radius",
  "badge_box_shadow",
  "badge_border_style",
  "badge_border_width",
  "badge_border_color",
  "badge_font_size",
  "badge_font_weight",
  "badge_font_family",
  "badge_font_custom",
]);

const PERSON_POPUP_FLAT_KEYS = Object.freeze([
  "popup_name",
  "popup_state",
  "popup_icon",
  "popup_use_entity_picture",
  "custom_popup_enabled",
  "custom_popup_card",
  ...HKI_POPUP_CONFIG_KEYS,
]);

function popupFlatKeyToNestedKey(flatKey) {
  if (flatKey === "popup_name") return "name";
  if (flatKey === "popup_state") return "state";
  if (flatKey === "popup_icon") return "icon";
  if (flatKey === "popup_use_entity_picture") return "use_entity_picture";
  if (flatKey === "custom_popup_enabled") return "custom_popup_enabled";
  if (flatKey === "custom_popup_card") return "custom_popup_card";
  if (flatKey.startsWith("popup_")) return flatKey.slice(6);
  return flatKey;
}

function popupNestedKeyToFlatKey(nestedKey) {
  if (nestedKey === "name") return "popup_name";
  if (nestedKey === "state") return "popup_state";
  if (nestedKey === "icon") return "popup_icon";
  if (nestedKey === "use_entity_picture") return "popup_use_entity_picture";
  if (nestedKey === "custom_popup_enabled") return "custom_popup_enabled";
  if (nestedKey === "custom_popup_card") return "custom_popup_card";
  if (nestedKey.startsWith("_")) return nestedKey;
  return `popup_${nestedKey}`;
}

function popupAnyKeyToFlatKey(key) {
  if (typeof key !== "string") return key;
  if (PERSON_POPUP_FLAT_KEYS.includes(key) || HKI_POPUP_CONFIG_KEYS.includes(key)) return key;
  return popupNestedKeyToFlatKey(key);
}

const createDefaultSlotButton = () => ({
  icon: "",
  icon_animation: "",
  name: "",
  state: "",
  entity: "",
  card_color: "",
  text_color: "",
  button_border_radius: "",
  button_box_shadow: "",
  button_border_style: "",
  button_border_width: "",
  button_border_color: "",
  icon_color: "",
  name_color: "",
  state_color: "",
  text_shadow: "",
  icon_shadow: "",
  name_offset_x: 0,
  name_offset_y: 0,
  state_offset_x: 0,
  state_offset_y: 0,
  tap_action: { action: "none" },
  hold_action: { action: "none" },
  double_tap_action: { action: "none" },
  visibility_mode: "none", // none | state | attribute
  visibility_entity: "",
  visibility_state: "",
  visibility_attribute: "",
  visibility_attribute_value: "",
  show_badge: false,
  badge_source: "entity",
  badge_entity: "",
  badge_template: "",
  badge_color: "",
  badge_text_color: "",
  badge_border_radius: "",
  badge_box_shadow: "",
  badge_border_style: "",
  badge_border_width: "",
  badge_border_color: "",
  badge_font_size: "",
  badge_font_weight: "",
  badge_font_family: "",
  badge_font_custom: "",
  show_icon: true,
  show_name: true,
  show_state: true,
  popup: {},
});

function normalizeSlotButton(btn) {
  const src = (btn && typeof btn === "object") ? btn : {};
  const style = (src.style && typeof src.style === "object") ? src.style : {};
  const normalized = {
    ...createDefaultSlotButton(),
    ...style,
    ...src,
  };
  normalized.show_badge = !!normalized.show_badge;
  normalized.show_icon = normalized.show_icon !== false;
  normalized.show_name = normalized.show_name !== false;
  normalized.show_state = normalized.show_state !== false;
  normalized.badge_source = normalized.badge_source === "template" ? "template" : "entity";
  normalized.visibility_mode = (normalized.visibility_mode === "state" || normalized.visibility_mode === "attribute") ? normalized.visibility_mode : "none";
  const popupObj = {};
  const nestedPopup = (src.popup && typeof src.popup === "object") ? src.popup : null;
  if (nestedPopup) {
    Object.entries(nestedPopup).forEach(([k, v]) => {
      if (v !== undefined) popupObj[popupAnyKeyToFlatKey(k)] = v;
    });
  }
  PERSON_POPUP_FLAT_KEYS.forEach((flatKey) => {
    if (src[flatKey] === undefined) return;
    popupObj[flatKey] = src[flatKey];
  });
  normalized.popup = popupObj;
  return normalized;
}

function cleanupSlotButton(btn) {
  if (!btn || typeof btn !== "object") return null;
  const normalized = normalizeSlotButton(btn);
  const cleaned = {};

  SLOT_BUTTON_TEMPLATE_FIELDS.forEach((k) => {
    const v = normalized[k];
    if (typeof v === "string") {
      const trimmed = v.trim();
      if (trimmed) cleaned[k] = trimmed;
    }
  });
  if (normalized.entity) cleaned.entity = normalized.entity;
  const keepNum = (k) => {
    const n = Number(normalized[k]);
    if (Number.isFinite(n) && n !== 0) cleaned[k] = n;
  };
  keepNum("name_offset_x");
  keepNum("name_offset_y");
  keepNum("state_offset_x");
  keepNum("state_offset_y");
  keepNum("button_border_radius");
  keepNum("button_border_width");
  keepNum("badge_border_radius");
  keepNum("badge_border_width");
  keepNum("badge_font_size");
  if (normalized.show_icon === false) cleaned.show_icon = false;
  if (normalized.show_name === false) cleaned.show_name = false;
  if (normalized.show_state === false) cleaned.show_state = false;
  if (normalized.visibility_mode && normalized.visibility_mode !== "none") {
    cleaned.visibility_mode = normalized.visibility_mode;
    if (normalized.visibility_entity) cleaned.visibility_entity = normalized.visibility_entity;
    if (normalized.visibility_mode === "state") {
      if (normalized.visibility_state) cleaned.visibility_state = normalized.visibility_state;
      delete cleaned.visibility_attribute;
      delete cleaned.visibility_attribute_value;
    } else if (normalized.visibility_mode === "attribute") {
      if (normalized.visibility_attribute) cleaned.visibility_attribute = normalized.visibility_attribute;
      if (normalized.visibility_attribute_value) cleaned.visibility_attribute_value = normalized.visibility_attribute_value;
      delete cleaned.visibility_state;
    }
  }

  cleaned.show_badge = !!normalized.show_badge;
  if (cleaned.show_badge) {
    cleaned.badge_source = normalized.badge_source === "template" ? "template" : "entity";
    if (cleaned.badge_source === "entity") {
      if (normalized.badge_entity) cleaned.badge_entity = normalized.badge_entity;
      delete cleaned.badge_template;
    } else {
      if (normalized.badge_template) cleaned.badge_template = normalized.badge_template;
      delete cleaned.badge_entity;
    }
  } else {
    delete cleaned.badge_source;
    delete cleaned.badge_entity;
    delete cleaned.badge_template;
    delete cleaned.badge_color;
    delete cleaned.badge_text_color;
  }

  const normalizeAction = (action) => {
    if (!action || typeof action !== "object") return null;
    const actionType = action.action || "none";
    const out = { action: actionType };
    if (actionType === "navigate" && action.navigation_path) out.navigation_path = action.navigation_path;
    else if (actionType === "url" && action.url_path) out.url_path = action.url_path;
    else if ((actionType === "more-info" || actionType === "toggle" || actionType === "hki-more-info") && action.entity) out.entity = action.entity;
    else if (actionType === "perform-action") {
      if (action.perform_action) out.perform_action = action.perform_action;
      if (action.target) out.target = action.target;
      if (action.data) out.data = action.data;
    } else if (actionType === "fire-dom-event") {
      if (action.event_data !== undefined) out.event_data = action.event_data;
      if (action.event_name) out.event_name = action.event_name;
    }
    return out;
  };
  cleaned.tap_action = normalizeAction(normalized.tap_action) || { action: "none" };
  cleaned.hold_action = normalizeAction(normalized.hold_action) || { action: "none" };
  cleaned.double_tap_action = normalizeAction(normalized.double_tap_action) || { action: "none" };
  if (normalized.popup && typeof normalized.popup === "object") {
    const popup = {};
    Object.entries(normalized.popup).forEach(([key, value]) => {
      if (value === undefined || value === null || value === "") return;
      popup[popupFlatKeyToNestedKey(popupAnyKeyToFlatKey(key))] = value;
    });
    if (Object.keys(popup).length) cleaned.popup = popup;
  }
  return cleaned;
}

// Shared defaults - single source of truth
const DEFAULTS = Object.freeze({
  title: "Header",
  subtitle: "",
  text_align: "left",
  title_color: "",
  subtitle_color: "",
  background: "https://github.com/jimz011/hki-header-card/blob/main/wallpapers/livingroom.jpg?raw=true",
  background_color: "", // Background blend color for blending
  background_position: "center",
  background_repeat: "no-repeat",
  background_size: "cover",
  background_blend_mode: "normal",
  height_vh: 35,
  min_height: 215,
  max_height: 240,
  blend_color: "var(--primary-background-color)",
  blend_stop: 95,
  blend_enabled: true,
  // Header styling
  // Border radius (back-compat): card_border_radius applies to both top and bottom
  // if the split options below are not provided.
  card_border_radius: "",
  card_border_radius_top: "",
  card_border_radius_bottom: "",
  card_box_shadow: "",
  card_border_style: "none",
  card_border_width: 0,
  card_border_color: "",
  fixed: true,
  fixed_top: 0,
  // When fixed is false, allow resizing/bleeding the card within the view
  // Positive left/right values make the card wider (bleed outwards)
  // Positive top/bottom add spacing around the card
  inset_top: 0,
  inset_left: 0,
  inset_right: 0,
  inset_bottom: 0,
  title_offset_x: 5,
  title_offset_y: 65,
  subtitle_offset_x: 5,
  subtitle_offset_y: 70,
  badges_offset_pinned: 48,
  badges_offset_unpinned: 100,
  badges_gap: 0,
  badges_fixed: false,
  
  // Person Entities Display
  persons_enabled: false,
  persons_entities: [],
  persons_align: "right",
  persons_offset_x: 5,
  persons_offset_y: 63,
  persons_size: 35,
  persons_spacing: 0,
  persons_stack_order: "descending",
  persons_dynamic_order: true,
  persons_hide_away: false,
  persons_use_entity_picture: true,
  persons_border_width: 1,
  persons_border_style: "solid",
  persons_border_radius: 50,
  persons_border_color: "rgba(255,255,255,0.3)",
  persons_border_color_away: "rgba(255,0,0,0.5)",
  persons_box_shadow: "0 2px 8px rgba(0, 0, 0, 0.4)",
  persons_grayscale_away: true,
  
  font_family: "inherit",
  font_family_custom: "",
  font_style: "normal",
  title_size_px: 36,
  subtitle_size_px: 15,
  title_weight: "bold",
  subtitle_weight: "medium",
  mobile_breakpoint: 768,

  // Top Bar Layout
  top_bar_enabled: true,
  top_bar_offset_y: 15,
  top_bar_padding_x: 0,
  
  // Slot types: "none", "spacer", "weather", "datetime", "notifications", "card", "button"
  top_bar_left: "none",
  top_bar_center: "none",
  top_bar_right: "none",
  top_bar_left_align: "start",
  top_bar_center_align: "center",
  top_bar_right_align: "end",
  
  // Default custom cards for slots (no default for "card" type - shows picker)
  top_bar_left_card: null,
  top_bar_center_card: null,
  top_bar_right_card: null,

  // Bottom Bar Layout
  bottom_bar_enabled: false,
  bottom_bar_offset_y: 10,
  bottom_bar_padding_x: 0,
  bottom_bar_left: "none",
  bottom_bar_center: "none",
  bottom_bar_right: "none",
  bottom_bar_left_align: "start",
  bottom_bar_center_align: "center",
  bottom_bar_right_align: "end",
  bottom_bar_left_card: null,
  bottom_bar_center_card: null,
  bottom_bar_right_card: null,

  // Global Info Styling (defaults for all slots)
  info_size_px: 12,
  info_weight: "medium",
  info_color: "",
  info_text_shadow: "",
  info_icon_shadow: "",
  info_pill: true,
  info_pill_background: "rgba(0,0,0,0.25)",
  info_pill_padding_x: 12,
  info_pill_padding_y: 8,
  info_pill_radius: 999,
  info_pill_blur: 0,
  info_pill_border_style: "none",
  info_pill_border_width: 0,
  info_pill_border_color: "rgba(255,255,255,0.1)",

  // Bottom Bar Global Info Styling (independent defaults for bottom bar slots)
  bottom_info_size_px: 12,
  bottom_info_weight: "medium",
  bottom_info_color: "",
  bottom_info_text_shadow: "",
  bottom_info_icon_shadow: "",
  bottom_info_pill: true,
  bottom_info_pill_background: "rgba(0,0,0,0.25)",
  bottom_info_pill_padding_x: 12,
  bottom_info_pill_padding_y: 8,
  bottom_info_pill_radius: 999,
  bottom_info_pill_blur: 0,
  bottom_info_pill_border_style: "none",
  bottom_info_pill_border_width: 0,
  bottom_info_pill_border_color: "rgba(255,255,255,0.1)",

  // Defaults fallback if per-slot is missing
  weather_entity: "",
  weather_show_icon: true,
  weather_show_condition: true,
  weather_show_temperature: true,
  weather_show_humidity: false,
  weather_show_wind: false,
  weather_show_pressure: false,
  weather_colored_icons: true,
  weather_icon_color_mode: "state",
  weather_animate_icon: "none",
  weather_icon_pack_path: "",
  datetime_show_time: true,
  datetime_show_date: true,
  datetime_show_day: true,
  datetime_time_format: "HH:mm",
  datetime_date_format: "D MMM",
  datetime_separator: " â€¢ ",
});

function normalizeWeightKey(input, fallbackKey) {
  if (typeof input === "string" && WEIGHT_MAP[input]) return input;
  if (typeof input === "number" && Number.isFinite(input)) {
    let best = fallbackKey, bestDist = Infinity;
    for (const [k, v] of Object.entries(WEIGHT_MAP)) {
      const d = Math.abs(v - input);
      if (d < bestDist) { best = k; bestDist = d; }
    }
    return best;
  }
  return fallbackKey;
}

// Migration helper: Detect if config is in old flat format
function isOldFormat(config) {
  // Check for old flat keys
  const oldKeys = [
    'top_bar_left_weather_entity', 'top_bar_right_weather_entity', 'top_bar_center_weather_entity',
    'top_bar_left_show_icon', 'persons_enabled', 'persons_entities'
  ];
  return oldKeys.some(key => key in config);
}

// Migrate old flat format to new nested format
function migrateToNestedFormat(oldConfig) {
  const newConfig = { type: oldConfig.type || "custom:hki-header-card" };
  
  // Copy simple top-level properties
  const simpleProps = [
    'title', 'subtitle', 'text_align', 'title_color', 'subtitle_color',
    'background', 'background_color', 'background_position', 'background_repeat',
    'background_size', 'background_blend_mode', 'height_vh', 'min_height', 'max_height',
    'grid_options', 'visibility',
    'blend_color', 'blend_stop', 'blend_enabled',
    'card_border_radius', 'card_border_radius_top', 'card_border_radius_bottom',
    'card_box_shadow', 'card_border_style', 'card_border_width', 'card_border_color',
    'fixed', 'fixed_top', 'inset_top', 'inset_left', 'inset_right', 'inset_bottom',
    'title_offset_x', 'title_offset_y', 'subtitle_offset_x', 'subtitle_offset_y',
    'badges_offset_pinned', 'badges_offset_unpinned', 'badges_gap', 'badges_fixed',
    'font_family', 'font_family_custom', 'font_style', 'title_size_px', 'subtitle_size_px',
    'title_weight', 'subtitle_weight', 'mobile_breakpoint'
  ];
  
  simpleProps.forEach(prop => {
    if (oldConfig[prop] !== undefined) {
      newConfig[prop] = oldConfig[prop];
    }
  });
  
  // Migrate top_bar global settings
  if (oldConfig.top_bar_enabled !== undefined || oldConfig.top_bar_offset_y !== undefined || oldConfig.top_bar_padding_x !== undefined) {
    newConfig.top_bar = {};
    if (oldConfig.top_bar_enabled !== undefined) newConfig.top_bar.enabled = oldConfig.top_bar_enabled;
    if (oldConfig.top_bar_offset_y !== undefined) newConfig.top_bar.offset_y = oldConfig.top_bar_offset_y;
    if (oldConfig.top_bar_padding_x !== undefined) newConfig.top_bar.padding_x = oldConfig.top_bar_padding_x;
  }
  
  // Migrate global info styling
  const infoKeys = ['info_size_px', 'info_weight', 'info_color', 'info_text_shadow', 'info_icon_shadow', 'info_pill', 'info_pill_background',
                    'info_pill_padding_x', 'info_pill_padding_y', 'info_pill_radius', 'info_pill_blur',
                    'info_pill_border_style', 'info_pill_border_width', 'info_pill_border_color'];
  if (infoKeys.some(k => oldConfig[k] !== undefined)) {
    newConfig.info = {};
    if (oldConfig.info_size_px !== undefined) newConfig.info.size_px = oldConfig.info_size_px;
    if (oldConfig.info_weight !== undefined) newConfig.info.weight = oldConfig.info_weight;
    if (oldConfig.info_color !== undefined) newConfig.info.color = oldConfig.info_color;
    if (oldConfig.info_text_shadow !== undefined) newConfig.info.text_shadow = oldConfig.info_text_shadow;
    if (oldConfig.info_icon_shadow !== undefined) newConfig.info.icon_shadow = oldConfig.info_icon_shadow;
    if (oldConfig.info_pill !== undefined) newConfig.info.pill = oldConfig.info_pill;
    if (oldConfig.info_pill_background !== undefined) newConfig.info.pill_background = oldConfig.info_pill_background;
    if (oldConfig.info_pill_padding_x !== undefined) newConfig.info.pill_padding_x = oldConfig.info_pill_padding_x;
    if (oldConfig.info_pill_padding_y !== undefined) newConfig.info.pill_padding_y = oldConfig.info_pill_padding_y;
    if (oldConfig.info_pill_radius !== undefined) newConfig.info.pill_radius = oldConfig.info_pill_radius;
    if (oldConfig.info_pill_blur !== undefined) newConfig.info.pill_blur = oldConfig.info_pill_blur;
    if (oldConfig.info_pill_border_style !== undefined) newConfig.info.pill_border_style = oldConfig.info_pill_border_style;
    if (oldConfig.info_pill_border_width !== undefined) newConfig.info.pill_border_width = oldConfig.info_pill_border_width;
    if (oldConfig.info_pill_border_color !== undefined) newConfig.info.pill_border_color = oldConfig.info_pill_border_color;
  }
  
  // Migrate each slot (left, center, right) for both bars
  ['top_bar', 'bottom_bar'].forEach(bar => {
  ['left', 'center', 'right'].forEach(slot => {
    const slotType = oldConfig[`${bar}_${slot}`] || "none";
    if (slotType === "none") return;
    
    const prefix = `${bar}_${slot}_`;
    const slotConfig = { type: slotType };
    
    // Common slot properties
    if (oldConfig[prefix + "offset_x"] !== undefined) slotConfig.offset_x = oldConfig[prefix + "offset_x"];
    if (oldConfig[prefix + "offset_y"] !== undefined) slotConfig.offset_y = oldConfig[prefix + "offset_y"];
    if (oldConfig[prefix + "offset_x_mobile"] !== undefined) slotConfig.offset_x_mobile = oldConfig[prefix + "offset_x_mobile"];
    if (oldConfig[prefix + "offset_y_mobile"] !== undefined) slotConfig.offset_y_mobile = oldConfig[prefix + "offset_y_mobile"];
    if (oldConfig[prefix + "overflow"] !== undefined) slotConfig.overflow = oldConfig[prefix + "overflow"];
    
    // Styling (only if not using global)
    if (oldConfig[prefix + "use_global"] === false) {
      slotConfig.styling = {
        size_px: oldConfig[prefix + "size_px"],
        weight: oldConfig[prefix + "weight"],
        color: oldConfig[prefix + "color"],
        text_shadow: oldConfig[prefix + "text_shadow"],
        icon_shadow: oldConfig[prefix + "icon_shadow"],
        pill: oldConfig[prefix + "pill"],
        pill_background: oldConfig[prefix + "pill_background"],
        pill_padding_x: oldConfig[prefix + "pill_padding_x"],
        pill_padding_y: oldConfig[prefix + "pill_padding_y"],
        pill_radius: oldConfig[prefix + "pill_radius"],
        pill_blur: oldConfig[prefix + "pill_blur"],
        pill_border_style: oldConfig[prefix + "pill_border_style"],
        pill_border_width: oldConfig[prefix + "pill_border_width"],
        pill_border_color: oldConfig[prefix + "pill_border_color"]
      };
    }
    
    // Type-specific configurations
    if (slotType === "weather") {
      slotConfig.weather = {
        entity: oldConfig[prefix + "weather_entity"],
        show_icon: oldConfig[prefix + "show_icon"],
        show_condition: oldConfig[prefix + "show_condition"],
        show_temperature: oldConfig[prefix + "show_temperature"],
        show_humidity: oldConfig[prefix + "show_humidity"],
        show_wind: oldConfig[prefix + "show_wind"],
        show_pressure: oldConfig[prefix + "show_pressure"],
        colored_icons: oldConfig[prefix + "weather_colored_icons"],
        icon_color_mode: oldConfig[prefix + "weather_icon_color_mode"],
        icon_color: oldConfig[prefix + "weather_icon_color"],
        animate_icon: oldConfig[prefix + "animate_icon"],
        icon_pack_path: oldConfig[prefix + "icon_pack_path"]
      };
    } else if (slotType === "datetime") {
      slotConfig.datetime = {
        show_day: oldConfig[prefix + "show_day"],
        show_date: oldConfig[prefix + "show_date"],
        show_time: oldConfig[prefix + "show_time"],
        time_format: oldConfig[prefix + "time_format"],
        date_format: oldConfig[prefix + "date_format"],
        separator: oldConfig[prefix + "separator"],
        icon: oldConfig[prefix + "icon"],
        animate_icon: oldConfig[prefix + "animate_icon"]
      };
    } else if (slotType === "button") {
      slotConfig.button = {
        icon: oldConfig[prefix + "icon"],
        icon_animation: oldConfig[prefix + "icon_animation"],
        name: oldConfig[prefix + "name"],
        state: oldConfig[prefix + "state"],
        entity: oldConfig[prefix + "entity"],
        card_color: oldConfig[prefix + "card_color"],
        icon_color: oldConfig[prefix + "icon_color"],
        name_color: oldConfig[prefix + "name_color"],
        state_color: oldConfig[prefix + "state_color"],
        text_shadow: oldConfig[prefix + "text_shadow"],
        icon_shadow: oldConfig[prefix + "icon_shadow"],
        name_offset_x: oldConfig[prefix + "name_offset_x"],
        name_offset_y: oldConfig[prefix + "name_offset_y"],
        state_offset_x: oldConfig[prefix + "state_offset_x"],
        state_offset_y: oldConfig[prefix + "state_offset_y"],
        visibility_mode: oldConfig[prefix + "visibility_mode"],
        visibility_entity: oldConfig[prefix + "visibility_entity"],
        visibility_state: oldConfig[prefix + "visibility_state"],
        visibility_attribute: oldConfig[prefix + "visibility_attribute"],
        visibility_attribute_value: oldConfig[prefix + "visibility_attribute_value"],
        show_badge: oldConfig[prefix + "show_badge"],
        badge_source: oldConfig[prefix + "badge_source"],
        badge_entity: oldConfig[prefix + "badge_entity"],
        badge_template: oldConfig[prefix + "badge_template"],
        badge_color: oldConfig[prefix + "badge_color"],
        badge_text_color: oldConfig[prefix + "badge_text_color"],
        buttons: oldConfig[prefix + "buttons"],
      };
    } else if (slotType === "custom" || slotType === "notifications") {
      slotConfig.custom = {
        card: oldConfig[prefix + "card"]
      };
      if (slotType === "custom") slotConfig.type = "notifications"; // migrate legacy value
    } else if (slotType === "card") {
      slotConfig.custom = {
        card: oldConfig[prefix + "card"]
      };
    }
    
    // Actions
    slotConfig.actions = {
      tap_action: oldConfig[prefix + "tap_action"],
      hold_action: oldConfig[prefix + "hold_action"],
      double_tap_action: oldConfig[prefix + "double_tap_action"]
    };
    
    newConfig[`${bar}_${slot}`] = slotConfig;
  });
  }); // end bar loop
  
  // Migrate persons
  if (oldConfig.persons_enabled || oldConfig.persons_entities) {
    newConfig.persons = {};
    if (oldConfig.persons_enabled !== undefined) newConfig.persons.enabled = oldConfig.persons_enabled;
    if (oldConfig.persons_align !== undefined) newConfig.persons.align = oldConfig.persons_align;
    if (oldConfig.persons_offset_x !== undefined) newConfig.persons.offset_x = oldConfig.persons_offset_x;
    if (oldConfig.persons_offset_y !== undefined) newConfig.persons.offset_y = oldConfig.persons_offset_y;
    if (oldConfig.persons_size !== undefined) newConfig.persons.size = oldConfig.persons_size;
    if (oldConfig.persons_spacing !== undefined) newConfig.persons.spacing = oldConfig.persons_spacing;
    if (oldConfig.persons_stack_order !== undefined) newConfig.persons.stack_order = oldConfig.persons_stack_order;
    if (oldConfig.persons_dynamic_order !== undefined) newConfig.persons.dynamic_order = oldConfig.persons_dynamic_order;
    if (oldConfig.persons_hide_away !== undefined) newConfig.persons.hide_away = oldConfig.persons_hide_away;
    if (oldConfig.persons_use_entity_picture !== undefined) newConfig.persons.use_entity_picture = oldConfig.persons_use_entity_picture;
    if (oldConfig.persons_border_width !== undefined) newConfig.persons.border_width = oldConfig.persons_border_width;
    if (oldConfig.persons_border_style !== undefined) newConfig.persons.border_style = oldConfig.persons_border_style;
    if (oldConfig.persons_border_radius !== undefined) newConfig.persons.border_radius = oldConfig.persons_border_radius;
    if (oldConfig.persons_border_color !== undefined) newConfig.persons.border_color = oldConfig.persons_border_color;
    if (oldConfig.persons_border_color_away !== undefined) newConfig.persons.border_color_away = oldConfig.persons_border_color_away;
    if (oldConfig.persons_box_shadow !== undefined) newConfig.persons.box_shadow = oldConfig.persons_box_shadow;
    if (oldConfig.persons_grayscale_away !== undefined) newConfig.persons.grayscale_away = oldConfig.persons_grayscale_away;
    if (oldConfig.persons_entities !== undefined) newConfig.persons.entities = oldConfig.persons_entities || [];
  }
  
  return newConfig;
}

// Flatten nested format to flat format for internal use
function flattenNestedFormat(nested) {
  const flat = { type: nested.type || "custom:hki-header-card" };
  
  // Copy simple top-level properties
  const simpleProps = [
    'title', 'subtitle', 'text_align', 'title_color', 'subtitle_color',
    'background', 'background_color', 'background_position', 'background_repeat',
    'background_size', 'background_blend_mode', 'height_vh', 'min_height', 'max_height',
    'grid_options', 'visibility',
    'blend_color', 'blend_stop', 'blend_enabled',
    'card_border_radius', 'card_border_radius_top', 'card_border_radius_bottom',
    'card_box_shadow', 'card_border_style', 'card_border_width', 'card_border_color',
    'fixed', 'fixed_top', 'inset_top', 'inset_left', 'inset_right', 'inset_bottom',
    'title_offset_x', 'title_offset_y', 'subtitle_offset_x', 'subtitle_offset_y',
    'badges_offset_pinned', 'badges_offset_unpinned', 'badges_gap', 'badges_fixed',
    'font_family', 'font_family_custom', 'font_style', 'title_size_px', 'subtitle_size_px',
    'title_weight', 'subtitle_weight', 'mobile_breakpoint'
  ];
  
  simpleProps.forEach(prop => {
    if (nested[prop] !== undefined) {
      flat[prop] = nested[prop];
    }
  });
  
  // Flatten top_bar
  if (nested.top_bar) {
    if (nested.top_bar.enabled !== undefined) flat.top_bar_enabled = nested.top_bar.enabled;
    if (nested.top_bar.offset_y !== undefined) flat.top_bar_offset_y = nested.top_bar.offset_y;
    if (nested.top_bar.padding_x !== undefined) flat.top_bar_padding_x = nested.top_bar.padding_x;
  }

  // Flatten bottom_bar
  if (nested.bottom_bar && typeof nested.bottom_bar === 'object') {
    if (nested.bottom_bar.enabled !== undefined) flat.bottom_bar_enabled = nested.bottom_bar.enabled;
    if (nested.bottom_bar.offset_y !== undefined) flat.bottom_bar_offset_y = nested.bottom_bar.offset_y;
    if (nested.bottom_bar.padding_x !== undefined) flat.bottom_bar_padding_x = nested.bottom_bar.padding_x;
  }
  
  // Flatten info
  if (nested.info) {
    if (nested.info.size_px !== undefined) flat.info_size_px = nested.info.size_px;
    if (nested.info.weight !== undefined) flat.info_weight = nested.info.weight;
    if (nested.info.color !== undefined) flat.info_color = nested.info.color;
    if (nested.info.text_shadow !== undefined) flat.info_text_shadow = nested.info.text_shadow;
    if (nested.info.icon_shadow !== undefined) flat.info_icon_shadow = nested.info.icon_shadow;
    if (nested.info.pill !== undefined) flat.info_pill = nested.info.pill;
    if (nested.info.pill_background !== undefined) flat.info_pill_background = nested.info.pill_background;
    if (nested.info.pill_padding_x !== undefined) flat.info_pill_padding_x = nested.info.pill_padding_x;
    if (nested.info.pill_padding_y !== undefined) flat.info_pill_padding_y = nested.info.pill_padding_y;
    if (nested.info.pill_radius !== undefined) flat.info_pill_radius = nested.info.pill_radius;
    if (nested.info.pill_blur !== undefined) flat.info_pill_blur = nested.info.pill_blur;
    if (nested.info.pill_border_style !== undefined) flat.info_pill_border_style = nested.info.pill_border_style;
    if (nested.info.pill_border_width !== undefined) flat.info_pill_border_width = nested.info.pill_border_width;
    if (nested.info.pill_border_color !== undefined) flat.info_pill_border_color = nested.info.pill_border_color;
  }
  
  // Flatten bottom_info (bottom bar independent global styling)
  if (nested.bottom_info) {
    if (nested.bottom_info.size_px !== undefined) flat.bottom_info_size_px = nested.bottom_info.size_px;
    if (nested.bottom_info.weight !== undefined) flat.bottom_info_weight = nested.bottom_info.weight;
    if (nested.bottom_info.color !== undefined) flat.bottom_info_color = nested.bottom_info.color;
    if (nested.bottom_info.text_shadow !== undefined) flat.bottom_info_text_shadow = nested.bottom_info.text_shadow;
    if (nested.bottom_info.icon_shadow !== undefined) flat.bottom_info_icon_shadow = nested.bottom_info.icon_shadow;
    if (nested.bottom_info.pill !== undefined) flat.bottom_info_pill = nested.bottom_info.pill;
    if (nested.bottom_info.pill_background !== undefined) flat.bottom_info_pill_background = nested.bottom_info.pill_background;
    if (nested.bottom_info.pill_padding_x !== undefined) flat.bottom_info_pill_padding_x = nested.bottom_info.pill_padding_x;
    if (nested.bottom_info.pill_padding_y !== undefined) flat.bottom_info_pill_padding_y = nested.bottom_info.pill_padding_y;
    if (nested.bottom_info.pill_radius !== undefined) flat.bottom_info_pill_radius = nested.bottom_info.pill_radius;
    if (nested.bottom_info.pill_blur !== undefined) flat.bottom_info_pill_blur = nested.bottom_info.pill_blur;
    if (nested.bottom_info.pill_border_style !== undefined) flat.bottom_info_pill_border_style = nested.bottom_info.pill_border_style;
    if (nested.bottom_info.pill_border_width !== undefined) flat.bottom_info_pill_border_width = nested.bottom_info.pill_border_width;
    if (nested.bottom_info.pill_border_color !== undefined) flat.bottom_info_pill_border_color = nested.bottom_info.pill_border_color;
  }
  
  // Flatten slots (top and bottom bar)
  ['top_bar', 'bottom_bar'].forEach(bar => {
  ['left', 'center', 'right'].forEach(slot => {
    const slotConfig = nested[`${bar}_${slot}`];
    if (!slotConfig) return;
    
    const prefix = `${bar}_${slot}_`;
    flat[`${bar}_${slot}`] = slotConfig.type || "none";
    
    // Only process additional properties if slot type is not "none"
    if (slotConfig.type === "none") return;
    
    // Common properties
    if (slotConfig.offset_x !== undefined) flat[prefix + "offset_x"] = slotConfig.offset_x;
    if (slotConfig.offset_y !== undefined) flat[prefix + "offset_y"] = slotConfig.offset_y;
    if (slotConfig.offset_x_mobile !== undefined) flat[prefix + "offset_x_mobile"] = slotConfig.offset_x_mobile;
    if (slotConfig.offset_y_mobile !== undefined) flat[prefix + "offset_y_mobile"] = slotConfig.offset_y_mobile;
    if (slotConfig.overflow !== undefined) flat[prefix + "overflow"] = slotConfig.overflow;
    
    // Styling
    if (slotConfig.styling) {
      flat[prefix + "use_global"] = false;
      flat[prefix + "size_px"] = slotConfig.styling.size_px;
      flat[prefix + "weight"] = slotConfig.styling.weight;
      flat[prefix + "color"] = slotConfig.styling.color;
      flat[prefix + "text_shadow"] = slotConfig.styling.text_shadow;
      flat[prefix + "icon_shadow"] = slotConfig.styling.icon_shadow;
      flat[prefix + "pill"] = slotConfig.styling.pill;
      flat[prefix + "pill_background"] = slotConfig.styling.pill_background;
      flat[prefix + "pill_padding_x"] = slotConfig.styling.pill_padding_x;
      flat[prefix + "pill_padding_y"] = slotConfig.styling.pill_padding_y;
      flat[prefix + "pill_radius"] = slotConfig.styling.pill_radius;
      flat[prefix + "pill_blur"] = slotConfig.styling.pill_blur;
      flat[prefix + "pill_border_style"] = slotConfig.styling.pill_border_style;
      flat[prefix + "pill_border_width"] = slotConfig.styling.pill_border_width;
      flat[prefix + "pill_border_color"] = slotConfig.styling.pill_border_color;
    } else {
      flat[prefix + "use_global"] = true;
    }
    
    // Type-specific
    if (slotConfig.weather) {
      Object.entries(slotConfig.weather).forEach(([key, val]) => {
        if (key === 'entity') {
          flat[prefix + "weather_entity"] = val;
        } else if (key.startsWith('icon_')) {
          flat[prefix + "weather_" + key] = val;
        } else {
          flat[prefix + key] = val;
        }
      });
    }
    
    if (slotConfig.datetime) {
      Object.entries(slotConfig.datetime).forEach(([key, val]) => {
        flat[prefix + key] = val;
      });
    }
    
    if (slotConfig.button) {
      Object.entries(slotConfig.button).forEach(([key, val]) => {
        flat[prefix + key] = val;
      });
    }
    
    if (slotConfig.custom) {
      flat[prefix + "card"] = slotConfig.custom.card;
    }
    
    if (slotConfig.align !== undefined) flat[prefix + "align"] = slotConfig.align;
    
    // Actions
    if (slotConfig.actions) {
      if (slotConfig.actions.tap_action) flat[prefix + "tap_action"] = slotConfig.actions.tap_action;
      if (slotConfig.actions.hold_action) flat[prefix + "hold_action"] = slotConfig.actions.hold_action;
      if (slotConfig.actions.double_tap_action) flat[prefix + "double_tap_action"] = slotConfig.actions.double_tap_action;
    }

    // HKI Popup config (nested sub-object â†’ flat prefix keys)
    if (slotConfig.hki_popup && typeof slotConfig.hki_popup === 'object') {
      Object.entries(slotConfig.hki_popup).forEach(([k, v]) => {
        if (v !== undefined) flat[prefix + popupNestedKeyToFlatKey(k)] = v;
      });
    }
    // Also support legacy flat popup keys directly on slotConfig (pre-hki_popup format)
    copyDefinedKeys({
      src: slotConfig,
      dst: flat,
      keys: HKI_POPUP_CONFIG_KEYS,
      dstPrefix: prefix,
      onlyIfDstMissing: true,
    });
  });
  }); // end bar loop
  
  // Flatten persons
  if (nested.persons) {
    if (nested.persons.enabled !== undefined) flat.persons_enabled = nested.persons.enabled;
    if (nested.persons.align !== undefined) flat.persons_align = nested.persons.align;
    if (nested.persons.offset_x !== undefined) flat.persons_offset_x = nested.persons.offset_x;
    if (nested.persons.offset_y !== undefined) flat.persons_offset_y = nested.persons.offset_y;
    if (nested.persons.size !== undefined) flat.persons_size = nested.persons.size;
    if (nested.persons.spacing !== undefined) flat.persons_spacing = nested.persons.spacing;
    if (nested.persons.stack_order !== undefined) flat.persons_stack_order = nested.persons.stack_order;
    if (nested.persons.dynamic_order !== undefined) flat.persons_dynamic_order = nested.persons.dynamic_order;
    if (nested.persons.hide_away !== undefined) flat.persons_hide_away = nested.persons.hide_away;
    if (nested.persons.use_entity_picture !== undefined) flat.persons_use_entity_picture = nested.persons.use_entity_picture;
    if (nested.persons.border_width !== undefined) flat.persons_border_width = nested.persons.border_width;
    if (nested.persons.border_style !== undefined) flat.persons_border_style = nested.persons.border_style;
    if (nested.persons.border_radius !== undefined) flat.persons_border_radius = nested.persons.border_radius;
    if (nested.persons.border_color !== undefined) flat.persons_border_color = nested.persons.border_color;
    if (nested.persons.border_color_away !== undefined) flat.persons_border_color_away = nested.persons.border_color_away;
    if (nested.persons.box_shadow !== undefined) flat.persons_box_shadow = nested.persons.box_shadow;
    if (nested.persons.grayscale_away !== undefined) flat.persons_grayscale_away = nested.persons.grayscale_away;
    if (nested.persons.entities !== undefined) {
      flat.persons_entities = (nested.persons.entities || []).map((person) => {
        if (!person || typeof person !== "object") return person;
        const out = { ...person };
        const popup = (person.popup && typeof person.popup === "object") ? person.popup : null;
        if (popup) {
          Object.entries(popup).forEach(([k, v]) => {
            if (v === undefined) return;
            out[popupNestedKeyToFlatKey(k)] = v;
          });
          delete out.popup;
        }
        return out;
      });
    }
  }
  
  return flat;
}


// Simplified hash - djb2
function hashStr(s) {
  let h = 5381;
  for (let i = 0; i < s.length; i++) h = (h * 33) ^ s.charCodeAt(i);
  return (h >>> 0).toString(16);
}

function cacheKey(raw, vars) {
  return `hkiTpl:${hashStr(raw + (vars ? JSON.stringify(vars) : ""))}`;
}

// Date formatting helper - uses locale for proper translations
function formatDateTime(date, format, locale = 'en') {
  const pad = (n) => String(n).padStart(2, '0');
  
  // Get localized day names
  const getDayName = (d, style) => {
    try {
      return new Intl.DateTimeFormat(locale, { weekday: style }).format(d);
    } catch (_) {
      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      const daysShort = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
      return style === 'long' ? days[d.getDay()] : daysShort[d.getDay()];
    }
  };
  
  // Get localized month names
  const getMonthName = (d, style) => {
    try {
      return new Intl.DateTimeFormat(locale, { month: style }).format(d);
    } catch (_) {
      const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
      const monthsShort = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      return style === 'long' ? months[d.getMonth()] : monthsShort[d.getMonth()];
    }
  };

  const h24 = date.getHours();
  const h12 = h24 % 12 || 12;
  const ampm = h24 < 12 ? 'AM' : 'PM';

  const tokens = {
    'YYYY': date.getFullYear(),
    'YY': String(date.getFullYear()).slice(-2),
    'MMMM': getMonthName(date, 'long'),
    'MMM': getMonthName(date, 'short'),
    'MM': pad(date.getMonth() + 1),
    'DDDD': getDayName(date, 'long'),
    'DDD': getDayName(date, 'short'),
    'DD': pad(date.getDate()),
    'HH': pad(h24),
    'hh': pad(h12),
    'mm': pad(date.getMinutes()),
    'ss': pad(date.getSeconds()),
    'M': date.getMonth() + 1,
    'D': date.getDate(),
    'H': h24,
    'h': h12,
    'm': date.getMinutes(),
    's': date.getSeconds(),
    'A': ampm,
    'a': ampm.toLowerCase(),
  };

  // Single-pass replacement using regex with all tokens (longest first via alternation order)
  const tokenPattern = /YYYY|MMMM|DDDD|YY|MMM|DDD|MM|DD|HH|hh|mm|ss|M|D|H|h|m|s|A|a/g;
  return format.replace(tokenPattern, match => tokens[match]);
}

class HkiHeaderCard extends LitElement {
  static get properties() {
    return {
      hass: {},
      _config: { attribute: false },
      _offsetLeft: { type: Number },
      _viewportWidth: { type: Number },
      _contentWidth: { type: Number },
      _inPreview: { type: Boolean },
      _headerHeight: { type: Number },
      _kioskMode: { type: Boolean },
      _editMode: { type: Boolean },
      _renderedTitle: { type: String },
      _renderedSubtitle: { type: String },
      _currentTime: { type: Number },
      _customCards: { attribute: false }, // Store elements for left/center/right
    };
  }

  constructor() {
    super();
    this._config = {};
    this._rawConfigInput = null;
    this._onGlobalSettingsChanged = () => {
      if (!this._rawConfigInput) return;
      try { this.setConfig(this._rawConfigInput); } catch (_) {}
    };
    this._offsetLeft = 0;
    this._viewportWidth = 0;
    this._contentWidth = 0;
    this._inPreview = false;
    this._headerHeight = 0;
    this._kioskMode = false;
    this._editMode = false;
    this._renderedTitle = "";
    this._renderedSubtitle = "";
    this._currentTime = Date.now();
    this._customCards = { left: null, center: null, right: null, bottom_left: null, bottom_center: null, bottom_right: null };

    // Handlers & observers
    this._resizeHandler = null;
    this._ro = null;
    this._rafMeasure = 0;
    this._rafBadges = 0;
    this._kioskCheckInterval = null;
    this._kioskMutationObserver = null;
    this._urlChangeHandler = null;
    this._cachedHeader = null;
    this._visibilityHandler = null;
    this._focusHandler = null;
    this._editModeInterval = null;
    this._timeInterval = null;

    this._tpl = {
      timer: 0,
      title: { raw: "", sig: "", seq: 0, unsub: null },
      subtitle: { raw: "", sig: "", seq: 0, unsub: null },
    };

    this._hassReady = false;
    this._badgesEl = null;
    
    // Performance: Style caches
    this._slotStyleCache = new Map();
    this._lastConfigHash = null;
    this._inlineTplSubs = new Map();
    this._activePopupProxyCards = new Set();
  }

  static get styles() {
    return css`
      :host { display: block; }

      .header-fixed {
        position: fixed;
        left: 0;
        top: 0;
        width: 100vw;
        z-index: 1;
        overflow: hidden; /* Respect border-radius and box-shadow of child */
      }

      ha-card.header {
        position: relative;
        width: 100vw;
        height: 240px;
        min-height: 240px;
        max-height: 240px;
        margin: 0;
        border-radius: 0; /* Overridden by inline style */
        overflow: visible; /* Allow box-shadow to show when fixed */
        box-sizing: border-box;
        color: var(--hki-header-text-color, #fff);
        /* border and box-shadow controlled via inline styles */
      }

      .overlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
      }

      .content {
        position: relative;
        z-index: 1;
        height: 100%;
        box-sizing: border-box;
      }

      .title-block {
        position: absolute;
        display: flex;
        flex-direction: column;
        gap: 2px;
        padding-right: 16px;
      }

      .title {
        line-height: 1.1;
        text-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
        white-space: pre-wrap;
      }

      .subtitle {
        opacity: 0.9;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.6);
        white-space: pre-wrap;
      }

      .header-spacer {
        width: 100%;
        display: block;
      }

      .edit-placeholder {
        border-radius: 14px;
        border: 2px dashed rgba(160, 160, 160, 0.35);
        background: rgba(0, 0, 0, 0.02);
        box-shadow: none;
      }

      .edit-placeholder-inner {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
      }

      .edit-placeholder-text {
        min-width: 0;
      }

      .edit-placeholder-title {
        font-weight: 800;
      }

      .edit-placeholder-subtitle {
        opacity: 0.7;
        font-size: 12px;
      }

      /* PERSON AVATARS */
      .persons-container {
        position: absolute;
        display: flex;
        align-items: center;
        z-index: 2;
      }

      .person-avatar {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        overflow: hidden;
        border: 2px solid rgba(255,255,255,0.3);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        flex-shrink: 0;
        background: var(--primary-background-color);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
      }

      .person-avatar:hover {
        transform: scale(1.05);
        box-shadow: 0 3px 12px rgba(0, 0, 0, 0.6);
      }

      .person-avatar img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
        pointer-events: none;
      }

      .person-avatar ha-icon {
        --mdc-icon-size: 28px;
        color: var(--primary-text-color);
        pointer-events: none;
      }

      /* INFO ITEM (Flex Child for Top Bar) */
      .info-item {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        color: var(--hki-header-text-color, #fff);
        text-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
        flex-shrink: 0;
        flex-grow: 0;
        line-height: 1;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
      }

      .hki-slot-button {
        position: relative;
        overflow: visible !important;
        height: var(--hki-slot-badge-height, 34px);
        min-height: var(--hki-slot-badge-height, 34px);
        max-height: var(--hki-slot-badge-height, 34px);
        box-sizing: border-box;
      }

      .hki-slot-button-icon-only {
        width: var(--hki-slot-circle-size, 34px) !important;
        height: var(--hki-slot-circle-size, 34px) !important;
        min-width: var(--hki-slot-circle-size, 34px) !important;
        max-width: var(--hki-slot-circle-size, 34px) !important;
        min-height: var(--hki-slot-circle-size, 34px) !important;
        max-height: var(--hki-slot-circle-size, 34px) !important;
        border-radius: 50% !important;
        padding: 0 !important;
        gap: 0 !important;
        aspect-ratio: 1 / 1;
      }

      .hki-slot-button-badge {
        position: absolute;
        top: -4px;
        right: -4px;
        min-width: 16px;
        height: 16px;
        padding: 0 5px;
        border-radius: 10px;
        background: #ff4444;
        color: #ffffff;
        font-size: 10px;
        font-weight: 600;
        line-height: 16px;
        text-align: center;
        box-sizing: border-box;
        z-index: 10;
        pointer-events: none;
      }

      .hki-slot-button-text {
        display: inline-flex;
        flex-direction: column;
        align-items: flex-start;
        gap: 2px;
        line-height: 1.1;
      }

      .hki-slot-button-name,
      .hki-slot-button-state {
        display: block;
      }

      .info-clickable {
        cursor: pointer;
        transition: opacity 0.2s;
      }
      .info-clickable:hover { opacity: 0.8; }

      .info-icon {
        color: var(--hki-header-text-color, #fff);
        filter: var(--hki-info-icon-filter, drop-shadow(0 2px 4px rgba(0, 0, 0, 0.6)));
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        overflow: visible;
        line-height: 0;
        box-sizing: border-box;
      }

      img.info-icon {
        object-fit: contain;
        display: block;
      }

      ha-icon {
        display: block;
        line-height: 0;
        box-sizing: border-box;
        padding: 0;
        margin: 0;
      }
      
      .info-icon ha-icon {
        width: 100%;
        height: 100%;
        max-width: 100%;
        max-height: 100%;
        min-width: 0;
        min-height: 0;
        overflow: visible;
        display: block;
        line-height: 0;
      }
      
      ha-icon svg {
        display: block;
        max-width: 100%;
        max-height: 100%;
        vertical-align: top;
      }

      .info-text { text-transform: capitalize; line-height: 1; display: inline-block; vertical-align: middle; }
      .info-temperature { font-weight: 500; line-height: 1; display: inline-block; vertical-align: middle; }
      .info-condition { line-height: 1; display: inline-block; vertical-align: middle; }
      .info-humidity { line-height: 1; display: inline-block; vertical-align: middle; }
      .info-wind { line-height: 1; display: inline-block; vertical-align: middle; }
      .info-pressure { line-height: 1; display: inline-block; vertical-align: middle; }

      .info-pill {
        background: var(--hki-info-pill-background, rgba(0, 0, 0, 0.25));
        border-radius: var(--hki-info-pill-radius, 999px);
        padding: var(--hki-info-pill-padding-y, 8px) var(--hki-info-pill-padding-x, 12px);
        backdrop-filter: blur(var(--hki-info-pill-blur, 0px));
        -webkit-backdrop-filter: blur(var(--hki-info-pill-blur, 0px));
        border-style: var(--hki-info-pill-border-style, none);
        border-width: var(--hki-info-pill-border-width, 0);
        border-color: var(--hki-info-pill-border-color, rgba(255,255,255,0.1));
        box-sizing: border-box;
        overflow: visible;
      }

      hki-notification-card {
        display: block;
        overflow: hidden;
        border-radius: inherit;
      }

      /* TOP BAR LAYOUT */
      .top-bar-container {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        z-index: 3;
        box-sizing: border-box;
      }

      .slot {
        display: flex;
        align-items: center;
        min-height: 20px;
        flex: 1 1 0%;
        min-width: 0;
        overflow: hidden;
      }

      .slot-visible {
        overflow: visible !important;
      }

      .slot-left {
        justify-content: flex-start;
        text-align: left;
      }
      .slot-center {
        justify-content: center;
        text-align: center;
      }
      .slot-right {
        justify-content: flex-end;
        text-align: right;
      }
      .slot-align-start  { justify-content: flex-start !important; text-align: left !important; }
      .slot-align-center { justify-content: center !important;     text-align: center !important; }
      .slot-align-end    { justify-content: flex-end !important;   text-align: right !important; }

      /* BOTTOM BAR LAYOUT */
      .bottom-bar-container {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        z-index: 3;
        box-sizing: border-box;
        overflow: visible;
      }
      
      /* Empty slots collapse to allow more space for occupied slots */
      .slot.slot-empty {
        flex: 0 0 auto;
        overflow: visible;
      }
      
      /* Spacer is invisible but takes up layout space */
      .slot-spacer {
        display: block;
        width: 1px;
        height: 1px;
        visibility: hidden;
      }

      .animate-float { animation: hki-float 3s ease-in-out infinite; }
      .animate-pulse { animation: hki-pulse 1.8s ease-in-out infinite; }
      .animate-spin { animation: hki-spin 2.8s linear infinite; }

      @keyframes hki-float {
        0%, 100% { transform: translateY(0); }
        50% { transform: translateY(-4px); }
      }
      @keyframes hki-pulse {
        0%, 100% { transform: scale(1); opacity: 1; }
        50% { transform: scale(1.08); opacity: 0.85; }
      }
      @keyframes hki-spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
    `;
  }

  connectedCallback() {
    super.connectedCallback();
    window.addEventListener("hki-global-settings-changed", this._onGlobalSettingsChanged);
    this._detectKioskMode();
    // Fix for template reactivity: re-establish subscriptions when reconnected to DOM
    this._scheduleTemplateSetup(0);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("hki-global-settings-changed", this._onGlobalSettingsChanged);

    if (this._resizeHandler) {
      window.removeEventListener("resize", this._resizeHandler);
      this._resizeHandler = null;
    }
    if (this._ro) {
      this._ro.disconnect();
      this._ro = null;
    }
    if (this._rafMeasure) cancelAnimationFrame(this._rafMeasure);
    if (this._rafBadges) cancelAnimationFrame(this._rafBadges);
    if (this._tpl.timer) clearTimeout(this._tpl.timer);
    if (this._kioskCheckInterval) clearInterval(this._kioskCheckInterval);
    if (this._kioskMutationObserver) this._kioskMutationObserver.disconnect();
    if (this._urlChangeHandler) {
      window.removeEventListener("popstate", this._urlChangeHandler);
      window.removeEventListener("hashchange", this._urlChangeHandler);
    }
    if (this._visibilityHandler) document.removeEventListener("visibilitychange", this._visibilityHandler);
    if (this._focusHandler) window.removeEventListener("focus", this._focusHandler);
    if (this._editModeInterval) clearInterval(this._editModeInterval);
    if (this._timeInterval) clearInterval(this._timeInterval);

    this._unsubscribeTemplate("title");
    this._unsubscribeTemplate("subtitle");
    this._clearInlineTemplateSubs();
    this._resetBadgesZIndex();
    this._activePopupProxyCards.clear();
  }

  firstUpdated() {
    this._detectPreview();
    this._detectKioskMode();
    this._detectEditMode();

    // Consolidated resize handling
    this._resizeHandler = () => {
      this._debouncedMeasure(true);
      this._debouncedBadgesZIndex();
      this.requestUpdate(); // Force update for responsive mobile offsets
    };
    window.addEventListener("resize", this._resizeHandler, { passive: true });

    this._ro = new ResizeObserver(this._resizeHandler);
    this._ro.observe(this);

    // Mutation observer for kiosk mode
    this._kioskMutationObserver = new MutationObserver(() => this._detectKioskMode());
    this._kioskMutationObserver.observe(document.body, { attributes: true, attributeFilter: ["class"] });
    this._kioskMutationObserver.observe(document.documentElement, { attributes: true, attributeFilter: ["class"] });

    // URL change handler
    this._urlChangeHandler = () => {
      this._detectKioskMode();
      this._detectEditMode();
    };
    window.addEventListener("popstate", this._urlChangeHandler);
    window.addEventListener("hashchange", this._urlChangeHandler);

    // Visibility & focus handlers
    this._visibilityHandler = () => {
      if (!document.hidden) {
        this._cachedHeader = null;
        this._detectKioskMode();
        setTimeout(() => this._detectKioskMode(), 200);
      }
    };
    document.addEventListener("visibilitychange", this._visibilityHandler);

    this._focusHandler = () => {
      this._cachedHeader = null;
      this._detectKioskMode();
    };
    window.addEventListener("focus", this._focusHandler);

    // Reduced polling: edit mode every 2s instead of 1s
    this._editModeInterval = setInterval(() => this._detectEditMode(), 2000);

    // Time update interval for datetime display
    this._timeInterval = setInterval(() => {
      if (this._config?.top_bar_enabled) {
        this._currentTime = Date.now();
        this.requestUpdate();
      }
    }, 1000);

    // Reduced initial checks
    [100, 500, 1500].forEach(delay => {
      setTimeout(() => {
        this._cachedHeader = null;
        this._detectKioskMode();
      }, delay);
    });

    // Reduced kiosk polling: 10s instead of 5s
    this._kioskCheckInterval = setInterval(() => this._detectKioskMode(), 10000);

    requestAnimationFrame(() => this._measure(true));
    this._scheduleTemplateSetup(0);
    this._debouncedBadgesZIndex();

    this._updateCustomCards();
  }

  updated(changed) {
    if (changed.has("_config")) {
      this._slotStyleCache.clear(); // Clear cached styles on config change
      this._detectPreview();
      this._debouncedMeasure(true);
      this._scheduleTemplateSetup(80);
      this._debouncedBadgesZIndex();
      this._updateCustomCards();
      return;
    }

    if (changed.has("hass")) {
      this._detectPreview();
      this._detectEditMode();
      this._debouncedMeasure(true);

      const nowReady = !!this.hass?.connection && typeof this.hass?.callWS === "function";
      if (nowReady && !this._hassReady) {
        this._hassReady = true;
        this._scheduleTemplateSetup(0);
        this._cachedHeader = null;
        this._detectKioskMode();
      }
      this._debouncedBadgesZIndex();

      // Pass hass to custom cards
      Object.values(this._customCards).forEach(el => {
        if (el) el.hass = this.hass;
      });

      // Keep detached popup proxy cards (opened via header actions) in sync
      this._syncActivePopupProxyCards();
    }

    if (changed.has("_kioskMode")) {
      this._debouncedMeasure(true);
      this._debouncedBadgesZIndex();
    }
  }

  _ensurePopupProxyHost() {
    if (!document?.body) return null;
    let host = document.getElementById("hki-popup-proxy-host");
    if (!host) {
      host = document.createElement("div");
      host.id = "hki-popup-proxy-host";
      host.style.cssText = "display:none !important; width:0; height:0; overflow:hidden; pointer-events:none;";
      document.body.appendChild(host);
    }
    return host;
  }

  _attachPopupProxyCard(card) {
    if (!card || card.isConnected) return;
    const host = this._ensurePopupProxyHost();
    if (!host) return;
    host.appendChild(card);
  }

  _syncActivePopupProxyCards() {
    if (!this._activePopupProxyCards?.size) return;
    [...this._activePopupProxyCards].forEach((card) => {
      if (!card || card._popupOpen !== true) {
        this._activePopupProxyCards.delete(card);
        try {
          if (card?.parentNode) card.remove();
        } catch (_) {}
        return;
      }
      try { card.hass = this.hass; } catch (_) {}
    });
  }

  _detectKioskMode() {
    const urlParams = new URLSearchParams(window.location.search);
    const urlKiosk = urlParams.get("kiosk") === "true" || window.location.search.includes("kiosk");
    
    const bodyKiosk = document.body.classList.contains("kiosk-mode") || 
                      document.documentElement.classList.contains("kiosk-mode");
    
    if (urlKiosk || bodyKiosk) {
      if (!this._kioskMode) {
        this._kioskMode = true;
        this.requestUpdate();
      }
      return;
    }
    
    let headerHidden = false;
    try {
      if (!this._cachedHeader || !document.contains(this._cachedHeader)) {
        const findHeader = (root, depth = 0) => {
          if (depth > 10) return null;
          
          const selectors = [
            "app-header",
            "mwc-top-app-bar-fixed", 
            ".toolbar",
            "[slot='header']",
            "ha-app-layout app-header",
            "ha-tabs"
          ];
          
          for (const selector of selectors) {
            const header = root.querySelector?.(selector);
            if (header) return header;
          }
          
          const elements = root.querySelectorAll?.("*") || [];
          for (const el of elements) {
            if (el.shadowRoot) {
              const found = findHeader(el.shadowRoot, depth + 1);
              if (found) return found;
            }
          }
          return null;
        };
        
        const ha = document.querySelector("home-assistant");
        if (ha?.shadowRoot) {
          this._cachedHeader = findHeader(ha.shadowRoot);
        }
        
        if (!this._cachedHeader) {
          this._cachedHeader = findHeader(document);
        }
      }
      
      if (this._cachedHeader) {
        const rect = this._cachedHeader.getBoundingClientRect();
        const style = window.getComputedStyle(this._cachedHeader);
        
        headerHidden = 
          rect.height === 0 || 
          this._cachedHeader.offsetHeight === 0 || 
          this._cachedHeader.clientHeight === 0 ||
          rect.top < -100 ||
          style.display === "none" || 
          style.visibility === "hidden" || 
          style.opacity === "0";
      }
    } catch (e) {
      // Silent fail
    }
    
    const newKioskMode = headerHidden;
    
    if (newKioskMode !== this._kioskMode) {
      this._kioskMode = newKioskMode;
      this.requestUpdate();
    }
  }

  _debouncedMeasure(readCard = false) {
    if (this._rafMeasure) return;
    this._rafMeasure = requestAnimationFrame(() => {
      this._rafMeasure = 0;
      this._measure(readCard);
    });
  }

  _measure(readCard = false) {
    const rect = this.getBoundingClientRect?.();
    if (!rect) return;

    const vw = window.innerWidth || document.documentElement.clientWidth || rect.width;

    if (vw !== this._viewportWidth || rect.left !== this._offsetLeft || rect.width !== this._contentWidth) {
      this._viewportWidth = vw;
      this._offsetLeft = rect.left;
      this._contentWidth = rect.width;
      this.requestUpdate();
    }

    if (readCard) {
      const card = this.renderRoot?.querySelector?.("ha-card.header");
      const cr = card?.getBoundingClientRect?.();
      if (cr?.height) this._headerHeight = Math.round(cr.height);
    }
  }

  _detectPreview() {
    let node = this;
    while (node) {
      const root = node.getRootNode?.();
      if (!root || root === document) break;
      const host = root.host;
      if (!host) break;

      const tag = (host.tagName || "").toLowerCase();
      if (tag === "hui-card-preview" || tag === "hui-dialog-edit-card" || tag === "ha-dialog" || tag === "ha-dialog-scroller") {
        this._inPreview = true;
        return;
      }
      node = host;
    }
    this._inPreview = false;
  }

  _detectEditMode() {
    if (this._inPreview) {
      if (!this._editMode) {
        this._editMode = true;
        this.requestUpdate();
      }
      return;
    }

    let edit = false;
    try {
      const huiRoot = document.querySelector("hui-root") ||
                      document.querySelector("home-assistant")?.shadowRoot?.querySelector("hui-root");
      edit = !!(huiRoot?.lovelace?.editMode || huiRoot?.editMode);
    } catch (_) {}

    if (!edit) {
      try {
        edit = document.body?.classList?.contains("edit-mode") ||
               !!document.querySelector("hui-dialog-edit-card");
      } catch (_) {}
    }

    if (edit !== this._editMode) {
      this._editMode = edit;
      this.requestUpdate();
    }
  }

  _isEditMode() {
    try {
      const qs = new URLSearchParams(window.location.search || "");
      if (qs.get("edit") === "1") return true;
    } catch (_) {}
    if (document.body?.classList) {
      if (document.body.classList.contains("edit-mode") || document.body.classList.contains("edit")) return true;
    }
    return false;
  }

  setConfig(config) {
    if (!config) throw new Error("Invalid configuration");
    this._rawConfigInput = config;

    // Detect format and convert if needed
    let workingConfig = config;
    
    // If config uses old flat format, migrate to nested first
    if (isOldFormat(config)) {
      const nested = migrateToNestedFormat(config);
      workingConfig = flattenNestedFormat(nested); // Flatten back for internal use
    } else {
      const hasNestedSlotConfig = [
        "top_bar_left", "top_bar_center", "top_bar_right",
        "bottom_bar_left", "bottom_bar_center", "bottom_bar_right",
      ].some((key) => config[key] && typeof config[key] === "object" && !Array.isArray(config[key]));
      const hasNestedSections = ["top_bar", "bottom_bar", "info", "bottom_info", "persons"]
        .some((key) => config[key] && typeof config[key] === "object" && !Array.isArray(config[key]));
      if (hasNestedSlotConfig || hasNestedSections) {
        // New nested format - flatten for internal use
        workingConfig = flattenNestedFormat(config);
      }
    }

    const m = { ...DEFAULTS, ...workingConfig };

    applyGlobalDefaultsToConfig({
      scope: "header",
      config: m,
      sourceConfig: workingConfig,
      fields: [
        "card_border_radius",
        "card_border_radius_top",
        "card_border_radius_bottom",
        "card_box_shadow",
        "card_border_style",
        "card_border_width",
        "card_border_color",
        "font_family",
        "font_family_custom",
        "font_style",
        "title_size_px",
        "subtitle_size_px",
        "title_weight",
        "subtitle_weight",
        "title_color",
        "subtitle_color",
      ],
    });

    // Numeric clamping
    m.height_vh = clamp(+m.height_vh, 10, 100);
    m.min_height = clamp(+m.min_height, 60, 2000);
    m.max_height = clamp(+m.max_height, m.min_height, 4000);
    m.blend_stop = clamp(+m.blend_stop, 0, 100);
    m.fixed = !!m.fixed;
    m.fixed_top = toNum(m.fixed_top, 0);
    m.title_offset_x = toNum(m.title_offset_x, 5);
    m.title_offset_y = toNum(m.title_offset_y, 32);
    m.subtitle_offset_x = toNum(m.subtitle_offset_x, 5);
    m.subtitle_offset_y = toNum(m.subtitle_offset_y, 32);
    m.badges_offset_pinned = toNum(m.badges_offset_pinned, 48);
    m.badges_offset_unpinned = toNum(m.badges_offset_unpinned, 100);
    m.badges_gap = toNum(m.badges_gap, 0);
    m.mobile_breakpoint = toNum(m.mobile_breakpoint, 768);

    // Person entities configuration
    m.persons_enabled = !!m.persons_enabled;
    
    // Handle backward compatibility and normalize persons_entities structure
    if (Array.isArray(m.persons_entities)) {
      m.persons_entities = m.persons_entities.map(item => {
        // If it's already an object, ensure it has all required fields
        if (typeof item === 'object' && item !== null) {
          const popup = (item.popup && typeof item.popup === 'object') ? item.popup : null;
          const normalized = {
            entity: item.entity || "",
            grayscale_entity: item.grayscale_entity || "",
            icon_home: item.icon_home || "",
            icon_away: item.icon_away || "",
            picture_home: item.picture_home || "",
            picture_away: item.picture_away || "",
            tap_action: item.tap_action || { action: "more-info" },
            hold_action: item.hold_action || { action: "none" },
            double_tap_action: item.double_tap_action || { action: "none" }
          };
          if (popup) {
            Object.entries(popup).forEach(([k, v]) => {
              if (v === undefined) return;
              const flatKey = popupNestedKeyToFlatKey(k);
              if (flatKey === "custom_popup_enabled" || flatKey === "custom_popup_card" || flatKey.startsWith("popup_") || HKI_POPUP_CONFIG_KEYS.includes(flatKey)) {
                normalized[flatKey] = v;
              }
            });
          }
          // Preserve popup settings (slot-level, shared across actions)
          if (item.custom_popup_enabled !== undefined) normalized.custom_popup_enabled = item.custom_popup_enabled;
          if (item.custom_popup_card !== undefined) normalized.custom_popup_card = item.custom_popup_card;
          if (item.popup_name !== undefined) normalized.popup_name = item.popup_name;
          if (item.popup_state !== undefined) normalized.popup_state = item.popup_state;
          if (item.popup_border_radius !== undefined) normalized.popup_border_radius = item.popup_border_radius;
          if (item.popup_width !== undefined) normalized.popup_width = item.popup_width;
          if (item.popup_open_animation !== undefined) normalized.popup_open_animation = item.popup_open_animation;
          if (item.popup_close_animation !== undefined) normalized.popup_close_animation = item.popup_close_animation;
          if (item.popup_animation_duration !== undefined) normalized.popup_animation_duration = item.popup_animation_duration;
          if (item.popup_blur_enabled !== undefined) normalized.popup_blur_enabled = item.popup_blur_enabled;
          // Preserve ALL popup config keys
          copyDefinedKeys({
            src: item,
            dst: normalized,
            keys: HKI_POPUP_CONFIG_KEYS,
            onlyIfDstMissing: true,
          });
          return normalized;
        }
        // If it's a string (old format), convert to object
        if (typeof item === 'string') {
          return {
            entity: item,
            grayscale_entity: "",
            icon_home: "",
            icon_away: "",
            picture_home: "",
            picture_away: "",
            tap_action: { action: "more-info" },
            hold_action: { action: "none" },
            double_tap_action: { action: "none" }
          };
        }
        return null;
      }).filter(Boolean);
    } else {
      m.persons_entities = [];
    }
    
    m.persons_align = ["left", "center", "right"].includes(m.persons_align) ? m.persons_align : "left";
    m.persons_offset_x = toNum(m.persons_offset_x, 5);
    m.persons_offset_y = toNum(m.persons_offset_y, 32);
    m.persons_size = clamp(+m.persons_size || 48, 24, 128);
    m.persons_spacing = toNum(m.persons_spacing, -8);
    m.persons_stack_order = ["ascending", "descending"].includes(m.persons_stack_order) ? m.persons_stack_order : "ascending";
    m.persons_dynamic_order = !!m.persons_dynamic_order;
    m.persons_hide_away = !!m.persons_hide_away;
    m.persons_use_entity_picture = m.persons_use_entity_picture !== false;
    m.persons_border_width = clamp(+m.persons_border_width || 1, 0, 10);
    m.persons_border_style = m.persons_border_style || "solid";
    m.persons_border_radius = m.persons_border_radius !== undefined ? m.persons_border_radius : 50;
    m.persons_border_color = m.persons_border_color || "rgba(255,255,255,0.3)";
    m.persons_border_color_away = m.persons_border_color_away || "rgba(255,100,100,0.5)";
    m.persons_box_shadow = m.persons_box_shadow !== undefined ? m.persons_box_shadow : "0 2px 8px rgba(0, 0, 0, 0.4)";
    m.persons_grayscale_away = !!m.persons_grayscale_away;


    // Background extra options
    m.background_blend_mode = m.background_blend_mode || "normal";
    // Allow custom sizing, default to cover if missing
    m.background_size = m.background_size || "cover";
    m.background_color = m.background_color || "";
    m.blend_enabled = m.blend_enabled !== false;
    
    // Header styling options
    // Border radius split: if top/bottom are not set, fall back to legacy card_border_radius.
    m.card_border_radius = m.card_border_radius || "";
    m.card_border_radius_top = m.card_border_radius_top || "";
    m.card_border_radius_bottom = m.card_border_radius_bottom || "";
    if (!m.card_border_radius_top && !m.card_border_radius_bottom && m.card_border_radius) {
      m.card_border_radius_top = m.card_border_radius;
      m.card_border_radius_bottom = m.card_border_radius;
    }
    m.card_box_shadow = m.card_box_shadow || "";
    m.card_border_style = m.card_border_style || "none";
    m.card_border_width = toNum(m.card_border_width, 0);
    m.card_border_color = m.card_border_color || "";

    // Top Bar Settings
    m.top_bar_enabled = m.top_bar_enabled !== false;
    m.top_bar_offset_y = toNum(m.top_bar_offset_y, 10);
    m.top_bar_padding_x = toNum(m.top_bar_padding_x, 5);
    
    const validSlotTypes = ["none", "spacer", "weather", "datetime", "notifications", "custom", "card", "button"];
    // Migrate legacy "custom" value to "notifications"
    if (m.top_bar_left === "custom") m.top_bar_left = "notifications";
    if (m.top_bar_center === "custom") m.top_bar_center = "notifications";
    if (m.top_bar_right === "custom") m.top_bar_right = "notifications";
    // Read bottom_bar settings from nested format
    if (m.bottom_bar && typeof m.bottom_bar === 'object') {
      if (m.bottom_bar.enabled !== undefined) m.bottom_bar_enabled = m.bottom_bar.enabled;
      if (m.bottom_bar.offset_y !== undefined) m.bottom_bar_offset_y = m.bottom_bar.offset_y;
      if (m.bottom_bar.padding_x !== undefined) m.bottom_bar_padding_x = m.bottom_bar.padding_x;
    }
    m.bottom_bar_left = validSlotTypes.includes(m.bottom_bar_left) ? m.bottom_bar_left : "none";
    m.bottom_bar_center = validSlotTypes.includes(m.bottom_bar_center) ? m.bottom_bar_center : "none";
    m.bottom_bar_right = validSlotTypes.includes(m.bottom_bar_right) ? m.bottom_bar_right : "none";
    m.top_bar_left = validSlotTypes.includes(m.top_bar_left) ? m.top_bar_left : "none";
    m.top_bar_center = validSlotTypes.includes(m.top_bar_center) ? m.top_bar_center : "none";
    m.top_bar_right = validSlotTypes.includes(m.top_bar_right) ? m.top_bar_right : "none";
    
    // Per-slot config processing for each slot
    const normalizeSlotButtonConfig = (prefix) => {
      const legacyButton = {
        icon: m[prefix + "icon"],
        icon_animation: m[prefix + "icon_animation"],
        name: m[prefix + "name"],
        state: m[prefix + "state"],
        entity: m[prefix + "entity"],
        card_color: m[prefix + "card_color"],
        icon_color: m[prefix + "icon_color"],
        name_color: m[prefix + "name_color"],
        state_color: m[prefix + "state_color"],
        text_shadow: m[prefix + "text_shadow"],
        icon_shadow: m[prefix + "icon_shadow"],
        name_offset_x: m[prefix + "name_offset_x"],
        name_offset_y: m[prefix + "name_offset_y"],
        state_offset_x: m[prefix + "state_offset_x"],
        state_offset_y: m[prefix + "state_offset_y"],
        visibility_mode: m[prefix + "visibility_mode"],
        visibility_entity: m[prefix + "visibility_entity"],
        visibility_state: m[prefix + "visibility_state"],
        visibility_attribute: m[prefix + "visibility_attribute"],
        visibility_attribute_value: m[prefix + "visibility_attribute_value"],
        show_badge: m[prefix + "show_badge"],
        badge_source: m[prefix + "badge_source"],
        badge_entity: m[prefix + "badge_entity"],
        badge_template: m[prefix + "badge_template"],
        badge_color: m[prefix + "badge_color"],
        badge_text_color: m[prefix + "badge_text_color"],
      };
      const hasLegacyButtonConfig = Object.values(legacyButton).some((v) => v !== undefined && v !== null && v !== "");
      const rawButtons = Array.isArray(m[prefix + "buttons"]) ? m[prefix + "buttons"] : [];
      let buttons = rawButtons.map((btn) => normalizeSlotButton(btn)).filter(Boolean);
      if (!buttons.length && hasLegacyButtonConfig) buttons = [normalizeSlotButton(legacyButton)];
      if (!buttons.length) buttons = [createDefaultSlotButton()];
      m[prefix + "buttons"] = buttons;
      m[prefix + "icon"] = buttons[0]?.icon || "mdi:gesture-tap";
      m[prefix + "icon_animation"] = buttons[0]?.icon_animation || "";
      m[prefix + "name"] = buttons[0]?.name || "";
    };

    ["left", "center", "right"].forEach(slot => {
      const prefix = `top_bar_${slot}_`;
      m[prefix + "use_global"] = m[prefix + "use_global"] !== false;
      normalizeSlotButtonConfig(prefix);
      // Alignment default differs per slot
      const defaultAlign = slot === "left" ? "start" : (slot === "right" ? "end" : "center");
      m[prefix + "align"] = ["start", "center", "end", "stretch"].includes(m[prefix + "align"]) ? m[prefix + "align"] : defaultAlign;
    });
    ["left", "center", "right"].forEach(slot => {
      const prefix = `bottom_bar_${slot}_`;
      m[prefix + "use_global"] = m[prefix + "use_global"] !== false;
      normalizeSlotButtonConfig(prefix);
      const defaultAlign = slot === "left" ? "start" : (slot === "right" ? "end" : "center");
      m[prefix + "align"] = ["start", "center", "end", "stretch"].includes(m[prefix + "align"]) ? m[prefix + "align"] : defaultAlign;
      m[prefix + "tap_action"] = m[prefix + "tap_action"] || { action: "none" };
      m[prefix + "hold_action"] = m[prefix + "hold_action"] || { action: "none" };
      m[prefix + "double_tap_action"] = m[prefix + "double_tap_action"] || { action: "none" };
      m[prefix + "tap_action"] = m[prefix + "tap_action"] || { action: "none" };
      m[prefix + "hold_action"] = m[prefix + "hold_action"] || { action: "none" };
      m[prefix + "double_tap_action"] = m[prefix + "double_tap_action"] || { action: "none" };
      m[prefix + "size_px"] = m[prefix + "size_px"] != null ? clamp(+m[prefix + "size_px"], 8, 64) : null;
      m[prefix + "weight"] = m[prefix + "weight"] ? normalizeWeightKey(m[prefix + "weight"], "medium") : null;
      m[prefix + "color"] = m[prefix + "color"] || null;
      m[prefix + "text_shadow"] = m[prefix + "text_shadow"] || null;
      m[prefix + "icon_shadow"] = m[prefix + "icon_shadow"] || null;
      m[prefix + "pill"] = m[prefix + "pill"] != null ? !!m[prefix + "pill"] : null;
      m[prefix + "pill_background"] = m[prefix + "pill_background"] || null;
      m[prefix + "pill_padding_x"] = m[prefix + "pill_padding_x"] != null ? clamp(+m[prefix + "pill_padding_x"], 0, 80) : null;
      m[prefix + "pill_padding_y"] = m[prefix + "pill_padding_y"] != null ? clamp(+m[prefix + "pill_padding_y"], 0, 80) : null;
      m[prefix + "pill_radius"] = m[prefix + "pill_radius"] != null ? clamp(+m[prefix + "pill_radius"], 0, 999) : null;
      m[prefix + "pill_blur"] = m[prefix + "pill_blur"] != null ? clamp(+m[prefix + "pill_blur"], 0, 40) : null;
      m[prefix + "pill_border_style"] = ["none", "solid", "dashed", "dotted"].includes(m[prefix + "pill_border_style"]) ? m[prefix + "pill_border_style"] : null;
      m[prefix + "pill_border_width"] = m[prefix + "pill_border_width"] != null ? clamp(+m[prefix + "pill_border_width"], 0, 10) : null;
      m[prefix + "pill_border_color"] = m[prefix + "pill_border_color"] || null;
      m[prefix + "offset_x"] = toNum(m[prefix + "offset_x"], 0);
      m[prefix + "offset_y"] = toNum(m[prefix + "offset_y"], 0);
      m[prefix + "overflow"] = !!m[prefix + "overflow"]; // New overflow option
      // Offset mobile can be null to inherit desktop, so we check carefully
      m[prefix + "offset_x_mobile"] = m[prefix + "offset_x_mobile"] != null ? toNum(m[prefix + "offset_x_mobile"], 0) : null;
      m[prefix + "offset_y_mobile"] = m[prefix + "offset_y_mobile"] != null ? toNum(m[prefix + "offset_y_mobile"], 0) : null;
    });

    // Global info styling
    m.info_size_px = clamp(+m.info_size_px || 12, 8, 64);
    m.info_weight = normalizeWeightKey(m.info_weight ?? "medium", "medium");
    m.info_text_shadow = m.info_text_shadow || "";
    m.info_icon_shadow = m.info_icon_shadow || "";
    m.info_pill = !!m.info_pill;
    m.info_pill_padding_x = clamp(+m.info_pill_padding_x || 12, 0, 80);
    m.info_pill_padding_y = clamp(+m.info_pill_padding_y || 8, 0, 80);
    m.info_pill_radius = clamp(+m.info_pill_radius || 999, 0, 999);
    m.info_pill_blur = clamp(+m.info_pill_blur || 0, 0, 40);
    m.info_pill_border_style = ["none", "solid", "dashed", "dotted"].includes(m.info_pill_border_style) ? m.info_pill_border_style : "none";
    m.info_pill_border_width = clamp(+m.info_pill_border_width || 0, 0, 10);
    m.info_pill_border_color = m.info_pill_border_color || "rgba(255,255,255,0.1)";
    m.bottom_info_text_shadow = m.bottom_info_text_shadow || "";
    m.bottom_info_icon_shadow = m.bottom_info_icon_shadow || "";

    // Weather options (Global fallback)
    m.weather_show_icon = m.weather_show_icon !== false;
    m.weather_show_condition = m.weather_show_condition !== false;
    m.weather_show_temperature = m.weather_show_temperature !== false;
    m.weather_show_humidity = !!m.weather_show_humidity;
    m.weather_show_wind = !!m.weather_show_wind;
    m.weather_show_pressure = !!m.weather_show_pressure;
    m.weather_colored_icons = m.weather_colored_icons !== false;
    m.weather_icon_color_mode = ["state", "custom", "inherit"].includes(m.weather_icon_color_mode) ? m.weather_icon_color_mode : "state";
    m.weather_animate_icon = ["none", "float", "pulse", "spin"].includes(m.weather_animate_icon) ? m.weather_animate_icon : "none";

    // Datetime options (Global fallback)
    m.datetime_show_time = m.datetime_show_time !== false;
    m.datetime_show_date = m.datetime_show_date !== false;
    m.datetime_show_day = m.datetime_show_day !== false;
    m.datetime_animate_icon = ["none", "float", "pulse", "spin"].includes(m.datetime_animate_icon) ? m.datetime_animate_icon : "none";

    // Font options
    m.font_family = ["inherit", "system", "roboto", "inter", "arial", "georgia", "mono", "custom"].includes(m.font_family) ? m.font_family : "inherit";
    m.font_family_custom = typeof m.font_family_custom === "string" ? m.font_family_custom : "";
    m.font_style = ["normal", "italic"].includes(m.font_style) ? m.font_style : "normal";
    m.title_size_px = clamp(+m.title_size_px || 36, 8, 256);
    m.subtitle_size_px = clamp(+m.subtitle_size_px || 15, 8, 128);
    m.title_weight = normalizeWeightKey(m.title_weight ?? "bold", "bold");
    m.subtitle_weight = normalizeWeightKey(m.subtitle_weight ?? "medium", "medium");

    // ========== CONFIG CLEANUP ==========
    // Remove deprecated fields from older versions
    // These fields have been replaced or moved to per-entity config
    delete m.persons_gap;           // Replaced by persons_spacing
    delete m.persons_overlap;       // Replaced by persons_spacing
    delete m.persons_tap_action;    // Now per-person in persons_entities
    delete m.persons_hold_action;   // Now per-person in persons_entities
    delete m.persons_double_tap_action; // Now per-person in persons_entities

    // Clean up all action configs to remove unused fields based on action type
    // This prevents having leftover fields like navigation_path when action is "url"
    const actionFields = Object.keys(m).filter(k => k.endsWith('_tap_action') || k.endsWith('_hold_action') || k.endsWith('_double_tap_action'));
    actionFields.forEach(field => {
      if (m[field] && typeof m[field] === 'object') {
        m[field] = this._cleanupActionConfig(m[field]);
      }
    });

    // Clean up persons_entities array to ensure proper structure and clean actions
    if (Array.isArray(m.persons_entities)) {
      m.persons_entities = m.persons_entities.map(person => {
        if (typeof person === 'string') return person;
        if (typeof person !== 'object' || !person) return null;
        
        const cleaned = { entity: person.entity || "" };
        if (person.grayscale_entity) cleaned.grayscale_entity = person.grayscale_entity;
        if (person.icon_home) cleaned.icon_home = person.icon_home;
        if (person.icon_away) cleaned.icon_away = person.icon_away;
        if (person.picture_home) cleaned.picture_home = person.picture_home;
        if (person.picture_away) cleaned.picture_away = person.picture_away;
        if (person.tap_action) cleaned.tap_action = this._cleanupActionConfig(person.tap_action);
        if (person.hold_action) cleaned.hold_action = this._cleanupActionConfig(person.hold_action);
        if (person.double_tap_action) cleaned.double_tap_action = this._cleanupActionConfig(person.double_tap_action);
        // Preserve slot-level popup settings
        copyDefinedKeys({ src: person, dst: cleaned, keys: HKI_POPUP_CONFIG_KEYS });
        
        return cleaned;
      }).filter(Boolean);
    }

    this._clearInlineTemplateSubs();
    this._config = m;
    this._scheduleTemplateSetup(0);
    this._debouncedBadgesZIndex();
  }

  _cleanupActionConfig(action) {
    if (!action || typeof action !== 'object') return action;
    
    const actionType = action.action || "none";
    const cleaned = { action: actionType };
    
    // Only keep fields relevant to the action type
    switch (actionType) {
      case "navigate":
        if (action.navigation_path) cleaned.navigation_path = action.navigation_path;
        break;
      case "url":
        if (action.url_path) cleaned.url_path = action.url_path;
        break;
      case "more-info":
      case "toggle":
        if (action.entity) cleaned.entity = action.entity;
        break;
      case "perform-action":
        if (action.perform_action) cleaned.perform_action = action.perform_action;
        if (action.data) cleaned.data = action.data;
        if (action.target) cleaned.target = action.target;
        break;
      case "hki-more-info":
        // Preserve entity and all popup settings
        if (action.entity) cleaned.entity = action.entity;
        if (action.custom_popup_card !== undefined) cleaned.custom_popup_card = action.custom_popup_card;
        copyDefinedKeys({
          src: action,
          dst: cleaned,
          keys: HKI_POPUP_CONFIG_KEYS.filter((k) => !["custom_popup_enabled", "custom_popup_card", "popup_name", "popup_state"].includes(k)),
        });
        if (action.popup_name) cleaned.popup_name = action.popup_name;
        if (action.popup_state) cleaned.popup_state = action.popup_state;
        if (action.popup_icon) cleaned.popup_icon = action.popup_icon;
        break;
      case "fire-dom-event":
        // Preserve all properties for fire-dom-event (browser_mod integration)
        Object.keys(action).forEach(key => {
          if (key !== 'action') {
            cleaned[key] = action[key];
          }
        });
        break;
      case "call-service":
        // Legacy support
        if (action.service) cleaned.service = action.service;
        if (action.service_data) cleaned.service_data = action.service_data;
        break;
    }
    
    return cleaned;
  }

  _isTemplateString(s) {
    if (typeof s !== "string") return false;
    return s.includes("{{") || s.includes("{%") || s.includes("{#");
  }

  _getUserVariable() {
    const u = this.hass?.user;
    return u?.name || u?.username || u?.id || "";
  }

  _buildTemplateVariables() {
    return { config: this._config ?? {}, user: this._getUserVariable() };
  }

  _scheduleTemplateSetup(delayMs = 0) {
    if (this._tpl.timer) clearTimeout(this._tpl.timer);
    this._tpl.timer = setTimeout(() => {
      this._tpl.timer = 0;
      this._setupTemplates();
    }, Math.max(0, delayMs));
  }

  _setupTemplates() {
    this._setupTemplateKey("title", this._config?.title ?? "");
    this._setupTemplateKey("subtitle", this._config?.subtitle ?? "");
  }

  _setupTemplateKey(key, raw) {
    const isTpl = this._isTemplateString(raw);

    if (!isTpl) {
      this._unsubscribeTemplate(key);
      this._tpl[key].raw = raw;
      this._tpl[key].sig = "";
      this._setRendered(key, raw);
      return;
    }

    // Don't show raw template - keep previous value or empty until render completes
    // This prevents the flash of unrendered Jinja templates

    const vars = this._buildTemplateVariables();
    const sig = cacheKey(raw, vars);
    const state = this._tpl[key];

    this._unsubscribeTemplate(key);
    state.raw = raw;
    state.sig = sig;
    state.seq += 1;
    const seq = state.seq;

    const hadCache = this._applyCachedTemplate(key, sig);
    
    // If no cache was found, set to empty to avoid showing raw template
    if (!hadCache) {
      this._setRendered(key, "");
    }

    if (!this._inPreview && this.hass?.connection?.subscribeMessage) {
      this._subscribeTemplateImmediate(key, seq, raw, vars, sig);
    } else if (this.hass?.callWS && !hadCache) {
      this._renderTemplateOnce(key, seq, raw, vars, sig);
    }
  }

  _applyCachedTemplate(key, sig) {
    try {
      const cached = sessionStorage.getItem(sig);
      if (cached != null && cached !== "") {
        this._setRendered(key, cached);
        return true;
      }
    } catch (_) {}
    return false;
  }

  async _renderTemplateOnce(key, seq, raw, vars, sig) {
    if (!this.hass?.callWS) return;
    try {
      const res = await this.hass.callWS({
        type: "render_template",
        template: raw,
        variables: vars,
        strict: false,
      });
      if (this._tpl[key].seq !== seq) return;
      const text = res?.result == null ? "" : String(res.result);
      this._setRendered(key, text);
      this._storeTemplateCache(sig, text);
    } catch (err) {
      console.warn(`Template render failed for ${key}:`, err);
    }
  }

  async _subscribeTemplateImmediate(key, seq, raw, vars, sig) {
    if (!this.hass?.connection?.subscribeMessage) return;
    try {
      const unsub = await this.hass.connection.subscribeMessage(
        (msg) => this._onTemplateMsg(key, seq, sig, msg),
        { type: "render_template", template: raw, variables: vars, strict: false, report_errors: false }
      );
      const st = this._tpl[key];
      if (st.seq !== seq) { unsub?.(); return; }
      st.unsub = unsub;
    } catch (err) {
      console.warn(`Template subscription failed for ${key}:`, err);
      this._renderTemplateOnce(key, seq, raw, vars, sig);
    }
  }

  _onTemplateMsg(key, seq, sig, msg) {
    if (this._tpl[key].seq !== seq) return;
    if (msg?.error) { console.warn(`Template update error for ${key}:`, msg.error); return; }
    const text = msg?.result == null ? "" : String(msg.result);
    this._setRendered(key, text);
    this._storeTemplateCache(sig, text);
  }

  _storeTemplateCache(sig, value) {
    try { sessionStorage.setItem(sig, value); } catch (_) {}
  }

  _setRendered(key, value) {
    const v = value == null ? "" : String(value);
    if (key === "title") {
      if (this._renderedTitle !== v) { this._renderedTitle = v; this.requestUpdate(); }
    } else if (key === "subtitle") {
      if (this._renderedSubtitle !== v) { this._renderedSubtitle = v; this.requestUpdate(); }
    }
  }

  _resolveInlineTemplate(raw, fallback = "") {
    if (raw === undefined || raw === null || raw === "") return fallback;
    const str = String(raw);
    if (!this._isTemplateString(str)) return str.trim();

    const vars = this._buildTemplateVariables();
    const sig = cacheKey(`inline:${str}`, vars);
    if (!this._inlineTplSubs.has(sig)) {
      this._inlineTplSubs.set(sig, { value: fallback, unsub: null, pending: false });
      this._subscribeInlineTemplate(sig, str, vars, fallback);
    }
    const current = this._inlineTplSubs.get(sig)?.value;
    return (current == null ? fallback : String(current)).trim();
  }

  _subscribeInlineTemplate(sig, template, vars, fallback = "") {
    const entry = this._inlineTplSubs.get(sig);
    if (!entry || entry.pending) return;
    entry.pending = true;

    const done = () => {
      const latest = this._inlineTplSubs.get(sig);
      if (latest) latest.pending = false;
    };

    if (this.hass?.connection?.subscribeMessage) {
      this.hass.connection.subscribeMessage(
        (msg) => {
          const e = this._inlineTplSubs.get(sig);
          if (!e) return;
          if (msg?.error) return;
          const nextValue = msg?.result != null ? String(msg.result).trim() : "";
          if (e.value !== nextValue) {
            e.value = nextValue;
            this.requestUpdate();
          }
        },
        { type: "render_template", template, variables: vars, strict: false, report_errors: false }
      ).then((unsub) => {
        const e = this._inlineTplSubs.get(sig);
        if (!e) {
          try { unsub?.(); } catch (_) {}
          return;
        }
        e.unsub = unsub;
        done();
      }).catch(async () => {
        await this._renderInlineTemplateOnce(sig, template, vars, fallback);
        done();
      });
      return;
    }

    this._renderInlineTemplateOnce(sig, template, vars, fallback).finally(done);
  }

  async _renderInlineTemplateOnce(sig, template, vars, fallback = "") {
    const entry = this._inlineTplSubs.get(sig);
    if (!entry) return;
    if (!this.hass?.callWS) {
      entry.value = fallback;
      return;
    }
    try {
      const res = await this.hass.callWS({ type: "render_template", template, variables: vars, strict: false });
      const value = res?.result != null ? String(res.result).trim() : "";
      if (entry.value !== value) {
        entry.value = value;
        this.requestUpdate();
      }
    } catch (_) {
      entry.value = fallback;
    }
  }

  _clearInlineTemplateSubs() {
    if (!this._inlineTplSubs || !this._inlineTplSubs.size) return;
    this._inlineTplSubs.forEach((entry) => {
      if (entry?.unsub) {
        try { entry.unsub(); } catch (_) {}
      }
    });
    this._inlineTplSubs.clear();
  }

  _getSlotButtons(prefix) {
    const configured = Array.isArray(this._config?.[prefix + "buttons"]) ? this._config[prefix + "buttons"] : [];
    if (configured.length) return configured.map((btn) => normalizeSlotButton(btn));
    return [normalizeSlotButton({
      icon: this._config?.[prefix + "icon"] || "",
      icon_animation: this._config?.[prefix + "icon_animation"] || "",
      name: this._config?.[prefix + "name"] ?? "",
      state: this._config?.[prefix + "state"] || "",
      entity: this._config?.[prefix + "entity"] || "",
      card_color: this._config?.[prefix + "card_color"] || "",
      icon_color: this._config?.[prefix + "icon_color"] || "",
      name_color: this._config?.[prefix + "name_color"] || "",
      state_color: this._config?.[prefix + "state_color"] || "",
      text_shadow: this._config?.[prefix + "text_shadow"] || "",
      icon_shadow: this._config?.[prefix + "icon_shadow"] || "",
      name_offset_x: this._config?.[prefix + "name_offset_x"] ?? 0,
      name_offset_y: this._config?.[prefix + "name_offset_y"] ?? 0,
      state_offset_x: this._config?.[prefix + "state_offset_x"] ?? 0,
      state_offset_y: this._config?.[prefix + "state_offset_y"] ?? 0,
      visibility_mode: this._config?.[prefix + "visibility_mode"] || "none",
      visibility_entity: this._config?.[prefix + "visibility_entity"] || "",
      visibility_state: this._config?.[prefix + "visibility_state"] || "",
      visibility_attribute: this._config?.[prefix + "visibility_attribute"] || "",
      visibility_attribute_value: this._config?.[prefix + "visibility_attribute_value"] || "",
      show_badge: this._config?.[prefix + "show_badge"] === true,
      badge_source: this._config?.[prefix + "badge_source"] || "entity",
      badge_entity: this._config?.[prefix + "badge_entity"] || "",
      badge_template: this._config?.[prefix + "badge_template"] || "",
      badge_color: this._config?.[prefix + "badge_color"] || "",
      badge_text_color: this._config?.[prefix + "badge_text_color"] || "",
    })];
  }

  _unsubscribeTemplate(key) {
    const st = this._tpl[key];
    if (st?.unsub) { try { st.unsub(); } catch (_) {} }
    if (st) st.unsub = null;
  }

  _resolveFontFamily() {
    const k = this._config?.font_family ?? "inherit";
    if (k === "custom") return (this._config?.font_family_custom || "").trim() || "inherit";
    return FONT_FAMILY_MAP[k] ?? "inherit";
  }

  _resolveWeight(key) {
    return WEIGHT_MAP[this._config?.[key]] ?? 400;
  }

  _resolveWeightValue(weight) {
    return WEIGHT_MAP[weight] ?? 400;
  }

  _resolveBackground(bg) {
    if (!bg || typeof bg !== "string") return bg;
    const t = bg.trim();
    if (t.startsWith("url(") || t.startsWith("linear-gradient(") || t.startsWith("radial-gradient(")) return t;
    const isPath = t.startsWith("/") || t.startsWith("./") || t.startsWith("../") ||
                   t.startsWith("http://") || t.startsWith("https://") ||
                   /\.(jpg|jpeg|png|gif|webp|svg|bmp)$/i.test(t);
    return isPath ? `url('${t}')` : t;
  }

  _resolveWeatherIconColor(cfg, state, prefix = "") {
    // Check specific slot config first, then fallback to global
    const mode = cfg[prefix + "weather_icon_color_mode"] || cfg.weather_icon_color_mode;
    const customColor = cfg[prefix + "weather_icon_color"] || cfg.weather_icon_color;
    const coloredIcons = cfg[prefix + "weather_colored_icons"] !== undefined ? cfg[prefix + "weather_colored_icons"] : cfg.weather_colored_icons;

    if (mode === "custom" && customColor) return customColor.trim();
    if (mode === "inherit" || !coloredIcons) return "inherit";
    return WEATHER_COLOR_MAP[state] || "inherit";
  }

  _debouncedBadgesZIndex() {
    if (this._rafBadges) return;
    this._rafBadges = requestAnimationFrame(() => {
      this._rafBadges = 0;
      this._applyBadgesZIndex();
    });
  }

  _applyBadgesZIndex() {
    const cfg = this._config || {};
    const effectiveFixed = !!cfg.fixed && !this._inPreview;

    if (!effectiveFixed) { this._resetBadgesZIndex(); return; }

    const el = this._findHaBadgesElement();
    if (!el) { this._resetBadgesZIndex(); return; }

    if (el !== this._badgesEl) {
      this._resetBadgesZIndex();
      this._badgesEl = el;
    }

    const kioskAdjustment = this._kioskMode ? 0 : 48;
    const badgesOffset = cfg.badges_fixed ? (cfg.badges_offset_pinned || 48) : (cfg.badges_offset_unpinned || 100);
    const topPosition = Math.max(0, (this._headerHeight || 0) - badgesOffset + (cfg.fixed_top || 0) + kioskAdjustment);

    if (cfg.badges_fixed) {
      el.style.cssText = `position:fixed;top:${topPosition}px;left:${this._offsetLeft}px;width:${this._contentWidth}px;z-index:2;`;
    } else {
      const kioskGapAdjustment = this._kioskMode ? 48 : 0;
      const effectiveGap = (cfg.badges_gap || 0) + kioskGapAdjustment;
      el.style.cssText = `position:relative;z-index:0;margin-bottom:${effectiveGap}px;`;
    }
  }

  _resetBadgesZIndex() {
    if (this._badgesEl) {
      try { this._badgesEl.style.cssText = ""; } catch (_) {}
      this._badgesEl = null;
    }
  }

  _findHaBadgesElement() {
    const selectors = "hui-badges, ha-badges, .badges, .header-badges";
    let node = this;
    for (let i = 0; i < 12; i++) {
      const root = node.getRootNode?.();
      if (!root || root === document) break;
      const host = root.host;
      if (!host) break;
      const sr = host.shadowRoot;
      const hit = sr?.querySelector?.(selectors) || host.querySelector?.(selectors);
      if (hit) return hit;
      node = host;
    }
    return null;
  }

  _parseServiceData(serviceData) {
    if (!serviceData) return {};
    if (typeof serviceData === "object") return serviceData;
    if (typeof serviceData !== "string") return {};

    const raw = serviceData.trim();
    if (!raw) return {};

    if (raw.startsWith("{") || raw.startsWith("[")) {
      try { const v = JSON.parse(raw); return v && typeof v === "object" ? v : {}; } catch (_) {}
    }

    try {
      const loader = window?.jsyaml?.load;
      if (typeof loader === "function") {
        const v = loader(raw);
        return v && typeof v === "object" ? v : {};
      }
    } catch (_) {}

    // Simple key: value parser
    const out = {};
    raw.split("\n").forEach((line) => {
      const t = line.trim();
      if (!t || t.startsWith("#")) return;
      const idx = t.indexOf(":");
      if (idx <= 0) return;
      const k = t.slice(0, idx).trim();
      let v = t.slice(idx + 1).trim();
      if ((v.startsWith('"') && v.endsWith('"')) || (v.startsWith("'") && v.endsWith("'"))) {
        v = v.slice(1, -1);
      }
      out[k] = v;
    });
    return out;
  }

  // Build a flat object of all popup fields from a merged popup config to spread into btn.setConfig()
  _buildPopupConfig(p, resolvedName, resolvedState, resolvedIcon = '') {
    const popupGlobals = window.HKI?.getGlobalDefaultsFor?.("popup") || {};
    const mergedPopup = { ...(popupGlobals || {}), ...(p || {}) };
    const cfg = {};
    const _copyTruthy = (keys) => {
      keys.forEach((k) => {
        if (mergedPopup[k]) cfg[k] = mergedPopup[k];
      });
    };
    if (resolvedName) cfg.name = resolvedName;
    if (resolvedState) cfg.state_label = resolvedState;
    copyDefinedKeys({
      src: mergedPopup,
      dst: cfg,
      keys: [
        "popup_border_radius",
        "popup_width",
        "popup_width_custom",
        "popup_height",
        "popup_height_custom",
        "popup_animation_duration",
        "popup_blur_enabled",
        "popup_blur_amount",
        "popup_card_blur_enabled",
        "popup_card_blur_amount",
        "popup_card_opacity",
        "popup_show_favorites",
        "popup_show_effects",
        "popup_show_presets",
        "popup_slider_radius",
        "popup_hide_button_text",
        "popup_value_font_size",
        "popup_value_font_weight",
        "popup_label_font_size",
        "popup_label_font_weight",
        "popup_highlight_radius",
        "popup_highlight_opacity",
        "popup_button_radius",
        "popup_button_opacity",
        "climate_temp_step",
        "climate_use_circular_slider",
        "climate_show_plus_minus",
        "climate_show_gradient",
        "climate_show_target_range",
        "humidifier_humidity_step",
        "humidifier_use_circular_slider",
        "humidifier_show_plus_minus",
        "humidifier_show_gradient",
        "sensor_graph_gradient",
        "sensor_line_width",
        "sensor_hours",
        "popup_bottom_bar_entities",
        "popup_bottom_bar_align",
        "popup_hide_bottom_bar",
        "popup_hide_top_bar",
        "popup_show_close_button",
        "popup_close_on_action",
        "_bb_slots",
      ],
    });
    _copyTruthy([
      "popup_open_animation",
      "popup_close_animation",
      "popup_time_format",
      "popup_default_view",
      "popup_default_section",
      "popup_highlight_color",
      "popup_highlight_text_color",
      "popup_highlight_border_color",
      "popup_highlight_border_style",
      "popup_highlight_border_width",
      "popup_highlight_box_shadow",
      "popup_button_bg",
      "popup_button_text_color",
      "popup_button_border_color",
      "popup_button_border_style",
      "popup_button_border_width",
      "climate_humidity_entity",
      "climate_humidity_name",
      "climate_pressure_entity",
      "climate_pressure_name",
      "climate_current_temperature_entity",
      "climate_temperature_name",
      "humidifier_fan_entity",
      "person_geocoded_entity",
      "sensor_graph_color",
      "sensor_graph_style",
    ]);
    // Icon & entity picture
    if (resolvedIcon) cfg.icon = resolvedIcon;
    if (mergedPopup.popup_use_entity_picture !== undefined) cfg.use_entity_picture = mergedPopup.popup_use_entity_picture;
    return cfg;
  }

  _handleAction(action, entityId = null, popupConfig = null) {
    if (!action || action.action === "none" || !this.hass) return;
    if ((this._isEditMode() || this._editMode) && action.action === "hki-more-info") return;

    // If entityId is provided and action doesn't have entity, add it
    // For perform-action, add entity to target if not present
    let finalAction = action;
    if (entityId && !action.entity) {
      finalAction = { ...action, entity: entityId };
    }
    if (entityId && action.action === "perform-action" && (!action.target || !action.target.entity_id)) {
      const existingTarget = action.target || {};
      finalAction = { ...finalAction, target: { ...existingTarget, entity_id: entityId } };
    }

    switch (finalAction.action) {
      case "navigate":
        if (finalAction.navigation_path) {
           if (finalAction.navigation_path === "back") {
             history.back();
           } else {
             history.pushState(null, "", finalAction.navigation_path);
             window.dispatchEvent(new CustomEvent("location-changed", { bubbles: true, composed: true, detail: { replace: false } }));
           }
        }
        break;
      case "back":
        history.back();
        break;
      case "menu":
        this.dispatchEvent(new CustomEvent("hass-toggle-menu", { bubbles: true, composed: true }));
        break;
      case "url":
        if (finalAction.url_path) window.open(finalAction.url_path, "_blank");
        break;
      case "perform-action":
        if (finalAction.perform_action) {
          const [domain, service] = finalAction.perform_action.split(".");
          if (domain && service) {
            const serviceData = finalAction.data || {};
            const target = finalAction.target || {};
            this.hass.callService(domain, service, serviceData, target);
          }
        }
        break;
      case "call-service":
        // Legacy support for old call-service action
        if (finalAction.service) {
          const [domain, service] = finalAction.service.split(".");
          if (domain && service) this.hass.callService(domain, service, this._parseServiceData(finalAction.service_data));
        }
        break;
      case "more-info": {
        const entity = finalAction.entity;
        if (entity) this.dispatchEvent(new CustomEvent("hass-more-info", { bubbles: true, composed: true, detail: { entityId: entity } }));
        break;
      }
      case "hki-more-info": {
        // Slot-level popupConfig takes precedence over action-level (backward-compat) settings
        const mergedPopup = { ...finalAction, ...(popupConfig || {}) };
        // custom_popup_enabled gates the custom card; undefined = true for backward compat
        const popupCard = mergedPopup.custom_popup_enabled === false
          ? null
          : mergedPopup.custom_popup_card;
        const resolveTemplate = async (str) => {
          if (!str) return str;
          if (!(str.includes('{{') || str.includes('{%'))) return str;
          try {
            const res = await this.hass.callWS({
              type: 'render_template',
              template: str,
              variables: { config: this._config ?? {}, user: this.hass?.user?.name || '' },
              strict: false,
            });
            return res?.result != null ? String(res.result) : str;
          } catch (_) { return str; }
        };
        if (popupCard && customElements.get('hki-button-card')) {
          // Custom popup card configured â€” open it inside the HKI popup frame
          Promise.all([
            resolveTemplate(mergedPopup.popup_name),
            resolveTemplate(mergedPopup.popup_state),
            resolveTemplate(mergedPopup.popup_icon),
          ]).then(([resolvedName, resolvedState, resolvedIcon]) => {
            try {
              const btn = document.createElement('hki-button-card');
              this._attachPopupProxyCard(btn);
              btn.hass = this.hass;
              btn.setConfig({
                type: 'custom:hki-button-card',
                custom_popup: { enabled: true, card: popupCard },
                ...this._buildPopupConfig(mergedPopup, resolvedName, resolvedState, resolvedIcon),
              });
              this._activePopupProxyCards.add(btn);
              btn._openPopup();
            } catch (err) {
              console.error('[hki-header-card] Failed to open popup:', err);
            }
          }).catch(err => console.error('[hki-header-card] Popup promise error:', err));
        } else {
          // No custom popup card â€” open the domain-appropriate HKI popup for the entity
          const popupEntityId = finalAction.entity || entityId;
          if (popupEntityId && customElements.get('hki-button-card')) {
            Promise.all([
              resolveTemplate(mergedPopup.popup_name),
              resolveTemplate(mergedPopup.popup_state),
              resolveTemplate(mergedPopup.popup_icon),
            ]).then(([resolvedName, resolvedState, resolvedIcon]) => {
            try {
              const btn = document.createElement('hki-button-card');
              this._attachPopupProxyCard(btn);
              btn.hass = this.hass;
              btn.setConfig({
                type: 'custom:hki-button-card',
                entity: popupEntityId,
                ...this._buildPopupConfig(mergedPopup, resolvedName, resolvedState, resolvedIcon),
                });
                this._activePopupProxyCards.add(btn);
                btn._openPopup();
              } catch (err) {
                console.error('[hki-header-card] Failed to open domain popup:', err);
              }
            }).catch(err => console.error('[hki-header-card] Popup promise error:', err));
          }
        }
        break;
      }
      case "toggle": {
        const toggleEntity = finalAction.entity;
        if (toggleEntity) this.hass.callService("homeassistant", "toggle", { entity_id: toggleEntity });
        break;
      }
      case "fire-dom-event": {
        // Fire a custom DOM event with all properties except 'action'
        const eventDetail = {};
        Object.keys(finalAction).forEach(key => {
          if (key !== 'action') {
            eventDetail[key] = finalAction[key];
          }
        });
        const rawEventData = (typeof finalAction.event_data === "string") ? finalAction.event_data.trim() : "";
        if (rawEventData) {
          try {
            const parsed = window.jsyaml?.load ? window.jsyaml.load(rawEventData) : JSON.parse(rawEventData);
            if (parsed !== undefined) eventDetail.data = parsed;
          } catch (_) {
            eventDetail.data = rawEventData;
          }
        }
        this.dispatchEvent(new CustomEvent("ll-custom", { 
          bubbles: true, 
          composed: true, 
          detail: eventDetail 
        }));
        break;
      }
    }
  }

  async _updateCustomCards() {
    if (!window.loadCardHelpers) return;
    
    const slots = [
      { key: 'left', bar: 'top_bar' },
      { key: 'center', bar: 'top_bar' },
      { key: 'right', bar: 'top_bar' },
      { key: 'left', bar: 'bottom_bar', cacheId: 'bottom_left' },
      { key: 'center', bar: 'bottom_bar', cacheId: 'bottom_center' },
      { key: 'right', bar: 'bottom_bar', cacheId: 'bottom_right' },
    ];
    let helpersLoaded = null;
    let needsUpdate = false;
    
    for (const slotDef of slots) {
        const slot = typeof slotDef === 'string' ? slotDef : slotDef.key;
        const bar = typeof slotDef === 'string' ? 'top_bar' : slotDef.bar;
        const cardId = (slotDef.cacheId) ? slotDef.cacheId : slot;
        const type = this._config[`${bar}_${slot}`];
        const cardConfigKey = `${bar}_${slot}_card`;
        const cardConfig = this._config[cardConfigKey];
        
        // Generate a simple hash to detect config changes
        const isCardSlot = type === 'notifications' || type === 'custom' || type === 'card';
        const configHash = isCardSlot ? JSON.stringify(cardConfig || {}) : '';
        const cacheKey = `_customCardHash_${cardId}`;
        
        if (isCardSlot) {
            // Only recreate if config has changed
            if (this[cacheKey] !== configHash || !this._customCards[slot]) {
                if (!helpersLoaded) helpersLoaded = await window.loadCardHelpers();
                
                // notifications type injects header-styling helpers; card type is bare
                let finalConfig;
                if (type === 'card') {
                    finalConfig = { ...(cardConfig || {}) };
                } else {
                    finalConfig = { 
                        use_header_styling: true, 
                        show_background: false,
                        show_empty: true,
                        ...(cardConfig || { type: "custom:hki-notification-card" })
                    };
                }

                try {
                    const element = await helpersLoaded.createCardElement(finalConfig);
                    if (this.hass) element.hass = this.hass;
                    element.style.display = "block";
                    this._customCards[cardId] = element;
                    this[cacheKey] = configHash;
                    needsUpdate = true;
                } catch (e) {
                    console.error(`Failed to create custom card for ${slot}`, e);
                }
            }
        } else if (this._customCards[cardId]) {
            this._customCards[cardId] = null;
            this[cacheKey] = '';
            needsUpdate = true;
        }
    }
    
    if (needsUpdate) this.requestUpdate();
  }

  _asIconFilterValue(rawValue) {
    const v = String(rawValue || "").trim();
    if (!v) return "";
    if (v.toLowerCase() === "none") return "none";
    if (/[a-z-]+\(/i.test(v)) return v;
    return `drop-shadow(${v})`;
  }

  _getSlotStyle(slotName, bar = "top_bar") {
    const cfg = this._config;
    const prefix = `${bar}_${slotName}_`;

    // Pick the right set of global defaults depending on which bar this slot belongs to
    const gp = bar === "bottom_bar" ? "bottom_info_" : "info_";
    
    const useGlobal = cfg[prefix + "use_global"] !== false;
    const rawColorForTpl = (!useGlobal && cfg[prefix + "color"]) ? cfg[prefix + "color"] : (cfg[gp + "color"] || "");
    const rawTextShadowForTpl = (!useGlobal && cfg[prefix + "text_shadow"]) ? cfg[prefix + "text_shadow"] : (cfg[gp + "text_shadow"] || "");
    const rawIconShadowForTpl = (!useGlobal && cfg[prefix + "icon_shadow"]) ? cfg[prefix + "icon_shadow"] : (cfg[gp + "icon_shadow"] || "");
    const rawPillBgForTpl = (!useGlobal && cfg[prefix + "pill_background"]) ? cfg[prefix + "pill_background"] : (cfg[gp + "pill_background"] || "");
    const hasTemplateDrivenStyle = this._isTemplateString(rawColorForTpl) || this._isTemplateString(rawTextShadowForTpl) || this._isTemplateString(rawIconShadowForTpl) || this._isTemplateString(rawPillBgForTpl);

    // Generate cache key based on relevant config values
    const cacheKey = `${bar}:${slotName}:${cfg[prefix + "use_global"]}:${cfg[prefix + "size_px"]}:${cfg[prefix + "weight"]}:${cfg[prefix + "color"]}:${cfg[prefix + "text_shadow"]}:${cfg[prefix + "icon_shadow"]}:${cfg[prefix + "pill"]}:${cfg[prefix + "pill_background"]}:${cfg[gp + "size_px"]}:${cfg[gp + "weight"]}:${cfg[gp + "color"]}:${cfg[gp + "text_shadow"]}:${cfg[gp + "icon_shadow"]}:${cfg[gp + "pill"]}:${cfg[gp + "pill_background"]}:${cfg.font_family}:${cfg.font_style}`;
    if (!hasTemplateDrivenStyle) {
      const cached = this._slotStyleCache.get(cacheKey);
      if (cached) return cached;
    }
    
    const fontFamily = this._resolveFontFamily();
    
    // Get values, preferring per-slot if not using global, otherwise use bar-specific global
    const sizePx = (!useGlobal && cfg[prefix + "size_px"] != null) ? cfg[prefix + "size_px"] : cfg[gp + "size_px"];
    const weight = (!useGlobal && cfg[prefix + "weight"] != null) ? cfg[prefix + "weight"] : cfg[gp + "weight"];
    const rawColor = rawColorForTpl;
    const color = this._resolveInlineTemplate(rawColor, "").trim() || "var(--hki-header-text-color, #fff)";
    const rawTextShadow = rawTextShadowForTpl;
    const textShadow = this._resolveInlineTemplate(rawTextShadow, "").trim();
    const rawIconShadow = rawIconShadowForTpl;
    const iconShadow = this._resolveInlineTemplate(rawIconShadow, "").trim();
    const iconShadowFilter = this._asIconFilterValue(iconShadow);
    const iconSize = Math.round(sizePx * 2);
    
    const pill = (!useGlobal && cfg[prefix + "pill"] != null) ? cfg[prefix + "pill"] : cfg[gp + "pill"];
    const rawPillBg = rawPillBgForTpl;
    const pillBg = this._resolveInlineTemplate(rawPillBg, "").trim() || "rgba(0,0,0,0.25)";
    const pillPaddingX = (!useGlobal && cfg[prefix + "pill_padding_x"] != null) ? cfg[prefix + "pill_padding_x"] : cfg[gp + "pill_padding_x"];
    const pillPaddingY = (!useGlobal && cfg[prefix + "pill_padding_y"] != null) ? cfg[prefix + "pill_padding_y"] : cfg[gp + "pill_padding_y"];
    const pillRadius = (!useGlobal && cfg[prefix + "pill_radius"] != null) ? cfg[prefix + "pill_radius"] : cfg[gp + "pill_radius"];
    const pillBlur = (!useGlobal && cfg[prefix + "pill_blur"] != null) ? cfg[prefix + "pill_blur"] : cfg[gp + "pill_blur"];
    const pillBorderStyle = (!useGlobal && cfg[prefix + "pill_border_style"]) ? cfg[prefix + "pill_border_style"] : cfg[gp + "pill_border_style"];
    const pillBorderWidth = (!useGlobal && cfg[prefix + "pill_border_width"] != null) ? cfg[prefix + "pill_border_width"] : cfg[gp + "pill_border_width"];
    const pillBorderColor = (!useGlobal && cfg[prefix + "pill_border_color"]) ? cfg[prefix + "pill_border_color"] : cfg[gp + "pill_border_color"];
    
    const weightValue = this._resolveWeightValue(weight);
    const fontStyleValue = cfg.font_style || "normal";
    
    const inlineStyle = `font-family:${fontFamily};font-style:${fontStyleValue};font-size:${sizePx}px;font-weight:${weightValue};color:${color};${textShadow ? `text-shadow:${textShadow};` : ""}${iconShadowFilter ? `--hki-info-icon-filter:${iconShadowFilter};` : ""}`;
    
    const pillStyle = pill ? `--hki-info-pill-background:${pillBg};--hki-info-pill-padding-x:${pillPaddingX}px;--hki-info-pill-padding-y:${pillPaddingY}px;--hki-info-pill-radius:${pillRadius}px;--hki-info-pill-blur:${pillBlur}px;--hki-info-pill-border-style:${pillBorderStyle};--hki-info-pill-border-width:${pillBorderWidth}px;--hki-info-pill-border-color:${pillBorderColor}` : "";
    
    // CSS variables for notification card
    const notifyVars = `--hki-notify-font-size:${sizePx}px;--hki-notify-font-weight:${weightValue};--hki-notify-color:${color};--hki-notify-icon-size:${iconSize}px;--hki-notify-font-family:${fontFamily};--hki-notify-font-style:${fontStyleValue};--hki-notify-pill-enabled:${pill ? '1' : '0'};--hki-notify-pill-bg:${pillBg};--hki-notify-pill-padding-x:${pillPaddingX}px;--hki-notify-pill-padding-y:${pillPaddingY}px;--hki-notify-pill-radius:${pillRadius}px;--hki-notify-pill-blur:${pillBlur}px;--hki-notify-pill-border-style:${pillBorderStyle};--hki-notify-pill-border-width:${pillBorderWidth}px;--hki-notify-pill-border-color:${pillBorderColor}`;
    
    const result = { 
      inlineStyle, 
      pillStyle, 
      notifyVars, 
      iconSize, 
      pill, 
      sizePx, 
      color,
      textShadow,
      iconShadow,
      iconShadowFilter,
      pillBg,
      pillPaddingX,
      pillPaddingY,
      pillRadius,
      pillBlur,
      pillBorderStyle,
      pillBorderWidth,
      pillBorderColor
    };
    
    // Cache the result (limit cache size)
    if (!hasTemplateDrivenStyle) {
      if (this._slotStyleCache.size > 20) this._slotStyleCache.clear();
      this._slotStyleCache.set(cacheKey, result);
    }
    
    return result;
  }

  _renderSlotContent(type, slotName, cardId = null, bar = "top_bar", stretch = false) {
      const cfg = this._config;
      const slotStyle = this._getSlotStyle(slotName, bar);
      // Unique key to persist hold/click state across re-renders for this slot
      const stateKey = cardId || slotName;
      
      switch (type) {
          case "weather": return this._renderWeatherSlot(slotName, slotStyle, stateKey, bar);
          case "datetime": return this._renderDatetimeSlot(slotName, slotStyle, stateKey, bar);
          case "notifications":
          case "custom":
          case "card": return this._renderCustomCardSlot(slotName, slotStyle, cardId, type, stretch);
          case "spacer": return this._renderSpacerSlot(slotName, stateKey, bar);
          case "button": return this._renderButtonSlot(slotName, slotStyle, stateKey, bar);
          default: return html``;
      }
  }

  _renderSpacerSlot(slotName, stateKey, bar = "top_bar") {
    const cfg = this._config;
    const prefix = `${bar}_${slotName}_`;
    const tapAction = cfg[prefix + "tap_action"] || { action: "none" };
    const holdAction = cfg[prefix + "hold_action"] || { action: "none" };
    const doubleTapAction = cfg[prefix + "double_tap_action"] || { action: "none" };
    const slotPopupConfig = this._getSlotPopupConfig(prefix);

    const hasAnyAction = tapAction.action !== "none" || holdAction.action !== "none" || doubleTapAction.action !== "none";
    if (!hasAnyAction) return html`<div class="slot-spacer"></div>`;

    if (!this._slotHoldState) this._slotHoldState = {};
    if (!this._slotHoldState[stateKey]) this._slotHoldState[stateKey] = { holdTimer: null, holdActive: false, clickTimer: null, clickCount: 0, touchHandled: false };
    const state = this._slotHoldState[stateKey];

    const startHold = () => {
      state.holdActive = false;
      state.holdTimer = setTimeout(() => {
        state.holdActive = true;
        if (holdAction.action !== "none") this._handleSlotTapAction(holdAction, slotName, null, slotPopupConfig);
      }, 500);
    };
    const endHold = () => {
      if (state.holdTimer) { clearTimeout(state.holdTimer); state.holdTimer = null; }
      if (!state.holdActive) {
        state.clickCount++;
        if (state.clickCount === 1) {
          state.clickTimer = setTimeout(() => {
            if (state.clickCount === 1) this._handleSlotTapAction(tapAction, slotName, null, slotPopupConfig);
            state.clickCount = 0;
          }, 250);
        } else if (state.clickCount === 2) {
          clearTimeout(state.clickTimer);
          state.clickCount = 0;
          this._handleSlotTapAction(doubleTapAction, slotName, null, slotPopupConfig);
        }
      }
      state.holdActive = false;
    };
    const cancelHold = () => {
      if (state.holdTimer) { clearTimeout(state.holdTimer); state.holdTimer = null; }
      state.holdActive = false;
    };

    const handleTouchStart = () => { state.touchHandled = true; startHold(); };
    const handleTouchEnd = () => { endHold(); setTimeout(() => { state.touchHandled = false; }, 500); };
    const handleMouseDown = () => { if (state.touchHandled) return; startHold(); };
    const handleMouseUp = () => { if (state.touchHandled) return; endHold(); };
    const handleMouseLeave = () => { if (!state.touchHandled) cancelHold(); };

    return html`
      <div class="slot-spacer"
        @mousedown=${handleMouseDown}
        @mouseup=${handleMouseUp}
        @mouseleave=${handleMouseLeave}
        @touchstart=${handleTouchStart}
        @touchend=${handleTouchEnd}
        @contextmenu=${(e) => e.preventDefault()}
        style="cursor:pointer;"
      ></div>
    `;
  }

  _getDomainDefaultIcon(domain) {
    const iconMap = {
      light: "mdi:lightbulb",
      switch: "mdi:toggle-switch",
      fan: "mdi:fan",
      cover: "mdi:window-shutter",
      lock: "mdi:lock",
      climate: "mdi:thermostat",
      alarm_control_panel: "mdi:shield-home",
      media_player: "mdi:speaker",
      vacuum: "mdi:robot-vacuum",
      camera: "mdi:camera",
      sensor: "mdi:gauge",
      binary_sensor: "mdi:checkbox-marked-circle",
      input_boolean: "mdi:toggle-switch",
      input_number: "mdi:ray-vertex",
      input_select: "mdi:format-list-bulleted",
      automation: "mdi:robot",
      script: "mdi:script-text",
      scene: "mdi:palette",
      remote: "mdi:remote",
      humidifier: "mdi:air-humidifier",
    };
    return iconMap[domain] || "mdi:gesture-tap";
  }

  _getEntityDefaultIcon(entity) {
    if (!entity || typeof entity !== "object") return "";
    if (entity.attributes?.icon) return String(entity.attributes.icon);
    const entityId = entity.entity_id || "";
    const domain = entityId.includes(".") ? entityId.split(".")[0] : "";
    return this._getDomainDefaultIcon(domain);
  }

  _getStateDomainColorVar(entityId, state) {
    const domain = String(entityId || "").split(".")[0] || "default";
    const stateKey = String(state ?? "unknown").toLowerCase().replace(/\s+/g, "-");
    const active = ["on", "open", "unlocked", "home", "heat", "cool", "auto", "playing"].includes(stateKey) ? "active" : "inactive";
    return `var(--state-${domain}-${stateKey}-color, var(--state-${domain}-${active}-color, var(--state-${active}-color, var(--primary-text-color))))`;
  }

  _getAutoEntityColor(entity) {
    if (!entity?.entity_id) return "";
    const domain = String(entity.entity_id).split(".")[0];
    const state = String(entity.state ?? "").toLowerCase();
    const isUnavailable = ["unavailable", "unknown"].includes(state);
    if (isUnavailable) return "var(--state-icon-unavailable-color)";
    if (domain === "climate") {
      const hvacAction = String(entity.attributes?.hvac_action || entity.state || "").toLowerCase();
      if (["heating", "heat"].includes(hvacAction)) return "#ff9800";
      if (["cooling", "cool"].includes(hvacAction)) return "#03a9f4";
      if (["drying", "dry"].includes(hvacAction)) return "#9c27b0";
      if (["fan", "fan_only"].includes(hvacAction)) return "#4caf50";
      if (state === "heat") return "#ff9800";
      if (state === "cool") return "#03a9f4";
      if (state === "auto" || state === "heat_cool") return "#4caf50";
      if (state === "dry") return "#9c27b0";
      if (state === "fan_only") return "#4caf50";
      return "var(--state-icon-color)";
    }
    const isOn = ["on", "open", "unlocked", "playing", "home"].includes(state);
    if (domain === "light" && isOn) {
      const attrs = entity.attributes || {};
      if (Array.isArray(attrs.rgb_color) && attrs.rgb_color.length === 3) {
        return `rgb(${attrs.rgb_color[0]}, ${attrs.rgb_color[1]}, ${attrs.rgb_color[2]})`;
      }
      if (Array.isArray(attrs.hs_color) && attrs.hs_color.length >= 2) {
        const h = Number(attrs.hs_color[0]) || 0;
        const s = (Number(attrs.hs_color[1]) || 0) / 100;
        return `hsl(${h}, ${Math.round(s * 100)}%, 50%)`;
      }
      return "#ffc107";
    }
    return isOn ? "#ffc107" : "var(--state-icon-color)";
  }

  _supportsHkiPopupForDomain(domain, popupConfig = null) {
    if (popupConfig?.custom_popup_enabled === true || popupConfig?.custom_popup_card) return true;
    return ['light', 'climate', 'alarm_control_panel', 'cover', 'humidifier', 'fan', 'switch', 'input_boolean', 'lock', 'group'].includes(String(domain || ""));
  }

  _defaultInfoActionForDomain(domain, popupConfig = null) {
    return this._supportsHkiPopupForDomain(domain, popupConfig) ? "hki-more-info" : "more-info";
  }

  _renderButtonSlot(slotName, slotStyle, stateKey, bar = "top_bar") {
    const cfg = this._config;
    const prefix = `${bar}_${slotName}_`;
    const buttons = this._getSlotButtons(prefix);
    const slotPopupConfig = this._getSlotPopupConfig(prefix);
    
    const pillClass = slotStyle.pill ? "info-pill" : "";
    
    // Button always uses 5px padding (always has icon)
    const buttonPaddingY = slotStyle.pill ? 5 : slotStyle.pillPaddingY;
    const buttonPillStyle = slotStyle.pill ? `--hki-info-pill-background:${slotStyle.pillBg};--hki-info-pill-padding-x:${slotStyle.pillPaddingX}px;--hki-info-pill-padding-y:${buttonPaddingY}px;--hki-info-pill-radius:${slotStyle.pillRadius}px;--hki-info-pill-blur:${slotStyle.pillBlur}px;--hki-info-pill-border-style:${slotStyle.pillBorderStyle};--hki-info-pill-border-width:${slotStyle.pillBorderWidth}px;--hki-info-pill-border-color:${slotStyle.pillBorderColor}` : "";
    const combinedStyle = `${slotStyle.inlineStyle} ${buttonPillStyle}`;
    
    return html`
      <div style="display:inline-flex;align-items:center;gap:8px;flex-wrap:wrap;">
        ${buttons.map((rawBtn, idx) => {
          const btn = normalizeSlotButton(rawBtn);
          const buttonEntityId = btn.entity || "";
          const buttonEntity = buttonEntityId && this.hass?.states?.[buttonEntityId] ? this.hass.states[buttonEntityId] : null;
          const entityName = buttonEntity?.attributes?.friendly_name ? String(buttonEntity.attributes.friendly_name) : "";
          const entityIcon = buttonEntity ? this._getEntityDefaultIcon(buttonEntity) : "";
          const entityState = buttonEntity ? String(buttonEntity.state ?? "") : "";
          const autoColor = buttonEntity ? this._getAutoEntityColor(buttonEntity) : "";

          const iconOverride = this._resolveInlineTemplate(btn.icon || "", "");
          const iconAnimation = (this._resolveInlineTemplate(btn.icon_animation || "", "") || "").trim();
          const nameOverride = this._resolveInlineTemplate(btn.name || "", "");
          const stateOverride = this._resolveInlineTemplate(btn.state || "", "");

          const icon = iconOverride || entityIcon || "mdi:gesture-tap";
          const name = nameOverride || entityName || "";
          const stateLabel = stateOverride || entityState || "";
          const badgeColor = this._resolveInlineTemplate(btn.badge_color || "", "");
          const badgeTextColor = this._resolveInlineTemplate(btn.badge_text_color || "", "");
          const cardColorOverride = this._resolveInlineTemplate(btn.card_color || "", "");
          const textColorOverride = this._resolveInlineTemplate(btn.text_color || "", "");
          const buttonBorderStyle = this._resolveInlineTemplate(btn.button_border_style || "", "");
          const buttonBorderColor = this._resolveInlineTemplate(btn.button_border_color || "", "");
          const buttonBoxShadow = this._resolveInlineTemplate(btn.button_box_shadow || "", "");
          const iconColorOverride = this._resolveInlineTemplate(btn.icon_color || "", "");
          const nameColorOverride = this._resolveInlineTemplate(btn.name_color || "", "");
          const stateColorOverride = this._resolveInlineTemplate(btn.state_color || "", "");
          const textShadowOverride = this._resolveInlineTemplate(btn.text_shadow || "", "");
          const iconShadowOverride = this._resolveInlineTemplate(btn.icon_shadow || "", "");
          const badgeBorderStyle = this._resolveInlineTemplate(btn.badge_border_style || "", "");
          const badgeBorderColor = this._resolveInlineTemplate(btn.badge_border_color || "", "");
          const badgeBoxShadow = this._resolveInlineTemplate(btn.badge_box_shadow || "", "");
          const badgeFontFamily = (btn.badge_font_family === "custom")
            ? this._resolveInlineTemplate(btn.badge_font_custom || "", "")
            : (btn.badge_font_family || "");
          const effectiveIconShadow = this._asIconFilterValue(iconShadowOverride || slotStyle.iconShadow || "");

          const conditionMode = btn.visibility_mode || "none";
          const conditionEntityId = btn.visibility_entity || buttonEntityId;
          const conditionEntity = conditionEntityId && this.hass?.states?.[conditionEntityId] ? this.hass.states[conditionEntityId] : null;
          const readAttributePath = (attributes, path) => {
            if (!attributes || !path) return undefined;
            return String(path).split(".").reduce((acc, key) => {
              if (acc == null || typeof acc !== "object") return undefined;
              return acc[key];
            }, attributes);
          };
          let isVisible = true;
          if (conditionMode === "state") {
            const expectedState = this._resolveInlineTemplate(btn.visibility_state || "", "");
            isVisible = !!(conditionEntity && expectedState !== "" && String(conditionEntity.state ?? "") === String(expectedState));
          } else if (conditionMode === "attribute") {
            const attrName = (btn.visibility_attribute || "").trim();
            const expectedAttrValue = this._resolveInlineTemplate(btn.visibility_attribute_value || "", "");
            const currentAttrValue = readAttributePath(conditionEntity?.attributes || null, attrName);
            isVisible = !!(conditionEntity && attrName && expectedAttrValue !== "" && String(currentAttrValue ?? "") === String(expectedAttrValue));
          }
          if (!isVisible) return html``;

          let badgeText = "";
          if (btn.show_badge) {
            if (btn.badge_source === "template") {
              badgeText = this._resolveInlineTemplate(btn.badge_template || "", "");
            } else if (btn.badge_entity && this.hass?.states?.[btn.badge_entity]) {
              badgeText = String(this.hass.states[btn.badge_entity].state ?? "");
            }
          }
          const showBadge = btn.show_badge && !!badgeText;

          const showIcon = btn.show_icon !== false;
          const showName = btn.show_name !== false;
          const showState = btn.show_state !== false;
          const isIconOnly = !showName && !showState;
          const circleSize = Math.max(slotStyle.iconSize, (slotStyle.iconSize + (buttonPaddingY * 2)));
          const iconStyle = `width:100%;height:100%;--mdc-icon-size:${slotStyle.iconSize}px;color:${iconColorOverride || autoColor || "inherit"};`;
          const buttonStyle = `${combinedStyle}${cardColorOverride ? `;--hki-info-pill-background:${cardColorOverride};` : ""}${iconShadowOverride ? `;--hki-info-icon-filter:${effectiveIconShadow};` : ""}${buttonBoxShadow ? `;box-shadow:${buttonBoxShadow};` : ""}${buttonBorderStyle ? `;border-style:${buttonBorderStyle};` : ""}${buttonBorderColor ? `;border-color:${buttonBorderColor};` : ""}${btn.button_border_width !== "" && btn.button_border_width != null ? `;border-width:${Number(btn.button_border_width) || 0}px;` : ""}${btn.button_border_radius !== "" && btn.button_border_radius != null ? `;border-radius:${Number(btn.button_border_radius) || 0}px;` : ""}${textColorOverride ? `;color:${textColorOverride};` : ""};--hki-slot-badge-height:${circleSize}px;${isIconOnly ? `--hki-slot-circle-size:${circleSize}px;justify-content:center;` : ""}`;
          const nameOffsetX = toNum(btn.name_offset_x, 0);
          const nameOffsetY = toNum(btn.name_offset_y, 0);
          const stateOffsetX = toNum(btn.state_offset_x, 0);
          const stateOffsetY = toNum(btn.state_offset_y, 0);
          const nameStyle = `${nameColorOverride ? `color:${nameColorOverride};` : (textColorOverride ? `color:${textColorOverride};` : "")}${textShadowOverride ? `text-shadow:${textShadowOverride};` : ""}${(nameOffsetX || nameOffsetY) ? `position:relative;left:${nameOffsetX}px;top:${nameOffsetY}px;` : ""}`;
          const stateStyle = `${stateColorOverride ? `color:${stateColorOverride};` : (textColorOverride ? `color:${textColorOverride};` : "")}${textShadowOverride ? `text-shadow:${textShadowOverride};` : ""}${(stateOffsetX || stateOffsetY) ? `position:relative;left:${stateOffsetX}px;top:${stateOffsetY}px;` : ""}`;
          const tapAction = btn.tap_action || { action: "none" };
          const buttonDomain = buttonEntityId ? buttonEntityId.split(".")[0] : "";
          const defaultInfoAction = this._defaultInfoActionForDomain(buttonDomain, slotPopupConfig);
          const toggleDomains = ["switch", "climate", "input_boolean", "automation", "light"];
          const defaultTapAction = toggleDomains.includes(buttonDomain) ? { action: "toggle" } : { action: defaultInfoAction };
          const holdAction = btn.hold_action || { action: defaultInfoAction };
          const doubleTapAction = btn.double_tap_action || { action: defaultInfoAction };
          const effectiveTapAction = (!tapAction || !tapAction.action || tapAction.action === "none") ? defaultTapAction : tapAction;
          const effectiveHoldAction = (!holdAction || !holdAction.action || holdAction.action === "none") ? { action: defaultInfoAction } : holdAction;
          const effectiveDoubleTapAction = (!doubleTapAction || !doubleTapAction.action || doubleTapAction.action === "none") ? { action: defaultInfoAction } : doubleTapAction;
          const hasAnyAction = (effectiveTapAction.action !== "none") || (effectiveHoldAction.action !== "none") || (effectiveDoubleTapAction.action !== "none");
          const buttonPopupOverrides = {};
          const buttonPopup = (btn.popup && typeof btn.popup === "object") ? btn.popup : null;
          if (buttonPopup) {
            Object.entries(buttonPopup).forEach(([key, value]) => {
              if (value === undefined) return;
              buttonPopupOverrides[popupAnyKeyToFlatKey(key)] = value;
            });
          }
          const buttonPopupConfig = {
            ...(slotPopupConfig || {}),
            ...buttonPopupOverrides,
          };
          const effectivePopupConfig = Object.keys(buttonPopupConfig).length ? buttonPopupConfig : null;

          const key = `${stateKey}_${idx}`;
          if (!this._slotHoldState) this._slotHoldState = {};
          if (!this._slotHoldState[key]) this._slotHoldState[key] = { holdTimer: null, holdActive: false, clickTimer: null, clickCount: 0, touchHandled: false };
          const state = this._slotHoldState[key];

          const startHold = () => {
            state.holdActive = false;
            state.holdTimer = setTimeout(() => {
              state.holdActive = true;
              if (effectiveHoldAction && effectiveHoldAction.action !== "none") {
                this._handleSlotTapAction(effectiveHoldAction, slotName, buttonEntityId || null, effectivePopupConfig);
              }
            }, 500);
          };

          const endHold = () => {
            if (state.holdTimer) {
              clearTimeout(state.holdTimer);
              state.holdTimer = null;
            }
            if (!state.holdActive) {
              state.clickCount++;
              if (state.clickCount === 1) {
                state.clickTimer = setTimeout(() => {
                  if (state.clickCount === 1) {
                    this._handleSlotTapAction(effectiveTapAction, slotName, buttonEntityId || null, effectivePopupConfig);
                  }
                  state.clickCount = 0;
                }, 250);
              } else if (state.clickCount === 2) {
                clearTimeout(state.clickTimer);
                state.clickCount = 0;
                this._handleSlotTapAction(effectiveDoubleTapAction, slotName, buttonEntityId || null, effectivePopupConfig);
              }
            }
            state.holdActive = false;
          };

          const cancelHold = () => {
            if (state.holdTimer) {
              clearTimeout(state.holdTimer);
              state.holdTimer = null;
            }
            state.holdActive = false;
          };

          const handleTouchStart = () => { state.touchHandled = true; startHold(); };
          const handleTouchEnd = () => { endHold(); setTimeout(() => { state.touchHandled = false; }, 500); };
          const handleMouseDown = () => { if (state.touchHandled) return; startHold(); };
          const handleMouseUp = () => { if (state.touchHandled) return; endHold(); };
          const handleMouseLeave = () => { if (!state.touchHandled) cancelHold(); };

          return html`
            <div
              class="info-item ${pillClass} hki-slot-button ${isIconOnly ? 'hki-slot-button-icon-only' : ''} ${hasAnyAction ? 'info-clickable' : ''}"
              style="${buttonStyle}"
              @mousedown=${handleMouseDown}
              @mouseup=${handleMouseUp}
              @mouseleave=${handleMouseLeave}
              @touchstart=${handleTouchStart}
              @touchend=${handleTouchEnd}
              @contextmenu=${(e) => e.preventDefault()}
            >
              ${showIcon ? html`
              <div class="info-icon" style="width:${slotStyle.iconSize}px;height:${slotStyle.iconSize}px;">
                <ha-icon class="${iconAnimation && iconAnimation !== "none" ? `animate-${iconAnimation}` : ""}" .icon=${icon} style="${iconStyle}"></ha-icon>
              </div>` : ''}
              ${(showName || showState) ? html`
                <span class="hki-slot-button-text">
                  ${showName && name ? html`<span class="hki-slot-button-name" style="${nameStyle}">${name}</span>` : ''}
                  ${showState && stateLabel ? html`<span class="hki-slot-button-state" style="${stateStyle}">${stateLabel}</span>` : ''}
                </span>
              ` : ''}
              ${showBadge ? html`
                <span class="hki-slot-button-badge" style="${((badgeColor || "").toLowerCase() === "auto" && autoColor) ? `background:${autoColor};` : (badgeColor ? `background:${badgeColor};` : "")}${badgeTextColor ? `color:${badgeTextColor};` : ""}${badgeBorderStyle ? `border-style:${badgeBorderStyle};` : ""}${btn.badge_border_width !== "" && btn.badge_border_width != null ? `border-width:${Number(btn.badge_border_width) || 0}px;` : ""}${badgeBorderColor ? `border-color:${badgeBorderColor};` : ""}${btn.badge_border_radius !== "" && btn.badge_border_radius != null ? `border-radius:${Number(btn.badge_border_radius) || 0}px;` : ""}${badgeBoxShadow ? `box-shadow:${badgeBoxShadow};` : ""}${btn.badge_font_size !== "" && btn.badge_font_size != null ? `font-size:${Number(btn.badge_font_size) || 10}px;` : ""}${btn.badge_font_weight ? `font-weight:${btn.badge_font_weight};` : ""}${badgeFontFamily ? `font-family:${badgeFontFamily};` : ""}">
                  ${badgeText}
                </span>
              ` : ''}
            </div>
          `;
        })}
      </div>
    `;
  }

  // Build a slot-level popup config object from flat config using the slot prefix
  _getSlotPopupConfig(prefix) {
    const cfg = this._config;
    const pc = {};
    copyDefinedKeys({
      src: cfg,
      dst: pc,
      keys: HKI_POPUP_CONFIG_KEYS,
      srcPrefix: prefix,
    });
    return Object.keys(pc).length ? pc : null;
  }

  _handleSlotTapAction(action, slotName, entityId = null, popupConfig = null) {
    if (!action || action.action === "none") return;
    this._handleAction(action, entityId, popupConfig);
  }

  _renderWeatherSlot(slotName, slotStyle, stateKey, bar = "top_bar") {
    const cfg = this._config;
    const prefix = `${bar}_${slotName}_`;
    const slotPopupConfig = this._getSlotPopupConfig(prefix);
    
    // Fallback to global if local is not set
    const entityId = cfg[prefix + "weather_entity"] || cfg.weather_entity;
    
    if (!entityId || !this.hass) return html``;

    const weatherEntity = this.hass.states[entityId];
    if (!weatherEntity) return html``;

    const state = weatherEntity.state;
    const attrs = weatherEntity.attributes || {};

    const weatherIcon = WEATHER_ICON_MAP[state] || "mdi:weather-cloudy";
    
    // Translate condition state
    let conditionText = state;
    if (this.hass.formatEntityState) {
        conditionText = this.hass.formatEntityState(weatherEntity);
    } else {
        conditionText = (attrs.friendly_name || state).replace(/-/g, " ");
    }
    
    const temperature = attrs.temperature;
    const humidity = attrs.humidity;
    const wind = attrs.wind_speed;
    const pressure = attrs.pressure;
    const unit = this.hass.config?.unit_system?.temperature || "Â°C";

    // Check for slot specific overrides, fallback to global
    const showIcon = cfg[prefix + "show_icon"] !== undefined ? cfg[prefix + "show_icon"] : (cfg.weather_show_icon !== false);
    const showCondition = cfg[prefix + "show_condition"] !== undefined ? cfg[prefix + "show_condition"] : (cfg.weather_show_condition !== false);
    const showTemp = cfg[prefix + "show_temperature"] !== undefined ? cfg[prefix + "show_temperature"] : (cfg.weather_show_temperature !== false);
    const showHum = cfg[prefix + "show_humidity"] !== undefined ? cfg[prefix + "show_humidity"] : !!cfg.weather_show_humidity;
    const showWind = cfg[prefix + "show_wind"] !== undefined ? cfg[prefix + "show_wind"] : !!cfg.weather_show_wind;
    const showPressure = cfg[prefix + "show_pressure"] !== undefined ? cfg[prefix + "show_pressure"] : !!cfg.weather_show_pressure;

    const iconColor = this._resolveWeatherIconColor(cfg, state, prefix);
    
    const animateIcon = cfg[prefix + "animate_icon"] || cfg.weather_animate_icon;
    const animClass = animateIcon && animateIcon !== "none" ? `animate-${animateIcon}` : "";

    const iconPack = cfg[prefix + "icon_pack_path"] || cfg.weather_icon_pack_path;
    const useSvg = !!iconPack;
    const svgUrl = useSvg ? `${iconPack}/${state}.svg` : "";

    const pillClass = slotStyle.pill ? "info-pill" : "";
    
    // Adjust padding for weather pill to maintain consistent height:
    // - With icon: 5px (to match notification card with icon)
    // - Without icon: 11px (compensates for missing icon height to match pill with icon)
    const weatherPaddingY = slotStyle.pill ? (showIcon ? 5 : 11) : slotStyle.pillPaddingY;
    const weatherPillStyle = slotStyle.pill ? `--hki-info-pill-background:${slotStyle.pillBg};--hki-info-pill-padding-x:${slotStyle.pillPaddingX}px;--hki-info-pill-padding-y:${weatherPaddingY}px;--hki-info-pill-radius:${slotStyle.pillRadius}px;--hki-info-pill-blur:${slotStyle.pillBlur}px;--hki-info-pill-border-style:${slotStyle.pillBorderStyle};--hki-info-pill-border-width:${slotStyle.pillBorderWidth}px;--hki-info-pill-border-color:${slotStyle.pillBorderColor}` : "";
    const combinedStyle = `${slotStyle.inlineStyle} ${weatherPillStyle}`;
    
    const tapAction = cfg[prefix + "tap_action"] || cfg.info_tap_action || { action: "none" };
    const holdAction = cfg[prefix + "hold_action"] || { action: "none" };
    const doubleTapAction = cfg[prefix + "double_tap_action"] || { action: "none" };
    const hasAnyAction = (tapAction.action !== "none") || (holdAction.action !== "none") || (doubleTapAction.action !== "none");

    // Hold state lives on the instance (keyed by slot) so it survives re-renders
    if (!this._slotHoldState) this._slotHoldState = {};
    if (!this._slotHoldState[stateKey]) this._slotHoldState[stateKey] = { holdTimer: null, holdActive: false, clickTimer: null, clickCount: 0, touchHandled: false };
    const holdState = this._slotHoldState[stateKey];

    const startHold = () => {
      holdState.holdActive = false;
      // Always set timer so a long-press is recognized even when holdAction is "none"
      holdState.holdTimer = setTimeout(() => {
        holdState.holdActive = true;
        if (holdAction && holdAction.action !== "none") {
          this._handleSlotTapAction(holdAction, slotName, entityId, slotPopupConfig);
        }
      }, 500);
    };

    const endHold = () => {
      if (holdState.holdTimer) {
        clearTimeout(holdState.holdTimer);
        holdState.holdTimer = null;
      }
      if (!holdState.holdActive) {
        holdState.clickCount++;
        if (holdState.clickCount === 1) {
          holdState.clickTimer = setTimeout(() => {
            if (holdState.clickCount === 1) {
              this._handleSlotTapAction(tapAction, slotName, entityId, slotPopupConfig);
            }
            holdState.clickCount = 0;
          }, 250);
        } else if (holdState.clickCount === 2) {
          clearTimeout(holdState.clickTimer);
          holdState.clickCount = 0;
          this._handleSlotTapAction(doubleTapAction, slotName, entityId, slotPopupConfig);
        }
      }
      holdState.holdActive = false;
    };

    const cancelHold = () => {
      if (holdState.holdTimer) {
        clearTimeout(holdState.holdTimer);
        holdState.holdTimer = null;
      }
      holdState.holdActive = false;
    };

    const handleTouchStart = () => { holdState.touchHandled = true; startHold(); };
    const handleTouchEnd = () => { endHold(); setTimeout(() => { holdState.touchHandled = false; }, 500); };
    const handleMouseDown = () => { if (holdState.touchHandled) return; startHold(); };
    const handleMouseUp = () => { if (holdState.touchHandled) return; endHold(); };
    const handleMouseLeave = () => { if (!holdState.touchHandled) cancelHold(); };

    return html`
      <div 
        class="info-item ${pillClass} ${hasAnyAction ? 'info-clickable' : ''}" 
        style="${combinedStyle}"
        @mousedown=${handleMouseDown}
        @mouseup=${handleMouseUp}
        @mouseleave=${handleMouseLeave}
        @touchstart=${handleTouchStart}
        @touchend=${handleTouchEnd}
        @contextmenu=${(e) => e.preventDefault()}
      >
        ${showIcon ? (useSvg 
            ? html`<img src="${svgUrl}" class="info-icon ${animClass}" style="width:${slotStyle.iconSize}px;height:${slotStyle.iconSize}px;${slotStyle.iconShadowFilter ? `filter:${slotStyle.iconShadowFilter};` : ""}" alt="${state}" />`
            : html`<div class="info-icon" style="width:${slotStyle.iconSize}px;height:${slotStyle.iconSize}px;"><ha-icon class="${animClass}" .icon=${weatherIcon}
                   style="width:100%;height:100%;--mdc-icon-size:${slotStyle.iconSize}px;color:${iconColor};${slotStyle.iconShadowFilter ? `filter:${slotStyle.iconShadowFilter};` : ""}"></ha-icon></div>`)
        : ""}
        ${showCondition ? html`<span class="info-condition">${conditionText}</span>` : ""}
        ${showTemp && temperature != null ? html`<span class="info-temperature">${Math.round(temperature)}${unit}</span>` : ""}
        ${showHum && humidity != null ? html`<span class="info-humidity">${humidity}%</span>` : ""}
        ${showWind && wind != null ? html`<span class="info-wind">${wind} ${attrs.wind_speed_unit || "km/h"}</span>` : ""}
        ${showPressure && pressure != null ? html`<span class="info-pressure">${pressure} ${attrs.pressure_unit || "hPa"}</span>` : ""}
      </div>
    `;
  }

  _renderDatetimeSlot(slotName, slotStyle, stateKey, bar = "top_bar") {
    const cfg = this._config;
    const prefix = `${bar}_${slotName}_`;
    const slotPopupConfig = this._getSlotPopupConfig(prefix);
    const locale = this.hass?.language || 'en';
    
    const now = new Date(this._currentTime);
    const parts = [];

    // Fallback to global defaults if local not set
    const showDay = cfg[prefix + "show_day"] !== undefined ? cfg[prefix + "show_day"] : (cfg.datetime_show_day !== false);
    const showDate = cfg[prefix + "show_date"] !== undefined ? cfg[prefix + "show_date"] : (cfg.datetime_show_date !== false);
    const showTime = cfg[prefix + "show_time"] !== undefined ? cfg[prefix + "show_time"] : (cfg.datetime_show_time !== false);
    
    const dateFormat = cfg[prefix + "date_format"] || cfg.datetime_date_format || "D MMM";
    const timeFormat = cfg[prefix + "time_format"] || cfg.datetime_time_format || "HH:mm";
    const sep = cfg[prefix + "separator"] || cfg.datetime_separator || " â€¢ ";
    const icon = cfg[prefix + "icon"] || cfg.datetime_icon;

    if (showDay) parts.push(formatDateTime(now, "DDDD", locale));
    if (showDate) parts.push(formatDateTime(now, dateFormat, locale));
    if (showTime) parts.push(formatDateTime(now, timeFormat, locale));

    const displayText = parts.join(sep);

    const pillClass = slotStyle.pill ? "info-pill" : "";
    
    // Adjust padding for datetime pill to maintain consistent height:
    // - With icon: 5px (to match notification card with icon)
    // - Without icon: 11px (compensates for missing icon height)
    const datetimePaddingY = slotStyle.pill ? (icon ? 5 : 11) : slotStyle.pillPaddingY;
    const datetimePillStyle = slotStyle.pill ? `--hki-info-pill-background:${slotStyle.pillBg};--hki-info-pill-padding-x:${slotStyle.pillPaddingX}px;--hki-info-pill-padding-y:${datetimePaddingY}px;--hki-info-pill-radius:${slotStyle.pillRadius}px;--hki-info-pill-blur:${slotStyle.pillBlur}px;--hki-info-pill-border-style:${slotStyle.pillBorderStyle};--hki-info-pill-border-width:${slotStyle.pillBorderWidth}px;--hki-info-pill-border-color:${slotStyle.pillBorderColor}` : "";
    const combinedStyle = `${slotStyle.inlineStyle} ${datetimePillStyle}`;
    
    const animateIcon = cfg[prefix + "animate_icon"] || cfg.datetime_animate_icon;
    const animClass = animateIcon && animateIcon !== "none" ? `animate-${animateIcon}` : "";
    
    const tapAction = cfg[prefix + "tap_action"] || cfg.info_tap_action || { action: "none" };
    const holdAction = cfg[prefix + "hold_action"] || { action: "none" };
    const doubleTapAction = cfg[prefix + "double_tap_action"] || { action: "none" };
    const hasAnyAction = (tapAction.action !== "none") || (holdAction.action !== "none") || (doubleTapAction.action !== "none");

    // Hold state lives on the instance (keyed by slot) so it survives re-renders
    if (!this._slotHoldState) this._slotHoldState = {};
    if (!this._slotHoldState[stateKey]) this._slotHoldState[stateKey] = { holdTimer: null, holdActive: false, clickTimer: null, clickCount: 0, touchHandled: false };
    const state = this._slotHoldState[stateKey];

    const startHold = () => {
      state.holdActive = false;
      // Always set timer so a long-press is recognized even when holdAction is "none"
      state.holdTimer = setTimeout(() => {
        state.holdActive = true;
        if (holdAction && holdAction.action !== "none") {
          this._handleSlotTapAction(holdAction, slotName, null, slotPopupConfig);
        }
      }, 500);
    };

    const endHold = () => {
      if (state.holdTimer) {
        clearTimeout(state.holdTimer);
        state.holdTimer = null;
      }
      if (!state.holdActive) {
        state.clickCount++;
        if (state.clickCount === 1) {
          state.clickTimer = setTimeout(() => {
            if (state.clickCount === 1) {
              this._handleSlotTapAction(tapAction, slotName, null, slotPopupConfig);
            }
            state.clickCount = 0;
          }, 250);
        } else if (state.clickCount === 2) {
          clearTimeout(state.clickTimer);
          state.clickCount = 0;
          this._handleSlotTapAction(doubleTapAction, slotName, null, slotPopupConfig);
        }
      }
      state.holdActive = false;
    };

    const cancelHold = () => {
      if (state.holdTimer) {
        clearTimeout(state.holdTimer);
        state.holdTimer = null;
      }
      state.holdActive = false;
    };

    const handleTouchStart = () => { state.touchHandled = true; startHold(); };
    const handleTouchEnd = () => { endHold(); setTimeout(() => { state.touchHandled = false; }, 500); };
    const handleMouseDown = () => { if (state.touchHandled) return; startHold(); };
    const handleMouseUp = () => { if (state.touchHandled) return; endHold(); };
    const handleMouseLeave = () => { if (!state.touchHandled) cancelHold(); };

    return html`
      <div 
        class="info-item ${pillClass} ${hasAnyAction ? 'info-clickable' : ''}" 
        style="${combinedStyle}"
        @mousedown=${handleMouseDown}
        @mouseup=${handleMouseUp}
        @mouseleave=${handleMouseLeave}
        @touchstart=${handleTouchStart}
        @touchend=${handleTouchEnd}
        @contextmenu=${(e) => e.preventDefault()}
      >
        ${icon ? html`
          <div class="info-icon ${animClass}" style="width:${slotStyle.iconSize}px;height:${slotStyle.iconSize}px;"><ha-icon .icon=${icon}
                   style="width:100%;height:100%;--mdc-icon-size:${slotStyle.iconSize}px;${slotStyle.iconShadowFilter ? `filter:${slotStyle.iconShadowFilter};` : ""}"></ha-icon></div>
        ` : ""}
        <span>${displayText}</span>
      </div>
    `;
  }

  _renderCustomCardSlot(slotName, slotStyle, cardId = null, type = "notifications", stretch = false) {
    const cardEl = this._customCards[cardId || slotName];
    if (!cardEl) return html``;

    // Force the card element itself to fill the slot when stretching.
    // We set the style directly on the live DOM node so it takes effect regardless
    // of how the card internally sizes itself.
    if (stretch) {
      cardEl.style.width = '100%';
      cardEl.style.minWidth = '0';
      cardEl.style.boxSizing = 'border-box';
    } else {
      cardEl.style.width = '';
      cardEl.style.minWidth = '';
      cardEl.style.boxSizing = '';
    }

    // 'card' type is a bare arbitrary card â€” do not inject header global styling.
    // 'notifications'/'custom' are hki-notification-card which consume notifyVars via use_header_styling.
    const isNotificationSlot = type !== "card";

    // When stretch is active: switch from inline-flex (content-sized) to flex (fills parent),
    // and make the wrapper fill the full slot width.
    const stretchStyle = stretch ? `display:flex;width:100%;min-width:0;` : '';

    const combinedStyle = isNotificationSlot
      ? `${slotStyle.inlineStyle} ${slotStyle.notifyVars}; min-width: 50px; ${stretchStyle}${slotStyle.pill ? `overflow: hidden; border-radius: ${slotStyle.pillRadius}px;` : ''}`
      : `min-width: 50px; ${stretchStyle}`;

    return html`
      <div class="info-item" style="${combinedStyle}">
        ${cardEl}
      </div>
    `;
  }

  _renderTopBar() {
      if (!this._config.top_bar_enabled) return html``;

      const cfg = this._config;
      const offsetY = cfg.top_bar_offset_y !== undefined ? cfg.top_bar_offset_y : 10;
      const paddingX = cfg.top_bar_padding_x !== undefined ? cfg.top_bar_padding_x : 5;
      const topStyle = `top: ${offsetY}px; padding: 0 ${paddingX}px;`;
      
      const isMobile = this._viewportWidth > 0 && this._viewportWidth <= (cfg.mobile_breakpoint || 768);
      
      // Helper to calculate offset, preferring mobile override if valid number
      const getOffset = (base, mobile) => {
         if (isMobile && typeof mobile === 'number' && Number.isFinite(mobile)) return mobile;
         return base || 0;
      };

      const leftX = getOffset(cfg.top_bar_left_offset_x, cfg.top_bar_left_offset_x_mobile);
      const leftY = getOffset(cfg.top_bar_left_offset_y, cfg.top_bar_left_offset_y_mobile);
      
      const centerX = getOffset(cfg.top_bar_center_offset_x, cfg.top_bar_center_offset_x_mobile);
      const centerY = getOffset(cfg.top_bar_center_offset_y, cfg.top_bar_center_offset_y_mobile);
      
      const rightX = getOffset(cfg.top_bar_right_offset_x, cfg.top_bar_right_offset_x_mobile);
      const rightY = getOffset(cfg.top_bar_right_offset_y, cfg.top_bar_right_offset_y_mobile);
      
      const leftStyle = (leftX || leftY) ? `transform: translate(${leftX}px, ${leftY}px);` : "";
      const centerStyle = (centerX || centerY) ? `transform: translate(${centerX}px, ${centerY}px);` : "";
      const rightStyle = (rightX || rightY) ? `transform: translate(${rightX}px, ${rightY}px);` : "";
      
      // Determine which slots are occupied
      const leftEmpty = cfg.top_bar_left === "none";
      const centerEmpty = cfg.top_bar_center === "none";
      const rightEmpty = cfg.top_bar_right === "none";
      
      // Determine overflow
      const leftOverflow = !!cfg.top_bar_left_overflow || cfg.top_bar_left === "button";
      const centerOverflow = !!cfg.top_bar_center_overflow || cfg.top_bar_center === "button";
      const rightOverflow = !!cfg.top_bar_right_overflow || cfg.top_bar_right === "button";

      const leftAlign = cfg.top_bar_left_align || 'start';
      const centerAlign = cfg.top_bar_center_align || 'center';
      const rightAlign = cfg.top_bar_right_align || 'end';

      // â”€â”€ Stretch: custom-card slots can absorb adjacent empty slots â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const CARD_TYPES = ['card', 'custom', 'notifications'];
      const calcStretchSpan = (slot, slotType) => {
        if (!CARD_TYPES.includes(slotType)) return 1;
        const align = cfg[`top_bar_${slot}_align`];
        if (align !== 'stretch') return 1;
        if (slot === 'left')   { let s = 1; if (centerEmpty) { s++; if (rightEmpty)  s++; } return s; }
        if (slot === 'right')  { let s = 1; if (centerEmpty) { s++; if (leftEmpty)   s++; } return s; }
        /* center */             let s = 1; if (leftEmpty) s++;   if (rightEmpty) s++;   return s;
      };
      const leftSpan   = calcStretchSpan('left',   cfg.top_bar_left);
      const centerSpan = calcStretchSpan('center', cfg.top_bar_center);
      const rightSpan  = calcStretchSpan('right',  cfg.top_bar_right);
      const leftStretch   = leftSpan   > 1 || (leftAlign   === 'stretch' && CARD_TYPES.includes(cfg.top_bar_left));
      const centerStretch = centerSpan > 1 || (centerAlign === 'stretch' && CARD_TYPES.includes(cfg.top_bar_center));
      const rightStretch  = rightSpan  > 1 || (rightAlign  === 'stretch' && CARD_TYPES.includes(cfg.top_bar_right));
      // Build per-slot flex-grow override (only when span > 1, i.e. absorbing neighbours)
      const leftFlexExtra   = leftSpan   > 1 ? `flex-grow:${leftSpan};`   : '';
      const centerFlexExtra = centerSpan > 1 ? `flex-grow:${centerSpan};` : '';
      const rightFlexExtra  = rightSpan  > 1 ? `flex-grow:${rightSpan};`  : '';

      return html`
        <div class="top-bar-container" style="${topStyle}">
            <div class="slot slot-left slot-align-${leftAlign} ${leftEmpty ? 'slot-empty' : ''} ${leftOverflow ? 'slot-visible' : ''}" style="${leftStyle}${leftFlexExtra}">${this._renderSlotContent(cfg.top_bar_left, "left", null, "top_bar", leftStretch)}</div>
            <div class="slot slot-center slot-align-${centerAlign} ${centerEmpty ? 'slot-empty' : ''} ${centerOverflow ? 'slot-visible' : ''}" style="${centerStyle}${centerFlexExtra}">${this._renderSlotContent(cfg.top_bar_center, "center", null, "top_bar", centerStretch)}</div>
            <div class="slot slot-right slot-align-${rightAlign} ${rightEmpty ? 'slot-empty' : ''} ${rightOverflow ? 'slot-visible' : ''}" style="${rightStyle}${rightFlexExtra}">${this._renderSlotContent(cfg.top_bar_right, "right", null, "top_bar", rightStretch)}</div>
        </div>
      `;
  }

  _renderBottomBar() {
      if (!this._config.bottom_bar_enabled) return html``;

      const cfg = this._config;
      const offsetY = cfg.bottom_bar_offset_y !== undefined ? cfg.bottom_bar_offset_y : 10;
      const paddingX = cfg.bottom_bar_padding_x !== undefined ? cfg.bottom_bar_padding_x : 5;
      const bottomStyle = `bottom: ${offsetY}px; padding: 0 ${paddingX}px;`;

      const isMobile = this._viewportWidth > 0 && this._viewportWidth <= (cfg.mobile_breakpoint || 768);
      const getOffset = (base, mobile) => {
         if (isMobile && typeof mobile === 'number' && Number.isFinite(mobile)) return mobile;
         return base || 0;
      };

      const leftX = getOffset(cfg.bottom_bar_left_offset_x, cfg.bottom_bar_left_offset_x_mobile);
      const leftY = getOffset(cfg.bottom_bar_left_offset_y, cfg.bottom_bar_left_offset_y_mobile);
      const centerX = getOffset(cfg.bottom_bar_center_offset_x, cfg.bottom_bar_center_offset_x_mobile);
      const centerY = getOffset(cfg.bottom_bar_center_offset_y, cfg.bottom_bar_center_offset_y_mobile);
      const rightX = getOffset(cfg.bottom_bar_right_offset_x, cfg.bottom_bar_right_offset_x_mobile);
      const rightY = getOffset(cfg.bottom_bar_right_offset_y, cfg.bottom_bar_right_offset_y_mobile);

      const leftStyle = (leftX || leftY) ? `transform: translate(${leftX}px, ${leftY}px);` : "";
      const centerStyle = (centerX || centerY) ? `transform: translate(${centerX}px, ${centerY}px);` : "";
      const rightStyle = (rightX || rightY) ? `transform: translate(${rightX}px, ${rightY}px);` : "";

      const leftEmpty = cfg.bottom_bar_left === "none";
      const centerEmpty = cfg.bottom_bar_center === "none";
      const rightEmpty = cfg.bottom_bar_right === "none";

      const leftOverflow = !!cfg.bottom_bar_left_overflow || cfg.bottom_bar_left === "button";
      const centerOverflow = !!cfg.bottom_bar_center_overflow || cfg.bottom_bar_center === "button";
      const rightOverflow = !!cfg.bottom_bar_right_overflow || cfg.bottom_bar_right === "button";

      const leftAlign = cfg.bottom_bar_left_align || 'start';
      const centerAlign = cfg.bottom_bar_center_align || 'center';
      const rightAlign = cfg.bottom_bar_right_align || 'end';

      // â”€â”€ Stretch: custom-card slots can absorb adjacent empty slots â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const CARD_TYPES = ['card', 'custom', 'notifications'];
      const calcStretchSpan = (slot, slotType) => {
        if (!CARD_TYPES.includes(slotType)) return 1;
        const align = cfg[`bottom_bar_${slot}_align`];
        if (align !== 'stretch') return 1;
        if (slot === 'left')   { let s = 1; if (centerEmpty) { s++; if (rightEmpty)  s++; } return s; }
        if (slot === 'right')  { let s = 1; if (centerEmpty) { s++; if (leftEmpty)   s++; } return s; }
        /* center */             let s = 1; if (leftEmpty) s++;   if (rightEmpty) s++;   return s;
      };
      const leftSpan   = calcStretchSpan('left',   cfg.bottom_bar_left);
      const centerSpan = calcStretchSpan('center', cfg.bottom_bar_center);
      const rightSpan  = calcStretchSpan('right',  cfg.bottom_bar_right);
      const leftStretch   = leftSpan   > 1 || (leftAlign   === 'stretch' && CARD_TYPES.includes(cfg.bottom_bar_left));
      const centerStretch = centerSpan > 1 || (centerAlign === 'stretch' && CARD_TYPES.includes(cfg.bottom_bar_center));
      const rightStretch  = rightSpan  > 1 || (rightAlign  === 'stretch' && CARD_TYPES.includes(cfg.bottom_bar_right));
      const leftFlexExtra   = leftSpan   > 1 ? `flex-grow:${leftSpan};`   : '';
      const centerFlexExtra = centerSpan > 1 ? `flex-grow:${centerSpan};` : '';
      const rightFlexExtra  = rightSpan  > 1 ? `flex-grow:${rightSpan};`  : '';

      return html`
        <div class="bottom-bar-container" style="${bottomStyle}">
            <div class="slot slot-left slot-align-${leftAlign} ${leftEmpty ? 'slot-empty' : ''} ${leftOverflow ? 'slot-visible' : ''}" style="${leftStyle}${leftFlexExtra}">${this._renderSlotContent(cfg.bottom_bar_left, "left", "bottom_left", "bottom_bar", leftStretch)}</div>
            <div class="slot slot-center slot-align-${centerAlign} ${centerEmpty ? 'slot-empty' : ''} ${centerOverflow ? 'slot-visible' : ''}" style="${centerStyle}${centerFlexExtra}">${this._renderSlotContent(cfg.bottom_bar_center, "center", "bottom_center", "bottom_bar", centerStretch)}</div>
            <div class="slot slot-right slot-align-${rightAlign} ${rightEmpty ? 'slot-empty' : ''} ${rightOverflow ? 'slot-visible' : ''}" style="${rightStyle}${rightFlexExtra}">${this._renderSlotContent(cfg.bottom_bar_right, "right", "bottom_right", "bottom_bar", rightStretch)}</div>
        </div>
      `;
  }

  _renderPersons() {
    const cfg = this._config;
    if (!cfg.persons_enabled || !cfg.persons_entities || cfg.persons_entities.length === 0) {
      return html``;
    }

    const personsAlign = cfg.persons_align || "left";
    const personsX = cfg.persons_offset_x || 5;
    const personsY = cfg.persons_offset_y || 32;
    const personsSize = cfg.persons_size || 48;
    const personsSpacing = cfg.persons_spacing != null ? cfg.persons_spacing : -8;
    const stackOrder = cfg.persons_stack_order || "ascending";
    const dynamicOrder = cfg.persons_dynamic_order || false;
    const hideAway = cfg.persons_hide_away || false;
    const borderWidth = cfg.persons_border_width || 1;
    const borderStyle = cfg.persons_border_style || "solid";
    
    // Parse border radius to handle integer values as pixels
    const parseRadius = (v) => {
      if (v === undefined || v === null || v === "") return "50%";
      if (typeof v === "number" && Number.isFinite(v)) return `${v}px`;
      const s = String(v).trim();
      // If user enters a plain number (incl. negative/decimal), interpret as px.
      // Otherwise pass through as any valid CSS length/value (%, em, var(), etc.)
      return /^-?\d+(?:\.\d+)?$/.test(s) ? `${s}px` : s;
    };
    
    const borderRadius = parseRadius(cfg.persons_border_radius);
    const borderColor = cfg.persons_border_color || "rgba(255,255,255,0.3)";
    const borderColorAway = cfg.persons_border_color_away || "rgba(255,100,100,0.5)";
    const boxShadow = cfg.persons_box_shadow !== undefined ? cfg.persons_box_shadow : "0 2px 8px rgba(0, 0, 0, 0.4)";
    const grayscaleAway = cfg.persons_grayscale_away || false;
    const useEntityPicture = cfg.persons_use_entity_picture !== false;

    // Filter out away persons if hide_away is enabled
    let filteredPersons = [...cfg.persons_entities];
    if (hideAway) {
      filteredPersons = filteredPersons.filter(personConfig => {
        const entityId = typeof personConfig === 'string' ? personConfig : personConfig.entity;
        const entity = this.hass?.states[entityId];
        return entity && entity.state === "home";
      });
    }

    // Sort persons if dynamic ordering is enabled
    let sortedPersons = filteredPersons;
    if (dynamicOrder) {
      sortedPersons = [...filteredPersons].sort((a, b) => {
        const entityIdA = typeof a === 'string' ? a : a.entity;
        const entityIdB = typeof b === 'string' ? b : b.entity;
        const entityA = this.hass?.states[entityIdA];
        const entityB = this.hass?.states[entityIdB];
        
        if (!entityA || !entityB) return 0;
        
        const isHomeA = entityA.state === "home";
        const isHomeB = entityB.state === "home";
        
        // Home entities come first
        if (isHomeA && !isHomeB) return -1;
        if (!isHomeA && isHomeB) return 1;
        
        // Within same group, maintain original order
        return 0;
      });
    }

    // If no persons to show after filtering, return empty
    if (sortedPersons.length === 0) {
      return html``;
    }

    let containerStyle;
    if (personsAlign === "right") {
      containerStyle = `left:auto;right:${personsX}px;top:${personsY}px;`;
    } else if (personsAlign === "center") {
      containerStyle = `left:50%;top:${personsY}px;transform:translateX(-50%);`;
    } else {
      containerStyle = `left:${personsX}px;top:${personsY}px;`;
    }

    const totalPersons = sortedPersons.length;

    return html`
      <div class="persons-container" style="${containerStyle}">
        ${sortedPersons.map((personConfig, index) => {
          const entityId = typeof personConfig === 'string' ? personConfig : personConfig.entity;
          const entity = this.hass?.states[entityId];
          if (!entity) return html``;

          const entityPicture = entity.attributes?.entity_picture;
          const icon = entity.attributes?.icon || "mdi:account";
          
          // Debug: log personConfig structure
          if (typeof personConfig !== 'string' && personConfig.grayscale_entity) {
            console.log(`Person ${entityId} config:`, JSON.stringify(personConfig, null, 2));
          }
          
          // Get per-person grayscale entity if configured
          const grayscaleEntity = (typeof personConfig !== 'string' && personConfig.grayscale_entity) || "";
          
          // Determine "home" state - use grayscale_entity if configured, otherwise use person state
          let isHome;
          if (grayscaleEntity && this.hass?.states[grayscaleEntity]) {
            // Use the grayscale entity's state: "on"/"true"/true = home, anything else = away
            const grayscaleEntityState = this.hass.states[grayscaleEntity];
            const state = String(grayscaleEntityState.state).toLowerCase();
            isHome = state === "on" || state === "true" || state === "home";
            
            // Debug logging
            console.log(`Person ${entityId}: grayscale_entity=${grayscaleEntity}, state=${state}, isHome=${isHome}, grayscaleAway=${grayscaleAway}`);
          } else {
            // Use the person entity's state
            isHome = entity.state === "home";
            
            if (grayscaleEntity) {
              console.log(`Person ${entityId}: grayscale_entity=${grayscaleEntity} NOT FOUND in hass.states`);
            }
          }

          // Get per-person custom icons and pictures
          const customIconHome = (typeof personConfig !== 'string' && personConfig.icon_home) || "";
          const customIconAway = (typeof personConfig !== 'string' && personConfig.icon_away) || "";
          const customPictureHome = (typeof personConfig !== 'string' && personConfig.picture_home) || "";
          const customPictureAway = (typeof personConfig !== 'string' && personConfig.picture_away) || "";

          // Determine which icon or picture to use based on state
          let displayIcon = icon;
          let displayPicture = entityPicture;

          if (isHome) {
            // Home state: use custom home icon/picture if available
            if (customIconHome) displayIcon = customIconHome;
            if (customPictureHome) displayPicture = customPictureHome;
          } else {
            // Away state: use custom away icon/picture if available
            if (customIconAway) displayIcon = customIconAway;
            if (customPictureAway) displayPicture = customPictureAway;
          }

          // Get per-person actions (with fallback to defaults)
          const tapAction = personConfig.tap_action || { action: "more-info" };
          const holdAction = personConfig.hold_action || { action: "none" };
          const doubleTapAction = personConfig.double_tap_action || { action: "none" };

          // Person-level popup config (single popup per person, shared across all actions)
          const personPopupConfig = (() => {
            const pc = {};
            copyDefinedKeys({ src: personConfig, dst: pc, keys: HKI_POPUP_CONFIG_KEYS });
            return Object.keys(pc).length ? pc : null;
          })();

          // Use entity picture if available and enabled, otherwise use icon
          const showPicture = useEntityPicture && displayPicture;
          
          // Determine border color based on state
          const currentBorderColor = isHome ? borderColor : borderColorAway;
          
          // Calculate z-index based on stack order
          // ascending: later avatars on top (1, 2, 3, 4...)
          // descending: earlier avatars on top (4, 3, 2, 1...)
          const zIndex = stackOrder === "ascending" ? index + 1 : totalPersons - index;

          // Apply spacing as margin-left on all but first avatar
          const marginLeft = index > 0 ? `margin-left:${personsSpacing}px;` : "";

          // Avatar container style (no filter here - border should always have color)
          const avatarStyle = `width:${personsSize}px;height:${personsSize}px;border-width:${borderWidth}px;border-style:${borderStyle};border-radius:${borderRadius};border-color:${currentBorderColor};box-shadow:${boxShadow};z-index:${zIndex};${marginLeft}`;
          
          // Apply grayscale filter to image/icon only, not the container
          const contentFilter = (!isHome && grayscaleAway) ? "filter:grayscale(100%);" : "";

          // Hold state lives on the instance (keyed by entity) so it survives re-renders
          if (!this._slotHoldState) this._slotHoldState = {};
          if (!this._slotHoldState[entityId]) this._slotHoldState[entityId] = { holdTimer: null, holdActive: false, clickTimer: null, clickCount: 0, touchHandled: false };
          const state = this._slotHoldState[entityId];

          const startHold = (e) => {
            state.holdActive = false;
            // Always set timer so a long-press is recognized even when holdAction is "none"
            state.holdTimer = setTimeout(() => {
              state.holdActive = true;
              if (holdAction && holdAction.action !== "none") {
                this._handleAction(holdAction, entityId, personPopupConfig);
              }
            }, 500);
          };

          const endHold = (e) => {
            if (state.holdTimer) {
              clearTimeout(state.holdTimer);
              state.holdTimer = null;
            }
            if (!state.holdActive) {
              state.clickCount++;
              if (state.clickCount === 1) {
                state.clickTimer = setTimeout(() => {
                  if (state.clickCount === 1) {
                    this._handleAction(tapAction, entityId, personPopupConfig);
                  }
                  state.clickCount = 0;
                }, 250);
              } else if (state.clickCount === 2) {
                clearTimeout(state.clickTimer);
                state.clickCount = 0;
                this._handleAction(doubleTapAction, entityId, personPopupConfig);
              }
            }
            state.holdActive = false;
          };

          const cancelHold = () => {
            if (state.holdTimer) {
              clearTimeout(state.holdTimer);
              state.holdTimer = null;
            }
            state.holdActive = false;
          };

          const handleTouchStart = () => { state.touchHandled = true; startHold(); };
          const handleTouchEnd = () => { endHold(); setTimeout(() => { state.touchHandled = false; }, 500); };
          const handleMouseDown = () => { if (state.touchHandled) return; startHold(); };
          const handleMouseUp = () => { if (state.touchHandled) return; endHold(); };
          const handleMouseLeave = () => { if (!state.touchHandled) cancelHold(); };

          return html`
            <div 
              class="person-avatar" 
              style="${avatarStyle}"
              @mousedown=${handleMouseDown}
              @mouseup=${handleMouseUp}
              @mouseleave=${handleMouseLeave}
              @touchstart=${handleTouchStart}
              @touchend=${handleTouchEnd}
              @touchcancel=${cancelHold}
              @contextmenu=${(e) => e.preventDefault()}
            >
              ${showPicture 
                ? html`<img src="${displayPicture}" alt="${entity.attributes?.friendly_name || entityId}" style="${contentFilter}" />`
                : html`<ha-icon .icon="${displayIcon}" style="${contentFilter}"></ha-icon>`
              }
            </div>
          `;
        })}
      </div>
    `;
  }

  _renderInfoDisplay() {
    return html``;
  }

  render() {
    if (!this._config) return html``;

    const cfg = this._config;
    const editMode = this._isEditMode() || this._editMode;
    const effectiveFixed = !!cfg.fixed && !this._inPreview;

    const titleText = this._isTemplateString(cfg.title) ? (this._renderedTitle ?? "") : (cfg.title ?? "");
    const subtitleText = this._isTemplateString(cfg.subtitle) ? (this._renderedSubtitle ?? "") : (cfg.subtitle ?? "");
    const subtitleVisible = !!subtitleText.trim();

    // When not fixed (or in preview), allow the header to "bleed" wider left/right and add spacing top/bottom.
    // Left/Right: positive values make the card wider on that side.
    // Top/Bottom: margin spacing.
    const insetTop = toNum(cfg.inset_top, 0);
    const insetLeft = toNum(cfg.inset_left, 0);
    const insetRight = toNum(cfg.inset_right, 0);
    const insetBottom = toNum(cfg.inset_bottom, 0);

    const extraWidth = insetLeft + insetRight;
    const cardWidth = effectiveFixed
      ? "100vw"
      : (extraWidth !== 0 ? `calc(100% + ${extraWidth}px)` : "100%");

    const nonFixedBleedStyle = !effectiveFixed
      ? [
          insetTop ? `margin-top:${insetTop}px` : "",
          insetBottom ? `margin-bottom:${insetBottom}px` : "",
          (insetLeft || insetRight)
            ? `margin-left:${-insetLeft}px;margin-right:${-insetRight}px`
            : "",
        ].filter(Boolean).join(";")
      : "";
    
    // Background can be a CSS color, a gradient, or an image URL.
    // Colors must map to background-color (not background-image).
    const bgRaw = (cfg.background ?? "").toString();
    const bgTrim = bgRaw.trim();
    const isGradient = bgTrim.startsWith("linear-gradient(") || bgTrim.startsWith("radial-gradient(");
    const isUrl = bgTrim.startsWith("url(");
    const isPath = bgTrim.startsWith("/") || bgTrim.startsWith("./") || bgTrim.startsWith("../") ||
                   bgTrim.startsWith("http://") || bgTrim.startsWith("https://") ||
                   /\.(jpg|jpeg|png|gif|webp|svg|bmp)$/i.test(bgTrim);

    let bgImage = "";
    let bgColor = "";

    if (bgTrim) {
      if (isGradient || isUrl) bgImage = bgTrim;
      else if (isPath) bgImage = `url('${bgTrim}')`;
      else bgColor = bgTrim;
    }

    // Determine border-radius: split top/bottom > legacy > system default (when not fixed)
    const parseRadius = (v) => {
      if (v === undefined || v === null || v === "") return "";
      if (typeof v === "number" && Number.isFinite(v)) return `${v}px`;
      const s = String(v).trim();
      // If user enters a plain number (incl. negative/decimal), interpret as px.
      // Otherwise pass through as any valid CSS length/value.
      return /^-?\d+(?:\.\d+)?$/.test(s) ? `${s}px` : s;
    };

    let topRadius = parseRadius(cfg.card_border_radius_top);
    let bottomRadius = parseRadius(cfg.card_border_radius_bottom);

    // Back-compat: if neither split value is set, use legacy card_border_radius
    if (!topRadius && !bottomRadius) {
      const legacy = parseRadius(cfg.card_border_radius);
      topRadius = legacy;
      bottomRadius = legacy;
    }

    // If only one is provided, mirror it to the other for a sensible default
    if (topRadius && !bottomRadius) bottomRadius = topRadius;
    if (bottomRadius && !topRadius) topRadius = bottomRadius;

    // System default when not fixed and nothing is set
    if (!topRadius && !bottomRadius && !effectiveFixed) {
      topRadius = "var(--ha-card-border-radius, 12px)";
      bottomRadius = topRadius;
    }

    // CSS border-radius shorthand: tl tr br bl
    const borderRadius = (topRadius || bottomRadius)
      ? `${topRadius || "0"} ${topRadius || "0"} ${bottomRadius || "0"} ${bottomRadius || "0"}`
      : "";

    // Build border style - always explicit to override ha-card defaults
    let borderStyle = "";
    if (cfg.card_border_style && cfg.card_border_style !== "none" && cfg.card_border_width > 0) {
      // Custom border configured
      borderStyle = `border-style:${cfg.card_border_style};border-width:${cfg.card_border_width}px;border-color:${cfg.card_border_color || 'transparent'}`;
    } else {
      // No border - explicitly set to none to override ha-card defaults
      borderStyle = "border:none";
    }

    // Keep header height fixed in pixels so bars/slots do not shift on viewport height changes.
    const fixedHeaderHeight = clamp(+cfg.max_height, 60, 4000);

    const cardStyle = [
      `width:${cardWidth}`,
      (!effectiveFixed && nonFixedBleedStyle) ? nonFixedBleedStyle : "",
      `height:${fixedHeaderHeight}px`,
      `min-height:${fixedHeaderHeight}px`,
      `max-height:${fixedHeaderHeight}px`,
      (bgColor || cfg.background_color) ? `background-color:${bgColor || cfg.background_color}` : "",
      bgImage ? `background-image:${bgImage}` : "",
      cfg.background_position ? `background-position:${cfg.background_position}` : "",
      cfg.background_repeat ? `background-repeat:${cfg.background_repeat}` : "",
      cfg.background_size ? `background-size:${cfg.background_size}` : "",
      cfg.background_blend_mode ? `background-blend-mode:${cfg.background_blend_mode}` : "",
      borderRadius ? `border-radius:${borderRadius}` : "",
      cfg.card_box_shadow ? `box-shadow:${cfg.card_box_shadow}` : "box-shadow:none",
      borderStyle,
      // Only apply overflow:hidden when not fixed and no bottom bar slot has overflow enabled
      // (bottom bar overflow:visible needs the card to not clip its content)
      !effectiveFixed && !(cfg.bottom_bar_left_overflow || cfg.bottom_bar_center_overflow || cfg.bottom_bar_right_overflow) ? "overflow:hidden" : ""
    ].filter(Boolean).join(";");

    // Only show overlay gradient if blend is enabled
    const blendEnabled = cfg.blend_enabled !== false;
    const overlayStyle = blendEnabled 
      ? `background:linear-gradient(to bottom, transparent 0%, ${cfg.blend_color} ${cfg.blend_stop}%, ${cfg.blend_color} 100%);`
      : "display:none;";
    
    // Change: if not fixed, do not apply calculated offsets
    const contentStyle = effectiveFixed 
      ? `margin-left:${this._offsetLeft}px;width:${this._contentWidth}px;`
      : `width:100%;`;

    const fontFamily = this._resolveFontFamily();
    const fontStyle = cfg.font_style || "normal";
    const titleColor = cfg.title_color?.trim() || "var(--hki-header-text-color, #fff)";
    const subtitleColor = cfg.subtitle_color?.trim() || "var(--hki-header-text-color, #fff)";
    const titleInline = `font-family:${fontFamily};font-style:${fontStyle};font-size:${cfg.title_size_px}px;font-weight:${this._resolveWeight("title_weight")};color:${titleColor};`;
    const subtitleInline = `font-family:${fontFamily};font-style:${fontStyle};font-size:${cfg.subtitle_size_px}px;font-weight:${this._resolveWeight("subtitle_weight")};color:${subtitleColor};`;

    const subtitleOffsetX = (cfg.subtitle_offset_x || 0) - (cfg.title_offset_x || 0);
    const subtitleOffsetY = (cfg.subtitle_offset_y || 0) - (cfg.title_offset_y || 0);
    const subtitleTransform = `transform:translate(${subtitleOffsetX}px, ${subtitleOffsetY}px);`;

    let titleBlockStyle;
    if (cfg.text_align === "right") titleBlockStyle = `left:auto;right:${cfg.title_offset_x}px;top:${cfg.title_offset_y}px;text-align:right;align-items:flex-end;`;
    else if (cfg.text_align === "center") titleBlockStyle = `left:50%;top:${cfg.title_offset_y}px;transform:translateX(-50%);text-align:center;align-items:center;`;
    else titleBlockStyle = `left:${cfg.title_offset_x}px;top:${cfg.title_offset_y}px;text-align:left;align-items:flex-start;`;

    const topOffset = this._kioskMode ? (cfg.fixed_top || 0) : (cfg.fixed_top || 0) + 48;
    const wrapperStyle = effectiveFixed 
      ? `top:${topOffset}px;${borderRadius ? `border-radius:${borderRadius};` : ''}` 
      : "";

    const badgesOffset = cfg.badges_fixed ? (cfg.badges_offset_pinned || 48) : (cfg.badges_offset_unpinned || 100);
    let spacerH = effectiveFixed ? Math.max(0, (this._headerHeight || 0) - badgesOffset + topOffset) : 0;

    if (cfg.badges_fixed && effectiveFixed) {
      const kioskGapAdjustment = this._kioskMode ? 48 : 0;
      spacerH += (cfg.badges_gap || 0) + kioskGapAdjustment - 48;
    }

    if (editMode && cfg.fixed && !this._inPreview) {
      return html`
        <ha-card class="edit-placeholder">
          <div class="edit-placeholder-inner">
            <ha-icon icon="mdi:view-headline"></ha-icon>
            <div class="edit-placeholder-text">
              <div class="edit-placeholder-title">HKI Header Card</div>
              <div class="edit-placeholder-subtitle">Fixed-position header â€¢ This header will be hidden in edit mode for easier editing, when editing the header you'll see a preview of the header.</div>
            </div>
          </div>
        </ha-card>
      `;
    }

    const cardMarkup = html`
      <ha-card class="header" style=${cardStyle} aria-label=${titleText || "Header"}>
        <div class="overlay" style=${overlayStyle}></div>
        <div class="content" style=${contentStyle}>
          ${this._renderTopBar()}
          ${this._renderBottomBar()}
          <div class="title-block" style=${titleBlockStyle}>
            <div class="title" style=${titleInline} role="heading" aria-level="1">${titleText}</div>
            ${subtitleVisible ? html`<div class="subtitle" style="${subtitleInline}${subtitleTransform}">${subtitleText}</div>` : html``}
          </div>
          ${this._renderPersons()}
          ${this._renderInfoDisplay()}
        </div>
      </ha-card>
    `;

    if (!effectiveFixed) return cardMarkup;

    return html`
      <div class="header-fixed" style=${wrapperStyle}>${cardMarkup}</div>
      <div class="header-spacer" style="height:${spacerH}px;"></div>
    `;
  }

  static getConfigElement() {
    return document.createElement("hki-header-card-editor");
  }

  static getStubConfig() {
    return {
      ...DEFAULTS,
      title: "Welcome Home",
      subtitle: "Tuesday 19:45",
      font_family: "roboto",
    };
  }

  static getCardSize() {
    return 3;
  }
}

if (!customElements.get(CARD_NAME)) {
  customElements.define(CARD_NAME, HkiHeaderCard);
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EDITOR
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

class HkiHeaderCardEditor extends LitElement {
  static get properties() {
    return {
      hass: {},
      lovelace: {},
      _config: { attribute: false },
    };
  }

  // Pre-computed field sets for performance (avoid recreating on every change)
  static _numericFields = new Set([
    "height_vh", "min_height", "max_height", "blend_stop", "fixed_top",
    "inset_top", "inset_left", "inset_right", "inset_bottom",
    "title_offset_x", "title_offset_y", "subtitle_offset_x", "subtitle_offset_y",
    "title_size_px", "subtitle_size_px", "badges_offset_pinned", "badges_offset_unpinned",
    "badges_gap", "info_offset_x", "info_offset_y", "info_size_px",
    "mobile_breakpoint", "info_pill_padding_x", "info_pill_padding_y",
    "info_pill_radius", "info_pill_blur", "top_bar_offset_y", "top_bar_padding_x",
    "top_bar_left_offset_x", "top_bar_left_offset_y",
    "top_bar_center_offset_x", "top_bar_center_offset_y",
    "top_bar_right_offset_x", "top_bar_right_offset_y",
    "top_bar_left_size_px", "top_bar_center_size_px", "top_bar_right_size_px",
    "top_bar_left_pill_padding_x", "top_bar_left_pill_padding_y", "top_bar_left_pill_radius", "top_bar_left_pill_blur",
    "top_bar_center_pill_padding_x", "top_bar_center_pill_padding_y", "top_bar_center_pill_radius", "top_bar_center_pill_blur",
    "top_bar_right_pill_padding_x", "top_bar_right_pill_padding_y", "top_bar_right_pill_radius", "top_bar_right_pill_blur",
    "info_pill_border_width", "top_bar_left_pill_border_width", "top_bar_center_pill_border_width", "top_bar_right_pill_border_width",
    "card_border_width",
    "persons_offset_x", "persons_offset_y", "persons_size", "persons_spacing", "persons_border_width",
    "bottom_bar_offset_y", "bottom_bar_padding_x"
  ]);

  static _nullableNumericFields = new Set([
    "info_offset_x_mobile", "info_offset_y_mobile",
    "top_bar_left_offset_x_mobile", "top_bar_left_offset_y_mobile",
    "top_bar_center_offset_x_mobile", "top_bar_center_offset_y_mobile",
    "top_bar_right_offset_x_mobile", "top_bar_right_offset_y_mobile"
  ]);

  static _booleanFields = new Set([
    "fixed", "badges_fixed", "weather_show_icon", "weather_show_condition",
    "weather_show_temperature", "weather_show_humidity", "weather_show_wind",
    "weather_show_pressure", "weather_colored_icons", "info_pill",
    "datetime_show_time", "datetime_show_date", "datetime_show_day", "top_bar_enabled",
    "blend_enabled", "persons_enabled", "persons_use_entity_picture", "persons_grayscale_away", "persons_dynamic_order", "persons_hide_away",
    "bottom_bar_enabled",
    "top_bar_left_use_global", "top_bar_left_pill", "top_bar_left_overflow", "top_bar_left_show_icon", "top_bar_left_show_condition", "top_bar_left_show_temperature", "top_bar_left_show_humidity", "top_bar_left_show_wind", "top_bar_left_show_pressure", "top_bar_left_weather_colored_icons", "top_bar_left_show_day", "top_bar_left_show_date", "top_bar_left_show_time",
    "top_bar_center_use_global", "top_bar_center_pill", "top_bar_center_overflow", "top_bar_center_show_icon", "top_bar_center_show_condition", "top_bar_center_show_temperature", "top_bar_center_show_humidity", "top_bar_center_show_wind", "top_bar_center_show_pressure", "top_bar_center_weather_colored_icons", "top_bar_center_show_day", "top_bar_center_show_date", "top_bar_center_show_time",
    "top_bar_right_use_global", "top_bar_right_pill", "top_bar_right_overflow", "top_bar_right_show_icon", "top_bar_right_show_condition", "top_bar_right_show_temperature", "top_bar_right_show_humidity", "top_bar_right_show_wind", "top_bar_right_show_pressure", "top_bar_right_weather_colored_icons", "top_bar_right_show_day", "top_bar_right_show_date", "top_bar_right_show_time",
    "bottom_bar_left_use_global", "bottom_bar_left_pill", "bottom_bar_left_overflow", "bottom_bar_left_show_icon", "bottom_bar_left_show_condition", "bottom_bar_left_show_temperature", "bottom_bar_left_show_humidity", "bottom_bar_left_show_wind", "bottom_bar_left_show_pressure", "bottom_bar_left_weather_colored_icons", "bottom_bar_left_show_day", "bottom_bar_left_show_date", "bottom_bar_left_show_time",
    "bottom_bar_center_use_global", "bottom_bar_center_pill", "bottom_bar_center_overflow", "bottom_bar_center_show_icon", "bottom_bar_center_show_condition", "bottom_bar_center_show_temperature", "bottom_bar_center_show_humidity", "bottom_bar_center_show_wind", "bottom_bar_center_show_pressure", "bottom_bar_center_weather_colored_icons", "bottom_bar_center_show_day", "bottom_bar_center_show_date", "bottom_bar_center_show_time",
    "bottom_bar_right_use_global", "bottom_bar_right_pill", "bottom_bar_right_overflow", "bottom_bar_right_show_icon", "bottom_bar_right_show_condition", "bottom_bar_right_show_temperature", "bottom_bar_right_show_humidity", "bottom_bar_right_show_wind", "bottom_bar_right_show_pressure", "bottom_bar_right_weather_colored_icons", "bottom_bar_right_show_day", "bottom_bar_right_show_date", "bottom_bar_right_show_time"
  ]);

  constructor() {
    super();
    this._config = {}; // Will be populated by setConfig
    // Cache for domain selection when ha-service-picker isn't available
    this._paDomainCache = {};
  }

  _getLovelace() {
    if (this.lovelace) return this.lovelace;
    try {
      const root = document.querySelector('home-assistant')?.shadowRoot
        ?.querySelector('ha-panel-lovelace')?.shadowRoot
        ?.querySelector('hui-root');
      return root?.lovelace || root?.__lovelace || null;
    } catch (e) { return null; }
  }

  _renderNavigationPathPicker(label, value, onChange) {
    const val = value || "";
    if (customElements.get("ha-navigation-picker")) {
      return html`
        <ha-navigation-picker
          .hass=${this.hass}
          .label=${label}
          .value=${val}
          @value-changed=${(e) => onChange(e.detail?.value ?? "")}
        ></ha-navigation-picker>
      `;
    }
    if (customElements.get("ha-selector")) {
      return html`
        <ha-selector
          .hass=${this.hass}
          .label=${label}
          .selector=${{ navigation: {} }}
          .value=${val}
          @value-changed=${(e) => onChange(e.detail?.value ?? "")}
        ></ha-selector>
      `;
    }
    return html`
      <ha-textfield
        .label=${label}
        .value=${val}
        placeholder="/lovelace/0"
        @change=${(e) => onChange(e.target.value)}
      ></ha-textfield>
    `;
  }

  setConfig(config) {
    // Ensure we have a valid config object  
    if (!config || typeof config !== 'object') {
      config = { type: "custom:hki-header-card" };
    }
    
    // Ensure type field exists
    if (!config.type) {
      config = { ...config, type: "custom:hki-header-card" };
    }
    
    // Detect format and convert if needed
    let workingConfig = config;
    
    // If config uses old flat format, migrate to nested first
    if (isOldFormat(config)) {
      const nested = migrateToNestedFormat(config);
      workingConfig = flattenNestedFormat(nested); // Flatten back for internal use
    } else if (
      // Detect nested format by checking for any nested objects
      (config.top_bar_left && typeof config.top_bar_left === 'object') ||
      (config.top_bar_center && typeof config.top_bar_center === 'object') ||
      (config.top_bar_right && typeof config.top_bar_right === 'object') ||
      (config.top_bar && typeof config.top_bar === 'object') ||
      (config.info && typeof config.info === 'object') ||
      (config.persons && typeof config.persons === 'object')
    ) {
      // New nested format - flatten for internal use
      workingConfig = flattenNestedFormat(config);
    }
    
    // Merge with defaults - this ensures all fields have values
    this._config = { ...DEFAULTS, ...workingConfig };
    this.requestUpdate();
  }

  _cleanupActionConfig(action) {
    if (!action || typeof action !== 'object') return action;
    
    const actionType = action.action || "none";
    const cleaned = { action: actionType };
    
    // Only keep fields relevant to the action type
    switch (actionType) {
      case "navigate":
        if (action.navigation_path) cleaned.navigation_path = action.navigation_path;
        break;
      case "url":
        if (action.url_path) cleaned.url_path = action.url_path;
        break;
      case "more-info":
      case "toggle":
        if (action.entity) cleaned.entity = action.entity;
        break;
      case "perform-action":
        if (action.perform_action) cleaned.perform_action = action.perform_action;
        if (action.data) cleaned.data = action.data;
        if (action.target) cleaned.target = action.target;
        break;
      case "hki-more-info":
        if (action.entity) cleaned.entity = action.entity;
        if (action.custom_popup_card !== undefined) cleaned.custom_popup_card = action.custom_popup_card;
        if (action.popup_name) cleaned.popup_name = action.popup_name;
        if (action.popup_state) cleaned.popup_state = action.popup_state;
        copyDefinedKeys({
          src: action,
          dst: cleaned,
          keys: HKI_POPUP_CONFIG_KEYS.filter((k) => !["custom_popup_enabled", "custom_popup_card", "popup_name", "popup_state"].includes(k)),
        });
        break;
      case "fire-dom-event":
        // Preserve all properties for fire-dom-event (browser_mod integration)
        Object.keys(action).forEach(key => {
          if (key !== 'action') {
            cleaned[key] = action[key];
          }
        });
        break;
      case "call-service":
        // Legacy support
        if (action.service) cleaned.service = action.service;
        if (action.service_data) cleaned.service_data = action.service_data;
        break;
    }
    
    return cleaned;
  }

  _stripDefaults(config) {
    // Create a clean config object with essential fields always present
    const stripped = { type: config.type };
    // Only write title/subtitle when they differ from defaults (avoids noise in YAML)
    if (config.title && config.title !== "Header") stripped.title = config.title;
    if (config.subtitle) stripped.subtitle = config.subtitle;
    
    // Always include these essential fields even if they match defaults
    // This ensures Home Assistant recognizes this as a valid header card
    const alwaysInclude = [
      'height_vh', 'min_height', 'max_height', 'background',
      'persons_enabled',
      'top_bar_enabled'
    ];
    
    alwaysInclude.forEach(key => {
      if (config[key] !== undefined) {
        stripped[key] = config[key];
      }
    });
    
    // List of deprecated config keys to remove
    const deprecatedKeys = [
      'persons_gap',           // Replaced by persons_spacing
      'persons_overlap',       // Replaced by persons_spacing
      'persons_tap_action',    // Now per-person in persons_entities
      'persons_hold_action',   // Now per-person in persons_entities
      'persons_double_tap_action' // Now per-person in persons_entities
    ];
    
    for (const [key, value] of Object.entries(config)) {
      if (key === 'type' || key === 'title' || key === 'subtitle') continue; // Already added
      if (alwaysInclude.includes(key)) continue; // Already added
      
      // Skip deprecated keys
      if (deprecatedKeys.includes(key)) continue;
      if (/^(top_bar|bottom_bar)_(left|center|right)_(card_color|icon_color|label_color)$/.test(key)) continue;
      
      const defaultValue = DEFAULTS[key];
      
      // Skip if value matches default
      if (defaultValue === value) continue;
      
      // Special handling for persons_entities array
      if (key === 'persons_entities' && Array.isArray(value)) {
        const cleanedPersons = value.map(person => {
          if (typeof person === 'string') return person;
          if (typeof person !== 'object' || !person) return null;
          
          const cleanedPerson = {
            entity: person.entity || ""
          };
          
          // Preserve grayscale_entity if present
          if (person.grayscale_entity) {
            cleanedPerson.grayscale_entity = person.grayscale_entity;
          }
          
          // Preserve custom icon and picture properties if present
          if (person.icon_home) {
            cleanedPerson.icon_home = person.icon_home;
          }
          if (person.icon_away) {
            cleanedPerson.icon_away = person.icon_away;
          }
          if (person.picture_home) {
            cleanedPerson.picture_home = person.picture_home;
          }
          if (person.picture_away) {
            cleanedPerson.picture_away = person.picture_away;
          }
          
          // Preserve ALL popup settings on the person object
          copyDefinedKeys({ src: person, dst: cleanedPerson, keys: HKI_POPUP_CONFIG_KEYS });

          // Clean up actions for each person
          if (person.tap_action) {
            cleanedPerson.tap_action = this._cleanupActionConfig(person.tap_action);
          }
          if (person.hold_action) {
            cleanedPerson.hold_action = this._cleanupActionConfig(person.hold_action);
          }
          if (person.double_tap_action) {
            cleanedPerson.double_tap_action = this._cleanupActionConfig(person.double_tap_action);
          }
          
          return cleanedPerson;
        }).filter(Boolean);
        
        // Always include persons_entities, even if empty, when persons are enabled
        if (cleanedPersons.length > 0 || config.persons_enabled) {
          stripped[key] = cleanedPersons;
        }
        continue;
      }
      
      // Clean up action configs (tap_action, hold_action, double_tap_action for slots)
      if (key.endsWith('_tap_action') || key.endsWith('_hold_action') || key.endsWith('_double_tap_action')) {
        if (typeof value === 'object' && value !== null) {
          const cleaned = this._cleanupActionConfig(value);
          const defaultAction = DEFAULTS[key] || { action: "none" };
          if (JSON.stringify(cleaned) !== JSON.stringify(defaultAction)) {
            stripped[key] = cleaned;
          }
        }
        continue;
      }

      // Clean up slot button arrays
      if (key.endsWith('_buttons') && Array.isArray(value)) {
        const cleanedButtons = value.map((btn) => cleanupSlotButton(btn)).filter(Boolean);
        if (cleanedButtons.length > 0) stripped[key] = cleanedButtons;
        continue;
      }
      
      // Handle deep equality for objects
      if (typeof value === 'object' && value !== null && typeof defaultValue === 'object' && defaultValue !== null) {
        if (JSON.stringify(value) === JSON.stringify(defaultValue)) continue;
      }
      
      // Keep the value if it's different from default
      stripped[key] = value;
    }
    
    // Convert stripped flat config to nested format for output
    return this._convertToNestedOutput(stripped);
  }

  _convertToNestedOutput(flat) {
    const nested = { type: flat.type };
    
    // Simple top-level properties stay as-is
    const simpleProps = [
      'title', 'subtitle', 'text_align', 'title_color', 'subtitle_color',
      'background', 'background_color', 'background_position', 'background_repeat',
      'background_size', 'background_blend_mode', 'height_vh', 'min_height', 'max_height',
      'grid_options', 'visibility',
      'blend_color', 'blend_stop', 'blend_enabled',
      'card_border_radius', 'card_border_radius_top', 'card_border_radius_bottom',
      'card_box_shadow', 'card_border_style', 'card_border_width', 'card_border_color',
      'fixed', 'fixed_top', 'inset_top', 'inset_left', 'inset_right', 'inset_bottom',
      'title_offset_x', 'title_offset_y', 'subtitle_offset_x', 'subtitle_offset_y',
      'badges_offset_pinned', 'badges_offset_unpinned', 'badges_gap', 'badges_fixed',
      'font_family', 'font_family_custom', 'font_style', 'title_size_px', 'subtitle_size_px',
      'title_weight', 'subtitle_weight', 'mobile_breakpoint'
    ];
    
    simpleProps.forEach(prop => {
      if (flat[prop] !== undefined) {
        nested[prop] = flat[prop];
      }
    });
    
    // Nest top_bar if any settings exist
    const hasTopBarConfig = flat.top_bar_enabled !== undefined || flat.top_bar_offset_y !== undefined || flat.top_bar_padding_x !== undefined;
    if (hasTopBarConfig) {
      nested.top_bar = {};
      if (flat.top_bar_enabled !== undefined) nested.top_bar.enabled = flat.top_bar_enabled;
      if (flat.top_bar_offset_y !== undefined) nested.top_bar.offset_y = flat.top_bar_offset_y;
      if (flat.top_bar_padding_x !== undefined) nested.top_bar.padding_x = flat.top_bar_padding_x;
    }

    // Nest bottom_bar if any settings exist
    const hasBottomBarConfig = flat.bottom_bar_enabled !== undefined || flat.bottom_bar_offset_y !== undefined || flat.bottom_bar_padding_x !== undefined;
    if (hasBottomBarConfig) {
      nested.bottom_bar = nested.bottom_bar || {};
      if (flat.bottom_bar_enabled !== undefined) nested.bottom_bar.enabled = flat.bottom_bar_enabled;
      if (flat.bottom_bar_offset_y !== undefined) nested.bottom_bar.offset_y = flat.bottom_bar_offset_y;
      if (flat.bottom_bar_padding_x !== undefined) nested.bottom_bar.padding_x = flat.bottom_bar_padding_x;
    }
    
    // Nest info if any settings exist
    const infoKeys = ['info_size_px', 'info_weight', 'info_color', 'info_text_shadow', 'info_icon_shadow', 'info_pill', 'info_pill_background',
                      'info_pill_padding_x', 'info_pill_padding_y', 'info_pill_radius', 'info_pill_blur',
                      'info_pill_border_style', 'info_pill_border_width', 'info_pill_border_color'];
    const hasInfoConfig = infoKeys.some(k => flat[k] !== undefined);
    if (hasInfoConfig) {
      nested.info = {};
      if (flat.info_size_px !== undefined) nested.info.size_px = flat.info_size_px;
      if (flat.info_weight !== undefined) nested.info.weight = flat.info_weight;
      if (flat.info_color !== undefined) nested.info.color = flat.info_color;
      if (flat.info_text_shadow !== undefined) nested.info.text_shadow = flat.info_text_shadow;
      if (flat.info_icon_shadow !== undefined) nested.info.icon_shadow = flat.info_icon_shadow;
      if (flat.info_pill !== undefined) nested.info.pill = flat.info_pill;
      if (flat.info_pill_background !== undefined) nested.info.pill_background = flat.info_pill_background;
      if (flat.info_pill_padding_x !== undefined) nested.info.pill_padding_x = flat.info_pill_padding_x;
      if (flat.info_pill_padding_y !== undefined) nested.info.pill_padding_y = flat.info_pill_padding_y;
      if (flat.info_pill_radius !== undefined) nested.info.pill_radius = flat.info_pill_radius;
      if (flat.info_pill_blur !== undefined) nested.info.pill_blur = flat.info_pill_blur;
      if (flat.info_pill_border_style !== undefined) nested.info.pill_border_style = flat.info_pill_border_style;
      if (flat.info_pill_border_width !== undefined) nested.info.pill_border_width = flat.info_pill_border_width;
      if (flat.info_pill_border_color !== undefined) nested.info.pill_border_color = flat.info_pill_border_color;
    }

    // Nest bottom_info if any settings exist
    const bottomInfoKeys = ['bottom_info_size_px', 'bottom_info_weight', 'bottom_info_color', 'bottom_info_text_shadow', 'bottom_info_icon_shadow', 'bottom_info_pill', 'bottom_info_pill_background',
                      'bottom_info_pill_padding_x', 'bottom_info_pill_padding_y', 'bottom_info_pill_radius', 'bottom_info_pill_blur',
                      'bottom_info_pill_border_style', 'bottom_info_pill_border_width', 'bottom_info_pill_border_color'];
    const hasBottomInfoConfig = bottomInfoKeys.some(k => flat[k] !== undefined);
    if (hasBottomInfoConfig) {
      nested.bottom_info = {};
      if (flat.bottom_info_size_px !== undefined) nested.bottom_info.size_px = flat.bottom_info_size_px;
      if (flat.bottom_info_weight !== undefined) nested.bottom_info.weight = flat.bottom_info_weight;
      if (flat.bottom_info_color !== undefined) nested.bottom_info.color = flat.bottom_info_color;
      if (flat.bottom_info_text_shadow !== undefined) nested.bottom_info.text_shadow = flat.bottom_info_text_shadow;
      if (flat.bottom_info_icon_shadow !== undefined) nested.bottom_info.icon_shadow = flat.bottom_info_icon_shadow;
      if (flat.bottom_info_pill !== undefined) nested.bottom_info.pill = flat.bottom_info_pill;
      if (flat.bottom_info_pill_background !== undefined) nested.bottom_info.pill_background = flat.bottom_info_pill_background;
      if (flat.bottom_info_pill_padding_x !== undefined) nested.bottom_info.pill_padding_x = flat.bottom_info_pill_padding_x;
      if (flat.bottom_info_pill_padding_y !== undefined) nested.bottom_info.pill_padding_y = flat.bottom_info_pill_padding_y;
      if (flat.bottom_info_pill_radius !== undefined) nested.bottom_info.pill_radius = flat.bottom_info_pill_radius;
      if (flat.bottom_info_pill_blur !== undefined) nested.bottom_info.pill_blur = flat.bottom_info_pill_blur;
      if (flat.bottom_info_pill_border_style !== undefined) nested.bottom_info.pill_border_style = flat.bottom_info_pill_border_style;
      if (flat.bottom_info_pill_border_width !== undefined) nested.bottom_info.pill_border_width = flat.bottom_info_pill_border_width;
      if (flat.bottom_info_pill_border_color !== undefined) nested.bottom_info.pill_border_color = flat.bottom_info_pill_border_color;
    }
    
    // Nest slots when they are explicitly configured
    ['top_bar', 'bottom_bar'].forEach(bar => {
    ['left', 'center', 'right'].forEach(slot => {
      const prefix = `${bar}_${slot}_`;
      const slotType = flat[`${bar}_${slot}`];
      const hasAnySlotField = Object.keys(flat).some((k) => k.startsWith(prefix));
      
      // Skip untouched slots entirely so we don't write unused keys.
      if (slotType === undefined && !hasAnySlotField) return;

      if (!slotType || slotType === "none") {
        nested[`${bar}_${slot}`] = { type: "none" };
        return;
      }
      
      const slotConfig = { type: slotType };
      
      // Common properties
      if (flat[prefix + "offset_x"] !== undefined) slotConfig.offset_x = flat[prefix + "offset_x"];
      if (flat[prefix + "offset_y"] !== undefined) slotConfig.offset_y = flat[prefix + "offset_y"];
      if (flat[prefix + "offset_x_mobile"] !== undefined) slotConfig.offset_x_mobile = flat[prefix + "offset_x_mobile"];
      if (flat[prefix + "offset_y_mobile"] !== undefined) slotConfig.offset_y_mobile = flat[prefix + "offset_y_mobile"];
      if (flat[prefix + "overflow"] !== undefined) slotConfig.overflow = flat[prefix + "overflow"];
      if (flat[prefix + "align"] !== undefined) slotConfig.align = flat[prefix + "align"];
      
      // Styling (only if not using global)
      if (flat[prefix + "use_global"] === false) {
        slotConfig.styling = {};
        const stylingKeys = ['size_px', 'weight', 'color', 'text_shadow', 'icon_shadow', 'pill', 'pill_background', 'pill_padding_x',
                            'pill_padding_y', 'pill_radius', 'pill_blur', 'pill_border_style',
                            'pill_border_width', 'pill_border_color'];
        stylingKeys.forEach(key => {
          if (flat[prefix + key] !== undefined) {
            slotConfig.styling[key] = flat[prefix + key];
          }
        });
      }
      
      // Type-specific config
      if (slotType === "weather") {
        const weatherKeys = {
          weather_entity: 'entity',
          show_icon: 'show_icon',
          show_condition: 'show_condition',
          show_temperature: 'show_temperature',
          show_humidity: 'show_humidity',
          show_wind: 'show_wind',
          show_pressure: 'show_pressure',
          weather_colored_icons: 'colored_icons',
          weather_icon_color_mode: 'icon_color_mode',
          weather_icon_color: 'icon_color',
          animate_icon: 'animate_icon',
          icon_pack_path: 'icon_pack_path'
        };
        
        const hasWeatherConfig = Object.keys(weatherKeys).some(k => flat[prefix + k] !== undefined);
        if (hasWeatherConfig) {
          slotConfig.weather = {};
          Object.entries(weatherKeys).forEach(([flatKey, nestedKey]) => {
            if (flat[prefix + flatKey] !== undefined) {
              slotConfig.weather[nestedKey] = flat[prefix + flatKey];
            }
          });
        }
      } else if (slotType === "datetime") {
        const dtKeys = ['show_day', 'show_date', 'show_time', 'time_format', 'date_format', 'separator', 'icon', 'animate_icon'];
        const hasDateTimeConfig = dtKeys.some(k => flat[prefix + k] !== undefined);
        if (hasDateTimeConfig) {
          slotConfig.datetime = {};
          dtKeys.forEach(key => {
            if (flat[prefix + key] !== undefined) {
              slotConfig.datetime[key] = flat[prefix + key];
            }
          });
        }
      } else if (slotType === "button") {
        const buttonKeys = [
          "icon", "icon_animation", "name", "state", "entity",
          "card_color", "icon_color", "name_color", "state_color", "text_shadow", "icon_shadow",
          "name_offset_x", "name_offset_y", "state_offset_x", "state_offset_y",
          "visibility_mode", "visibility_entity", "visibility_state", "visibility_attribute", "visibility_attribute_value",
          "show_badge", "badge_source", "badge_entity", "badge_template",
          "badge_color", "badge_text_color",
          "text_color", "button_border_radius", "button_box_shadow", "button_border_style", "button_border_width", "button_border_color",
          "badge_border_radius", "badge_box_shadow", "badge_border_style", "badge_border_width", "badge_border_color",
          "badge_font_size", "badge_font_weight", "badge_font_family", "badge_font_custom",
          "show_icon", "show_name", "show_state",
          "buttons",
        ];
        const hasButtonConfig = buttonKeys.some((k) => flat[prefix + k] !== undefined);
        if (hasButtonConfig) {
          slotConfig.button = {};
          if (flat[prefix + "icon"] !== undefined) slotConfig.button.icon = flat[prefix + "icon"];
          if (flat[prefix + "icon_animation"] !== undefined) slotConfig.button.icon_animation = flat[prefix + "icon_animation"];
          if (flat[prefix + "name"] !== undefined) slotConfig.button.name = flat[prefix + "name"];
          if (flat[prefix + "state"] !== undefined) slotConfig.button.state = flat[prefix + "state"];
          if (flat[prefix + "entity"] !== undefined) slotConfig.button.entity = flat[prefix + "entity"];
          if (flat[prefix + "card_color"] !== undefined) slotConfig.button.card_color = flat[prefix + "card_color"];
          if (flat[prefix + "icon_color"] !== undefined) slotConfig.button.icon_color = flat[prefix + "icon_color"];
          if (flat[prefix + "name_color"] !== undefined) slotConfig.button.name_color = flat[prefix + "name_color"];
          if (flat[prefix + "state_color"] !== undefined) slotConfig.button.state_color = flat[prefix + "state_color"];
          if (flat[prefix + "text_shadow"] !== undefined) slotConfig.button.text_shadow = flat[prefix + "text_shadow"];
          if (flat[prefix + "icon_shadow"] !== undefined) slotConfig.button.icon_shadow = flat[prefix + "icon_shadow"];
          if (flat[prefix + "name_offset_x"] !== undefined) slotConfig.button.name_offset_x = flat[prefix + "name_offset_x"];
          if (flat[prefix + "name_offset_y"] !== undefined) slotConfig.button.name_offset_y = flat[prefix + "name_offset_y"];
          if (flat[prefix + "state_offset_x"] !== undefined) slotConfig.button.state_offset_x = flat[prefix + "state_offset_x"];
          if (flat[prefix + "state_offset_y"] !== undefined) slotConfig.button.state_offset_y = flat[prefix + "state_offset_y"];
          if (flat[prefix + "visibility_mode"] !== undefined) slotConfig.button.visibility_mode = flat[prefix + "visibility_mode"];
          if (flat[prefix + "visibility_entity"] !== undefined) slotConfig.button.visibility_entity = flat[prefix + "visibility_entity"];
          if (flat[prefix + "visibility_state"] !== undefined) slotConfig.button.visibility_state = flat[prefix + "visibility_state"];
          if (flat[prefix + "visibility_attribute"] !== undefined) slotConfig.button.visibility_attribute = flat[prefix + "visibility_attribute"];
          if (flat[prefix + "visibility_attribute_value"] !== undefined) slotConfig.button.visibility_attribute_value = flat[prefix + "visibility_attribute_value"];
          if (flat[prefix + "show_badge"] !== undefined) slotConfig.button.show_badge = flat[prefix + "show_badge"];
          if (flat[prefix + "badge_source"] !== undefined) slotConfig.button.badge_source = flat[prefix + "badge_source"];
          if (flat[prefix + "badge_entity"] !== undefined) slotConfig.button.badge_entity = flat[prefix + "badge_entity"];
          if (flat[prefix + "badge_template"] !== undefined) slotConfig.button.badge_template = flat[prefix + "badge_template"];
          if (flat[prefix + "badge_color"] !== undefined) slotConfig.button.badge_color = flat[prefix + "badge_color"];
          if (flat[prefix + "badge_text_color"] !== undefined) slotConfig.button.badge_text_color = flat[prefix + "badge_text_color"];
          if (flat[prefix + "text_color"] !== undefined) slotConfig.button.text_color = flat[prefix + "text_color"];
          if (flat[prefix + "button_border_radius"] !== undefined) slotConfig.button.button_border_radius = flat[prefix + "button_border_radius"];
          if (flat[prefix + "button_box_shadow"] !== undefined) slotConfig.button.button_box_shadow = flat[prefix + "button_box_shadow"];
          if (flat[prefix + "button_border_style"] !== undefined) slotConfig.button.button_border_style = flat[prefix + "button_border_style"];
          if (flat[prefix + "button_border_width"] !== undefined) slotConfig.button.button_border_width = flat[prefix + "button_border_width"];
          if (flat[prefix + "button_border_color"] !== undefined) slotConfig.button.button_border_color = flat[prefix + "button_border_color"];
          if (flat[prefix + "badge_border_radius"] !== undefined) slotConfig.button.badge_border_radius = flat[prefix + "badge_border_radius"];
          if (flat[prefix + "badge_box_shadow"] !== undefined) slotConfig.button.badge_box_shadow = flat[prefix + "badge_box_shadow"];
          if (flat[prefix + "badge_border_style"] !== undefined) slotConfig.button.badge_border_style = flat[prefix + "badge_border_style"];
          if (flat[prefix + "badge_border_width"] !== undefined) slotConfig.button.badge_border_width = flat[prefix + "badge_border_width"];
          if (flat[prefix + "badge_border_color"] !== undefined) slotConfig.button.badge_border_color = flat[prefix + "badge_border_color"];
          if (flat[prefix + "badge_font_size"] !== undefined) slotConfig.button.badge_font_size = flat[prefix + "badge_font_size"];
          if (flat[prefix + "badge_font_weight"] !== undefined) slotConfig.button.badge_font_weight = flat[prefix + "badge_font_weight"];
          if (flat[prefix + "badge_font_family"] !== undefined) slotConfig.button.badge_font_family = flat[prefix + "badge_font_family"];
          if (flat[prefix + "badge_font_custom"] !== undefined) slotConfig.button.badge_font_custom = flat[prefix + "badge_font_custom"];
          if (flat[prefix + "show_icon"] !== undefined) slotConfig.button.show_icon = flat[prefix + "show_icon"];
          if (flat[prefix + "show_name"] !== undefined) slotConfig.button.show_name = flat[prefix + "show_name"];
          if (flat[prefix + "show_state"] !== undefined) slotConfig.button.show_state = flat[prefix + "show_state"];
          if (Array.isArray(flat[prefix + "buttons"])) {
            slotConfig.button.buttons = flat[prefix + "buttons"].map((b) => cleanupSlotButton(b)).filter(Boolean).map((b) => {
              const out = { ...b };
              const style = {};
              SLOT_BUTTON_STYLE_FIELDS.forEach((k) => {
                if (out[k] !== undefined) {
                  style[k] = out[k];
                  delete out[k];
                }
              });
              if (Object.keys(style).length) out.style = style;
              return out;
            });
          }
        }
      } else if (slotType === "notifications" || slotType === "custom" || slotType === "card") {
        if (flat[prefix + "card"] !== undefined) {
          slotConfig.custom = { card: flat[prefix + "card"] };
        }
      }
      
      // Actions
      const hasActions = flat[prefix + "tap_action"] || flat[prefix + "hold_action"] || flat[prefix + "double_tap_action"];
      if (hasActions) {
        slotConfig.actions = {};
        if (flat[prefix + "tap_action"]) slotConfig.actions.tap_action = flat[prefix + "tap_action"];
        if (flat[prefix + "hold_action"]) slotConfig.actions.hold_action = flat[prefix + "hold_action"];
        if (flat[prefix + "double_tap_action"]) slotConfig.actions.double_tap_action = flat[prefix + "double_tap_action"];
      }
      

      // HKI Popup config
      const _slotPopupConfig = {};
      copyDefinedKeys({
        src: flat,
        dst: _slotPopupConfig,
        keys: HKI_POPUP_CONFIG_KEYS,
        srcPrefix: prefix,
      });
      if (Object.keys(_slotPopupConfig).length) slotConfig.hki_popup = _slotPopupConfig;
      if (slotConfig.hki_popup) {
        const nestedPopup = {};
        Object.entries(slotConfig.hki_popup).forEach(([k, v]) => {
          if (v !== undefined) nestedPopup[popupFlatKeyToNestedKey(k)] = v;
        });
        slotConfig.hki_popup = nestedPopup;
      }

      nested[`${bar}_${slot}`] = slotConfig;
    });
    }); // end bar loop
    
    // Nest persons
    const personsKeys = ['persons_enabled', 'persons_align', 'persons_offset_x', 'persons_offset_y',
                         'persons_size', 'persons_spacing', 'persons_stack_order', 'persons_dynamic_order',
                         'persons_hide_away', 'persons_use_entity_picture', 'persons_border_width', 'persons_border_style',
                         'persons_border_radius', 'persons_border_color', 'persons_border_color_away', 'persons_box_shadow',
                         'persons_grayscale_away', 'persons_entities'];
    const hasPersonsConfig = personsKeys.some(k => flat[k] !== undefined);
    if (hasPersonsConfig) {
      nested.persons = {};
      if (flat.persons_enabled !== undefined) nested.persons.enabled = flat.persons_enabled;
      if (flat.persons_align !== undefined) nested.persons.align = flat.persons_align;
      if (flat.persons_offset_x !== undefined) nested.persons.offset_x = flat.persons_offset_x;
      if (flat.persons_offset_y !== undefined) nested.persons.offset_y = flat.persons_offset_y;
      if (flat.persons_size !== undefined) nested.persons.size = flat.persons_size;
      if (flat.persons_spacing !== undefined) nested.persons.spacing = flat.persons_spacing;
      if (flat.persons_stack_order !== undefined) nested.persons.stack_order = flat.persons_stack_order;
      if (flat.persons_dynamic_order !== undefined) nested.persons.dynamic_order = flat.persons_dynamic_order;
      if (flat.persons_hide_away !== undefined) nested.persons.hide_away = flat.persons_hide_away;
      if (flat.persons_use_entity_picture !== undefined) nested.persons.use_entity_picture = flat.persons_use_entity_picture;
      if (flat.persons_border_width !== undefined) nested.persons.border_width = flat.persons_border_width;
      if (flat.persons_border_style !== undefined) nested.persons.border_style = flat.persons_border_style;
      if (flat.persons_border_radius !== undefined) nested.persons.border_radius = flat.persons_border_radius;
      if (flat.persons_border_color !== undefined) nested.persons.border_color = flat.persons_border_color;
      if (flat.persons_border_color_away !== undefined) nested.persons.border_color_away = flat.persons_border_color_away;
      if (flat.persons_box_shadow !== undefined) nested.persons.box_shadow = flat.persons_box_shadow;
      if (flat.persons_grayscale_away !== undefined) nested.persons.grayscale_away = flat.persons_grayscale_away;
      if (flat.persons_entities) {
        nested.persons.entities = flat.persons_entities.map((person) => {
          if (!person || typeof person !== "object") return person;
          const out = { ...person };
          const popup = {};
          PERSON_POPUP_FLAT_KEYS.forEach((k) => {
            if (out[k] === undefined) return;
            const v = out[k];
            popup[popupFlatKeyToNestedKey(k)] = v;
            delete out[k];
          });
          if (Object.keys(popup).length) out.popup = popup;
          return out;
        });
      }
    }
    
    return nested;
  }

  _renderEntityPicker(label, field, value, helper = "", domain = null) {
    return html`
      <ha-selector
        .hass=${this.hass}
        .selector=${{ entity: { domain } }}
        .value=${value || ""}
        .label=${label}
        .helper=${helper}
        @value-changed=${(ev) => this._changed(ev, field)}
      ></ha-selector>
    `;
  }

  _renderNavigationPicker(label, field, value, helper = "") {
    return html`
      <ha-selector
        .hass=${this.hass}
        .selector=${{ navigation: {} }}
        .value=${value || ""}
        .label=${label}
        .helper=${helper}
        @value-changed=${(ev) => this._changed(ev, field)}
      ></ha-selector>
    `;
  }

  _renderIconPicker(label, field, value, helper = "") {
    return html`
      <ha-selector
        .hass=${this.hass}
        .selector=${{ icon: {} }}
        .value=${value || ""}
        .label=${label}
        .helper=${helper}
        @value-changed=${(ev) => this._changed(ev, field)}
      ></ha-selector>
    `;
  }

  _val(ev) {
    return ev.detail?.value ?? ev.target?.value;
  }

  _handleCustomCardChange(ev, slot, bar = "top_bar") {
    ev.stopPropagation();
    if (!this._config) return;
    const newCardConfig = ev.detail.config;
    const field = `${bar}_${slot}_card`;
    this._config = { ...this._config, [field]: newCardConfig };
    const strippedConfig = this._stripDefaults(this._config);
    this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
  }

  _handleBgSizeSelect(ev) {
    ev.stopPropagation();
    // Use proper value extraction like other handlers - check detail.value first, then target.value
    const val = ev.detail?.value ?? ev.target?.value;
    if (!val) return;
    
    // If selecting "custom", we need to ensure the config has a valid value to start with if it was currently a preset.
    // If it was already custom (e.g. 150%), we keep it. 
    // If switching from "cover" to "custom", we default to "100%" or similar to prep the input.
    if (val === "custom") {
       const current = this._config.background_size || "cover";
       if (BG_SIZE_PRESETS.includes(current)) {
           // Reset to a safe custom default so input is not empty/confusing
           this._config = { ...this._config, background_size: "100%" };
           const strippedConfig = this._stripDefaults(this._config);
           this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
       }
       // Force re-render to show the custom input field
       this.requestUpdate();
    } else {
       // Selected a preset
       this._config = { ...this._config, background_size: val };
       const strippedConfig = this._stripDefaults(this._config);
       this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
    }
  }

  _changed(ev, explicitField = null) {
    ev.stopPropagation();
    const field = explicitField || ev.target?.dataset?.field;
    if (!field || !this._config) return;

    let value = this._val(ev);

    // Special handling for persons_entities array field
    if (field === "persons_entities") {
      // Value is already an array from the custom handler, use it directly
      if (Array.isArray(value)) {
        this._config = { ...this._config, [field]: value };
        const strippedConfig = this._stripDefaults(this._config);
        this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
        this.requestUpdate();
        return;
      }
    }

    // Card border radius: allow users to enter just a number (interpreted as px at render time)
    // while still allowing any valid CSS value (e.g., 12px, 0, 50%, var(--x)).
    // IMPORTANT: do NOT auto-append "px" or coerce to Number here, because @input fires per-keystroke
    // and coercion can interfere with typing (e.g., "12." or "-" while editing).
    // Same applies to persons_border_radius.
    if (field === "card_border_radius" || field === "card_border_radius_top" || field === "card_border_radius_bottom" || field === "persons_border_radius") {
      const s = (value ?? "").toString().trim();
      value = s; // store raw string; conversion happens when building CSS
    }

    // Use pre-computed static sets for field type checking
    const { _numericFields, _nullableNumericFields, _booleanFields } = HkiHeaderCardEditor;

    if (_nullableNumericFields.has(field)) {
      value = value === "" || value == null ? null : toNum(value, null);
      if (value === null || !Number.isFinite(value)) value = null;
    } else if (_numericFields.has(field)) {
      const n = Number(value);
      if (!Number.isFinite(n)) return;
      value = n;
    }

    if (_booleanFields.has(field)) value = !!(ev.target?.checked ?? value);

    let next;

    if (field.includes(".")) {
      const [rootField, subField] = field.split(".");
      const currentValue = this._config[rootField] || {};
      next = { ...this._config, [rootField]: { ...currentValue, [subField]: value } };

      if (subField === "action" && value === "perform-action") {
        next[rootField] = { ...next[rootField], perform_action: next[rootField].perform_action ?? "" };
      } else if (subField === "action" && value === "call-service") {
        // Legacy support for old call-service action
        next[rootField] = { ...next[rootField], service: next[rootField].service ?? "", service_data: next[rootField].service_data ?? "entity_id: \n" };
      }
    } else {
      next = { ...this._config, [field]: value };
    }

    if (field === "badges_fixed") {
      const currentOffset = this._config.badges_offset;
      if (currentOffset === 48 || currentOffset === 100 || currentOffset === 0) {
        next.badges_offset = value ? 48 : 100;
      }
    }

    this._config = next;
    const strippedConfig = this._stripDefaults(next);
    this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
    this.requestUpdate();
  }

  _renderTemplateEditor(label, field, options = {}) {
    // options.value / options.onchange allow standalone use outside of this._config
    const hasCustomBinding = options.onchange !== undefined;
    const value = hasCustomBinding ? (options.value ?? "") : (this._config?.[field] ?? "");
    return html`
      <div class="section">${label}</div>
      <ha-code-editor
        .hass=${this.hass}
        .value=${value}
        mode="jinja2"
        autocomplete-entities
        autocomplete-icons
        @value-changed=${(ev) => {
          ev.stopPropagation();
          const newValue = ev.detail?.value ?? "";
          if (newValue === value) return;
          if (hasCustomBinding) {
            options.onchange(newValue);
          } else {
            this._config = { ...this._config, [field]: newValue };
            const strippedConfig = this._stripDefaults(this._config);
            this.dispatchEvent(new CustomEvent('config-changed', { detail: { config: strippedConfig }, bubbles: true, composed: true }));
          }
        }}
        @click=${(e) => e.stopPropagation()}
      ></ha-code-editor>
    `;
  }

  _renderTemplateTextField(label, value, onInput, placeholder = "") {
    return html`
      <ha-textfield
        .label=${label}
        .value=${value || ""}
        .placeholder=${placeholder}
        helper="Jinja supported"
        @input=${(ev) => {
          ev.stopPropagation();
          onInput(ev.target.value ?? "");
        }}
      ></ha-textfield>
    `;
  }

  // Removed - using ha-yaml-editor inline instead

  _getSlotLabel(type) {
    const labels = {
      none: "Empty",
      spacer: "Spacer",
      weather: "Weather",
      datetime: "Date/Time",
      notifications: "Notifications",
      custom: "Notifications",
      card: "Custom Card",
      button: "Badge"
    };
    return labels[type] || "Empty";
  }

  _supportsHkiPopupForDomain(domain) {
    return ['light', 'climate', 'alarm_control_panel', 'cover', 'humidifier', 'fan', 'switch', 'input_boolean', 'lock', 'group'].includes(String(domain || ""));
  }

  _defaultInfoActionForDomain(domain) {
    return this._supportsHkiPopupForDomain(domain) ? "hki-more-info" : "more-info";
  }

  _renderSlotEditor(slotName, bar = "top_bar") {
    const prefix = `${bar}_${slotName}_`;
    const type = this._config[`${bar}_${slotName}`] || "none";
    const useGlobal = this._config[prefix + "use_global"] !== false;
    
    const displayType = (type === "custom") ? "notifications" : type;
    return html`
      <ha-select label="Content Type" .value=${displayType} data-field="${bar}_${slotName}" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
        <mwc-list-item value="none">None</mwc-list-item>
        <mwc-list-item value="spacer">Spacer</mwc-list-item>
        <mwc-list-item value="weather">Weather</mwc-list-item>
        <mwc-list-item value="datetime">Date/Time</mwc-list-item>
        <mwc-list-item value="notifications">Notifications</mwc-list-item>
        <mwc-list-item value="card">Custom Card</mwc-list-item>
        <mwc-list-item value="button">Badge</mwc-list-item>
      </ha-select>
      
      ${type !== "none" && type !== "spacer" ? html`
        <div class="section" style="margin-top: 12px;">Alignment</div>
        <ha-select label="Content Alignment" .value=${this._config[prefix + "align"] || (slotName === "left" ? "start" : slotName === "right" ? "end" : "center")} data-field="${prefix}align" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
          <mwc-list-item value="start">Start (left)</mwc-list-item>
          <mwc-list-item value="center">Center</mwc-list-item>
          <mwc-list-item value="end">End (right)</mwc-list-item>
          ${(type === "card" || type === "notifications" || type === "custom") ? html`
            <mwc-list-item value="stretch">Stretch (fill available slots)</mwc-list-item>
          ` : ''}
        </ha-select>
        <div class="section" style="margin-top: 12px;">Position Offset</div>
        <div class="inline-fields-2">
          <ha-textfield label="X offset (px)" type="number" .value=${String(this._config[prefix + "offset_x"] || 0)} data-field="${prefix}offset_x" @input=${this._changed}></ha-textfield>
          <ha-textfield label="Y offset (px)" type="number" .value=${String(this._config[prefix + "offset_y"] || 0)} data-field="${prefix}offset_y" @input=${this._changed}></ha-textfield>
        </div>
        <div class="inline-fields-2">
          <ha-textfield label="Mobile X offset (px)" type="number" .value=${this._config[prefix + "offset_x_mobile"] == null ? "" : String(this._config[prefix + "offset_x_mobile"])} data-field="${prefix}offset_x_mobile" @input=${this._changed}></ha-textfield>
          <ha-textfield label="Mobile Y offset (px)" type="number" .value=${this._config[prefix + "offset_y_mobile"] == null ? "" : String(this._config[prefix + "offset_y_mobile"])} data-field="${prefix}offset_y_mobile" @input=${this._changed}></ha-textfield>
        </div>
        
        <div class="switch-row" style="margin-top: 8px;">
            <ha-switch .checked=${!!this._config[prefix + "overflow"]} data-field="${prefix}overflow" @change=${this._changed}></ha-switch>
            <span>Allow Overflow (content bleeds out)</span>
        </div>
      ` : ''}

      ${type === "weather" ? html`
        <div class="section" style="margin-top: 12px;">Weather Settings</div>
        ${this._renderEntityPicker("Weather entity", prefix + "weather_entity", this._config[prefix + "weather_entity"] || this._config.weather_entity || "", "Select a weather entity", "weather")}
        
        <div class="inline-fields-3" style="margin-top: 8px;">
            <div class="switch-row"><ha-switch .checked=${this._config[prefix + "show_icon"] !== false} data-field="${prefix}show_icon" @change=${this._changed}></ha-switch><span>Icon</span></div>
            <div class="switch-row"><ha-switch .checked=${this._config[prefix + "show_condition"] !== false} data-field="${prefix}show_condition" @change=${this._changed}></ha-switch><span>Condition</span></div>
            <div class="switch-row"><ha-switch .checked=${this._config[prefix + "show_temperature"] !== false} data-field="${prefix}show_temperature" @change=${this._changed}></ha-switch><span>Temp</span></div>
            <div class="switch-row"><ha-switch .checked=${!!this._config[prefix + "show_humidity"]} data-field="${prefix}show_humidity" @change=${this._changed}></ha-switch><span>Humidity</span></div>
            <div class="switch-row"><ha-switch .checked=${!!this._config[prefix + "show_wind"]} data-field="${prefix}show_wind" @change=${this._changed}></ha-switch><span>Wind</span></div>
            <div class="switch-row"><ha-switch .checked=${!!this._config[prefix + "show_pressure"]} data-field="${prefix}show_pressure" @change=${this._changed}></ha-switch><span>Pressure</span></div>
        </div>
        
        <ha-textfield label="Icon pack path (SVG)" helper="Path to folder (e.g., /local/icons/weather)" .value=${this._config[prefix + "icon_pack_path"] || ""} data-field="${prefix}icon_pack_path" @input=${this._changed}></ha-textfield>

        <div class="switch-row" style="margin-top: 8px;">
            <ha-switch .checked=${this._config[prefix + "weather_colored_icons"] !== false} data-field="${prefix}weather_colored_icons" @change=${this._changed}></ha-switch>
            <span>Colored icons</span>
        </div>
        
        <div class="inline-fields-2">
          <ha-select label="Icon color mode" .value=${this._config[prefix + "weather_icon_color_mode"] || "state"} data-field="${prefix}weather_icon_color_mode" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
            <mwc-list-item value="state">By condition</mwc-list-item>
            <mwc-list-item value="custom">Custom</mwc-list-item>
            <mwc-list-item value="inherit">Inherit</mwc-list-item>
          </ha-select>
          <ha-select label="Icon animation" .value=${this._config[prefix + "animate_icon"] || "none"} data-field="${prefix}animate_icon" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
            <mwc-list-item value="none">None</mwc-list-item>
            <mwc-list-item value="float">Float</mwc-list-item>
            <mwc-list-item value="pulse">Pulse</mwc-list-item>
            <mwc-list-item value="spin">Spin</mwc-list-item>
          </ha-select>
        </div>
        ${this._config[prefix + "weather_icon_color_mode"] === "custom" ? html`
            <ha-textfield label="Custom icon color (CSS)" .value=${this._config[prefix + "weather_icon_color"] || ""} data-field="${prefix}weather_icon_color" @input=${this._changed}></ha-textfield>
        ` : ""}
      ` : ''}

      ${type === "datetime" ? html`
        <div class="section" style="margin-top: 12px;">Date/Time Settings</div>
        <div class="inline-fields-3">
          <div class="switch-row"><ha-switch .checked=${this._config[prefix + "show_day"] !== false} data-field="${prefix}show_day" @change=${this._changed}></ha-switch><span>Day</span></div>
          <div class="switch-row"><ha-switch .checked=${this._config[prefix + "show_date"] !== false} data-field="${prefix}show_date" @change=${this._changed}></ha-switch><span>Date</span></div>
          <div class="switch-row"><ha-switch .checked=${this._config[prefix + "show_time"] !== false} data-field="${prefix}show_time" @change=${this._changed}></ha-switch><span>Time</span></div>
        </div>
        
        <ha-textfield label="Time format" helper="HH:mm (24h) or h:mm A (12h)" .value=${this._config[prefix + "time_format"] || "HH:mm"} data-field="${prefix}time_format" @input=${this._changed}></ha-textfield>
        <ha-textfield label="Date format" helper="D MMM, DD/MM/YYYY, MMMM D, etc." .value=${this._config[prefix + "date_format"] || "D MMM"} data-field="${prefix}date_format" @input=${this._changed}></ha-textfield>
        <ha-textfield label="Separator" .value=${this._config[prefix + "separator"] || " â€¢ "} data-field="${prefix}separator" @input=${this._changed}></ha-textfield>
        
        ${this._renderIconPicker("Icon", prefix + "icon", this._config[prefix + "icon"] || "", "Optional icon")}
        <ha-select label="Icon animation" .value=${this._config[prefix + "animate_icon"] || "none"} data-field="${prefix}animate_icon" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
            <mwc-list-item value="none">None</mwc-list-item>
            <mwc-list-item value="float">Float</mwc-list-item>
            <mwc-list-item value="pulse">Pulse</mwc-list-item>
            <mwc-list-item value="spin">Spin</mwc-list-item>
        </ha-select>
      ` : ''}
      
      ${type === "button" ? html`
        <div class="section" style="margin-top: 12px;">Badge Settings</div>
        ${(() => {
          const configured = Array.isArray(this._config[prefix + "buttons"]) ? this._config[prefix + "buttons"] : [];
          const fallback = normalizeSlotButton({
            icon: this._config[prefix + "icon"] || "",
            icon_animation: this._config[prefix + "icon_animation"] || "",
            name: this._config[prefix + "name"] ?? "",
            state: this._config[prefix + "state"] || "",
            entity: this._config[prefix + "entity"] || "",
            card_color: this._config[prefix + "card_color"] || "",
            icon_color: this._config[prefix + "icon_color"] || "",
            name_color: this._config[prefix + "name_color"] || "",
            state_color: this._config[prefix + "state_color"] || "",
            text_shadow: this._config[prefix + "text_shadow"] || "",
            icon_shadow: this._config[prefix + "icon_shadow"] || "",
            name_offset_x: this._config[prefix + "name_offset_x"] ?? 0,
            name_offset_y: this._config[prefix + "name_offset_y"] ?? 0,
            state_offset_x: this._config[prefix + "state_offset_x"] ?? 0,
            state_offset_y: this._config[prefix + "state_offset_y"] ?? 0,
            visibility_mode: this._config[prefix + "visibility_mode"] || "none",
            visibility_entity: this._config[prefix + "visibility_entity"] || "",
            visibility_state: this._config[prefix + "visibility_state"] || "",
            visibility_attribute: this._config[prefix + "visibility_attribute"] || "",
            visibility_attribute_value: this._config[prefix + "visibility_attribute_value"] || "",
            show_badge: this._config[prefix + "show_badge"] === true,
            badge_source: this._config[prefix + "badge_source"] || "entity",
            badge_entity: this._config[prefix + "badge_entity"] || "",
            badge_template: this._config[prefix + "badge_template"] || "",
            badge_color: this._config[prefix + "badge_color"] || "",
            badge_text_color: this._config[prefix + "badge_text_color"] || "",
          });
          const buttons = configured.length ? configured.map((b) => normalizeSlotButton(b)) : [fallback];

          const saveButtons = (nextButtons) => {
            const cleaned = nextButtons.map((b) => cleanupSlotButton(b)).filter(Boolean);
            const first = cleaned[0] || createDefaultSlotButton();
            this._config = {
              ...this._config,
              [prefix + "buttons"]: cleaned,
              [prefix + "icon"]: first.icon || "mdi:gesture-tap",
              [prefix + "icon_animation"]: first.icon_animation || "",
              [prefix + "name"]: first.name || "",
              [prefix + "state"]: first.state || "",
              [prefix + "entity"]: first.entity || "",
            };
            const strippedConfig = this._stripDefaults(this._config);
            this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
            this.requestUpdate();
          };

          const setButton = (idx, patch) => {
            const next = buttons.map((b, i) => (i === idx ? normalizeSlotButton({ ...b, ...patch }) : b));
            saveButtons(next);
          };

          return html`
            <div style="display:flex;flex-wrap:wrap;gap:6px;margin:8px 0;">
              ${buttons.map((_, idx) => html`<span style="padding:2px 8px;border-radius:10px;background:rgba(255,255,255,0.08);font-size:12px;">${idx + 1}</span>`)}
              <button type="button"
                style="width:28px;height:28px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);background:rgba(255,255,255,0.06);color:var(--primary-text-color);cursor:pointer;font-size:16px;display:flex;align-items:center;justify-content:center;"
                @click=${(e) => { e.stopPropagation(); saveButtons([...buttons, createDefaultSlotButton()]); }}>
                <ha-icon icon="mdi:plus"></ha-icon>
              </button>
            </div>

            ${buttons.map((btn, idx) => {
              const badgeSource = btn.badge_source === "template" ? "template" : "entity";
              const domain = (btn.entity || "").split(".")[0];
              const defaultInfoAction = this._defaultInfoActionForDomain(domain);
              const defaultTapAction = (["switch", "climate", "input_boolean", "automation", "light"].includes(domain))
                ? { action: "toggle" }
                : { action: defaultInfoAction };
              const tapAction = (!btn.tap_action || !btn.tap_action.action || btn.tap_action.action === "none")
                ? defaultTapAction
                : btn.tap_action;
              const holdAction = (!btn.hold_action || !btn.hold_action.action || btn.hold_action.action === "none")
                ? { action: defaultInfoAction }
                : btn.hold_action;
              const doubleTapAction = (!btn.double_tap_action || !btn.double_tap_action.action || btn.double_tap_action.action === "none")
                ? { action: defaultInfoAction }
                : btn.double_tap_action;
              const popupEntity = tapAction.entity || holdAction.entity || doubleTapAction.entity || btn.entity || "";
              const renderActionEditor = (actionLabel, actionObj, setAction) => html`
                <div style="margin-top:6px;">
                  <p style="font-size:11px;opacity:0.7;margin:0 0 4px 0;">${actionLabel}</p>
                  <ha-select .value=${actionObj.action || "none"}
                    @selected=${(e) => setAction({ action: e.target.value || "none" })}
                    @closed=${(e) => e.stopPropagation()}>
                    ${HKI_EDITOR_OPTIONS.headerActionOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                  </ha-select>
                  ${(actionObj.action === "navigate") ? html`
                    ${this._renderNavigationPathPicker("Navigation path", actionObj.navigation_path || "", (v) => setAction({ ...actionObj, navigation_path: v }))}
                  ` : ''}
                  ${(actionObj.action === "url") ? html`
                    <ha-textfield label="URL" .value=${actionObj.url_path || ""} @input=${(e) => setAction({ ...actionObj, url_path: e.target.value || "" })}></ha-textfield>
                  ` : ''}
                  ${(actionObj.action === "more-info" || actionObj.action === "toggle" || actionObj.action === "hki-more-info") ? html`
                    <ha-entity-picker .hass=${this.hass} .value=${actionObj.entity || ""} label="Entity override"
                      @value-changed=${(e) => setAction({ ...actionObj, entity: e.detail.value || undefined })}></ha-entity-picker>
                  ` : ''}
                  ${(actionObj.action === "fire-dom-event") ? html`
                    <ha-textfield label="Event Name (optional)" .value=${actionObj.event_name || ""}
                      @input=${(e) => setAction({ ...actionObj, event_name: e.target.value || "" })}></ha-textfield>
                    <div class="section">Event Data (YAML/JSON text)</div>
                    <ha-code-editor
                      .hass=${this.hass}
                      .value=${actionObj.event_data || ""}
                      mode="yaml"
                      @value-changed=${(e) => setAction({ ...actionObj, event_data: e.detail?.value || "" })}
                      @click=${(e) => e.stopPropagation()}
                    ></ha-code-editor>
                  ` : ''}
                </div>
              `;
              return html`
                <details class="box-section" style="margin-top:8px;" open>
                  <summary>Badge ${idx + 1}</summary>
                  <div class="box-content" style="padding:10px;background:rgba(255,255,255,0.04);border-radius:10px;">
                    <div style="display:flex;justify-content:flex-end;align-items:center;margin-bottom:6px;">
                    <div style="display:flex;align-items:center;gap:2px;">
                      <mwc-icon-button ?disabled=${idx === 0} @click=${() => {
                        if (idx === 0) return;
                        const next = [...buttons];
                        [next[idx - 1], next[idx]] = [next[idx], next[idx - 1]];
                        saveButtons(next);
                      }}>
                        <ha-icon icon="mdi:chevron-up"></ha-icon>
                      </mwc-icon-button>
                      <mwc-icon-button ?disabled=${idx === buttons.length - 1} @click=${() => {
                        if (idx >= buttons.length - 1) return;
                        const next = [...buttons];
                        [next[idx + 1], next[idx]] = [next[idx], next[idx + 1]];
                        saveButtons(next);
                      }}>
                        <ha-icon icon="mdi:chevron-down"></ha-icon>
                      </mwc-icon-button>
                      ${buttons.length > 1 ? html`
                        <mwc-icon-button @click=${() => saveButtons(buttons.filter((_, i) => i !== idx))}>
                          <ha-icon icon="mdi:delete"></ha-icon>
                        </mwc-icon-button>
                      ` : ''}
                    </div>
                    </div>

                  <ha-entity-picker .hass=${this.hass} .value=${btn.entity || ""} label="Entity (optional)"
                    @value-changed=${(e) => setButton(idx, { entity: e.detail.value || "" })}></ha-entity-picker>
                  ${this._renderTemplateEditor("Icon (Jinja or mdi:...)", `${prefix}btn_${idx}_icon`, {
                    value: btn.icon || "",
                    onchange: (v) => setButton(idx, { icon: v || "" }),
                  })}
                  ${this._renderTemplateEditor("Icon Animation (Jinja: none|spin|float|pulse)", `${prefix}btn_${idx}_icon_animation`, {
                    value: btn.icon_animation || "",
                    onchange: (v) => setButton(idx, { icon_animation: v || "" }),
                  })}
                  ${this._renderTemplateEditor("Name Override (optional, Jinja)", `${prefix}btn_${idx}_name`, {
                    value: btn.name || "",
                    onchange: (v) => setButton(idx, { name: v || "" }),
                  })}
                  ${this._renderTemplateEditor("State Override (optional, Jinja)", `${prefix}btn_${idx}_state`, {
                    value: btn.state || "",
                    onchange: (v) => setButton(idx, { state: v || "" }),
                  })}

                  <div class="switch-row" style="margin-top: 6px;">
                    <ha-switch .checked=${btn.show_badge === true} @change=${(e) => setButton(idx, { show_badge: e.target.checked })}></ha-switch>
                    <span>Show badge</span>
                  </div>

                  ${btn.show_badge ? html`
                    <ha-select label="Badge Source" .value=${badgeSource}
                      @selected=${(e) => setButton(idx, { badge_source: e.target.value || "entity" })}
                      @closed=${(e) => e.stopPropagation()}>
                      <mwc-list-item value="entity">Entity state</mwc-list-item>
                      <mwc-list-item value="template">Jinja template</mwc-list-item>
                    </ha-select>
                    ${badgeSource === "entity" ? html`
                      <ha-entity-picker .hass=${this.hass} .value=${btn.badge_entity || ""} label="Badge Entity"
                        @value-changed=${(e) => setButton(idx, { badge_entity: e.detail.value || "" })}></ha-entity-picker>
                    ` : html`
                      ${this._renderTemplateEditor("Badge Template (Jinja)", `${prefix}btn_${idx}_badge_template`, {
                        value: btn.badge_template || "",
                        onchange: (v) => setButton(idx, { badge_template: v || "" }),
                      })}
                    `}
                  ` : ''}

                  <details class="box-section" style="margin-top:8px;">
                    <summary>Actions</summary>
                    <div class="box-content">
                      ${renderActionEditor("Tap action", tapAction, (v) => setButton(idx, { tap_action: v }))}
                      ${renderActionEditor("Hold action", holdAction, (v) => setButton(idx, { hold_action: v }))}
                      ${renderActionEditor("Double tap action", doubleTapAction, (v) => setButton(idx, { double_tap_action: v }))}
                    </div>
                  </details>

                  <details class="box-section" style="margin-top:8px;">
                    <summary>HKI Popup Settings</summary>
                    <div class="box-content">
                      ${this._renderSlotPopupEditor(`${prefix}btn_${idx}_popup_`, popupEntity, {
                        actions: [tapAction, holdAction, doubleTapAction],
                        popupGetter: () => btn.popup || {},
                        popupSetter: (patch) => {
                          const prev = (btn.popup && typeof btn.popup === "object") ? btn.popup : {};
                          const nextPopup = { ...prev, ...patch };
                          Object.keys(nextPopup).forEach((k) => {
                            if (nextPopup[k] === undefined || nextPopup[k] === null || nextPopup[k] === "") delete nextPopup[k];
                          });
                          setButton(idx, { popup: nextPopup });
                        },
                      })}
                    </div>
                  </details>

                  <details class="box-section" style="margin-top:8px;">
                    <summary>Style Overrides</summary>
                    <div class="box-content">
                      <details class="box-section">
                        <summary>Card / Badge Button Surface</summary>
                        <div class="box-content">
                          ${this._renderTemplateEditor("Button Background (Jinja)", `${prefix}btn_${idx}_card_color`, {
                            value: btn.card_color || "",
                            onchange: (v) => setButton(idx, { card_color: v || "" }),
                          })}
                          ${this._renderTemplateEditor("Text Color (Jinja)", `${prefix}btn_${idx}_text_color`, {
                            value: btn.text_color || "",
                            onchange: (v) => setButton(idx, { text_color: v || "" }),
                          })}
                          ${this._renderTemplateEditor("Icon Color (Jinja)", `${prefix}btn_${idx}_icon_color`, {
                            value: btn.icon_color || "",
                            onchange: (v) => setButton(idx, { icon_color: v || "" }),
                          })}
                          ${this._renderTemplateEditor("Name Color (Jinja)", `${prefix}btn_${idx}_name_color`, {
                            value: btn.name_color || "",
                            onchange: (v) => setButton(idx, { name_color: v || "" }),
                          })}
                          ${this._renderTemplateEditor("State Color (Jinja)", `${prefix}btn_${idx}_state_color`, {
                            value: btn.state_color || "",
                            onchange: (v) => setButton(idx, { state_color: v || "" }),
                          })}
                          ${this._renderTemplateEditor("Text Shadow (CSS/Jinja)", `${prefix}btn_${idx}_text_shadow`, {
                            value: btn.text_shadow || "",
                            onchange: (v) => setButton(idx, { text_shadow: v || "" }),
                          })}
                          ${this._renderTemplateEditor("Icon Shadow (CSS/Jinja)", `${prefix}btn_${idx}_icon_shadow`, {
                            value: btn.icon_shadow || "",
                            onchange: (v) => setButton(idx, { icon_shadow: v || "" }),
                          })}
                          ${this._renderTemplateTextField("Border Style", btn.button_border_style || "", (v) => setButton(idx, { button_border_style: v || "" }), "solid / dashed / none")}
                          ${this._renderTemplateTextField("Border Color", btn.button_border_color || "", (v) => setButton(idx, { button_border_color: v || "" }), "{{ ... }} / #ffffff")}
                          ${this._renderTemplateTextField("Box Shadow", btn.button_box_shadow || "", (v) => setButton(idx, { button_box_shadow: v || "" }), "0 2px 8px rgba(...)")}
                          <div class="inline-fields-2">
                            <ha-textfield label="Border Width (px)" type="number" .value=${String(btn.button_border_width ?? "")}
                              @input=${(e) => setButton(idx, { button_border_width: e.target.value === "" ? "" : Number(e.target.value) || 0 })}></ha-textfield>
                            <ha-textfield label="Border Radius (px)" type="number" .value=${String(btn.button_border_radius ?? "")}
                              @input=${(e) => setButton(idx, { button_border_radius: e.target.value === "" ? "" : Number(e.target.value) || 0 })}></ha-textfield>
                          </div>
                          <div class="inline-fields-2">
                            <ha-textfield label="Name Offset X" type="number" .value=${String(btn.name_offset_x ?? 0)}
                              @input=${(e) => setButton(idx, { name_offset_x: Number(e.target.value) || 0 })}></ha-textfield>
                            <ha-textfield label="Name Offset Y" type="number" .value=${String(btn.name_offset_y ?? 0)}
                              @input=${(e) => setButton(idx, { name_offset_y: Number(e.target.value) || 0 })}></ha-textfield>
                          </div>
                          <div class="inline-fields-2">
                            <ha-textfield label="State Offset X" type="number" .value=${String(btn.state_offset_x ?? 0)}
                              @input=${(e) => setButton(idx, { state_offset_x: Number(e.target.value) || 0 })}></ha-textfield>
                            <ha-textfield label="State Offset Y" type="number" .value=${String(btn.state_offset_y ?? 0)}
                              @input=${(e) => setButton(idx, { state_offset_y: Number(e.target.value) || 0 })}></ha-textfield>
                          </div>
                        </div>
                      </details>

                      <details class="box-section">
                        <summary>Top-right Corner Badge (notification badge)</summary>
                        <div class="box-content">
                          ${this._renderTemplateTextField("Badge Color", btn.badge_color || "", (v) => setButton(idx, { badge_color: v || "" }), "{{ ... }} / #ff4444")}
                          ${this._renderTemplateTextField("Badge Text Color", btn.badge_text_color || "", (v) => setButton(idx, { badge_text_color: v || "" }), "{{ ... }} / #ffffff")}
                          ${this._renderTemplateTextField("Badge Border Style", btn.badge_border_style || "", (v) => setButton(idx, { badge_border_style: v || "" }), "solid / dashed / none")}
                          ${this._renderTemplateTextField("Badge Border Color", btn.badge_border_color || "", (v) => setButton(idx, { badge_border_color: v || "" }), "{{ ... }} / #ffffff")}
                          ${this._renderTemplateTextField("Badge Box Shadow", btn.badge_box_shadow || "", (v) => setButton(idx, { badge_box_shadow: v || "" }), "0 2px 8px rgba(...)")}
                          <div class="inline-fields-3">
                            <ha-textfield label="Badge Border Width (px)" type="number" .value=${String(btn.badge_border_width ?? "")}
                              @input=${(e) => setButton(idx, { badge_border_width: e.target.value === "" ? "" : Number(e.target.value) || 0 })}></ha-textfield>
                            <ha-textfield label="Badge Border Radius (px)" type="number" .value=${String(btn.badge_border_radius ?? "")}
                              @input=${(e) => setButton(idx, { badge_border_radius: e.target.value === "" ? "" : Number(e.target.value) || 0 })}></ha-textfield>
                            <ha-textfield label="Badge Font Size (px)" type="number" .value=${String(btn.badge_font_size ?? "")}
                              @input=${(e) => setButton(idx, { badge_font_size: e.target.value === "" ? "" : Number(e.target.value) || 0 })}></ha-textfield>
                          </div>
                          <div class="inline-fields-2">
                            <ha-select label="Badge Font Family" .value=${btn.badge_font_family || "inherit"}
                              @selected=${(e) => setButton(idx, { badge_font_family: e.target.value || "inherit" })}
                              @closed=${(e) => e.stopPropagation()}>
                              <mwc-list-item value="inherit">inherit</mwc-list-item>
                              <mwc-list-item value="system">system</mwc-list-item>
                              <mwc-list-item value="roboto">roboto</mwc-list-item>
                              <mwc-list-item value="inter">inter</mwc-list-item>
                              <mwc-list-item value="arial">arial</mwc-list-item>
                              <mwc-list-item value="georgia">georgia</mwc-list-item>
                              <mwc-list-item value="mono">mono</mwc-list-item>
                              <mwc-list-item value="custom">custom</mwc-list-item>
                            </ha-select>
                            <ha-textfield label="Badge Font Weight" .value=${String(btn.badge_font_weight ?? "")}
                              @input=${(e) => setButton(idx, { badge_font_weight: e.target.value || "" })} placeholder="400 / semibold"></ha-textfield>
                          </div>
                          ${btn.badge_font_family === "custom" ? html`
                            ${this._renderTemplateTextField("Badge Custom Font Family", btn.badge_font_custom || "", (v) => setButton(idx, { badge_font_custom: v || "" }), "'My Font', sans-serif")}
                          ` : ''}
                        </div>
                      </details>
                    </div>
                  </details>

                  <details class="box-section" style="margin-top:8px;">
                    <summary>Visibility Conditions</summary>
                    <div class="box-content">
                      <div class="inline-fields-3">
                        <div class="switch-row"><ha-switch .checked=${btn.show_icon !== false} @change=${(e) => setButton(idx, { show_icon: e.target.checked })}></ha-switch><span>Show icon</span></div>
                        <div class="switch-row"><ha-switch .checked=${btn.show_name !== false} @change=${(e) => setButton(idx, { show_name: e.target.checked })}></ha-switch><span>Show name</span></div>
                        <div class="switch-row"><ha-switch .checked=${btn.show_state !== false} @change=${(e) => setButton(idx, { show_state: e.target.checked })}></ha-switch><span>Show state</span></div>
                      </div>
                      <ha-select label="Show badge when" .value=${btn.visibility_mode || "none"}
                        @selected=${(e) => setButton(idx, { visibility_mode: e.target.value || "none" })}
                        @closed=${(e) => e.stopPropagation()}>
                        <mwc-list-item value="none">Always show</mwc-list-item>
                        <mwc-list-item value="state">Entity state equals</mwc-list-item>
                        <mwc-list-item value="attribute">Entity attribute equals</mwc-list-item>
                      </ha-select>

                      ${btn.visibility_mode && btn.visibility_mode !== "none" ? html`
                        <ha-entity-picker .hass=${this.hass} .value=${btn.visibility_entity || btn.entity || ""} label="Condition Entity"
                          @value-changed=${(e) => setButton(idx, { visibility_entity: e.detail.value || "" })}></ha-entity-picker>
                      ` : ''}

                      ${btn.visibility_mode === "state" ? html`
                        ${this._renderTemplateEditor("Expected State (Jinja supported)", `${prefix}btn_${idx}_visibility_state`, {
                          value: btn.visibility_state || "",
                          onchange: (v) => setButton(idx, { visibility_state: v || "" }),
                        })}
                      ` : ''}

                      ${btn.visibility_mode === "attribute" ? html`
                        <ha-textfield label="Attribute path" .value=${btn.visibility_attribute || ""} placeholder="friendly_name or nested.path"
                          @input=${(e) => setButton(idx, { visibility_attribute: e.target.value || "" })}></ha-textfield>
                        ${this._renderTemplateEditor("Expected Attribute Value (Jinja supported)", `${prefix}btn_${idx}_visibility_attribute_value`, {
                          value: btn.visibility_attribute_value || "",
                          onchange: (v) => setButton(idx, { visibility_attribute_value: v || "" }),
                        })}
                      ` : ''}
                    </div>
                  </details>
                  </div>
                </details>
              `;
            })}
          `;
        })()}
      ` : ''}
      
      ${(type === "notifications" || type === "custom") ? html`
          <ha-alert alert-type="info" style="margin-bottom: 8px;">
            This requires the <b>hki-notify</b> integration and the <b>custom:hki-notification-card</b> resource.
          </ha-alert>
          <p style="opacity: 0.7; font-size: 0.9em; margin-top: 8px;">Enable "Use Header Styling" in the notification card below to inherit styling from the Global Styling (Defaults) settings.</p>
          <div class="card-config">
            <hui-card-element-editor
              .hass=${this.hass}
              .lovelace=${this._getLovelace()}
              .value=${{ 
                type: "custom:hki-notification-card", 
                use_header_styling: true, 
                show_background: false,
                show_empty: true,
                ...(this._config[`${bar}_${slotName}_card`] || {})
              }}
              @config-changed=${(ev) => this._handleCustomCardChange(ev, slotName, bar)}
            ></hui-card-element-editor>
          </div>
      ` : ''}
      
      ${type === "card" ? html`
          <div class="card-config">
            <hui-card-element-editor
              .hass=${this.hass}
              .lovelace=${this._getLovelace()}
              .value=${this._config[`${bar}_${slotName}_card`] || { type: "vertical-stack", cards: [] }}
              @config-changed=${(ev) => this._handleCustomCardChange(ev, slotName, bar)}
            ></hui-card-element-editor>
          </div>
      ` : ''}
      
      ${type === "spacer" ? html`
        <div class="section" style="margin-top: 12px;">Actions</div>
        ${this._renderActionEditor("Tap action", prefix + "tap_action")}
        ${this._renderActionEditor("Hold action", prefix + "hold_action")}
        ${this._renderActionEditor("Double tap action", prefix + "double_tap_action")}
        <details class="box-section" style="margin-top:8px;">
          <summary>HKI Popup Settings</summary>
          <div class="box-content">${this._renderSlotPopupEditor(prefix)}</div>
        </details>
      ` : ''}
      
      ${(type === "weather" || type === "datetime") ? html`
        <div class="section" style="margin-top: 12px;">Actions</div>
        ${this._renderActionEditor("Tap action", prefix + "tap_action")}
        ${this._renderActionEditor("Hold action", prefix + "hold_action")}
        ${this._renderActionEditor("Double tap action", prefix + "double_tap_action")}
        <details class="box-section" style="margin-top:8px;">
          <summary>HKI Popup Settings</summary>
          <div class="box-content">${this._renderSlotPopupEditor(prefix)}</div>
        </details>
      ` : ''}
      
      ${type !== "none" && type !== "notifications" && type !== "custom" && type !== "card" && type !== "spacer" ? html`
        <div class="section" style="margin-top: 12px;">Styling</div>
        <div class="switch-row">
          <ha-switch .checked=${useGlobal} data-field="${prefix}use_global" @change=${this._changed}></ha-switch>
          <span>Use global styling</span>
        </div>
        
        ${!useGlobal ? html`
          <div class="inline-fields-2">
            <ha-textfield label="Font Size (px)" type="number" .value=${String(this._config[prefix + "size_px"] ?? "")} data-field="${prefix}size_px" @input=${this._changed}></ha-textfield>
            <ha-select label="Font Weight" .value=${this._config[prefix + "weight"] || ""} data-field="${prefix}weight" @selected=${this._changed} @closed=${this._changed}>
              <mwc-list-item value="">Use Global</mwc-list-item>
              ${["light", "regular", "medium", "semibold", "bold", "extrabold"].map(w => html`<mwc-list-item .value=${w}>${w.charAt(0).toUpperCase() + w.slice(1)}</mwc-list-item>`)}
            </ha-select>
          </div>
          <ha-textfield label="Text Color (Jinja supported)" .value=${this._config[prefix + "color"] || ""} data-field="${prefix}color" @input=${this._changed}></ha-textfield>
          <ha-textfield label="Text Shadow (CSS/Jinja)" .value=${this._config[prefix + "text_shadow"] || ""} data-field="${prefix}text_shadow" @input=${this._changed}></ha-textfield>
          
          <div class="switch-row">
            <ha-switch .checked=${this._config[prefix + "pill"] === true} data-field="${prefix}pill" @change=${this._changed}></ha-switch>
            <span>Enable Pill Style</span>
          </div>
          ${this._config[prefix + "pill"] ? html`
            ${this._renderTemplateEditor("Pill Background (Jinja)", `${prefix}pill_background`)}
            <div class="inline-fields-2">
              <ha-textfield label="Padding X" type="number" .value=${String(this._config[prefix + "pill_padding_x"] ?? "")} data-field="${prefix}pill_padding_x" @input=${this._changed}></ha-textfield>
              <ha-textfield label="Padding Y" type="number" .value=${String(this._config[prefix + "pill_padding_y"] ?? "")} data-field="${prefix}pill_padding_y" @input=${this._changed}></ha-textfield>
            </div>
            <div class="inline-fields-2">
              <ha-textfield label="Border Radius" type="number" .value=${String(this._config[prefix + "pill_radius"] ?? "")} data-field="${prefix}pill_radius" @input=${this._changed}></ha-textfield>
              <ha-textfield label="Blur" type="number" .value=${String(this._config[prefix + "pill_blur"] ?? "")} data-field="${prefix}pill_blur" @input=${this._changed}></ha-textfield>
            </div>
          ` : ''}
        ` : ''}
      ` : ''}
    `;
  }

  _renderSlotPopupEditor(prefix, entityId = null, options = {}) {
    const cfg = this._config;
    const boundPopup = (options.popupGetter && typeof options.popupGetter === "function")
      ? (options.popupGetter() || {})
      : null;
    const slotActions = Array.isArray(options.actions) && options.actions.length
      ? options.actions.filter(Boolean)
      : [
          cfg[prefix + "tap_action"],
          cfg[prefix + "hold_action"],
          cfg[prefix + "double_tap_action"],
        ].filter(Boolean);
    const effectiveEntity = entityId
      || slotActions.find((a) => a?.action === "hki-more-info" && a?.entity)?.entity
      || slotActions.find((a) => a?.entity)?.entity
      || null;
    const domain = effectiveEntity ? effectiveEntity.split('.')[0] : null;
    const selectedEntity = (effectiveEntity && this.hass?.states?.[effectiveEntity]) || null;
    const hasChildren = selectedEntity?.attributes?.entity_id && Array.isArray(selectedEntity.attributes.entity_id);
    const isLightGroup = domain === 'light' && hasChildren;

    const enabled = boundPopup ? !!boundPopup.custom_popup_enabled : !!cfg[prefix + "custom_popup_enabled"];
    const p = (k) => boundPopup ? boundPopup[k] : cfg[prefix + k];
    const pp = (patch) => {
      if (boundPopup && options.popupSetter && typeof options.popupSetter === "function") {
        options.popupSetter(patch);
        return;
      }
      const mapped = {};
      Object.keys(patch).forEach(k => mapped[prefix + k] = patch[k]);
      this._config = { ...this._config, ...mapped };
      this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: this._stripDefaults(this._config) }, bubbles: true, composed: true }));
      this.requestUpdate();
    };
    const popupAnimOptions = HKI_POPUP_EDITOR_OPTIONS.animations;
    const popupWidthOptions = HKI_POPUP_EDITOR_OPTIONS.width;
    const popupHeightOptions = HKI_POPUP_EDITOR_OPTIONS.height;
    const popupTimeFormatOptions = HKI_POPUP_EDITOR_OPTIONS.timeFormats;
    const popupBottomBarActionOptions = HKI_EDITOR_OPTIONS.popupBottomBarActionOptions;
    const popupDefaultViewOptions = HKI_EDITOR_OPTIONS.popupDefaultViewOptions;
    const popupDefaultSectionOptions = HKI_EDITOR_OPTIONS.popupDefaultSectionOptions;
    const popupBottomBarAlignOptions = HKI_EDITOR_OPTIONS.popupBottomBarAlignOptions;

    return html`
      <div class="section" style="margin-top: 12px;">HKI More Info Popup</div>
      <p style="font-size: 11px; opacity: 0.7; margin: 4px 0 8px 0;">Settings for the HKI More Info popup. Apply when an action on this slot is set to "HKI More Info".</p>

      <details class="box-section">
        <summary>Popup Header</summary>
        <div class="box-content">
          ${this._renderTemplateEditor("Name (optional, supports Jinja)", "hki_popup_name_" + prefix, { value: p("popup_name") || "", onchange: (v) => pp({ "popup_name": v || undefined }) })}
          ${this._renderTemplateEditor("State text (optional, supports Jinja)", "hki_popup_state_" + prefix, { value: p("popup_state") || "", onchange: (v) => pp({ "popup_state": v || undefined }) })}
          ${this._renderTemplateEditor("Icon (optional, supports Jinja)", "hki_popup_icon_" + prefix, { value: p("popup_icon") || "", placeholder: "mdi:home or {{ ... }}", onchange: (v) => pp({ "popup_icon": v || undefined }) })}
          <div class="switch-row" style="margin-top:6px;">
            <ha-switch .checked=${p("popup_use_entity_picture") === true} @change=${(ev) => pp({ "popup_use_entity_picture": ev.target.checked || undefined })}></ha-switch>
            <span>Use entity picture (if available)</span>
          </div>
        </div>
      </details>

      <details class="box-section" open>
        <summary>Popup Card</summary>
        <div class="box-content">
          <p style="font-size: 11px; opacity: 0.7; margin: 0 0 6px 0;">Enable to show a custom card instead of the auto domain popup.</p>
          <div class="switch-row">
            <ha-switch .checked=${enabled} @change=${(ev) => pp({ "custom_popup_enabled": ev.target.checked })}></ha-switch>
            <span>Enable custom popup card</span>
          </div>
          ${enabled ? html`
            <div class="card-config">
              ${customElements.get('hui-card-element-editor') ? html`
                <hui-card-element-editor
                  .hass=${this.hass}
                  .lovelace=${this._getLovelace()}
                  .value=${p("custom_popup_card") || { type: "vertical-stack", cards: [] }}
                  @config-changed=${(ev) => {
                    ev.stopPropagation();
                    const newCard = ev.detail?.config;
                    if (newCard && JSON.stringify(newCard) !== JSON.stringify(p("custom_popup_card"))) pp({ "custom_popup_card": newCard });
                  }}
                ></hui-card-element-editor>
              ` : html`<p style="font-size:11px;opacity:0.6;">Card editor not available. Use YAML mode.</p>`}
            </div>
          ` : ''}
        </div>
      </details>

      <details class="box-section">
        <summary>Animation</summary>
        <div class="box-content">
          <div class="inline-fields-2">
            <ha-select label="Open Animation" .value=${p("popup_open_animation") || "scale"}
              @selected=${(ev) => { ev.stopPropagation(); pp({ "popup_open_animation": ev.target.value }); }}
              @closed=${(ev) => ev.stopPropagation()}>
              ${popupAnimOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
            </ha-select>
            <ha-select label="Close Animation" .value=${p("popup_close_animation") || p("popup_open_animation") || "scale"}
              @selected=${(ev) => { ev.stopPropagation(); pp({ "popup_close_animation": ev.target.value }); }}
              @closed=${(ev) => ev.stopPropagation()}>
              ${popupAnimOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
            </ha-select>
          </div>
          <ha-textfield label="Animation Duration (ms)" type="number" .value=${String(p("popup_animation_duration") ?? 300)} @input=${(ev) => pp({ "popup_animation_duration": Number(ev.target.value) })}></ha-textfield>
        </div>
      </details>

      <details class="box-section">
        <summary>Container & Size</summary>
        <div class="box-content">
          <ha-textfield label="Border Radius (px)" type="number" .value=${String(p("popup_border_radius") ?? 16)} @input=${(ev) => pp({ "popup_border_radius": Number(ev.target.value) })}></ha-textfield>
          <div class="inline-fields-2">
            <ha-select label="Width" .value=${p("popup_width") || "auto"}
              @selected=${(ev) => { ev.stopPropagation(); pp({ "popup_width": ev.target.value }); }}
              @closed=${(ev) => ev.stopPropagation()}>
              ${popupWidthOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
            </ha-select>
            ${p("popup_width") === "custom" ? html`<ha-textfield label="Custom Width (px)" type="number" .value=${String(p("popup_width_custom") ?? 400)} @input=${(ev) => pp({ "popup_width_custom": Number(ev.target.value) })}></ha-textfield>` : html`<div></div>`}
          </div>
          <div class="inline-fields-2">
            <ha-select label="Height" .value=${p("popup_height") || "auto"}
              @selected=${(ev) => { ev.stopPropagation(); pp({ "popup_height": ev.target.value }); }}
              @closed=${(ev) => ev.stopPropagation()}>
              ${popupHeightOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
            </ha-select>
            ${p("popup_height") === "custom" ? html`<ha-textfield label="Custom Height (px)" type="number" .value=${String(p("popup_height_custom") ?? 600)} @input=${(ev) => pp({ "popup_height_custom": Number(ev.target.value) })}></ha-textfield>` : html`<div></div>`}
          </div>
        </div>
      </details>

      <details class="box-section">
        <summary>Blur & Glass Effect</summary>
        <div class="box-content">
          <p style="font-size: 11px; opacity: 0.7; margin: 0 0 4px 0;">Background (portal)</p>
          <div class="switch-row">
            <ha-switch .checked=${p("popup_blur_enabled") !== false} @change=${(ev) => pp({ "popup_blur_enabled": ev.target.checked })}></ha-switch>
            <span>Enable background blur</span>
          </div>
          <ha-textfield label="Blur Amount (px)" type="number" .value=${String(p("popup_blur_amount") ?? 10)} @input=${(ev) => pp({ "popup_blur_amount": Number(ev.target.value) })} .disabled=${p("popup_blur_enabled") === false}></ha-textfield>
          <p style="font-size: 11px; opacity: 0.7; margin: 4px 0 4px 0;">Card glass effect</p>
          <div class="switch-row">
            <ha-switch .checked=${p("popup_card_blur_enabled") !== false} @change=${(ev) => pp({ "popup_card_blur_enabled": ev.target.checked })}></ha-switch>
            <span>Enable card blur (frosted glass)</span>
          </div>
          <div class="inline-fields-2">
            <ha-textfield label="Card Blur (px)" type="number" .value=${String(p("popup_card_blur_amount") ?? 40)} @input=${(ev) => pp({ "popup_card_blur_amount": Number(ev.target.value) })} .disabled=${p("popup_card_blur_enabled") === false}></ha-textfield>
            <ha-textfield label="Card Opacity" type="number" step="0.1" min="0" max="1" .value=${String(p("popup_card_opacity") ?? 0.4)} @input=${(ev) => pp({ "popup_card_opacity": Number(ev.target.value) })}></ha-textfield>
          </div>
        </div>
      </details>

      ${!enabled ? html`
        ${(hasChildren) ? html`
          <details class="box-section">
            <summary>Default View (Groups)</summary>
            <div class="box-content">
              <div class="inline-fields-2">
                <ha-select label="Default View" .value=${p("popup_default_view") || "main"}
                  @selected=${(ev) => { ev.stopPropagation(); pp({ "popup_default_view": ev.target.value }); }}
                  @closed=${(ev) => ev.stopPropagation()}>
                  ${popupDefaultViewOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                </ha-select>
                ${isLightGroup ? html`
                  <ha-select label="Default Section" .value=${p("popup_default_section") || "last"}
                    @selected=${(ev) => { ev.stopPropagation(); pp({ "popup_default_section": ev.target.value }); }}
                    @closed=${(ev) => ev.stopPropagation()}>
                    ${popupDefaultSectionOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                  </ha-select>
                ` : html`<div></div>`}
              </div>
            </div>
          </details>
        ` : ''}

        ${(domain === 'light' || domain === 'cover') ? html`
          <details class="box-section">
            <summary>Features</summary>
            <div class="box-content">
              <div class="switch-row"><ha-switch .checked=${p("popup_show_favorites") !== false} @change=${(ev) => pp({ "popup_show_favorites": ev.target.checked })}></ha-switch><span>Show Favorites</span></div>
              ${domain === 'light' ? html`<div class="switch-row"><ha-switch .checked=${p("popup_show_effects") !== false} @change=${(ev) => pp({ "popup_show_effects": ev.target.checked })}></ha-switch><span>Show Effects</span></div>` : ''}
              <div class="switch-row"><ha-switch .checked=${p("popup_hide_bottom_bar") !== true} @change=${(ev) => pp({ popup_hide_bottom_bar: !ev.target.checked })}></ha-switch><span>Show bottom bar</span></div>
              <div class="switch-row"><ha-switch .checked=${p("popup_hide_top_bar") !== true} @change=${(ev) => pp({ popup_hide_top_bar: !ev.target.checked })}></ha-switch><span>Show top bar</span></div>
              ${p("popup_hide_top_bar") === true ? html`
                <div class="switch-row"><ha-switch .checked=${p("popup_show_close_button") !== false} @change=${(ev) => pp({ popup_show_close_button: ev.target.checked })}></ha-switch><span>Show close button</span></div>
              ` : ''}
              <div class="switch-row"><ha-switch .checked=${p("popup_close_on_action") === true} @change=${(ev) => pp({ popup_close_on_action: ev.target.checked })}></ha-switch><span>Close popup after perform-action</span></div>
            </div>
          </details>
        ` : ''}

        ${domain === 'climate' ? html`
          <details class="box-section">
            <summary>Climate Options</summary>
            <div class="box-content">
              <div class="switch-row"><ha-switch .checked=${p("popup_show_presets") !== false} @change=${(ev) => pp({ "popup_show_presets": ev.target.checked })}></ha-switch><span>Show Presets</span></div>
              <ha-textfield label="Temperature Step Size" type="number" step="0.1" .value=${String(p("climate_temp_step") ?? 0.5)} @input=${(ev) => pp({ "climate_temp_step": Number(ev.target.value) })} placeholder="0.5"></ha-textfield>
              <div class="switch-row"><ha-switch .checked=${p("climate_use_circular_slider") === true} @change=${(ev) => pp({ "climate_use_circular_slider": ev.target.checked })}></ha-switch><span>Use Circular Slider</span></div>
              <div class="switch-row"><ha-switch .checked=${p("climate_show_plus_minus") === true} @change=${(ev) => pp({ "climate_show_plus_minus": ev.target.checked })}></ha-switch><span>Show +/- Buttons</span></div>
              <div class="switch-row"><ha-switch .checked=${p("climate_show_gradient") !== false} @change=${(ev) => pp({ "climate_show_gradient": ev.target.checked })}></ha-switch><span>Show Gradient</span></div>
              <div class="switch-row"><ha-switch .checked=${p("climate_show_target_range") !== false} @change=${(ev) => pp({ "climate_show_target_range": ev.target.checked })}></ha-switch><span>Show Min/Max Target Range (if supported)</span></div>
              <p style="font-size: 12px; font-weight: 500; margin: 8px 0 4px 0;">Extra Sensors (optional)</p>
              <ha-entity-picker .hass=${this.hass} label="Current Temperature Entity" .value=${p("climate_current_temperature_entity") || ""} @value-changed=${(ev) => pp({ "climate_current_temperature_entity": ev.detail.value || undefined })}></ha-entity-picker>
              <ha-textfield label="Temperature Sensor Name" .value=${p("climate_temperature_name") || ""} @input=${(ev) => pp({ "climate_temperature_name": ev.target.value || undefined })}></ha-textfield>
              <ha-entity-picker .hass=${this.hass} label="Humidity Entity" .value=${p("climate_humidity_entity") || ""} @value-changed=${(ev) => pp({ "climate_humidity_entity": ev.detail.value || undefined })}></ha-entity-picker>
              <ha-textfield label="Humidity Sensor Name" .value=${p("climate_humidity_name") || ""} @input=${(ev) => pp({ "climate_humidity_name": ev.target.value || undefined })}></ha-textfield>
              <ha-entity-picker .hass=${this.hass} label="Pressure Entity" .value=${p("climate_pressure_entity") || ""} @value-changed=${(ev) => pp({ "climate_pressure_entity": ev.detail.value || undefined })}></ha-entity-picker>
              <ha-textfield label="Pressure Sensor Name" .value=${p("climate_pressure_name") || ""} @input=${(ev) => pp({ "climate_pressure_name": ev.target.value || undefined })}></ha-textfield>
            </div>
          </details>
        ` : ''}

        ${domain === 'humidifier' ? html`
          <details class="box-section">
            <summary>Humidifier Options</summary>
            <div class="box-content">
              <ha-textfield label="Humidity Step Size" type="number" step="1" .value=${String(p("humidifier_humidity_step") ?? 1)} @input=${(ev) => pp({ "humidifier_humidity_step": Number(ev.target.value) })} placeholder="1"></ha-textfield>
              <div class="switch-row"><ha-switch .checked=${p("humidifier_use_circular_slider") === true} @change=${(ev) => pp({ "humidifier_use_circular_slider": ev.target.checked })}></ha-switch><span>Use Circular Slider</span></div>
              <div class="switch-row"><ha-switch .checked=${p("humidifier_show_plus_minus") === true} @change=${(ev) => pp({ "humidifier_show_plus_minus": ev.target.checked })}></ha-switch><span>Show +/- Buttons</span></div>
              <div class="switch-row"><ha-switch .checked=${p("humidifier_show_gradient") !== false} @change=${(ev) => pp({ "humidifier_show_gradient": ev.target.checked })}></ha-switch><span>Show Gradient</span></div>
              <ha-entity-picker .hass=${this.hass} label="Fan Speed Entity (select or fan)" .value=${p("humidifier_fan_entity") || ""} @value-changed=${(ev) => pp({ "humidifier_fan_entity": ev.detail.value || undefined })}></ha-entity-picker>
            </div>
          </details>
        ` : ''}

        ${(domain === 'sensor' || domain === 'input_number') ? html`
          <details class="box-section">
            <summary>Sensor Graph Options</summary>
            <div class="box-content">
              <ha-select label="Graph Style" .value=${p("sensor_graph_style") || "line"}
                @selected=${(ev) => { ev.stopPropagation(); pp({ sensor_graph_style: ev.target.value }); }}
                @closed=${(ev) => ev.stopPropagation()}>
                <mwc-list-item value="line">Line Graph</mwc-list-item>
                <mwc-list-item value="bar">Bar Chart</mwc-list-item>
              </ha-select>
              <div class="switch-row"><ha-switch .checked=${p("sensor_graph_gradient") !== false} @change=${(ev) => pp({ sensor_graph_gradient: ev.target.checked })}></ha-switch><span>Temperature Gradient</span></div>
              <ha-textfield label="Fixed Line Color (overrides gradient)" .value=${p("sensor_graph_color") || ""} @input=${(ev) => pp({ sensor_graph_color: ev.target.value || undefined })} placeholder="e.g. #2196F3"></ha-textfield>
              <ha-textfield label="Line Width (px)" type="number" .value=${String(p("sensor_line_width") ?? 3)} @input=${(ev) => pp({ sensor_line_width: Number(ev.target.value) })}></ha-textfield>
              <ha-textfield label="Default Time Range (hours)" type="number" .value=${String(p("sensor_hours") ?? 24)} @input=${(ev) => pp({ sensor_hours: Number(ev.target.value) })} placeholder="24"></ha-textfield>
            </div>
          </details>
        ` : ''}

        ${domain === 'person' ? html`
          <details class="box-section">
            <summary>Person Map Options</summary>
            <div class="box-content">
              <p style="font-size: 11px; opacity: 0.7; margin: 0 0 6px 0;">Link a geocoded address sensor to show the real street address on the map pin.</p>
              <ha-entity-picker .hass=${this.hass} label="Geocoded Address Entity" .value=${p("person_geocoded_entity") || ""}
                @value-changed=${(ev) => pp({ person_geocoded_entity: ev.detail.value || undefined })}
                allow-custom-entity></ha-entity-picker>
            </div>
          </details>
        ` : ''}

        <details class="box-section">
          <summary>Content Display</summary>
          <div class="box-content">
            <ha-textfield label="Slider Border Radius (px)" type="number" .value=${String(p("popup_slider_radius") ?? 12)} @input=${(ev) => pp({ "popup_slider_radius": Number(ev.target.value) })}></ha-textfield>
            <div class="switch-row"><ha-switch .checked=${p("popup_hide_button_text") === true} @change=${(ev) => pp({ "popup_hide_button_text": ev.target.checked })}></ha-switch><span>Hide Text Under Buttons</span></div>
            <p style="font-size: 11px; opacity: 0.7; margin: 4px 0 2px 0;">Value Display (Temperature/Brightness)</p>
            <div class="inline-fields-2">
              <ha-textfield label="Font Size (px)" type="number" .value=${String(p("popup_value_font_size") ?? 36)} @input=${(ev) => pp({ "popup_value_font_size": Number(ev.target.value) })}></ha-textfield>
              <ha-textfield label="Font Weight" type="number" .value=${String(p("popup_value_font_weight") ?? 300)} @input=${(ev) => pp({ "popup_value_font_weight": Number(ev.target.value) })}></ha-textfield>
            </div>
            <p style="font-size: 11px; opacity: 0.7; margin: 4px 0 2px 0;">Label Display (Color/Mode Names)</p>
            <div class="inline-fields-2">
              <ha-textfield label="Font Size (px)" type="number" .value=${String(p("popup_label_font_size") ?? 16)} @input=${(ev) => pp({ "popup_label_font_size": Number(ev.target.value) })}></ha-textfield>
              <ha-textfield label="Font Weight" type="number" .value=${String(p("popup_label_font_weight") ?? 400)} @input=${(ev) => pp({ "popup_label_font_weight": Number(ev.target.value) })}></ha-textfield>
            </div>
            <ha-select label="Time Format" .value=${p("popup_time_format") || "auto"}
              @selected=${(ev) => { ev.stopPropagation(); pp({ "popup_time_format": ev.target.value }); }}
              @closed=${(ev) => ev.stopPropagation()}>
              ${popupTimeFormatOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
            </ha-select>
          </div>
        </details>

        <details class="box-section">
          <summary>Active Button Styling</summary>
          <div class="box-content">
            <div class="inline-fields-2">
              <ha-textfield label="Color" .value=${p("popup_highlight_color") || ""} @input=${(ev) => pp({ "popup_highlight_color": ev.target.value || undefined })} placeholder="var(--primary-color)"></ha-textfield>
              <ha-textfield label="Text Color" .value=${p("popup_highlight_text_color") || ""} @input=${(ev) => pp({ "popup_highlight_text_color": ev.target.value || undefined })} placeholder="white"></ha-textfield>
            </div>
            <div class="inline-fields-2">
              <ha-textfield label="Border Radius (px)" type="number" .value=${p("popup_highlight_radius") ?? ""} @input=${(ev) => pp({ "popup_highlight_radius": Number(ev.target.value) || undefined })} placeholder="8"></ha-textfield>
              <ha-textfield label="Opacity" type="number" step="0.1" min="0" max="1" .value=${p("popup_highlight_opacity") ?? ""} @input=${(ev) => pp({ "popup_highlight_opacity": Number(ev.target.value) || undefined })} placeholder="1"></ha-textfield>
            </div>
            <div class="inline-fields-2">
              <ha-textfield label="Border Color" .value=${p("popup_highlight_border_color") || ""} @input=${(ev) => pp({ "popup_highlight_border_color": ev.target.value || undefined })}></ha-textfield>
              <ha-textfield label="Border Width" .value=${p("popup_highlight_border_width") || ""} @input=${(ev) => pp({ "popup_highlight_border_width": ev.target.value || undefined })}></ha-textfield>
            </div>
            <ha-textfield label="Box Shadow" .value=${p("popup_highlight_box_shadow") || ""} @input=${(ev) => pp({ "popup_highlight_box_shadow": ev.target.value || undefined })}></ha-textfield>
          </div>
        </details>

        <details class="box-section">
          <summary>Button Styling</summary>
          <div class="box-content">
            <div class="inline-fields-2">
              <ha-textfield label="Background" .value=${p("popup_button_bg") || ""} @input=${(ev) => pp({ "popup_button_bg": ev.target.value || undefined })}></ha-textfield>
              <ha-textfield label="Text Color" .value=${p("popup_button_text_color") || ""} @input=${(ev) => pp({ "popup_button_text_color": ev.target.value || undefined })}></ha-textfield>
            </div>
            <div class="inline-fields-2">
              <ha-textfield label="Border Radius (px)" type="number" .value=${p("popup_button_radius") ?? ""} @input=${(ev) => pp({ "popup_button_radius": Number(ev.target.value) || undefined })}></ha-textfield>
              <ha-textfield label="Opacity" type="number" step="0.1" min="0" max="1" .value=${p("popup_button_opacity") ?? ""} @input=${(ev) => pp({ "popup_button_opacity": Number(ev.target.value) || undefined })}></ha-textfield>
            </div>
            <div class="inline-fields-2">
              <ha-textfield label="Border Color" .value=${p("popup_button_border_color") || ""} @input=${(ev) => pp({ "popup_button_border_color": ev.target.value || undefined })}></ha-textfield>
              <ha-textfield label="Border Width" .value=${p("popup_button_border_width") || ""} @input=${(ev) => pp({ "popup_button_border_width": ev.target.value || undefined })}></ha-textfield>
            </div>
          </div>
        </details>

        <details class="box-section">
          <summary>Bottom Bar Entities</summary>
          <div class="box-content">
            <p style="font-size: 11px; opacity: 0.7; margin: 0 0 6px 0;">Add up to 8 icon buttons to the popup bottom bar.</p>
            <ha-select label="Button Alignment" .value=${p('popup_bottom_bar_align') || 'spread'}
              @selected=${(ev) => { ev.stopPropagation(); pp({ popup_bottom_bar_align: ev.target.value }); }}
              @closed=${(ev) => ev.stopPropagation()}>
              ${popupBottomBarAlignOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
            </ha-select>
            ${(() => {
              const _bbSlots = Math.max(1, Math.min(8, p('_bb_slots') ?? Math.max(1, (p('popup_bottom_bar_entities') || []).filter(Boolean).length || 1)));
              return html`
                <div style="display:flex;align-items:center;gap:8px;margin:10px 0 4px 0;">
                  <span style="font-size:12px;opacity:0.7;flex:1;">Slots: ${_bbSlots}</span>
                  <button style="width:28px;height:28px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);background:rgba(255,255,255,0.06);color:var(--primary-text-color);cursor:pointer;font-size:16px;display:flex;align-items:center;justify-content:center;"
                    @click=${(e) => { e.stopPropagation(); pp({ _bb_slots: Math.max(1, _bbSlots - 1) }); }}>&#8722;</button>
                  <button style="width:28px;height:28px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);background:rgba(255,255,255,0.06);color:var(--primary-text-color);cursor:pointer;font-size:16px;display:flex;align-items:center;justify-content:center;"
                    @click=${(e) => { e.stopPropagation(); pp({ _bb_slots: Math.min(8, _bbSlots + 1) }); }}>+</button>
                </div>
                ${Array.from({ length: _bbSlots }, (_, i) => {
                  const _ents = (p('popup_bottom_bar_entities') || []);
                  const _ent = _ents[i] || {};
                  const _tap = _ent.tap_action || { action: 'more-info' };
                  const _act = _tap.action || 'more-info';
                  const setSlot = (patch) => {
                    const src = (p('popup_bottom_bar_entities') || []);
                    const arr = Array.from({ length: Math.max(src.length, i + 1) }, (_, j) => src[j] || null);
                    arr[i] = { ...(arr[i] || {}), ...patch };
                    while (arr.length > 0 && !arr[arr.length - 1]?.entity) arr.pop();
                    pp({ popup_bottom_bar_entities: arr.length ? arr : undefined });
                  };
                  const moveSlot = (toIndex) => {
                    const src = (p('popup_bottom_bar_entities') || []);
                    if (toIndex < 0 || toIndex >= _bbSlots || toIndex === i) return;
                    const arr = Array.from({ length: Math.max(src.length, _bbSlots) }, (_, j) => src[j] || null);
                    [arr[toIndex], arr[i]] = [arr[i], arr[toIndex]];
                    while (arr.length > 0 && !arr[arr.length - 1]?.entity) arr.pop();
                    pp({ popup_bottom_bar_entities: arr.length ? arr : undefined });
                  };
                  const setTap = (tap) => setSlot({ tap_action: { ..._tap, ...tap } });
                  return html`
                    <div style="margin-top:8px;padding:10px;background:rgba(255,255,255,0.04);border-radius:10px;">
                      <div style="display:flex;justify-content:space-between;align-items:center;">
                        <p style="font-size:11px;opacity:0.7;margin:0 0 6px 0;font-weight:600;">Button ${i+1}</p>
                        <div style="display:flex;align-items:center;gap:2px;">
                          <mwc-icon-button ?disabled=${i === 0} @click=${() => moveSlot(i - 1)}><ha-icon icon="mdi:chevron-up"></ha-icon></mwc-icon-button>
                          <mwc-icon-button ?disabled=${i === _bbSlots - 1} @click=${() => moveSlot(i + 1)}><ha-icon icon="mdi:chevron-down"></ha-icon></mwc-icon-button>
                        </div>
                      </div>
                      <ha-entity-picker .hass=${this.hass} .value=${_ent.entity||''} .label=${"Entity"}
                        @value-changed=${(ev) => setSlot({ entity: ev.detail.value || undefined })}
                        allow-custom-entity></ha-entity-picker>
                      ${_ent.entity ? html`
                        <ha-textfield label="Name (optional)" .value=${_ent.name||''}
                          @input=${(ev) => setSlot({ name: ev.target.value || undefined })} style="margin-top:6px;"></ha-textfield>
                        <ha-textfield label="Icon (optional)" .value=${_ent.icon||''} placeholder="mdi:home"
                          @input=${(ev) => setSlot({ icon: ev.target.value || undefined })} style="margin-top:6px;"></ha-textfield>
                        <ha-select label="Tap Action" .value=${_act}
                          @selected=${(ev) => { ev.stopPropagation(); const v=ev.detail?.value||ev.target?.value; if(v && v!==_act) setTap({ action:v }); }}
                          @closed=${(e)=>e.stopPropagation()} @click=${(e)=>e.stopPropagation()} style="margin-top:6px;">
                          ${popupBottomBarActionOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                        </ha-select>
                        ${_act==='navigate'?html`<ha-textfield label="Navigation Path" .value=${_tap.navigation_path||''} @input=${(ev)=>setTap({navigation_path:ev.target.value})} style="margin-top:6px;"></ha-textfield>`:''}
                        ${_act==='url'?html`<ha-textfield label="URL" .value=${_tap.url_path||''} @input=${(ev)=>setTap({url_path:ev.target.value})} style="margin-top:6px;"></ha-textfield>`:''}
                        ${_act==='perform-action'?html`<ha-textfield label="Action (domain.service)" .value=${_tap.perform_action||''} @input=${(ev)=>setTap({perform_action:ev.target.value})} style="margin-top:6px;"></ha-textfield>`:''}
                        ${_act==='fire-dom-event'?html`
                          <ha-textfield label="Event Name (optional)" .value=${_tap.event_name||''} @input=${(ev)=>setTap({event_name:ev.target.value})} style="margin-top:6px;"></ha-textfield>
                          <ha-code-editor .hass=${this.hass} .value=${_tap.event_data||''} mode="yaml"
                            @value-changed=${(ev)=>setTap({event_data:ev.detail?.value||''})}
                            @click=${(e)=>e.stopPropagation()}></ha-code-editor>
                        `:''}
                      ` : ''}
                    </div>`;
                })}
              `;
            })()}
          </div>
        </details>
      ` : ''}
    `;
  }
  _renderSlotActionEditor(field) {
    const action = this._config?.[field] || { action: "none" };
    const actionType = action.action || "none";

    const setAction = (nextAction) => {
      this._config = { ...this._config, [field]: nextAction };
      const strippedConfig = this._stripDefaults(this._config);
      this.dispatchEvent(
        new CustomEvent("config-changed", {
          detail: { config: strippedConfig },
          bubbles: true,
          composed: true,
        })
      );
      this.requestUpdate();
    };

      const patchAction = (patch) => {
        const current = this._config?.[field] || { action: "none" };
        setAction({ ...current, ...patch });
      };
      const headerActionOptions = HKI_EDITOR_OPTIONS.headerActionOptions;
    
      return html`
      <ha-select label="Action" .value=${actionType} data-field="${field}.action" @selected=${this._changed} @closed=${this._changed}>
        ${headerActionOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
      </ha-select>
      ${actionType === "navigate" ? html`
        ${this._renderNavigationPathPicker("Navigation path", action.navigation_path || "", (v) => patchAction({ navigation_path: v }))}
      ` : ''}
      ${actionType === "url" ? html`
        <ha-textfield label="URL" .value=${action.url_path || ""} data-field="${field}.url_path" @input=${this._changed}></ha-textfield>
      ` : ''}
      ${actionType === "more-info" || actionType === "toggle" ? html`
        <ha-entity-picker .hass=${this.hass} .value=${action.entity || ""} @value-changed=${(e) => this._changed(e, field + ".entity")}></ha-entity-picker>
      ` : ''}
      ${actionType === "hki-more-info" ? html`
        <ha-entity-picker .hass=${this.hass} .value=${action.entity || ""} label="Override Entity" @value-changed=${(e) => patchAction({ entity: e.detail.value || undefined })}></ha-entity-picker>
        <p style="font-size: 11px; opacity: 0.7; margin: 8px 0 4px 0;">Popup settings (card, animations, header) are configured in the slot's "Custom Popup" section above.</p>
      ` : ''}
      ${actionType === "fire-dom-event" ? html`
        <ha-textfield label="Event Name (optional)" .value=${action.event_name || ""} @input=${(e) => patchAction({ event_name: e.target.value || "" })}></ha-textfield>
        <div class="section">Event Data (YAML/JSON text)</div>
        <ha-code-editor
          .hass=${this.hass}
          .value=${action.event_data || ""}
          mode="yaml"
          @value-changed=${(e) => patchAction({ event_data: e.detail?.value || "" })}
          @click=${(e) => e.stopPropagation()}
        ></ha-code-editor>
      ` : ''}
      ${actionType === "perform-action" ? html`
        ${customElements.get("ha-service-picker") ? html`
          <ha-service-picker
            .hass=${this.hass}
            .label=${"Action (service)"}
            .value=${action.perform_action || ""}
            @value-changed=${(ev) => {
              ev.stopPropagation();
              const v = ev.detail?.value ?? ev.target?.value ?? "";
              patchAction({ perform_action: String(v || "") });
            }}
            @click=${(e) => e.stopPropagation()}
          ></ha-service-picker>
        ` : html`
          ${(() => {
            const key = `${field}`;
            const full = String(action.perform_action || "");
            const derivedDomain = full.includes(".") ? full.split(".")[0] : "";
            const cachedDomain = this._paDomainCache?.[key] || "";
            const domain = cachedDomain || derivedDomain;
            const derivedService = (full.includes(".") && derivedDomain === domain)
              ? (full.split(".")[1] || "")
              : "";
            const services = (domain && this.hass?.services?.[domain])
              ? Object.keys(this.hass.services[domain]).sort()
              : [];
            return html`
              <div class="inline-fields-2">
                <ha-select
                  label="Domain"
                  .value=${domain || undefined}
                  @selected=${(e) => {
                    const nextDomain = e.target.value || "";
                    this._paDomainCache[key] = nextDomain;
                    // Clear service when domain changes
                    patchAction({ perform_action: "" });
                    this.requestUpdate();
                  }}
                  @closed=${(e) => e.stopPropagation()}
                  @click=${(e) => e.stopPropagation()}
                >
                  <mwc-list-item value=""></mwc-list-item>
                  ${Object.keys(this.hass?.services || {}).sort().map((d) => html`<mwc-list-item .value=${d}>${d}</mwc-list-item>`)}
                </ha-select>

                <ha-select
                  label="Service"
                  .value=${derivedService || undefined}
                  .disabled=${!domain}
                  @selected=${(e) => {
                    const service = e.target.value || "";
                    const d = this._paDomainCache[key] || domain;
                    patchAction({ perform_action: (d && service) ? `${d}.${service}` : "" });
                  }}
                  @closed=${(e) => e.stopPropagation()}
                  @click=${(e) => e.stopPropagation()}
                >
                  <mwc-list-item value=""></mwc-list-item>
                  ${services.map((s) => html`<mwc-list-item .value=${s}>${s}</mwc-list-item>`)}
                </ha-select>
              </div>
            `;
          })()}
        `}

        <ha-selector
          .hass=${this.hass}
          .selector=${{ target: {} }}
          .label=${"Target (optional)"}
          .value=${action.target || null}
          @value-changed=${(ev) => {
            ev.stopPropagation();
            const target = ev.detail?.value;
            const currentTarget = action.target;
            if (JSON.stringify(currentTarget) !== JSON.stringify(target)) {
              const updated = { ...action };
              if (target && Object.keys(target).length > 0) {
                updated.target = target;
              } else {
                delete updated.target;
              }
              setAction(updated);
            }
          }}
          @click=${(e) => e.stopPropagation()}
        ></ha-selector>

        <ha-yaml-editor
          .hass=${this.hass}
          .label=${"Service Data (optional, YAML)"}
          .value=${action.data || null}
          @value-changed=${(ev) => {
            ev.stopPropagation();
            const data = ev.detail?.value;
            const currentData = action.data;
            if (JSON.stringify(currentData) !== JSON.stringify(data)) {
              const updated = { ...action };
              if (data && typeof data === "object" && Object.keys(data).length > 0) {
                updated.data = data;
              } else {
                delete updated.data;
              }
              setAction(updated);
            }
          }}
          @click=${(e) => e.stopPropagation()}
        ></ha-yaml-editor>
      ` : ''}
    `;
  }

  _renderPersonActionEditors(personIndex) {
    const personConfig = this._config.persons_entities[personIndex];
    
    const renderPersonAction = (label, actionType) => {
      const action = personConfig[actionType] || { action: actionType === "tap_action" ? "more-info" : "none" };
      const actionValue = action.action || "none";

      const setAction = (nextAction) => {
        const updated = [...this._config.persons_entities];
        updated[personIndex] = { ...updated[personIndex], [actionType]: nextAction };
        this._config = { ...this._config, persons_entities: updated };
        const strippedConfig = this._stripDefaults(this._config);
        this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
        this.requestUpdate();
      };

      const patchAction = (patch) => {
        const current = personConfig[actionType] || { action: "none" };
        setAction({ ...current, ...patch });
      };
      const headerActionOptions = HKI_EDITOR_OPTIONS.headerActionOptions;

      return html`
        <div style="margin-top: 8px;">
          <p style="font-weight: 500; margin-bottom: 4px; font-size: 0.9em;">${label}</p>
          <ha-select label="Action" .value=${actionValue} @selected=${(e) => setAction({ action: e.target.value })} @closed=${(e) => e.stopPropagation()}>
            ${headerActionOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
          </ha-select>
          ${actionValue === "navigate" ? html`
            ${this._renderNavigationPathPicker("Navigation path", action.navigation_path || "", (v) => patchAction({ navigation_path: v }))}
          ` : ''}
          ${actionValue === "url" ? html`
            <ha-textfield label="URL" .value=${action.url_path || ""} @input=${(e) => patchAction({ url_path: e.target.value })}></ha-textfield>
          ` : ''}
          ${actionValue === "more-info" || actionValue === "toggle" ? html`
            <ha-entity-picker .hass=${this.hass} .value=${action.entity || personConfig.entity || ""} @value-changed=${(e) => patchAction({ entity: e.detail.value })}></ha-entity-picker>
          ` : ''}
          ${actionValue === "hki-more-info" ? html`
            <ha-entity-picker .hass=${this.hass} .value=${action.entity || personConfig.entity || ""} label="Override Entity" @value-changed=${(e) => patchAction({ entity: e.detail.value || undefined })}></ha-entity-picker>
            <p style="font-size: 11px; opacity: 0.7; margin: 8px 0 4px 0;">Popup settings are configured in the person's "Custom Popup" section.</p>
          ` : ''}
          ${actionValue === "fire-dom-event" ? html`
            <ha-textfield label="Event Name (optional)" .value=${action.event_name || ""} @input=${(e) => patchAction({ event_name: e.target.value || "" })}></ha-textfield>
            <div class="section">Event Data (YAML/JSON text)</div>
            <ha-code-editor
              .hass=${this.hass}
              .value=${action.event_data || ""}
              mode="yaml"
              @value-changed=${(e) => patchAction({ event_data: e.detail?.value || "" })}
              @click=${(e) => e.stopPropagation()}
            ></ha-code-editor>
          ` : ''}
          ${actionValue === "perform-action" ? html`
            ${customElements.get("ha-service-picker") ? html`
              <ha-service-picker
                .hass=${this.hass}
                .label=${"Action (service)"}
                .value=${action.perform_action || ""}
                @value-changed=${(ev) => {
                  ev.stopPropagation();
                  const v = ev.detail?.value ?? ev.target?.value ?? "";
                  patchAction({ perform_action: String(v || "") });
                }}
                @click=${(e) => e.stopPropagation()}
              ></ha-service-picker>
            ` : html`
              ${(() => {
                const key = `person_${personIndex}_${actionType}`;
                const full = String(action.perform_action || "");
                const derivedDomain = full.includes(".") ? full.split(".")[0] : "";
                const cachedDomain = this._paDomainCache?.[key] || "";
                const domain = cachedDomain || derivedDomain;
                const derivedService = (full.includes(".") && derivedDomain === domain)
                  ? (full.split(".")[1] || "")
                  : "";
                const services = (domain && this.hass?.services?.[domain])
                  ? Object.keys(this.hass.services[domain]).sort()
                  : [];
                return html`
                  <div class="inline-fields-2">
                    <ha-select
                      label="Domain"
                      .value=${domain || undefined}
                      @selected=${(e) => {
                        const nextDomain = e.target.value || "";
                        this._paDomainCache[key] = nextDomain;
                        patchAction({ perform_action: "" });
                        this.requestUpdate();
                      }}
                      @closed=${(e) => e.stopPropagation()}
                      @click=${(e) => e.stopPropagation()}
                    >
                      <mwc-list-item value=""></mwc-list-item>
                      ${Object.keys(this.hass?.services || {}).sort().map((d) => html`<mwc-list-item .value=${d}>${d}</mwc-list-item>`)}
                    </ha-select>

                    <ha-select
                      label="Service"
                      .value=${derivedService || undefined}
                      .disabled=${!domain}
                      @selected=${(e) => {
                        const service = e.target.value || "";
                        const d = this._paDomainCache[key] || domain;
                        patchAction({ perform_action: (d && service) ? `${d}.${service}` : "" });
                      }}
                      @closed=${(e) => e.stopPropagation()}
                      @click=${(e) => e.stopPropagation()}
                    >
                      <mwc-list-item value=""></mwc-list-item>
                      ${services.map((s) => html`<mwc-list-item .value=${s}>${s}</mwc-list-item>`)}
                    </ha-select>
                  </div>
                `;
              })()}
            `}

            <ha-selector
              .hass=${this.hass}
              .selector=${{ target: {} }}
              .label=${"Target (optional)"}
              .value=${action.target || null}
              @value-changed=${(ev) => {
                ev.stopPropagation();
                const target = ev.detail?.value;
                const currentTarget = action.target;
                if (JSON.stringify(currentTarget) !== JSON.stringify(target)) {
                  const updated = { ...action };
                  if (target && Object.keys(target).length > 0) {
                    updated.target = target;
                  } else {
                    delete updated.target;
                  }
                  setAction(updated);
                }
              }}
              @click=${(e) => e.stopPropagation()}
            ></ha-selector>

            <ha-yaml-editor
              .hass=${this.hass}
              .label=${"Service Data (optional, YAML)"}
              .value=${action.data || null}
              @value-changed=${(ev) => {
                ev.stopPropagation();
                const data = ev.detail?.value;
                const currentData = action.data;
                if (JSON.stringify(currentData) !== JSON.stringify(data)) {
                  const updated = { ...action };
                  if (data && typeof data === "object" && Object.keys(data).length > 0) {
                    updated.data = data;
                  } else {
                    delete updated.data;
                  }
                  setAction(updated);
                }
              }}
              @click=${(e) => e.stopPropagation()}
            ></ha-yaml-editor>
          ` : ''}
        </div>
      `;
    };

    const patchPerson = (patch) => {
      const updated = [...this._config.persons_entities];
      updated[personIndex] = { ...updated[personIndex], ...patch };
      this._config = { ...this._config, persons_entities: updated };
      const strippedConfig = this._stripDefaults(this._config);
      this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
      this.requestUpdate();
    };

    // Person popup editor â€” accordion layout matching slot editor
    const pc = personConfig;
    const pv = (k) => pc[k];
    const pp = patchPerson;
    const personActions = [pc.tap_action, pc.hold_action, pc.double_tap_action].filter(Boolean);
    const p_ent = personActions.find((a) => a?.action === "hki-more-info" && a?.entity)?.entity
      || personActions.find((a) => a?.entity)?.entity
      || pc.entity
      || '';
    const p_domain = p_ent ? p_ent.split('.')[0] : null;
    const p_entState = (p_ent && this.hass?.states?.[p_ent]) || null;
    const p_hasChildren = p_entState?.attributes?.entity_id && Array.isArray(p_entState.attributes.entity_id);
    const p_isLightGroup = p_domain === 'light' && p_hasChildren;
    const p_enabled = !!pv('custom_popup_enabled');
    const popupAnimOptions = HKI_POPUP_EDITOR_OPTIONS.animations;
    const popupWidthOptions = HKI_POPUP_EDITOR_OPTIONS.width;
    const popupHeightOptions = HKI_POPUP_EDITOR_OPTIONS.height;
    const popupTimeFormatOptions = HKI_POPUP_EDITOR_OPTIONS.timeFormats;
    const popupBottomBarActionOptions = HKI_EDITOR_OPTIONS.popupBottomBarActionOptions;
    const popupDefaultViewOptions = HKI_EDITOR_OPTIONS.popupDefaultViewOptions;
    const popupDefaultSectionOptions = HKI_EDITOR_OPTIONS.popupDefaultSectionOptions;
    const popupBottomBarAlignOptions = HKI_EDITOR_OPTIONS.popupBottomBarAlignOptions;

    return html`
      <details class="box-section" open>
        <summary>Actions</summary>
        <div class="box-content">
          ${renderPersonAction('Tap action', 'tap_action')}
          ${renderPersonAction('Hold action', 'hold_action')}
          ${renderPersonAction('Double tap action', 'double_tap_action')}
        </div>
      </details>

      <details class="box-section">
        <summary>HKI Popup Settings</summary>
        <div class="box-content">
          <p style="font-size: 11px; opacity: 0.7; margin: 0 0 8px 0;">Settings for the HKI More Info popup triggered by this person.</p>

          <details class="box-section">
        <summary>Popup Header</summary>
        <div class="box-content">
          ${this._renderTemplateEditor('Name (optional, supports Jinja)', 'hki_popup_name_person_' + personIndex, { value: pv('popup_name') || '', onchange: (v) => pp({ popup_name: v || undefined }) })}
          ${this._renderTemplateEditor('State text (optional, supports Jinja)', 'hki_popup_state_person_' + personIndex, { value: pv('popup_state') || '', onchange: (v) => pp({ popup_state: v || undefined }) })}
          ${this._renderTemplateEditor('Icon (optional, supports Jinja)', 'hki_popup_icon_person_' + personIndex, { value: pv('popup_icon') || '', placeholder: 'mdi:account or {{ ... }}', onchange: (v) => pp({ popup_icon: v || undefined }) })}
          <div class="switch-row" style="margin-top:6px;">
            <ha-switch .checked=${pv('popup_use_entity_picture') === true} @change=${(ev) => pp({ popup_use_entity_picture: ev.target.checked || undefined })}></ha-switch>
            <span>Use entity picture (if available)</span>
          </div>
        </div>
      </details>

      <details class="box-section" open>
        <summary>Popup Card</summary>
        <div class="box-content">
          <p style="font-size: 11px; opacity: 0.7; margin: 0 0 6px 0;">Enable to show a custom card instead of the auto domain popup.</p>
          <div class="switch-row">
            <ha-switch .checked=${p_enabled} @change=${(ev) => pp({ custom_popup_enabled: ev.target.checked })}></ha-switch>
            <span>Enable custom popup card</span>
          </div>
          ${p_enabled ? html`
            <div class="card-config">
              ${customElements.get('hui-card-element-editor') ? html`
                <hui-card-element-editor
                  .hass=${this.hass}
                  .lovelace=${this._getLovelace()}
                  .value=${pv('custom_popup_card') || { type: 'vertical-stack', cards: [] }}
                  @config-changed=${(ev) => {
                    ev.stopPropagation();
                    const newCard = ev.detail?.config;
                    if (newCard && JSON.stringify(newCard) !== JSON.stringify(pv('custom_popup_card'))) pp({ custom_popup_card: newCard });
                  }}
                ></hui-card-element-editor>
              ` : html`<p style="font-size:11px;opacity:0.6;">Card editor not available. Use YAML mode.</p>`}
            </div>
          ` : ''}
        </div>
      </details>

      <details class="box-section">
        <summary>Animation</summary>
        <div class="box-content">
          <div class="inline-fields-2">
            <ha-select label="Open Animation" .value=${pv('popup_open_animation') || 'scale'}
              @selected=${(ev) => { ev.stopPropagation(); pp({ popup_open_animation: ev.target.value }); }}
              @closed=${(ev) => ev.stopPropagation()}>
              ${popupAnimOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
            </ha-select>
            <ha-select label="Close Animation" .value=${pv('popup_close_animation') || pv('popup_open_animation') || 'scale'}
              @selected=${(ev) => { ev.stopPropagation(); pp({ popup_close_animation: ev.target.value }); }}
              @closed=${(ev) => ev.stopPropagation()}>
              ${popupAnimOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
            </ha-select>
          </div>
          <ha-textfield label="Animation Duration (ms)" type="number" .value=${String(pv('popup_animation_duration') ?? 300)} @input=${(ev) => pp({ popup_animation_duration: Number(ev.target.value) })}></ha-textfield>
        </div>
      </details>

      <details class="box-section">
        <summary>Container & Size</summary>
        <div class="box-content">
          <ha-textfield label="Border Radius (px)" type="number" .value=${String(pv('popup_border_radius') ?? 16)} @input=${(ev) => pp({ popup_border_radius: Number(ev.target.value) })}></ha-textfield>
          <div class="inline-fields-2">
            <ha-select label="Width" .value=${pv('popup_width') || 'auto'}
              @selected=${(ev) => { ev.stopPropagation(); pp({ popup_width: ev.target.value }); }}
              @closed=${(ev) => ev.stopPropagation()}>
              ${popupWidthOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
            </ha-select>
            ${pv('popup_width') === 'custom' ? html`<ha-textfield label="Custom Width (px)" type="number" .value=${String(pv('popup_width_custom') ?? 400)} @input=${(ev) => pp({ popup_width_custom: Number(ev.target.value) })}></ha-textfield>` : html`<div></div>`}
          </div>
          <div class="inline-fields-2">
            <ha-select label="Height" .value=${pv('popup_height') || 'auto'}
              @selected=${(ev) => { ev.stopPropagation(); pp({ popup_height: ev.target.value }); }}
              @closed=${(ev) => ev.stopPropagation()}>
              ${popupHeightOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
            </ha-select>
            ${pv('popup_height') === 'custom' ? html`<ha-textfield label="Custom Height (px)" type="number" .value=${String(pv('popup_height_custom') ?? 600)} @input=${(ev) => pp({ popup_height_custom: Number(ev.target.value) })}></ha-textfield>` : html`<div></div>`}
          </div>
        </div>
      </details>

      <details class="box-section">
        <summary>Blur & Glass Effect</summary>
        <div class="box-content">
          <p style="font-size: 11px; opacity: 0.7; margin: 0 0 4px 0;">Background (portal)</p>
          <div class="switch-row">
            <ha-switch .checked=${pv('popup_blur_enabled') !== false} @change=${(ev) => pp({ popup_blur_enabled: ev.target.checked })}></ha-switch>
            <span>Enable background blur</span>
          </div>
          <ha-textfield label="Blur Amount (px)" type="number" .value=${String(pv('popup_blur_amount') ?? 10)} @input=${(ev) => pp({ popup_blur_amount: Number(ev.target.value) })} .disabled=${pv('popup_blur_enabled') === false}></ha-textfield>
          <p style="font-size: 11px; opacity: 0.7; margin: 4px 0 4px 0;">Card glass effect</p>
          <div class="switch-row">
            <ha-switch .checked=${pv('popup_card_blur_enabled') !== false} @change=${(ev) => pp({ popup_card_blur_enabled: ev.target.checked })}></ha-switch>
            <span>Enable card blur (frosted glass)</span>
          </div>
          <div class="inline-fields-2">
            <ha-textfield label="Card Blur (px)" type="number" .value=${String(pv('popup_card_blur_amount') ?? 40)} @input=${(ev) => pp({ popup_card_blur_amount: Number(ev.target.value) })} .disabled=${pv('popup_card_blur_enabled') === false}></ha-textfield>
            <ha-textfield label="Card Opacity" type="number" step="0.1" min="0" max="1" .value=${String(pv('popup_card_opacity') ?? 0.4)} @input=${(ev) => pp({ popup_card_opacity: Number(ev.target.value) })}></ha-textfield>
          </div>
        </div>
      </details>

      ${!p_enabled ? html`
        ${p_hasChildren ? html`
          <details class="box-section">
            <summary>Default View (Groups)</summary>
            <div class="box-content">
              <div class="inline-fields-2">
                <ha-select label="Default View" .value=${pv('popup_default_view') || 'main'}
                  @selected=${(ev) => { ev.stopPropagation(); pp({ popup_default_view: ev.target.value }); }}
                  @closed=${(ev) => ev.stopPropagation()}>
                  ${popupDefaultViewOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                </ha-select>
                ${p_isLightGroup ? html`
                  <ha-select label="Default Section" .value=${pv('popup_default_section') || 'last'}
                    @selected=${(ev) => { ev.stopPropagation(); pp({ popup_default_section: ev.target.value }); }}
                    @closed=${(ev) => ev.stopPropagation()}>
                    ${popupDefaultSectionOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                  </ha-select>
                ` : html`<div></div>`}
              </div>
            </div>
          </details>
        ` : ''}

        ${(p_domain === 'light' || p_domain === 'cover') ? html`
          <details class="box-section">
            <summary>Features</summary>
            <div class="box-content">
              <div class="switch-row"><ha-switch .checked=${pv('popup_show_favorites') !== false} @change=${(ev) => pp({ popup_show_favorites: ev.target.checked })}></ha-switch><span>Show Favorites</span></div>
              ${p_domain === 'light' ? html`<div class="switch-row"><ha-switch .checked=${pv('popup_show_effects') !== false} @change=${(ev) => pp({ popup_show_effects: ev.target.checked })}></ha-switch><span>Show Effects</span></div>` : ''}
              <div class="switch-row"><ha-switch .checked=${pv('popup_hide_bottom_bar') !== true} @change=${(ev) => pp({ popup_hide_bottom_bar: !ev.target.checked })}></ha-switch><span>Show bottom bar</span></div>
              <div class="switch-row"><ha-switch .checked=${pv('popup_hide_top_bar') !== true} @change=${(ev) => pp({ popup_hide_top_bar: !ev.target.checked })}></ha-switch><span>Show top bar</span></div>
              ${pv('popup_hide_top_bar') === true ? html`
                <div class="switch-row"><ha-switch .checked=${pv('popup_show_close_button') !== false} @change=${(ev) => pp({ popup_show_close_button: ev.target.checked })}></ha-switch><span>Show close button</span></div>
              ` : ''}
              <div class="switch-row"><ha-switch .checked=${pv('popup_close_on_action') === true} @change=${(ev) => pp({ popup_close_on_action: ev.target.checked })}></ha-switch><span>Close popup after perform-action</span></div>
            </div>
          </details>
        ` : ''}

        ${p_domain === 'climate' ? html`
          <details class="box-section">
            <summary>Climate Options</summary>
            <div class="box-content">
              <div class="switch-row"><ha-switch .checked=${pv('popup_show_presets') !== false} @change=${(ev) => pp({ popup_show_presets: ev.target.checked })}></ha-switch><span>Show Presets</span></div>
              <ha-textfield label="Temperature Step Size" type="number" step="0.1" .value=${String(pv('climate_temp_step') ?? 0.5)} @input=${(ev) => pp({ climate_temp_step: Number(ev.target.value) })} placeholder="0.5"></ha-textfield>
              <div class="switch-row"><ha-switch .checked=${pv('climate_use_circular_slider') === true} @change=${(ev) => pp({ climate_use_circular_slider: ev.target.checked })}></ha-switch><span>Use Circular Slider</span></div>
              <div class="switch-row"><ha-switch .checked=${pv('climate_show_plus_minus') === true} @change=${(ev) => pp({ climate_show_plus_minus: ev.target.checked })}></ha-switch><span>Show +/- Buttons</span></div>
              <div class="switch-row"><ha-switch .checked=${pv('climate_show_gradient') !== false} @change=${(ev) => pp({ climate_show_gradient: ev.target.checked })}></ha-switch><span>Show Gradient</span></div>
              <div class="switch-row"><ha-switch .checked=${pv('climate_show_target_range') !== false} @change=${(ev) => pp({ climate_show_target_range: ev.target.checked })}></ha-switch><span>Show Min/Max Target Range (if supported)</span></div>
              <p style="font-size: 12px; font-weight: 500; margin: 8px 0 4px 0;">Extra Sensors (optional)</p>
              <ha-entity-picker .hass=${this.hass} label="Current Temperature Entity" .value=${pv('climate_current_temperature_entity') || ''} @value-changed=${(ev) => pp({ climate_current_temperature_entity: ev.detail.value || undefined })}></ha-entity-picker>
              <ha-textfield label="Temperature Sensor Name" .value=${pv('climate_temperature_name') || ''} @input=${(ev) => pp({ climate_temperature_name: ev.target.value || undefined })}></ha-textfield>
              <ha-entity-picker .hass=${this.hass} label="Humidity Entity" .value=${pv('climate_humidity_entity') || ''} @value-changed=${(ev) => pp({ climate_humidity_entity: ev.detail.value || undefined })}></ha-entity-picker>
              <ha-textfield label="Humidity Sensor Name" .value=${pv('climate_humidity_name') || ''} @input=${(ev) => pp({ climate_humidity_name: ev.target.value || undefined })}></ha-textfield>
              <ha-entity-picker .hass=${this.hass} label="Pressure Entity" .value=${pv('climate_pressure_entity') || ''} @value-changed=${(ev) => pp({ climate_pressure_entity: ev.detail.value || undefined })}></ha-entity-picker>
              <ha-textfield label="Pressure Sensor Name" .value=${pv('climate_pressure_name') || ''} @input=${(ev) => pp({ climate_pressure_name: ev.target.value || undefined })}></ha-textfield>
            </div>
          </details>
        ` : ''}

        ${p_domain === 'humidifier' ? html`
          <details class="box-section">
            <summary>Humidifier Options</summary>
            <div class="box-content">
              <ha-textfield label="Humidity Step Size" type="number" step="1" .value=${String(pv('humidifier_humidity_step') ?? 1)} @input=${(ev) => pp({ humidifier_humidity_step: Number(ev.target.value) })} placeholder="1"></ha-textfield>
              <div class="switch-row"><ha-switch .checked=${pv('humidifier_use_circular_slider') === true} @change=${(ev) => pp({ humidifier_use_circular_slider: ev.target.checked })}></ha-switch><span>Use Circular Slider</span></div>
              <div class="switch-row"><ha-switch .checked=${pv('humidifier_show_plus_minus') === true} @change=${(ev) => pp({ humidifier_show_plus_minus: ev.target.checked })}></ha-switch><span>Show +/- Buttons</span></div>
              <div class="switch-row"><ha-switch .checked=${pv('humidifier_show_gradient') !== false} @change=${(ev) => pp({ humidifier_show_gradient: ev.target.checked })}></ha-switch><span>Show Gradient</span></div>
              <ha-entity-picker .hass=${this.hass} label="Fan Speed Entity (select or fan)" .value=${pv('humidifier_fan_entity') || ''} @value-changed=${(ev) => pp({ humidifier_fan_entity: ev.detail.value || undefined })}></ha-entity-picker>
            </div>
          </details>
        ` : ''}

        ${p_domain === 'person' ? html`
          <details class="box-section">
            <summary>Person Map Options</summary>
            <div class="box-content">
              <ha-entity-picker .hass=${this.hass} label="Geocoded Address Entity" .value=${pv('person_geocoded_entity') || ""}
                @value-changed=${(ev) => pp({ person_geocoded_entity: ev.detail.value || undefined })}
              ></ha-entity-picker>
            </div>
          </details>
        ` : ''}

        <details class="box-section">
          <summary>Content Display</summary>
          <div class="box-content">
            <ha-textfield label="Slider Border Radius (px)" type="number" .value=${String(pv('popup_slider_radius') ?? 12)} @input=${(ev) => pp({ popup_slider_radius: Number(ev.target.value) })}></ha-textfield>
            <div class="switch-row"><ha-switch .checked=${pv('popup_hide_button_text') === true} @change=${(ev) => pp({ popup_hide_button_text: ev.target.checked })}></ha-switch><span>Hide Text Under Buttons</span></div>
            <p style="font-size: 11px; opacity: 0.7; margin: 4px 0 2px 0;">Value Display (Temperature/Brightness)</p>
            <div class="inline-fields-2">
              <ha-textfield label="Font Size (px)" type="number" .value=${String(pv('popup_value_font_size') ?? 36)} @input=${(ev) => pp({ popup_value_font_size: Number(ev.target.value) })}></ha-textfield>
              <ha-textfield label="Font Weight" type="number" .value=${String(pv('popup_value_font_weight') ?? 300)} @input=${(ev) => pp({ popup_value_font_weight: Number(ev.target.value) })}></ha-textfield>
            </div>
            <p style="font-size: 11px; opacity: 0.7; margin: 4px 0 2px 0;">Label Display (Color/Mode Names)</p>
            <div class="inline-fields-2">
              <ha-textfield label="Font Size (px)" type="number" .value=${String(pv('popup_label_font_size') ?? 16)} @input=${(ev) => pp({ popup_label_font_size: Number(ev.target.value) })}></ha-textfield>
              <ha-textfield label="Font Weight" type="number" .value=${String(pv('popup_label_font_weight') ?? 400)} @input=${(ev) => pp({ popup_label_font_weight: Number(ev.target.value) })}></ha-textfield>
            </div>
            <ha-select label="Time Format" .value=${pv('popup_time_format') || 'auto'}
              @selected=${(ev) => { ev.stopPropagation(); pp({ popup_time_format: ev.target.value }); }}
              @closed=${(ev) => ev.stopPropagation()}>
              ${popupTimeFormatOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
            </ha-select>
          </div>
        </details>

        <details class="box-section">
          <summary>Active Button Styling</summary>
          <div class="box-content">
            <div class="inline-fields-2">
              <ha-textfield label="Color" .value=${pv('popup_highlight_color') || ''} @input=${(ev) => pp({ popup_highlight_color: ev.target.value || undefined })} placeholder="var(--primary-color)"></ha-textfield>
              <ha-textfield label="Text Color" .value=${pv('popup_highlight_text_color') || ''} @input=${(ev) => pp({ popup_highlight_text_color: ev.target.value || undefined })} placeholder="white"></ha-textfield>
            </div>
            <div class="inline-fields-2">
              <ha-textfield label="Border Radius (px)" type="number" .value=${pv('popup_highlight_radius') ?? ''} @input=${(ev) => pp({ popup_highlight_radius: Number(ev.target.value) || undefined })} placeholder="8"></ha-textfield>
              <ha-textfield label="Opacity" type="number" step="0.1" min="0" max="1" .value=${pv('popup_highlight_opacity') ?? ''} @input=${(ev) => pp({ popup_highlight_opacity: Number(ev.target.value) || undefined })} placeholder="1"></ha-textfield>
            </div>
            <div class="inline-fields-2">
              <ha-textfield label="Border Color" .value=${pv('popup_highlight_border_color') || ''} @input=${(ev) => pp({ popup_highlight_border_color: ev.target.value || undefined })}></ha-textfield>
              <ha-textfield label="Border Width" .value=${pv('popup_highlight_border_width') || ''} @input=${(ev) => pp({ popup_highlight_border_width: ev.target.value || undefined })}></ha-textfield>
            </div>
            <ha-textfield label="Box Shadow" .value=${pv('popup_highlight_box_shadow') || ''} @input=${(ev) => pp({ popup_highlight_box_shadow: ev.target.value || undefined })}></ha-textfield>
          </div>
        </details>

        <details class="box-section">
          <summary>Button Styling</summary>
          <div class="box-content">
            <div class="inline-fields-2">
              <ha-textfield label="Background" .value=${pv('popup_button_bg') || ''} @input=${(ev) => pp({ popup_button_bg: ev.target.value || undefined })}></ha-textfield>
              <ha-textfield label="Text Color" .value=${pv('popup_button_text_color') || ''} @input=${(ev) => pp({ popup_button_text_color: ev.target.value || undefined })}></ha-textfield>
            </div>
            <div class="inline-fields-2">
              <ha-textfield label="Border Radius (px)" type="number" .value=${pv('popup_button_radius') ?? ''} @input=${(ev) => pp({ popup_button_radius: Number(ev.target.value) || undefined })}></ha-textfield>
              <ha-textfield label="Opacity" type="number" step="0.1" min="0" max="1" .value=${pv('popup_button_opacity') ?? ''} @input=${(ev) => pp({ popup_button_opacity: Number(ev.target.value) || undefined })}></ha-textfield>
            </div>
            <div class="inline-fields-2">
              <ha-textfield label="Border Color" .value=${pv('popup_button_border_color') || ''} @input=${(ev) => pp({ popup_button_border_color: ev.target.value || undefined })}></ha-textfield>
              <ha-textfield label="Border Width" .value=${pv('popup_button_border_width') || ''} @input=${(ev) => pp({ popup_button_border_width: ev.target.value || undefined })}></ha-textfield>
            </div>
          </div>
        </details>

        <details class="box-section">
          <summary>Bottom Bar Entities</summary>
          <div class="box-content">
            <p style="font-size: 11px; opacity: 0.7; margin: 0 0 6px 0;">Add up to 8 icon buttons to the popup bottom bar.</p>
            <ha-select label="Button Alignment" .value=${pv('popup_bottom_bar_align') || 'spread'}
              @selected=${(ev) => { ev.stopPropagation(); pp({ popup_bottom_bar_align: ev.target.value }); }}
              @closed=${(ev) => ev.stopPropagation()}>
              ${popupBottomBarAlignOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
            </ha-select>
            ${(() => {
              const _bbSlots = Math.max(1, Math.min(8, pv('_bb_slots') ?? Math.max(1, (pv('popup_bottom_bar_entities') || []).filter(Boolean).length || 1)));
              return html`
                <div style="display:flex;align-items:center;gap:8px;margin:10px 0 4px 0;">
                  <span style="font-size:12px;opacity:0.7;flex:1;">Slots: ${_bbSlots}</span>
                  <button style="width:28px;height:28px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);background:rgba(255,255,255,0.06);color:var(--primary-text-color);cursor:pointer;font-size:16px;display:flex;align-items:center;justify-content:center;"
                    @click=${(e) => { e.stopPropagation(); pp({ _bb_slots: Math.max(1, _bbSlots - 1) }); }}>&#8722;</button>
                  <button style="width:28px;height:28px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);background:rgba(255,255,255,0.06);color:var(--primary-text-color);cursor:pointer;font-size:16px;display:flex;align-items:center;justify-content:center;"
                    @click=${(e) => { e.stopPropagation(); pp({ _bb_slots: Math.min(8, _bbSlots + 1) }); }}>+</button>
                </div>
                ${Array.from({ length: _bbSlots }, (_, i) => {
                  const _ents = (pv('popup_bottom_bar_entities') || []);
                  const _ent = _ents[i] || {};
                  const _tap = _ent.tap_action || { action: 'more-info' };
                  const _act = _tap.action || 'more-info';
                  const setSlot = (patch) => {
                    const src = (pv('popup_bottom_bar_entities') || []);
                    const arr = Array.from({ length: Math.max(src.length, i + 1) }, (_, j) => src[j] || null);
                    arr[i] = { ...(arr[i] || {}), ...patch };
                    while (arr.length > 0 && !arr[arr.length - 1]?.entity) arr.pop();
                    pp({ popup_bottom_bar_entities: arr.length ? arr : undefined });
                  };
                  const moveSlot = (toIndex) => {
                    const src = (pv('popup_bottom_bar_entities') || []);
                    if (toIndex < 0 || toIndex >= _bbSlots || toIndex === i) return;
                    const arr = Array.from({ length: Math.max(src.length, _bbSlots) }, (_, j) => src[j] || null);
                    [arr[toIndex], arr[i]] = [arr[i], arr[toIndex]];
                    while (arr.length > 0 && !arr[arr.length - 1]?.entity) arr.pop();
                    pp({ popup_bottom_bar_entities: arr.length ? arr : undefined });
                  };
                  const setTap = (tap) => setSlot({ tap_action: { ..._tap, ...tap } });
                  return html`
                    <div style="margin-top:8px;padding:10px;background:rgba(255,255,255,0.04);border-radius:10px;">
                      <div style="display:flex;justify-content:space-between;align-items:center;">
                        <p style="font-size:11px;opacity:0.7;margin:0 0 6px 0;font-weight:600;">Button ${i+1}</p>
                        <div style="display:flex;align-items:center;gap:2px;">
                          <mwc-icon-button ?disabled=${i === 0} @click=${() => moveSlot(i - 1)}><ha-icon icon="mdi:chevron-up"></ha-icon></mwc-icon-button>
                          <mwc-icon-button ?disabled=${i === _bbSlots - 1} @click=${() => moveSlot(i + 1)}><ha-icon icon="mdi:chevron-down"></ha-icon></mwc-icon-button>
                        </div>
                      </div>
                      <ha-entity-picker .hass=${this.hass} .value=${_ent.entity||''} .label=${"Entity"}
                        @value-changed=${(ev) => setSlot({ entity: ev.detail.value || undefined })}
                        allow-custom-entity></ha-entity-picker>
                      ${_ent.entity ? html`
                        <ha-textfield label="Name (optional)" .value=${_ent.name||''}
                          @input=${(ev) => setSlot({ name: ev.target.value || undefined })} style="margin-top:6px;"></ha-textfield>
                        <ha-textfield label="Icon (optional)" .value=${_ent.icon||''} placeholder="mdi:home"
                          @input=${(ev) => setSlot({ icon: ev.target.value || undefined })} style="margin-top:6px;"></ha-textfield>
                        <ha-select label="Tap Action" .value=${_act}
                          @selected=${(ev) => { ev.stopPropagation(); const v=ev.detail?.value||ev.target?.value; if(v && v!==_act) setTap({ action:v }); }}
                          @closed=${(e)=>e.stopPropagation()} @click=${(e)=>e.stopPropagation()} style="margin-top:6px;">
                          ${popupBottomBarActionOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                        </ha-select>
                        ${_act==='navigate'?html`<ha-textfield label="Navigation Path" .value=${_tap.navigation_path||''} @input=${(ev)=>setTap({navigation_path:ev.target.value})} style="margin-top:6px;"></ha-textfield>`:''}
                        ${_act==='url'?html`<ha-textfield label="URL" .value=${_tap.url_path||''} @input=${(ev)=>setTap({url_path:ev.target.value})} style="margin-top:6px;"></ha-textfield>`:''}
                        ${_act==='perform-action'?html`<ha-textfield label="Action (domain.service)" .value=${_tap.perform_action||''} @input=${(ev)=>setTap({perform_action:ev.target.value})} style="margin-top:6px;"></ha-textfield>`:''}
                        ${_act==='fire-dom-event'?html`
                          <ha-textfield label="Event Name (optional)" .value=${_tap.event_name||''} @input=${(ev)=>setTap({event_name:ev.target.value})} style="margin-top:6px;"></ha-textfield>
                          <ha-code-editor .hass=${this.hass} .value=${_tap.event_data||''} mode="yaml"
                            @value-changed=${(ev)=>setTap({event_data:ev.detail?.value||''})}
                            @click=${(e)=>e.stopPropagation()}></ha-code-editor>
                        `:''}
                      ` : ''}
                    </div>`;
                })}
              `;
            })()}
          </div>
        </details>
      ` : ''}
        </div>
      </details>
    `;
  }
  _renderActionEditor(label, field) {
    return html`
      <div style="margin-top: 8px;">
        <p style="font-weight: 500; margin-bottom: 4px;">${label}</p>
        ${this._renderSlotActionEditor(field)}
      </div>
    `;
  }

  render() {
    // Don't render until setConfig has been called and config has been merged with DEFAULTS
    if (!this._config || !this._config.type) return html``;

    const showCustomFont = this._config.font_family === "custom";

    // --- LOGIC FOR BACKGROUND SIZE HYBRID SELECTOR ---
    const bgSize = this._config.background_size || "cover";
    const isCustomBgSize = !BG_SIZE_PRESETS.includes(bgSize);
    const bgSizeSelectValue = isCustomBgSize ? "custom" : bgSize;

    return html`
      <div class="card-config">
        <div class="disclaimer">
          <ha-alert alert-type="info" title="Documentation">
            This card can be placed in the header slot, but to make use of advanced layout settings put it in a normal section at the top of the page and make the section as wide as possible. <br><br>
            Please read the documentation for details and examples: <a href="https://jimz011.github.io/hki-elements/cards/hki-header-card/overview/" target="_blank" rel="noopener noreferrer">HKI Header Card</a> <br><br>
            This card may contain bugs. Use at your own risk!
          </ha-alert>
        </div>

        <details class="box-section" open>
          <summary>Header Text</summary>
          <div class="box-content">
            ${this._renderTemplateEditor("Title template (Jinja)", "title")}
            ${this._renderTemplateEditor("Subtitle template (Jinja)", "subtitle")}

            <ha-select label="Text alignment" .value=${this._config.text_align} data-field="text_align" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
              <mwc-list-item value="left">Left</mwc-list-item>
              <mwc-list-item value="center">Center</mwc-list-item>
              <mwc-list-item value="right">Right</mwc-list-item>
            </ha-select>
          </div>
        </details>

        <details class="box-section">
          <summary>Layout & Visibility</summary>
          <div class="box-content">
            <div class="section">Title position</div>
            <div class="inline-fields-2">
              <ha-textfield label="Title horizontal offset (px)" type="number" .value=${String(this._config.title_offset_x)} data-field="title_offset_x" @input=${this._changed}></ha-textfield>
              <ha-textfield label="Title vertical offset (px)" type="number" .value=${String(this._config.title_offset_y)} data-field="title_offset_y" @input=${this._changed}></ha-textfield>
            </div>

            <div class="section">Subtitle position</div>
            <div class="inline-fields-2">
              <ha-textfield label="Subtitle horizontal offset (px)" type="number" .value=${String(this._config.subtitle_offset_x)} data-field="subtitle_offset_x" @input=${this._changed}></ha-textfield>
              <ha-textfield label="Subtitle vertical offset (px)" type="number" .value=${String(this._config.subtitle_offset_y)} data-field="subtitle_offset_y" @input=${this._changed}></ha-textfield>
            </div>

            <div class="inline-fields-2">
              <ha-textfield label="Min height (px)" type="number" .value=${String(this._config.min_height)} data-field="min_height" @input=${this._changed}></ha-textfield>
              <ha-textfield label="Max height (px)" type="number" .value=${String(this._config.max_height)} data-field="max_height" @input=${this._changed}></ha-textfield>
            </div>
            
            <ha-textfield label="Mobile Breakpoint (px)" type="number" .value=${String(this._config.mobile_breakpoint || 768)} data-field="mobile_breakpoint" @input=${this._changed}></ha-textfield>
          </div>
        </details>

        <details class="box-section">
          <summary>Persons</summary>
          <div class="box-content">
            <ha-formfield label="Enable persons">
              <ha-switch .checked=${!!this._config.persons_enabled} data-field="persons_enabled" @change=${this._changed}></ha-switch>
            </ha-formfield>

            ${this._config.persons_enabled ? html`
              <div class="section">Persons</div>
              <p style="opacity: 0.7; font-size: 0.9em; margin: 8px 0;">Configure individual persons below. ${this._config.persons_grayscale_away ? html`<span style="color: var(--primary-color);">Enable "Grayscale when away" in Options to show per-person state override.</span>` : html`Enable "Grayscale when away" in Options below to add per-person state control.`}</p>
              
              ${(this._config.persons_entities || []).map((personConfig, index) => {
                const entityId = typeof personConfig === 'string' ? personConfig : personConfig.entity;
                return html`
                  <div style="border: 1px solid var(--divider-color); border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                      <strong>Person ${index + 1}</strong>
                      <div style="display:flex;align-items:center;gap:2px;">
                        <mwc-icon-button ?disabled=${index === 0} @click=${() => {
                          if (index === 0) return;
                          const updated = [...this._config.persons_entities];
                          [updated[index - 1], updated[index]] = [updated[index], updated[index - 1]];
                          this._config = { ...this._config, persons_entities: updated };
                          const strippedConfig = this._stripDefaults(this._config);
                          this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
                          this.requestUpdate();
                        }}>
                          <ha-icon icon="mdi:chevron-up"></ha-icon>
                        </mwc-icon-button>
                        <mwc-icon-button ?disabled=${index === (this._config.persons_entities || []).length - 1} @click=${() => {
                          const arr = this._config.persons_entities || [];
                          if (index >= arr.length - 1) return;
                          const updated = [...arr];
                          [updated[index + 1], updated[index]] = [updated[index], updated[index + 1]];
                          this._config = { ...this._config, persons_entities: updated };
                          const strippedConfig = this._stripDefaults(this._config);
                          this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
                          this.requestUpdate();
                        }}>
                          <ha-icon icon="mdi:chevron-down"></ha-icon>
                        </mwc-icon-button>
                        <mwc-icon-button 
                          @click=${() => {
                            const updated = [...this._config.persons_entities];
                            updated.splice(index, 1);
                            this._config = { ...this._config, persons_entities: updated };
                            const strippedConfig = this._stripDefaults(this._config);
                            this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
                            this.requestUpdate();
                          }}
                        >
                          <ha-icon icon="mdi:delete"></ha-icon>
                        </mwc-icon-button>
                      </div>
                    </div>
                    
                    <ha-entity-picker
                      .hass=${this.hass}
                      .value=${entityId}
                      .label=${"Person Entity"}
                      .includeDomains=${["person"]}
                      @value-changed=${(e) => {
                        const updated = [...this._config.persons_entities];
                        if (typeof updated[index] === 'string') {
                          updated[index] = {
                            entity: e.detail.value,
                            tap_action: { action: "more-info" },
                            hold_action: { action: "none" },
                            double_tap_action: { action: "none" }
                          };
                        } else {
                          updated[index] = { ...updated[index], entity: e.detail.value };
                        }
                        this._config = { ...this._config, persons_entities: updated };
                        const strippedConfig = this._stripDefaults(this._config);
                        this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
                        this.requestUpdate();
                      }}
                    ></ha-entity-picker>

                    ${this._config.persons_grayscale_away ? html`
                      <ha-entity-picker
                        .hass=${this.hass}
                        .value=${typeof personConfig !== 'string' ? (personConfig.grayscale_entity || "") : ""}
                        .label=${"State Override Entity (optional)"}
                        helper="Override person state with this entity: ON = home/color, OFF = away/grayscale"
                        @value-changed=${(e) => {
                          const updated = [...this._config.persons_entities];
                          if (typeof updated[index] === 'string') {
                            updated[index] = {
                              entity: updated[index],
                              grayscale_entity: e.detail.value || "",
                              tap_action: { action: "more-info" },
                              hold_action: { action: "none" },
                              double_tap_action: { action: "none" }
                            };
                          } else {
                            updated[index] = { ...updated[index], grayscale_entity: e.detail.value || "" };
                          }
                          this._config = { ...this._config, persons_entities: updated };
                          const strippedConfig = this._stripDefaults(this._config);
                          this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
                          this.requestUpdate();
                        }}
                      ></ha-entity-picker>
                    ` : ''}

                    <details class="box-section" style="margin-top: 8px;">
                      <summary>Custom Icons & Pictures</summary>
                      <div class="box-content" style="display: flex; flex-direction: column; gap: 8px;">
                        <ha-icon-picker
                          .hass=${this.hass}
                          .value=${typeof personConfig !== 'string' ? (personConfig.icon_home || "") : ""}
                          .label=${"Icon (Home)"}
                          helper="Custom icon when home (overrides entity icon)"
                          @value-changed=${(e) => {
                            const updated = [...this._config.persons_entities];
                            if (typeof updated[index] === 'string') {
                              updated[index] = {
                                entity: updated[index],
                                icon_home: e.detail.value || "",
                                tap_action: { action: "more-info" },
                                hold_action: { action: "none" },
                                double_tap_action: { action: "none" }
                              };
                            } else {
                              updated[index] = { ...updated[index], icon_home: e.detail.value || "" };
                            }
                            this._config = { ...this._config, persons_entities: updated };
                            const strippedConfig = this._stripDefaults(this._config);
                            this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
                            this.requestUpdate();
                          }}
                        ></ha-icon-picker>

                        <ha-icon-picker
                          .hass=${this.hass}
                          .value=${typeof personConfig !== 'string' ? (personConfig.icon_away || "") : ""}
                          .label=${"Icon (Away)"}
                          helper="Custom icon when away (overrides entity icon)"
                          @value-changed=${(e) => {
                            const updated = [...this._config.persons_entities];
                            if (typeof updated[index] === 'string') {
                              updated[index] = {
                                entity: updated[index],
                                icon_away: e.detail.value || "",
                                tap_action: { action: "more-info" },
                                hold_action: { action: "none" },
                                double_tap_action: { action: "none" }
                              };
                            } else {
                              updated[index] = { ...updated[index], icon_away: e.detail.value || "" };
                            }
                            this._config = { ...this._config, persons_entities: updated };
                            const strippedConfig = this._stripDefaults(this._config);
                            this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
                            this.requestUpdate();
                          }}
                        ></ha-icon-picker>

                        <ha-textfield
                          .hass=${this.hass}
                          .value=${typeof personConfig !== 'string' ? (personConfig.picture_home || "") : ""}
                          .label=${"Picture URL (Home)"}
                          helper="Custom picture URL when home (e.g., /local/person_home.jpg)"
                          @input=${(e) => {
                            const updated = [...this._config.persons_entities];
                            if (typeof updated[index] === 'string') {
                              updated[index] = {
                                entity: updated[index],
                                picture_home: e.target.value || "",
                                tap_action: { action: "more-info" },
                                hold_action: { action: "none" },
                                double_tap_action: { action: "none" }
                              };
                            } else {
                              updated[index] = { ...updated[index], picture_home: e.target.value || "" };
                            }
                            this._config = { ...this._config, persons_entities: updated };
                            const strippedConfig = this._stripDefaults(this._config);
                            this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
                            this.requestUpdate();
                          }}
                        ></ha-textfield>

                        <ha-textfield
                          .hass=${this.hass}
                          .value=${typeof personConfig !== 'string' ? (personConfig.picture_away || "") : ""}
                          .label=${"Picture URL (Away)"}
                          helper="Custom picture URL when away (e.g., /local/person_away.jpg)"
                          @input=${(e) => {
                            const updated = [...this._config.persons_entities];
                            if (typeof updated[index] === 'string') {
                              updated[index] = {
                                entity: updated[index],
                                picture_away: e.target.value || "",
                                tap_action: { action: "more-info" },
                                hold_action: { action: "none" },
                                double_tap_action: { action: "none" }
                              };
                            } else {
                              updated[index] = { ...updated[index], picture_away: e.target.value || "" };
                            }
                            this._config = { ...this._config, persons_entities: updated };
                            const strippedConfig = this._stripDefaults(this._config);
                            this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
                            this.requestUpdate();
                          }}
                        ></ha-textfield>
                      </div>
                    </details>

                    ${this._renderPersonActionEditors(index)}
                  </div>
                `;
              })}

              <mwc-button 
                @click=${() => {
                  const updated = [...(this._config.persons_entities || []), {
                    entity: "",
                    tap_action: { action: "more-info" },
                    hold_action: { action: "none" },
                    double_tap_action: { action: "none" }
                  }];
                  this._config = { ...this._config, persons_entities: updated };
                  const strippedConfig = this._stripDefaults(this._config);
                  this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: strippedConfig } }));
                  this.requestUpdate();
                }}
              >
                <ha-icon icon="mdi:plus"></ha-icon> Add Person
              </mwc-button>

              <div class="section" style="margin-top: 16px;">Position</div>
              <div class="inline-fields-2">
                <ha-textfield label="Horizontal offset (px)" type="number" .value=${String(this._config.persons_offset_x || 5)} data-field="persons_offset_x" @input=${this._changed}></ha-textfield>
                <ha-textfield label="Vertical offset (px)" type="number" .value=${String(this._config.persons_offset_y || 32)} data-field="persons_offset_y" @input=${this._changed}></ha-textfield>
              </div>

              <div class="section">Alignment</div>
              <ha-select label="Persons alignment" .value=${this._config.persons_align || "left"} data-field="persons_align" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
                <mwc-list-item value="left">Left</mwc-list-item>
                <mwc-list-item value="center">Center</mwc-list-item>
                <mwc-list-item value="right">Right</mwc-list-item>
              </ha-select>

              <div class="section">Appearance</div>
              <div class="inline-fields-2">
                <ha-textfield label="Avatar size (px)" type="number" .value=${String(this._config.persons_size || 48)} data-field="persons_size" @input=${this._changed}></ha-textfield>
                <ha-textfield label="Spacing (px)" helper="Negative = overlap" type="number" .value=${String(this._config.persons_spacing != null ? this._config.persons_spacing : -8)} data-field="persons_spacing" @input=${this._changed}></ha-textfield>
              </div>

              <ha-select label="Stack order" helper="Only affects overlapping (negative spacing)" .value=${this._config.persons_stack_order || "ascending"} data-field="persons_stack_order" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
                <mwc-list-item value="ascending">Ascending (last on top)</mwc-list-item>
                <mwc-list-item value="descending">Descending (first on top)</mwc-list-item>
              </ha-select>

              <div class="inline-fields-2">
                <ha-textfield label="Border width (px)" type="number" .value=${String(this._config.persons_border_width || 1)} data-field="persons_border_width" @input=${this._changed}></ha-textfield>
                <ha-select label="Border style" .value=${this._config.persons_border_style || "solid"} data-field="persons_border_style" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
                  <mwc-list-item value="solid">Solid</mwc-list-item>
                  <mwc-list-item value="dashed">Dashed</mwc-list-item>
                  <mwc-list-item value="dotted">Dotted</mwc-list-item>
                  <mwc-list-item value="double">Double</mwc-list-item>
                  <mwc-list-item value="groove">Groove</mwc-list-item>
                  <mwc-list-item value="ridge">Ridge</mwc-list-item>
                  <mwc-list-item value="inset">Inset</mwc-list-item>
                  <mwc-list-item value="outset">Outset</mwc-list-item>
                  <mwc-list-item value="none">None</mwc-list-item>
                </ha-select>
              </div>

              <div class="inline-fields-2">
                <ha-textfield label="Border radius (px)" helper="Integer for pixels, or CSS value" .value=${String(this._config.persons_border_radius !== undefined ? this._config.persons_border_radius : 50)} data-field="persons_border_radius" @input=${this._changed}></ha-textfield>
                <ha-textfield label="Border color" .value=${this._config.persons_border_color || "rgba(255,255,255,0.3)"} data-field="persons_border_color" @input=${this._changed}></ha-textfield>
              </div>

              <ha-textfield label="Border color (away)" .value=${this._config.persons_border_color_away || "rgba(255,100,100,0.5)"} data-field="persons_border_color_away" @input=${this._changed}></ha-textfield>

              <ha-textfield label="Box shadow" helper="Leave empty for no shadow" .value=${this._config.persons_box_shadow !== undefined ? this._config.persons_box_shadow : "0 2px 8px rgba(0, 0, 0, 0.4)"} data-field="persons_box_shadow" @input=${this._changed}></ha-textfield>

              <div class="section">Options</div>
              <ha-formfield label="Use entity picture (if available)">
                <ha-switch .checked=${this._config.persons_use_entity_picture !== false} data-field="persons_use_entity_picture" @change=${this._changed}></ha-switch>
              </ha-formfield>

              <ha-formfield label="Dynamic order (home persons first)">
                <ha-switch .checked=${!!this._config.persons_dynamic_order} data-field="persons_dynamic_order" @change=${this._changed}></ha-switch>
              </ha-formfield>

              <ha-formfield label="Hide away persons">
                <ha-switch .checked=${!!this._config.persons_hide_away} data-field="persons_hide_away" @change=${this._changed}></ha-switch>
              </ha-formfield>

              <ha-formfield label="Grayscale when away">
                <ha-switch .checked=${!!this._config.persons_grayscale_away} data-field="persons_grayscale_away" @change=${this._changed}></ha-switch>
              </ha-formfield>
              ${this._config.persons_grayscale_away ? html`
                <p style="opacity: 0.6; font-size: 0.85em; margin: 4px 0 8px 24px; font-style: italic;">Per-person state override available in Persons section above</p>
              ` : ''}
            ` : ''}
          </div>
        </details>

        <details class="box-section">
          <summary>Header Styling</summary>
          <div class="box-content">
            <div class="section">Text Colors</div>
            <div class="inline-fields-2">
              <ha-textfield label="Title color" helper="Any CSS color (hex, rgb, rgba, etc.)" placeholder="inherit" .value=${this._config.title_color || ""} data-field="title_color" @input=${this._changed}></ha-textfield>
              <ha-textfield label="Subtitle color" helper="Any CSS color (hex, rgb, rgba, etc.)" placeholder="inherit" .value=${this._config.subtitle_color || ""} data-field="subtitle_color" @input=${this._changed}></ha-textfield>
            </div>

            <div class="section">Background</div>
            <ha-textfield label="Background" helper="CSS color (hex, rgb, rgba, color name), gradient, or image URL (/local/image.jpg)" .value=${this._config.background} data-field="background" @input=${this._changed}></ha-textfield>

            <div class="inline-fields-2">
                <ha-select label="Background position" .value=${this._config.background_position} data-field="background_position" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
                  <mwc-list-item value="top">Top</mwc-list-item>
                  <mwc-list-item value="center">Center</mwc-list-item>
                  <mwc-list-item value="bottom">Bottom</mwc-list-item>
                  <mwc-list-item value="left">Left</mwc-list-item>
                  <mwc-list-item value="right">Right</mwc-list-item>
                </ha-select>

                <ha-select label="Background repeat" .value=${this._config.background_repeat} data-field="background_repeat" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
                  <mwc-list-item value="no-repeat">No repeat</mwc-list-item>
                  <mwc-list-item value="repeat">Repeat</mwc-list-item>
                  <mwc-list-item value="repeat-x">Repeat horizontally</mwc-list-item>
                  <mwc-list-item value="repeat-y">Repeat vertically</mwc-list-item>
                </ha-select>
            </div>

            <div class="inline-fields-2">
                <ha-select 
                    label="Background size" 
                    .value=${bgSizeSelectValue} 
                    
                    @selected=${this._handleBgSizeSelect} 
                    @closed=${(e) => e.stopPropagation()}
                >
                  <mwc-list-item value="cover">Cover</mwc-list-item>
                  <mwc-list-item value="contain">Contain</mwc-list-item>
                  <mwc-list-item value="auto">Auto</mwc-list-item>
                  <mwc-list-item value="custom">Custom</mwc-list-item>
                </ha-select>
                
                <ha-select label="Background blend mode" .value=${this._config.background_blend_mode || "normal"} data-field="background_blend_mode" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
                  <mwc-list-item value="normal">Normal</mwc-list-item>
                  <mwc-list-item value="multiply">Multiply</mwc-list-item>
                  <mwc-list-item value="screen">Screen</mwc-list-item>
                  <mwc-list-item value="overlay">Overlay</mwc-list-item>
                  <mwc-list-item value="darken">Darken</mwc-list-item>
                  <mwc-list-item value="lighten">Lighten</mwc-list-item>
                  <mwc-list-item value="color-dodge">Color Dodge</mwc-list-item>
                  <mwc-list-item value="soft-light">Soft Light</mwc-list-item>
                  <mwc-list-item value="difference">Difference</mwc-list-item>
                </ha-select>
            </div>
            
            ${isCustomBgSize ? html`
                <ha-textfield 
                    label="Custom Size (e.g. 150%)" 
                    .value=${this._config.background_size} 
                    data-field="background_size" 
                    @input=${this._changed}
                ></ha-textfield>
            ` : ""}

            <ha-textfield label="Background blend color" helper="Color to blend with background image using blend mode above" .value=${this._config.background_color} data-field="background_color" @input=${this._changed}></ha-textfield>

            <div class="section">Gradient Overlay</div>
            <div class="switch-row">
              <ha-formfield label="Enable gradient overlay">
                <ha-switch .checked=${this._config.blend_enabled !== false} data-field="blend_enabled" @change=${this._changed}></ha-switch>
              </ha-formfield>
            </div>
            ${this._config.blend_enabled !== false ? html`
              <ha-textfield label="Blend color" helper="Any CSS color" .value=${this._config.blend_color} data-field="blend_color" @input=${this._changed}></ha-textfield>
              <ha-textfield label="Blend stop (%)" type="number" .value=${String(this._config.blend_stop)} data-field="blend_stop" @input=${this._changed}></ha-textfield>
            ` : ""}

            <div class="section">Border & Shadow</div>
            <div class="inline-fields-2">
              <ha-textfield
                label="Border radius (top)"
                helper="Number (px) like 12, or any CSS value (12px, 0, 50%, var(--radius))"
                .value=${(this._config.card_border_radius_top ?? "").toString()}
                data-field="card_border_radius_top"
                @input=${this._changed}
              ></ha-textfield>
              <ha-textfield
                label="Border radius (bottom)"
                helper="Number (px) like 12, or any CSS value (12px, 0, 50%, var(--radius))"
                .value=${(this._config.card_border_radius_bottom ?? "").toString()}
                data-field="card_border_radius_bottom"
                @input=${this._changed}
              ></ha-textfield>
            </div>
            <ha-textfield label="Box Shadow" helper="e.g. 0 4px 12px rgba(0,0,0,0.3)" .value=${this._config.card_box_shadow || ""} data-field="card_box_shadow" @input=${this._changed}></ha-textfield>
            <div class="inline-fields-3">
              <ha-select label="Border Style" .value=${this._config.card_border_style || "none"} data-field="card_border_style" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
                <mwc-list-item value="none">None</mwc-list-item>
                <mwc-list-item value="solid">Solid</mwc-list-item>
                <mwc-list-item value="dashed">Dashed</mwc-list-item>
                <mwc-list-item value="dotted">Dotted</mwc-list-item>
                <mwc-list-item value="double">Double</mwc-list-item>
                <mwc-list-item value="groove">Groove</mwc-list-item>
                <mwc-list-item value="ridge">Ridge</mwc-list-item>
                <mwc-list-item value="inset">Inset</mwc-list-item>
                <mwc-list-item value="outset">Outset</mwc-list-item>
              </ha-select>
              <ha-textfield label="Border Width (px)" type="number" .value=${String(this._config.card_border_width || 0)} data-field="card_border_width" @input=${this._changed}></ha-textfield>
              <ha-textfield label="Border Color" .value=${this._config.card_border_color || ""} data-field="card_border_color" @input=${this._changed}></ha-textfield>
            </div>
          </div>
        </details>

        <details class="box-section">
          <summary>Typography</summary>
          <div class="box-content">
            <div class="section">Font Settings</div>
            <ha-select label="Font family" .value=${this._config.font_family} data-field="font_family" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
              <mwc-list-item value="inherit">Inherit</mwc-list-item>
              <mwc-list-item value="system">System</mwc-list-item>
              <mwc-list-item value="roboto">Roboto</mwc-list-item>
              <mwc-list-item value="inter">Inter</mwc-list-item>
              <mwc-list-item value="arial">Arial</mwc-list-item>
              <mwc-list-item value="georgia">Georgia</mwc-list-item>
              <mwc-list-item value="mono">Monospace</mwc-list-item>
              <mwc-list-item value="custom">Customâ€¦</mwc-list-item>
            </ha-select>

            ${showCustomFont ? html`<ha-textfield label="Custom font-family (CSS)" .value=${this._config.font_family_custom} data-field="font_family_custom" @input=${this._changed}></ha-textfield>` : ""}

            <ha-select label="Font style" .value=${this._config.font_style} data-field="font_style" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
              <mwc-list-item value="normal">Normal</mwc-list-item>
              <mwc-list-item value="italic">Italic</mwc-list-item>
            </ha-select>

            <div class="inline-fields-2">
              <ha-textfield label="Title size (px)" type="number" .value=${String(this._config.title_size_px)} data-field="title_size_px" @input=${this._changed}></ha-textfield>
              <ha-textfield label="Subtitle size (px)" type="number" .value=${String(this._config.subtitle_size_px)} data-field="subtitle_size_px" @input=${this._changed}></ha-textfield>
            </div>

            <div class="inline-fields-2">
              <ha-select label="Title weight" .value=${this._config.title_weight} data-field="title_weight" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
                <mwc-list-item value="light">Light</mwc-list-item>
                <mwc-list-item value="regular">Regular</mwc-list-item>
                <mwc-list-item value="medium">Medium</mwc-list-item>
                <mwc-list-item value="semibold">Semi-bold</mwc-list-item>
                <mwc-list-item value="bold">Bold</mwc-list-item>
                <mwc-list-item value="black">Black</mwc-list-item>
              </ha-select>

              <ha-select label="Subtitle weight" .value=${this._config.subtitle_weight} data-field="subtitle_weight" @selected=${this._changed} @closed=${this._changed} @value-changed=${this._changed}>
                <mwc-list-item value="light">Light</mwc-list-item>
                <mwc-list-item value="regular">Regular</mwc-list-item>
                <mwc-list-item value="medium">Medium</mwc-list-item>
                <mwc-list-item value="semibold">Semi-bold</mwc-list-item>
                <mwc-list-item value="bold">Bold</mwc-list-item>
                <mwc-list-item value="black">Black</mwc-list-item>
              </ha-select>
            </div>
          </div>
        </details>
        <details class="box-section">
          <summary>Top Bar</summary>
          <div class="box-content">
            <div class="switch-row">
                <ha-switch .checked=${this._config.top_bar_enabled !== false} data-field="top_bar_enabled" @change=${this._changed}></ha-switch>
                <span>Enable top bar</span>
            </div>

            ${this._config.top_bar_enabled !== false ? html`
                <div class="inline-fields-2">
                    <ha-textfield label="Bar vertical offset (px)" type="number" .value=${String(this._config.top_bar_offset_y ?? 10)} data-field="top_bar_offset_y" @input=${this._changed}></ha-textfield>
                    <ha-textfield label="Bar padding X (px)" type="number" .value=${String(this._config.top_bar_padding_x ?? 5)} data-field="top_bar_padding_x" @input=${this._changed}></ha-textfield>
                </div>
                
                <details class="box-section">
                  <summary>Global Styling (Defaults)</summary>
                  <div class="box-content">
                    <div class="inline-fields-2">
                      <ha-textfield label="Font Size (px)" type="number" .value=${String(this._config.info_size_px || 12)} data-field="info_size_px" @input=${this._changed}></ha-textfield>
                      <ha-select label="Font Weight" .value=${this._config.info_weight || "medium"} data-field="info_weight" @selected=${this._changed} @closed=${this._changed}>
                        ${["light", "regular", "medium", "semibold", "bold", "extrabold"].map(w => html`<mwc-list-item .value=${w}>${w.charAt(0).toUpperCase() + w.slice(1)}</mwc-list-item>`)}
                      </ha-select>
                    </div>
                    <ha-textfield label="Text Color (Jinja supported)" .value=${this._config.info_color || ""} data-field="info_color" @input=${this._changed}></ha-textfield>
                    <ha-textfield label="Text Shadow (CSS/Jinja)" .value=${this._config.info_text_shadow || ""} data-field="info_text_shadow" @input=${this._changed}></ha-textfield>
                    <ha-textfield label="Icon Shadow (CSS/Jinja)" helper="Use filter syntax or plain shadow, e.g. drop-shadow(0 2px 6px rgba(0,0,0,.6)) or 0 2px 6px rgba(0,0,0,.6)" .value=${this._config.info_icon_shadow || ""} data-field="info_icon_shadow" @input=${this._changed}></ha-textfield>
                    
                    <div class="switch-row">
                      <ha-switch .checked=${!!this._config.info_pill} data-field="info_pill" @change=${this._changed}></ha-switch>
                      <span>Enable Pill Style</span>
                    </div>
                    ${this._config.info_pill ? html`
                      ${this._renderTemplateEditor("Pill Background (Jinja)", "info_pill_background")}
                      <div class="inline-fields-2">
                        <ha-textfield label="Padding X (px)" type="number" .value=${String(this._config.info_pill_padding_x ?? 12)} data-field="info_pill_padding_x" @input=${this._changed}></ha-textfield>
                        <ha-textfield label="Padding Y (px)" type="number" .value=${String(this._config.info_pill_padding_y ?? 8)} data-field="info_pill_padding_y" @input=${this._changed}></ha-textfield>
                      </div>
                      <div class="inline-fields-2">
                        <ha-textfield label="Border Radius (px)" type="number" .value=${String(this._config.info_pill_radius ?? 999)} data-field="info_pill_radius" @input=${this._changed}></ha-textfield>
                        <ha-textfield label="Blur (px)" type="number" .value=${String(this._config.info_pill_blur ?? 0)} data-field="info_pill_blur" @input=${this._changed}></ha-textfield>
                      </div>
                      <div class="inline-fields-3">
                        <ha-select label="Border Style" .value=${this._config.info_pill_border_style || "none"} data-field="info_pill_border_style" @selected=${this._changed} @closed=${this._changed}>
                          <mwc-list-item value="none">None</mwc-list-item>
                          <mwc-list-item value="solid">Solid</mwc-list-item>
                          <mwc-list-item value="dashed">Dashed</mwc-list-item>
                          <mwc-list-item value="dotted">Dotted</mwc-list-item>
                        </ha-select>
                        <ha-textfield label="Border Width" type="number" .value=${String(this._config.info_pill_border_width ?? 0)} data-field="info_pill_border_width" @input=${this._changed}></ha-textfield>
                        <ha-textfield label="Border Color" .value=${this._config.info_pill_border_color || "rgba(255,255,255,0.1)"} data-field="info_pill_border_color" @input=${this._changed}></ha-textfield>
                      </div>
                    ` : ''}
                  </div>
                </details>

                <details class="box-section">
                  <summary>Left Slot: ${this._getSlotLabel(this._config.top_bar_left)}</summary>
                  <div class="box-content">
                    ${this._renderSlotEditor('left', 'top_bar')}
                  </div>
                </details>

                <details class="box-section">
                  <summary>Center Slot: ${this._getSlotLabel(this._config.top_bar_center)}</summary>
                  <div class="box-content">
                    ${this._renderSlotEditor('center', 'top_bar')}
                  </div>
                </details>

                <details class="box-section">
                  <summary>Right Slot: ${this._getSlotLabel(this._config.top_bar_right)}</summary>
                  <div class="box-content">
                    ${this._renderSlotEditor('right', 'top_bar')}
                  </div>
                </details>
            ` : ''}
          </div>
        </details>

        <details class="box-section">
          <summary>Bottom Bar</summary>
          <div class="box-content">
            <div class="switch-row">
              <ha-switch .checked=${!!this._config.bottom_bar_enabled} data-field="bottom_bar_enabled" @change=${this._changed}></ha-switch>
              <span>Enable Bottom Bar</span>
            </div>
            ${this._config.bottom_bar_enabled ? html`
              <div class="inline-fields-2" style="margin-top: 8px;">
                <ha-textfield label="Y Offset (px)" type="number" .value=${String(this._config.bottom_bar_offset_y ?? 10)} data-field="bottom_bar_offset_y" @input=${this._changed}></ha-textfield>
                <ha-textfield label="Padding X (px)" type="number" .value=${String(this._config.bottom_bar_padding_x ?? 0)} data-field="bottom_bar_padding_x" @input=${this._changed}></ha-textfield>
              </div>

              <details class="box-section">
                <summary>Global Styling (Defaults)</summary>
                <div class="box-content">
                  <div class="inline-fields-2">
                    <ha-textfield label="Font Size (px)" type="number" .value=${String(this._config.bottom_info_size_px || 12)} data-field="bottom_info_size_px" @input=${this._changed}></ha-textfield>
                    <ha-select label="Font Weight" .value=${this._config.bottom_info_weight || "medium"} data-field="bottom_info_weight" @selected=${this._changed} @closed=${this._changed}>
                      ${["light", "regular", "medium", "semibold", "bold", "extrabold"].map(w => html`<mwc-list-item .value=${w}>${w.charAt(0).toUpperCase() + w.slice(1)}</mwc-list-item>`)}
                    </ha-select>
                  </div>
                  <ha-textfield label="Text Color (Jinja supported)" .value=${this._config.bottom_info_color || ""} data-field="bottom_info_color" @input=${this._changed}></ha-textfield>
                  <ha-textfield label="Text Shadow (CSS/Jinja)" .value=${this._config.bottom_info_text_shadow || ""} data-field="bottom_info_text_shadow" @input=${this._changed}></ha-textfield>
                  <ha-textfield label="Icon Shadow (CSS/Jinja)" helper="Use filter syntax or plain shadow, e.g. drop-shadow(0 2px 6px rgba(0,0,0,.6)) or 0 2px 6px rgba(0,0,0,.6)" .value=${this._config.bottom_info_icon_shadow || ""} data-field="bottom_info_icon_shadow" @input=${this._changed}></ha-textfield>
                  
                  <div class="switch-row">
                    <ha-switch .checked=${!!this._config.bottom_info_pill} data-field="bottom_info_pill" @change=${this._changed}></ha-switch>
                    <span>Enable Pill Style</span>
                  </div>
                  ${this._config.bottom_info_pill ? html`
                    ${this._renderTemplateEditor("Pill Background (Jinja)", "bottom_info_pill_background")}
                    <div class="inline-fields-2">
                      <ha-textfield label="Padding X (px)" type="number" .value=${String(this._config.bottom_info_pill_padding_x ?? 12)} data-field="bottom_info_pill_padding_x" @input=${this._changed}></ha-textfield>
                      <ha-textfield label="Padding Y (px)" type="number" .value=${String(this._config.bottom_info_pill_padding_y ?? 8)} data-field="bottom_info_pill_padding_y" @input=${this._changed}></ha-textfield>
                    </div>
                    <div class="inline-fields-2">
                      <ha-textfield label="Border Radius (px)" type="number" .value=${String(this._config.bottom_info_pill_radius ?? 999)} data-field="bottom_info_pill_radius" @input=${this._changed}></ha-textfield>
                      <ha-textfield label="Blur (px)" type="number" .value=${String(this._config.bottom_info_pill_blur ?? 0)} data-field="bottom_info_pill_blur" @input=${this._changed}></ha-textfield>
                    </div>
                    <div class="inline-fields-3">
                      <ha-select label="Border Style" .value=${this._config.bottom_info_pill_border_style || "none"} data-field="bottom_info_pill_border_style" @selected=${this._changed} @closed=${this._changed}>
                        <mwc-list-item value="none">None</mwc-list-item>
                        <mwc-list-item value="solid">Solid</mwc-list-item>
                        <mwc-list-item value="dashed">Dashed</mwc-list-item>
                        <mwc-list-item value="dotted">Dotted</mwc-list-item>
                      </ha-select>
                      <ha-textfield label="Border Width" type="number" .value=${String(this._config.bottom_info_pill_border_width ?? 0)} data-field="bottom_info_pill_border_width" @input=${this._changed}></ha-textfield>
                      <ha-textfield label="Border Color" .value=${this._config.bottom_info_pill_border_color || "rgba(255,255,255,0.1)"} data-field="bottom_info_pill_border_color" @input=${this._changed}></ha-textfield>
                    </div>
                  ` : ''}
                </div>
              </details>

              <details class="box-section">
                <summary>Left Slot: ${this._getSlotLabel(this._config.bottom_bar_left)}</summary>
                <div class="box-content">
                  ${this._renderSlotEditor('left', 'bottom_bar')}
                </div>
              </details>

              <details class="box-section">
                <summary>Center Slot: ${this._getSlotLabel(this._config.bottom_bar_center)}</summary>
                <div class="box-content">
                  ${this._renderSlotEditor('center', 'bottom_bar')}
                </div>
              </details>

              <details class="box-section">
                <summary>Right Slot: ${this._getSlotLabel(this._config.bottom_bar_right)}</summary>
                <div class="box-content">
                  ${this._renderSlotEditor('right', 'bottom_bar')}
                </div>
              </details>
            ` : ''}
          </div>
        </details>

        <details class="box-section">
          <summary>Fixed Header</summary>
          <div class="box-content">
            <div class="section">Positioning</div>
            <div class="switch-row">
              <ha-formfield label="Keep header fixed to top">
                <ha-switch .checked=${!!this._config.fixed} data-field="fixed" @change=${this._changed}></ha-switch>
              </ha-formfield>
            </div>

            ${this._config.fixed ? html`
              <ha-textfield label="Fixed top offset (px)" type="number" .value=${String(this._config.fixed_top)} data-field="fixed_top" @input=${this._changed}></ha-textfield>
            ` : html`
              <div class="section">Card size (not fixed)</div>
              <div class="inline-fields-2">
                <ha-textfield label="Inset top (px)" type="number" .value=${String(this._config.inset_top ?? 0)} data-field="inset_top" @input=${this._changed}></ha-textfield>
                <ha-textfield label="Inset bottom (px)" type="number" .value=${String(this._config.inset_bottom ?? 0)} data-field="inset_bottom" @input=${this._changed}></ha-textfield>
              </div>
              <div class="inline-fields-2">
                <ha-textfield label="Inset left (px)" helper="Positive values make the card wider left" type="number" .value=${String(this._config.inset_left ?? 0)} data-field="inset_left" @input=${this._changed}></ha-textfield>
                <ha-textfield label="Inset right (px)" helper="Positive values make the card wider right" type="number" .value=${String(this._config.inset_right ?? 0)} data-field="inset_right" @input=${this._changed}></ha-textfield>
              </div>
            `}
          </div>
        </details>

        <details class="box-section">
          <summary>Badge Positioning</summary>
          <div class="box-content">
            <div class="section">Badge Settings</div>
            
            <ha-alert alert-type="warning" class="badge-warning">
              For badge positioning to work, this card must be placed in the <strong>header slot</strong> of your view/section. Otherwise, these badge settings will have no effect. <br><br>
              NOTE: This card does not manage or display any badges itself. Badges must be added separately using Home Assistant's native badge support (e.g. via the "badges" option in your Lovelace view/section configuration).
            </ha-alert>
            
            <div class="switch-row">
              <ha-formfield label="Pin badges in place (content scrolls beneath)">
                <ha-switch .checked=${!!this._config.badges_fixed} data-field="badges_fixed" @change=${this._changed}></ha-switch>
              </ha-formfield>
            </div>
            
            ${this._config.badges_fixed
              ? html`<ha-textfield label="Badges vertical offset when pinned (px)" helper="Negative values pull badges up (into header), positive values push down" type="number" .value=${String(this._config.badges_offset_pinned)} data-field="badges_offset_pinned" @input=${this._changed}></ha-textfield>`
              : html`<ha-textfield label="Badges vertical offset when unpinned (px)" helper="Negative values pull badges up (into header), positive values push down" type="number" .value=${String(this._config.badges_offset_unpinned)} data-field="badges_offset_unpinned" @input=${this._changed}></ha-textfield>`}
            
            <ha-textfield label="Gap under badges (px)" helper="Space between badges and next content (auto-adjusts -48px when pinned, +48px in kiosk mode)" type="number" .value=${String(this._config.badges_gap)} data-field="badges_gap" @input=${this._changed}></ha-textfield>
          </div>
        </details>

      </div>
    `;
  }

  static get styles() {
    return css`
      .card-config {
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding: 8px;
      }
      .disclaimer { margin-bottom: 8px; }
      .disclaimer ha-alert { margin-bottom: 0; }
      .disclaimer a { color: var(--primary-color); text-decoration: none; }
      .disclaimer a:hover { text-decoration: underline; }
      .badge-warning { margin-bottom: 12px; }
      .section { margin-top: 8px; font-weight: 600; }
      .switch-row { display: flex; align-items: center; gap: 12px; }
      .inline-fields-2 { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px; }
      .inline-fields-3 { display: grid; grid-template-columns: repeat(3, minmax(0, 1fr)); gap: 8px; }
      ha-textfield, ha-select, ha-combo-box, ha-navigation-picker, ha-entity-picker, ha-selector, ha-service-picker, ha-yaml-editor, ha-code-editor { width: 100%; }
      
      /* Collapsible Sections */
      details.box-section {
        background: var(--secondary-background-color);
        border-radius: 4px;
        margin-bottom: 8px;
        border: 1px solid var(--divider-color);
      }
      summary {
        padding: 12px;
        cursor: pointer;
        font-weight: 600;
        background: var(--primary-background-color);
        border-bottom: 1px solid var(--divider-color);
        list-style: none; /* Hide default triangle in some browsers */
        display: flex;
        align-items: center;
        justify-content: space-between;
        border-radius: 4px 4px 0 0;
      }
      details:not([open]) summary {
        border-radius: 4px;
        border-bottom: none;
      }
      summary::-webkit-details-marker { display: none; } /* Hide Chrome marker */
      summary::after {
        content: '+'; 
        font-weight: bold;
        font-size: 1.2em;
      }
      details[open] summary::after {
        content: '-';
      }
      .box-content {
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 12px;
        border-radius: 0 0 4px 4px;
      }
    `;
  }
}

if (!customElements.get("hki-header-card-editor")) {
  customElements.define("hki-header-card-editor", HkiHeaderCardEditor);
}

window.customCards = window.customCards || [];
window.customCards.push({
  type: CARD_NAME,
  name: "HKI Header Card",
  description: "Full Width Customizable Header.",
  preview: true,
  documentationURL: "https://github.com/jimz011/hki-header-card",
});

})();

// ============================================================
// hki-button-card
// ============================================================

(() => {
// HKI Button Card

(function() {
  const { LitElement, html, css } = window.HKI.getLit();
  const CARD_TYPE = "hki-button-card";
  const EDITOR_TAG = "hki-button-card-editor";

  // hvac_mode colors (what mode the thermostat is set to)
  const HVAC_COLORS = {
    heat: "darkorange", cool: "#1E90FF", heat_cool: "#4CAF50", auto: "#4CAF50",
    dry: "#FFC107", fan_only: "#9E9E9E", off: "#424242",
    // hvac_action colors (what the device is actually doing right now)
    idle: "#4CAF50", heating: "darkorange", cooling: "#1E90FF", fan: "#9E9E9E",
  };
  const HVAC_ICONS = {
    heat: "mdi:fire", cool: "mdi:snowflake", heat_cool: "mdi:autorenew", auto: "mdi:autorenew",
    dry: "mdi:water-percent", fan_only: "mdi:fan", off: "mdi:power"
  };

  // Template caching helpers
  function hashStr(s) {
    let h = 5381;
    for (let i = 0; i < s.length; i++) h = (h * 33) ^ s.charCodeAt(i);
    return (h >>> 0).toString(16);
  }

  function cacheKey(raw, vars) {
    return `hkiTpl:${hashStr(raw + (vars ? JSON.stringify(vars) : ""))}`;
  }

  const COLOR_PRESETS = [
    { name: "Warm White", temp: 2700, color: "#FFE4B5" },
    { name: "Soft White", temp: 3000, color: "#FFECD2" },
    { name: "Neutral", temp: 4000, color: "#FFF5E6" },
    { name: "Cool White", temp: 5000, color: "#F5F5FF" },
    { name: "Daylight", temp: 6500, color: "#E8F0FF" },
    { name: "Red", rgb: [255, 0, 0], color: "#FF0000" },
    { name: "Orange", rgb: [255, 165, 0], color: "#FFA500" },
    { name: "Yellow", rgb: [255, 255, 0], color: "#FFFF00" },
    { name: "Green", rgb: [0, 255, 0], color: "#00FF00" },
    { name: "Cyan", rgb: [0, 255, 255], color: "#00FFFF" },
    { name: "Blue", rgb: [0, 0, 255], color: "#0000FF" },
    { name: "Purple", rgb: [128, 0, 128], color: "#800080" },
    { name: "Pink", rgb: [255, 105, 180], color: "#FF69B4" },
  ];

  // Convert HSV (H:0-360, S:0-100, V:0-100) to RGB array [r,g,b]
  const _hsvToRgb = (h, sPct, vPct = 100) => {
    const H = ((Number(h) % 360) + 360) % 360;
    const S = Math.max(0, Math.min(100, Number(sPct))) / 100;
    const V = Math.max(0, Math.min(100, Number(vPct))) / 100;

    const C = V * S;
    const X = C * (1 - Math.abs(((H / 60) % 2) - 1));
    const m = V - C;

    let r = 0, g = 0, b = 0;
    if (H < 60) { r = C; g = X; b = 0; }
    else if (H < 120) { r = X; g = C; b = 0; }
    else if (H < 180) { r = 0; g = C; b = X; }
    else if (H < 240) { r = 0; g = X; b = C; }
    else if (H < 300) { r = X; g = 0; b = C; }
    else { r = C; g = 0; b = X; }

    return [
      Math.round((r + m) * 255),
      Math.round((g + m) * 255),
      Math.round((b + m) * 255),
    ];
  };

  // Local favorites storage (per-entity)
  const __hkiFavKey = (entityId) => `hki_button_card_favorites::${entityId}`;
  const __hkiSeedFavorites = () => COLOR_PRESETS.map((p, i) => {
    const out = { id: `seed_${i}`, name: p.name, color: p.color };
    if (p.temp) {
      out.type = 'temp';
      out.kelvin = p.temp;
      out.color_temp = Math.round(1000000 / p.temp);
    } else if (p.rgb) {
      out.type = 'rgb';
      out.rgb_color = p.rgb;
    }

    return out;
  });


  // Ensure popup animation keyframes are injected once (shared across HKI cards)
  window.HKI?.ensurePopupAnimations?.();

  // Prevent background page scroll when any popup is open
  // Scroll locking is shared across HKI cards (implemented in _bundle-header.js)
  const __hkiLockScroll = () => window.HKI?.lockScroll?.();
  const __hkiUnlockScroll = () => window.HKI?.unlockScroll?.();
  const HKI_POPUP_EDITOR_OPTIONS = window.HKI?.POPUP_EDITOR_OPTIONS || {
    animations: [
      { value: "none", label: "None" },
      { value: "fade", label: "Fade" },
      { value: "scale", label: "Scale" },
      { value: "zoom", label: "Zoom" },
      { value: "slide-up", label: "Slide Up" },
      { value: "slide-down", label: "Slide Down" },
      { value: "slide-left", label: "Slide Left" },
      { value: "slide-right", label: "Slide Right" },
      { value: "flip", label: "Flip" },
      { value: "bounce", label: "Bounce" },
      { value: "rotate", label: "Rotate" },
      { value: "drop", label: "Drop" },
      { value: "swing", label: "Swing" },
    ],
    width: [
      { value: "auto", label: "Auto (Responsive)" },
      { value: "default", label: "Default (400px)" },
      { value: "custom", label: "Custom" },
    ],
    height: [
      { value: "auto", label: "Auto (Responsive)" },
      { value: "default", label: "Default (600px)" },
      { value: "custom", label: "Custom" },
    ],
    timeFormats: [
      { value: "auto", label: "Auto" },
      { value: "12", label: "12-Hour Clock" },
      { value: "24", label: "24-Hour Clock" },
    ],
  };
  const HKI_EDITOR_OPTIONS = window.HKI?.EDITOR_OPTIONS || {
    borderStyles: [
      { value: "solid", label: "solid" },
      { value: "dashed", label: "dashed" },
      { value: "dotted", label: "dotted" },
      { value: "double", label: "double" },
      { value: "none", label: "none" },
    ],
    buttonActionOptions: [
      { value: "toggle", label: "Toggle" },
      { value: "hki-more-info", label: "More Info (HKI)" },
      { value: "more-info", label: "More Info (Native)" },
      { value: "navigate", label: "Navigate" },
      { value: "perform-action", label: "Perform Action" },
      { value: "url", label: "URL" },
      { value: "fire-dom-event", label: "Fire DOM Event" },
      { value: "none", label: "None" },
    ],
    headerActionOptions: [
      { value: "none", label: "None" },
      { value: "navigate", label: "Navigate" },
      { value: "back", label: "Back" },
      { value: "menu", label: "Toggle Menu" },
      { value: "url", label: "Open URL" },
      { value: "more-info", label: "More Info" },
      { value: "hki-more-info", label: "HKI More Info" },
      { value: "toggle", label: "Toggle Entity" },
      { value: "perform-action", label: "Perform Action" },
    ],
    popupBottomBarActionOptions: [
      { value: "toggle", label: "Toggle" },
      { value: "more-info", label: "More Info" },
      { value: "hki-more-info", label: "HKI More Info" },
      { value: "navigate", label: "Navigate" },
      { value: "perform-action", label: "Perform Action" },
      { value: "url", label: "URL" },
      { value: "none", label: "None" },
    ],
    popupDefaultViewOptions: [
      { value: "main", label: "Main (Group Controls)" },
      { value: "individual", label: "Individual Entities" },
    ],
    popupDefaultSectionOptions: [
      { value: "last", label: "Last Used" },
      { value: "brightness", label: "Always Brightness" },
      { value: "color", label: "Always Color" },
      { value: "temperature", label: "Always Temperature" },
    ],
    popupDefaultSectionOptionsTagged: [
      { value: "last", label: "Last Used (Default)" },
      { value: "brightness", label: "Always Brightness" },
      { value: "color", label: "Always Color" },
      { value: "temperature", label: "Always Temperature" },
    ],
    popupBottomBarAlignOptions: [
      { value: "spread", label: "Spread" },
      { value: "start", label: "Start" },
      { value: "center", label: "Center" },
      { value: "end", label: "End" },
    ],
    popupBottomBarAlignOptionsDetailed: [
      { value: "spread", label: "Spread (space around)" },
      { value: "start", label: "Start (left aligned)" },
      { value: "center", label: "Center" },
      { value: "end", label: "End (right aligned)" },
    ],
  };
  const applyGlobalDefaultsToConfig = window.HKI?.applyGlobalDefaultsToConfig || (({ config }) => config);

  



  class HkiButtonCard extends LitElement {
    static BASE_DEFAULTS = Object.freeze({
      show_name: true,
      show_state: true,
      show_info_display: true,
      show_brightness: true,
      show_scenes_button: true,
      show_individual_button: true,
      show_effects_button: true,
      show_popup_scenes: true,
      show_popup_effects: true,
      // Default actions
      tap_action: { action: "toggle" },
      hold_action: { action: "hki-more-info" },
      bar_border_radius: 40,
      dynamic_bar_color: true,
      popup_slider_radius: 12,
      popup_value_font_size: 36,
      popup_value_font_weight: 300,
      popup_label_font_size: 16,
      popup_label_font_weight: 400,
      popup_time_format: "auto",
      // Default styling offsets/sizes
      brightness_font_weight: "bold",
      name_offset_x: -10,
      state_offset_x: -10,
      label_offset_x: -10,
      icon_offset_x: -10,
      brightness_offset_x: 10,
      brightness_offset_y: 10,
      temp_badge_offset_x: 10,
      temp_badge_offset_y: -10,
      icon_offset_y: -4,
      label_offset_y: 11,
      state_offset_y: 10,
      name_offset_y: 17,
      name_font_weight: "bold",
      state_font_weight: "bold",
      size_name: 13,
      size_state: 12,
      size_label: -2,
      size_brightness: 12,
      size_icon: 30,
      temp_badge_size: 40,
    });

    static _cloneBaseDefaults() {
      return JSON.parse(JSON.stringify(HkiButtonCard.BASE_DEFAULTS));
    }
    
    static getConfigElement() {
      // Guard: if editor failed to register for any reason, fall back to a minimal element.
      if (!customElements.get(EDITOR_TAG)) {
        const el = document.createElement("div");
        el.innerHTML = "HKI Button Card editor failed to load. Check browser console for errors.";
        return el;
      }
      return document.createElement(EDITOR_TAG);
    }

    static getStubConfig() {
      return {
        type: `custom:${CARD_TYPE}`,
        ...HkiButtonCard._cloneBaseDefaults(),
      };
    }

    // â”€â”€â”€ CONFIG FORMAT: FLAT (internal) â†” NESTED (user YAML) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Each entry: [flatKey, ...nestedPathSegments]
    static _CONFIG_MAP = [
      // styles.card
      ['card_color',            'styles','card','color'],
      ['card_opacity',          'styles','card','opacity'],
      ['border_radius',         'styles','card','border_radius'],
      ['box_shadow',            'styles','card','box_shadow'],
      ['border_width',          'styles','card','border_width'],
      ['border_style',          'styles','card','border_style'],
      ['border_color',          'styles','card','border_color'],
      // styles.icon
      ['icon_color',            'styles','icon','color'],
      ['size_icon',             'styles','icon','size'],
      ['icon_circle_bg',        'styles','icon','circle','bg'],
      ['icon_circle_border_style','styles','icon','circle','border_style'],
      ['icon_circle_border_color','styles','icon','circle','border_color'],
      ['icon_circle_border_width','styles','icon','circle','border_width'],
      // styles.typography.name
      ['name_color',            'styles','typography','name','color'],
      ['name_font_family',      'styles','typography','name','font_family'],
      ['name_font_custom',      'styles','typography','name','font_custom'],
      ['name_font_weight',      'styles','typography','name','weight'],
      ['size_name',             'styles','typography','name','size'],
      ['name_text_align',       'styles','typography','name','text_align'],
      // styles.typography.state
      ['state_color',           'styles','typography','state','color'],
      ['state_font_family',     'styles','typography','state','font_family'],
      ['state_font_custom',     'styles','typography','state','font_custom'],
      ['state_font_weight',     'styles','typography','state','weight'],
      ['size_state',            'styles','typography','state','size'],
      ['state_text_align',      'styles','typography','state','text_align'],
      // styles.typography.label
      ['label_color',           'styles','typography','label','color'],
      ['label_font_family',     'styles','typography','label','font_family'],
      ['label_font_custom',     'styles','typography','label','font_custom'],
      ['label_font_weight',     'styles','typography','label','weight'],
      ['size_label',            'styles','typography','label','size'],
      ['label_text_align',      'styles','typography','label','text_align'],
      // styles.typography.info_display (formerly brightness_*)
      ['brightness_color',      'styles','typography','info_display','color'],
      ['brightness_color_on',   'styles','typography','info_display','color_on'],
      ['brightness_color_off',  'styles','typography','info_display','color_off'],
      ['brightness_font_family','styles','typography','info_display','font_family'],
      ['brightness_font_custom','styles','typography','info_display','font_custom'],
      ['brightness_font_weight','styles','typography','info_display','weight'],
      ['size_brightness',       'styles','typography','info_display','size'],
      ['brightness_text_align', 'styles','typography','info_display','text_align'],
      // offsets
      ['name_offset_x',         'offsets','name','x'],
      ['name_offset_y',         'offsets','name','y'],
      ['state_offset_x',        'offsets','state','x'],
      ['state_offset_y',        'offsets','state','y'],
      ['label_offset_x',        'offsets','label','x'],
      ['label_offset_y',        'offsets','label','y'],
      ['icon_offset_x',         'offsets','icon','x'],
      ['icon_offset_y',         'offsets','icon','y'],
      ['icon_circle_offset_x',  'offsets','icon_circle','x'],
      ['icon_circle_offset_y',  'offsets','icon_circle','y'],
      ['icon_badge_offset_x',   'offsets','icon_badge','x'],
      ['icon_badge_offset_y',   'offsets','icon_badge','y'],
      ['brightness_offset_x',   'offsets','info_display','x'],
      ['brightness_offset_y',   'offsets','info_display','y'],
      ['temp_badge_offset_x',   'offsets','temp_badge','x'],
      ['temp_badge_offset_y',   'offsets','temp_badge','y'],
      ['badge_offset_x',        'offsets','badge_card','x'],
      ['badge_offset_y',        'offsets','badge_card','y'],
      // badge card styling (badge layout outer appearance)
      ['badge_bg',              'styles','badge_card','bg'],
      ['badge_border_style',    'styles','badge_card','border_style'],
      ['badge_border_width',    'styles','badge_card','border_width'],
      ['badge_border_color',    'styles','badge_card','border_color'],
      ['badge_border_radius',   'styles','badge_card','border_radius'],
      ['badge_box_shadow',      'styles','badge_card','box_shadow'],
      ['badge_circle',          'styles','badge_card','circle'],
      ['badge_font_family',     'styles','badge_card','font_family'],
      ['badge_font_weight',     'styles','badge_card','font_weight'],
      ['badge_size',            'styles','badge_card','size'],
      ['size_badge',            'styles','badge_card','font_size'],
      // temp_badge styling
      ['temp_badge_border_color', 'styles','temp_badge','border_color'],
      ['temp_badge_border_radius','styles','temp_badge','border_radius'],
      ['temp_badge_border_style', 'styles','temp_badge','border_style'],
      ['temp_badge_border_width', 'styles','temp_badge','border_width'],
      ['temp_badge_box_shadow',   'styles','temp_badge','box_shadow'],
      ['temp_badge_font_custom',  'styles','temp_badge','font_custom'],
      ['temp_badge_font_family',  'styles','temp_badge','font_family'],
      ['temp_badge_font_weight',  'styles','temp_badge','font_weight'],
      ['temp_badge_size',         'styles','temp_badge','size'],
      ['temp_badge_text_color',   'styles','temp_badge','text_color'],
      ['size_temp_badge',         'styles','temp_badge','font_size'],
      // tile styling
      ['tile_height',             'styles','tile','height'],
      ['tile_slider_fill_color',  'styles','tile','slider_fill_color'],
      ['tile_slider_track_color', 'styles','tile','slider_track_color'],
      ['show_tile_slider',        'styles','tile','show_slider'],
      // climate
      ['climate_current_temperature_entity','climate','current_temperature_entity'],
      ['climate_humidity_entity',   'climate','humidity_entity'],
      ['climate_humidity_name',     'climate','humidity_name'],
      ['climate_pressure_entity',   'climate','pressure_entity'],
      ['climate_pressure_name',     'climate','pressure_name'],
      ['climate_show_gradient',     'climate','show_gradient'],
      ['climate_show_plus_minus',   'climate','show_plus_minus'],
      ['climate_temp_step',         'climate','temp_step'],
      ['climate_temperature_name',  'climate','temperature_name'],
      ['climate_use_circular_slider','climate','use_circular_slider'],
      ['climate_show_target_range',  'climate','show_target_range'],
      // humidifier
      ['humidifier_use_circular_slider','humidifier','use_circular_slider'],
      ['humidifier_show_plus_minus',    'humidifier','show_plus_minus'],
      ['humidifier_fan_entity',         'humidifier','fan_entity'],
      ['humidifier_show_gradient',      'humidifier','show_gradient'],
      ['humidifier_humidity_step',      'humidifier','humidity_step'],
      // hki_popup
      ['popup_border_radius',       'hki_popup','border_radius'],
      ['popup_button_bg',           'hki_popup','button','bg'],
      ['popup_button_border_color', 'hki_popup','button','border_color'],
      ['popup_button_border_style', 'hki_popup','button','border_style'],
      ['popup_button_border_width', 'hki_popup','button','border_width'],
      ['popup_button_opacity',      'hki_popup','button','opacity'],
      ['popup_button_radius',       'hki_popup','button','radius'],
      ['popup_button_text_color',   'hki_popup','button','text_color'],
      ['popup_hide_button_text',    'hki_popup','hide_button_text'],
      ['popup_highlight_border_color','hki_popup','highlight','border_color'],
      ['popup_highlight_border_style','hki_popup','highlight','border_style'],
      ['popup_highlight_border_width','hki_popup','highlight','border_width'],
      ['popup_highlight_box_shadow','hki_popup','highlight','box_shadow'],
      ['popup_highlight_color',     'hki_popup','highlight','color'],
      ['popup_highlight_opacity',   'hki_popup','highlight','opacity'],
      ['popup_highlight_radius',    'hki_popup','highlight','radius'],
      ['popup_highlight_text_color','hki_popup','highlight','text_color'],
      ['popup_label_font_size',     'hki_popup','label','font_size'],
      ['popup_label_font_weight',   'hki_popup','label','font_weight'],
      ['popup_show_effects',        'hki_popup','show_effects'],
      ['popup_show_favorites',      'hki_popup','show_favorites'],
      ['popup_show_presets',        'hki_popup','show_presets'],
      ['popup_slider_radius',       'hki_popup','slider_radius'],
      ['popup_time_format',         'hki_popup','time_format'],
      ['popup_value_font_size',     'hki_popup','value','font_size'],
      ['popup_value_font_weight',   'hki_popup','value','font_weight'],
      ['popup_blur_enabled',        'hki_popup','blur_enabled'],
      ['popup_blur_amount',         'hki_popup','blur_amount'],
      ['popup_width',               'hki_popup','width'],
      ['popup_height',              'hki_popup','height'],
      ['popup_width_custom',        'hki_popup','width_custom'],
      ['popup_height_custom',       'hki_popup','height_custom'],
      ['popup_card_blur_enabled',   'hki_popup','card_blur_enabled'],
      ['popup_card_blur_amount',    'hki_popup','card_blur_amount'],
      ['popup_card_opacity',        'hki_popup','card_opacity'],
      ['popup_default_view',        'hki_popup','default_view'],
      ['popup_default_section',     'hki_popup','default_section'],
      ['popup_open_animation',      'hki_popup','open_animation'],
      ['popup_close_animation',     'hki_popup','close_animation'],
      ['popup_animation_duration',  'hki_popup','animation_duration'],
      // bottom bar & person popup (new)
      ['popup_hide_bottom_bar',     'hki_popup','hide_bottom_bar'],
      ['popup_hide_top_bar',        'hki_popup','hide_top_bar'],
      ['popup_show_close_button',   'hki_popup','show_close_button'],
      ['popup_close_on_action',     'hki_popup','close_on_action'],
      ['popup_bottom_bar_align',    'hki_popup','bottom_bar_align'],
      ['popup_bottom_bar_entities', 'hki_popup','bottom_bar_entities'],
      ['person_geocoded_entity',    'hki_popup','person_geocoded_entity'],
      // sensor popup graph options (new)
      ['sensor_graph_color',        'hki_popup','sensor_graph_color'],
      ['sensor_graph_gradient',     'hki_popup','sensor_graph_gradient'],
      ['sensor_line_width',         'hki_popup','sensor_line_width'],
      ['sensor_hours',              'hki_popup','sensor_hours'],
      ['sensor_graph_style',         'hki_popup','sensor_graph_style'],
      // custom popup
      ['custom_popup_enabled',      'custom_popup','enabled'],
      ['custom_popup_card',         'custom_popup','card'],
      // lock
      ['lock_contact_sensor_entity','lock','contact_sensor_entity'],
      ['lock_contact_sensor_label', 'lock','contact_sensor_label'],
    ];

    // All valid non-mapped root-level keys. Anything else (old/obsolete) gets stripped.
    static VALID_ROOT_KEYS = new Set([
      // Identity
      'type', 'entity', 'icon', 'card_layout',
      // Content
      'name', 'state_label', 'label', 'info_display',
      'use_entity_picture', 'entity_picture', 'entity_picture_override',
      // Actions
      'tap_action', 'hold_action', 'double_tap_action',
      'icon_tap_action', 'icon_hold_action', 'icon_double_tap_action',
      // Visibility
      'show_name', 'show_state', 'show_label', 'show_brightness',
      'show_info_display', 'show_icon', 'show_icon_circle', 'show_icon_badge',
      'show_temp_badge', 'show_tile_slider',
      'show_scenes_button', 'show_individual_button', 'show_effects_button',
      'show_popup_scenes', 'show_popup_effects',
      // Misc card settings
      'bar_border_radius', 'dynamic_bar_color',
      'icon_animation', 'icon_align', 'enable_icon_animation',
      // Custom popup
      'custom_popup',
      // Home Assistant layout metadata (must be preserved)
      'grid_options', 'visibility',
      '_bb_slots',
      // Layout / canvas
      'element_order', 'element_grid', 'grid_rows', 'grid_columns',
      'use_canvas_layout', 'canvas_layout',
      'grid_cell_padding_px', 'grid_inset_percent', 'text_line_gap_px',
    ]);

    static _getNestedValue(obj, path) {
      let cur = obj;
      for (const key of path) {
        if (cur === null || cur === undefined || typeof cur !== 'object') return undefined;
        cur = cur[key];
      }
      return cur;
    }

    static _setNestedValue(obj, path, value) {
      let cur = obj;
      for (let i = 0; i < path.length - 1; i++) {
        if (typeof cur[path[i]] !== 'object' || cur[path[i]] === null) cur[path[i]] = {};
        cur = cur[path[i]];
      }
      cur[path[path.length - 1]] = value;
    }

    // Normalize any config format (old flat OR new nested) â†’ flat internal keys.
    // Also strips obsolete/unknown keys that are not in the valid set.
    static _migrateFlatConfig(config) {
      if (!config || typeof config !== 'object') return config;
      const NESTED_SECTIONS = new Set(['styles','offsets','climate','humidifier','hki_popup','lock','custom_popup']);
      const MAPPED_FLAT_KEYS = new Set(HkiButtonCard._CONFIG_MAP.map(([k]) => k));
      const flat = {};
      // 1. Copy root-level keys that are in the valid whitelist (strips obsolete flat keys)
      for (const [k, v] of Object.entries(config)) {
        if (!NESTED_SECTIONS.has(k) && HkiButtonCard.VALID_ROOT_KEYS.has(k)) flat[k] = v;
      }
      // 2. Also copy root-level keys that are valid mapped flat keys (old flat format passthrough)
      for (const [k, v] of Object.entries(config)) {
        if (!NESTED_SECTIONS.has(k) && MAPPED_FLAT_KEYS.has(k)) flat[k] = v;
      }
      // 3. Extract nested keys via the map (new nested format; wins over old flat)
      for (const [flatKey, ...path] of HkiButtonCard._CONFIG_MAP) {
        const val = HkiButtonCard._getNestedValue(config, path);
        if (val !== undefined) flat[flatKey] = val;
      }
      return flat;
    }

    // Convert flat internal config â†’ nested YAML format for user-facing output.
    static _serializeToNested(flat) {
      if (!flat || typeof flat !== 'object') return flat;
      const MAPPED_FLAT_KEYS = new Set(HkiButtonCard._CONFIG_MAP.map(([k]) => k));
      const nested = {};
      // 1. Root-level (non-mapped) keys stay at root
      for (const [k, v] of Object.entries(flat)) {
        if (!MAPPED_FLAT_KEYS.has(k)) nested[k] = v;
      }
      // 2. Mapped keys go to their nested paths
      for (const [flatKey, ...path] of HkiButtonCard._CONFIG_MAP) {
        if (Object.prototype.hasOwnProperty.call(flat, flatKey)) {
          HkiButtonCard._setNestedValue(nested, path, flat[flatKey]);
        }
      }
      return nested;
    }

    static get properties() {
      return {
        hass: {},
        _config: { state: true },
        _popupOpen: { state: true },
        _activeView: { state: true },
        _brightness: { state: true },
        _expandedEffects: { state: true }, 
        _tempMin: { state: true },
        _tempMax: { state: true },
        _step: { state: true }
      };
    }

    constructor() {
      super();
      this._paDomainCache = {};
      this._rawConfigInput = null;
      this._onGlobalSettingsChanged = () => {
        if (!this._rawConfigInput) return;
        try { this.setConfig(this._rawConfigInput); } catch (_) {}
      };

      // Custom Popup YAML editor state (prevents re-serializing YAML while typing)
      this._customPopupYamlDraft = null;
      this._customPopupYamlFocused = false;
      this._customPopupYamlDebounce = null;
      this._popupOpen = false;
      this._popupPortal = null;
      this._activeView = 'brightness'; // brightness, temperature, color
      this._favoritesEditMode = false;
      this._lightFavorites = null;
      this._groupMemberModes = {};
      this._switchGroupMode = false;
      this._holdTimer = null;
      this._tapTimer = null;
      this._brightness = 100;
      this._hue = 0;
      this._saturation = 0; 
      this._isDragging = false;
      this._expandedEffects = false;
      this._tempMin = 7;
      this._tempMax = 35;
      this._step = 0.5;
    
      // Stage size measurement (used for stable placement inside parent grid cards)
      this._stageW = 0;
      this._stageH = 0;
      this._stageRO = null;
      
      // Template rendering system with caching
      this._tpl = {
        timer: 0,
        name: { raw: "", sig: "", seq: 0, unsub: null },
        state: { raw: "", sig: "", seq: 0, unsub: null },
        label: { raw: "", sig: "", seq: 0, unsub: null },
        info: { raw: "", sig: "", seq: 0, unsub: null },
        icon: { raw: "", sig: "", seq: 0, unsub: null },
        // Styling templates
        cardColor: { raw: "", sig: "", seq: 0, unsub: null },
        cardOpacity: { raw: "", sig: "", seq: 0, unsub: null },
        boxShadow: { raw: "", sig: "", seq: 0, unsub: null },
        borderColor: { raw: "", sig: "", seq: 0, unsub: null },
        borderWidth: { raw: "", sig: "", seq: 0, unsub: null },
        borderStyle: { raw: "", sig: "", seq: 0, unsub: null },
        borderRadius: { raw: "", sig: "", seq: 0, unsub: null },
        iconColor: { raw: "", sig: "", seq: 0, unsub: null },
        iconCircleBg: { raw: "", sig: "", seq: 0, unsub: null },
        iconCircleBorderColor: { raw: "", sig: "", seq: 0, unsub: null },
        iconCircleBorderWidth: { raw: "", sig: "", seq: 0, unsub: null },
        iconCircleBorderStyle: { raw: "", sig: "", seq: 0, unsub: null },
        badgeBg: { raw: "", sig: "", seq: 0, unsub: null },
        badgeBorderColor: { raw: "", sig: "", seq: 0, unsub: null },
        badgeBorderWidth: { raw: "", sig: "", seq: 0, unsub: null },
        badgeBorderStyle: { raw: "", sig: "", seq: 0, unsub: null },
        nameColor: { raw: "", sig: "", seq: 0, unsub: null },
        stateColor: { raw: "", sig: "", seq: 0, unsub: null },
        labelColor: { raw: "", sig: "", seq: 0, unsub: null },
        brightnessColor: { raw: "", sig: "", seq: 0, unsub: null },
        brightnessColorOn: { raw: "", sig: "", seq: 0, unsub: null },
        brightnessColorOff: { raw: "", sig: "", seq: 0, unsub: null },
        iconAnimation: { raw: "", sig: "", seq: 0, unsub: null }
      };
      this._renderedName = '';
      this._renderedState = '';
      this._renderedLabel = '';
      this._renderedInfo = '';
      this._renderedIcon = '';
      // Styling rendered values
      this._renderedCardColor = '';
      this._renderedCardOpacity = '';
      this._renderedBoxShadow = '';
      this._renderedBorderColor = '';
      this._renderedBorderWidth = '';
      this._renderedBorderStyle = '';
      this._renderedBorderRadius = '';
      this._renderedIconColor = '';
      this._renderedIconCircleBg = '';
      this._renderedIconCircleBorderColor = '';
      this._renderedIconCircleBorderWidth = '';
      this._renderedIconCircleBorderStyle = '';
      this._renderedBadgeBg = '';
      this._renderedBadgeBorderColor = '';
      this._renderedBadgeBorderWidth = '';
      this._renderedBadgeBorderStyle = '';
      this._renderedNameColor = '';
      this._renderedStateColor = '';
      this._renderedLabelColor = '';
      this._renderedBrightnessColor = '';
      this._renderedIconAnimation = '';
      this._hassReady = false;
      
      // Tile slider throttling
      this._sliderThrottleTimer = null;
      this._sliderPendingValue = null;
    }

    setConfig(config) {
      if (!config) throw new Error("Config is required");
      this._rawConfigInput = config;
      // Normalize: accept both old flat format and new nested YAML format.
      const flatConfig = HkiButtonCard._migrateFlatConfig(config);
      this._config = {
        ...HkiButtonCard._cloneBaseDefaults(),
        ...flatConfig,
      };
      // Use the flat (migrated) config for user-override checks below
      const __layout = (this._config.card_layout || 'square');
      const cfg = flatConfig;
      const __rawOffsetFields = [
        'name_offset_x','name_offset_y',
        'state_offset_x','state_offset_y',
        'label_offset_x','label_offset_y',
        'icon_offset_x','icon_offset_y',
        'icon_badge_offset_x','icon_badge_offset_y',
        'brightness_offset_x','brightness_offset_y',
        'temp_badge_offset_x','temp_badge_offset_y',
      ];

      if (__layout === 'badge') {
        // Badge default icon size should be smaller (HA-like)
        if (!Object.prototype.hasOwnProperty.call(cfg, 'size_icon')) this._config.size_icon = 20;

        // Badge defaults: match Home Assistant badge outline
        // Apply only when the user didn't set these explicitly.
        if (!Object.prototype.hasOwnProperty.call(cfg, 'badge_border_width')) this._config.badge_border_width = 1;
        if (!Object.prototype.hasOwnProperty.call(cfg, 'badge_border_style')) this._config.badge_border_style = 'solid';
        if (!Object.prototype.hasOwnProperty.call(cfg, 'badge_border_color')) this._config.badge_border_color = 'var(--divider-color)';
        // Raw offsets default to 0 (true origin)
        for (const f of __rawOffsetFields) {
          if (!Object.prototype.hasOwnProperty.call(cfg, f)) this._config[f] = 0;
        }
        // Badge does not support label/info display fields
        this._config.show_label = false;
        this._config.show_brightness = false;
        this._config.show_info_display = false;
      }


      if (__layout === 'google_default') {
        // Google Default: square-like layout with Google Home style spacing
        if (!Object.prototype.hasOwnProperty.call(cfg, 'double_tap_action')) this._config.double_tap_action = { action: "hki-more-info" };
        if (!Object.prototype.hasOwnProperty.call(cfg, 'border_radius')) this._config.border_radius = "35";

        // Typography defaults
        if (!Object.prototype.hasOwnProperty.call(cfg, 'size_name')) this._config.size_name = 14;
        if (!Object.prototype.hasOwnProperty.call(cfg, 'size_state')) this._config.size_state = 12;
        if (!Object.prototype.hasOwnProperty.call(cfg, 'state_font_weight')) this._config.state_font_weight = "normal";
        if (!Object.prototype.hasOwnProperty.call(cfg, 'name_font_weight')) this._config.name_font_weight = "bold";

        // Offsets (editor 0-point for Google Default)
        const __googleOffsetDefaults = {
          name_offset_x: 0, name_offset_y: -6,
          state_offset_x: 0, state_offset_y: -8,
          label_offset_x: 0, label_offset_y: -6,
          icon_offset_x: -10, icon_offset_y: -1,
          icon_badge_offset_x: 0, icon_badge_offset_y: 0,
          brightness_offset_x: 0, brightness_offset_y: 0,
          temp_badge_offset_x: 0, temp_badge_offset_y: 0,
        };
        for (const [k, v] of Object.entries(__googleOffsetDefaults)) {
          if (!Object.prototype.hasOwnProperty.call(cfg, k)) this._config[k] = v;
        }

        // Feature visibility: fixed off for this style
        if (!Object.prototype.hasOwnProperty.call(cfg, 'show_brightness')) this._config.show_brightness = false;
        this._config.show_icon_circle = false;
        this._config.show_icon_badge = false;
        this._config.show_info_display = false;
      }

      if (__layout === 'hki_tile') {
        // Tile default icon size
        if (!Object.prototype.hasOwnProperty.call(cfg, 'size_icon')) this._config.size_icon = 45;

        // Tile baseline offsets (editor 0-point)
        const __tileOffsetDefaults = {
          name_offset_x: 44, name_offset_y: -18,
          state_offset_x: 44, state_offset_y: -15,
          label_offset_x: 0, label_offset_y: 0,
          icon_offset_x: -17, icon_offset_y: 13,
          icon_badge_offset_x: 0, icon_badge_offset_y: 0,
          brightness_offset_x: 21, brightness_offset_y: 43,
          temp_badge_offset_x: 0, temp_badge_offset_y: 0,
        };
        for (const [k, v] of Object.entries(__tileOffsetDefaults)) {
          if (!Object.prototype.hasOwnProperty.call(cfg, k)) this._config[k] = v;
        }
        // Tile does not support label
        this._config.show_label = false;
      }

      applyGlobalDefaultsToConfig({
        scope: "button",
        config: this._config,
        sourceConfig: cfg,
        fields: [
          "card_color",
          "card_opacity",
          "border_radius",
          "box_shadow",
          "border_width",
          "border_style",
          "border_color",
          "icon_color",
          "icon_animation",
          "size_icon",
          "icon_circle_bg",
          "icon_circle_border_style",
          "icon_circle_border_width",
          "icon_circle_border_color",
          "badge_bg",
          "badge_border_style",
          "badge_border_width",
          "badge_border_color",
          "badge_border_radius",
          "badge_box_shadow",
          "size_badge",
          "badge_font_family",
          "badge_font_weight",
          "temp_badge_text_color",
          "temp_badge_border_color",
          "temp_badge_border_style",
          "temp_badge_border_width",
          "temp_badge_border_radius",
          "temp_badge_box_shadow",
          "temp_badge_font_family",
          "temp_badge_font_custom",
          "temp_badge_font_weight",
          "size_temp_badge",
          "temp_badge_size",
          "name_font_family",
          "name_font_custom",
          "name_font_weight",
          "size_name",
          "name_color",
          "state_font_family",
          "state_font_custom",
          "state_font_weight",
          "size_state",
          "state_color",
          "label_font_family",
          "label_font_custom",
          "label_font_weight",
          "size_label",
          "label_color",
          "brightness_font_family",
          "brightness_font_custom",
          "brightness_font_weight",
          "size_brightness",
          "brightness_color",
          "brightness_color_on",
          "brightness_color_off",
          "name_text_align",
          "state_text_align",
          "label_text_align",
          "brightness_text_align",
          "name_offset_x",
          "name_offset_y",
          "state_offset_x",
          "state_offset_y",
          "label_offset_x",
          "label_offset_y",
          "icon_offset_x",
          "icon_offset_y",
          "icon_circle_offset_x",
          "icon_circle_offset_y",
          "icon_badge_offset_x",
          "icon_badge_offset_y",
          "badge_offset_x",
          "badge_offset_y",
          "brightness_offset_x",
          "brightness_offset_y",
          "temp_badge_offset_x",
          "temp_badge_offset_y",
          "badge_circle",
          "badge_size",
          "icon_align",
          "enable_icon_animation",
          "tile_height",
          "show_tile_slider",
          "tile_slider_fill_color",
          "tile_slider_track_color",
        ],
      });
      applyGlobalDefaultsToConfig({
        scope: "popup",
        config: this._config,
        sourceConfig: cfg,
        fields: [
          "popup_border_radius",
          "popup_width",
          "popup_width_custom",
          "popup_height",
          "popup_height_custom",
          "popup_open_animation",
          "popup_close_animation",
          "popup_animation_duration",
          "popup_blur_enabled",
          "popup_blur_amount",
          "popup_card_blur_enabled",
          "popup_card_blur_amount",
          "popup_card_opacity",
          "popup_show_favorites",
          "popup_show_effects",
          "popup_show_presets",
          "popup_slider_radius",
          "popup_hide_button_text",
          "popup_value_font_size",
          "popup_value_font_weight",
          "popup_label_font_size",
          "popup_label_font_weight",
          "popup_time_format",
          "popup_default_view",
          "popup_default_section",
          "popup_highlight_color",
          "popup_highlight_text_color",
          "popup_highlight_radius",
          "popup_highlight_opacity",
          "popup_highlight_border_color",
          "popup_highlight_border_style",
          "popup_highlight_border_width",
          "popup_highlight_box_shadow",
          "popup_button_bg",
          "popup_button_text_color",
          "popup_button_radius",
          "popup_button_opacity",
          "popup_button_border_color",
          "popup_button_border_style",
          "popup_button_border_width",
          "popup_bottom_bar_align",
          "popup_hide_bottom_bar",
          "popup_hide_top_bar",
          "popup_show_close_button",
          "popup_close_on_action",
          "sensor_graph_color",
          "sensor_graph_gradient",
          "sensor_line_width",
          "sensor_hours",
          "sensor_graph_style",
          "climate_temp_step",
          "climate_use_circular_slider",
          "climate_show_plus_minus",
          "climate_show_gradient",
          "climate_show_target_range",
          "humidifier_humidity_step",
          "humidifier_use_circular_slider",
          "humidifier_show_plus_minus",
          "humidifier_show_gradient",
        ],
      });
      
      // Domain-specific action defaults (only when user did not explicitly configure the action)
      const domain = this._config.entity ? this._config.entity.split('.')[0] : '';
      const toggleDomains = new Set(['switch', 'climate', 'input_boolean', 'automation', 'light']);
      const infoAction = this._supportsHkiPopup() ? 'hki-more-info' : 'more-info';
      if (!Object.prototype.hasOwnProperty.call(cfg, 'tap_action')) {
        this._config.tap_action = toggleDomains.has(domain) ? { action: 'toggle' } : { action: infoAction };
      }
      if (!Object.prototype.hasOwnProperty.call(cfg, 'hold_action')) {
        this._config.hold_action = { action: infoAction };
      }
      if (!Object.prototype.hasOwnProperty.call(cfg, 'double_tap_action')) {
        this._config.double_tap_action = { action: infoAction };
      }
      
      // Setup templates when config changes (use longer delay to debounce editor changes)
      if (this.hass) {
        this._scheduleTemplateSetup(80);
      }
      
      this.requestUpdate();
    

      // Ensure badge layout sizes to content inside HA stacks (avoids large gaps)
      this._applyHostLayoutSizing();
      }

    connectedCallback() {
      super.connectedCallback();
      window.addEventListener("hki-global-settings-changed", this._onGlobalSettingsChanged);
      // Set up templates immediately when element connects (0ms = next tick)
      // This matches header card behavior for faster initial render
      if (this.hass && this._config) {
        this._scheduleTemplateSetup();
      }
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      window.removeEventListener("hki-global-settings-changed", this._onGlobalSettingsChanged);
      // Unsubscribe all templates
      if (this._tpl) {
        Object.keys(this._tpl).forEach(key => {
          if (key !== 'timer') {
            this._unsubscribeTemplate(key);
          }
        });
        if (this._tpl.timer) clearTimeout(this._tpl.timer);
      }
      // Disconnect stage resize observer
      if (this._stageRO) {
        try { this._stageRO.disconnect(); } catch (_) {}
        this._stageRO = null;
      }
      
      // Clear slider throttle timer
      if (this._sliderThrottleTimer) {
        clearTimeout(this._sliderThrottleTimer);
        this._sliderThrottleTimer = null;
      }
    }

    updated(changedProps) {

      // Keep host sizing in sync with layout (important for badge layout in stacks)
      this._applyHostLayoutSizing();

      // Ensure we have accurate stage dimensions for stable grid placement (especially inside parent type: grid cards).
      // We observe the ha-card (actual visible box) rather than the host element to avoid padding/overflow clipping issues.
      if (!this._stageRO && this.shadowRoot) {
        const _cardEl = this.shadowRoot.querySelector('ha-card');
        if (_cardEl && window.ResizeObserver) {
          this._stageRO = new ResizeObserver(() => {
            try {
              const r = _cardEl.getBoundingClientRect();
              const w = r.width || 0;
              const h = r.height || 0;
              if (w !== this._stageW || h !== this._stageH) {
                this._stageW = w;
                this._stageH = h;
                this.requestUpdate();
              }
            } catch (_) {}
          });
          try { this._stageRO.observe(_cardEl); } catch (_) {}
          try {
            const r0 = _cardEl.getBoundingClientRect();
            this._stageW = r0.width || 0;
            this._stageH = r0.height || 0;
          } catch (_) {}
        }
      }


      // Setup templates when hass changes
      if (changedProps.has("hass") && this.hass) {
        const nowReady = !!this.hass?.connection && typeof this.hass?.callWS === "function";
        if (nowReady && !this._hassReady) {
          // First time hass is ready - set up templates immediately (0ms)
          this._hassReady = true;
          this._scheduleTemplateSetup(0);
        } else {
          // Subsequent updates - can use default delay
          this._scheduleTemplateSetup?.();
        }
      }
      
      // Logic for popup updates
      if (changedProps.has("hass")) {
        // Popup updates
        if (this._popupOpen) {
          if (this._isDragging) return;
          const oldHass = changedProps.get("hass");
          const trackedId = this._popupEntityId || this._config.entity;
          const oldEntity = trackedId ? oldHass?.states[trackedId] : null;
          const newEntity = trackedId ? this.hass?.states[trackedId] : null;
          
          // For locks, also check if contact sensor state has changed
          let shouldUpdate = false;
          if (this._getDomain() === 'lock' && this._config.lock_contact_sensor_entity) {
            const oldContactSensor = oldHass?.states[this._config.lock_contact_sensor_entity];
            const newContactSensor = this.hass?.states[this._config.lock_contact_sensor_entity];
            if (oldContactSensor?.state !== newContactSensor?.state) {
              shouldUpdate = true;
            }
          }
          
          
          // For switch popup group view: update if any member state/attrs changed, even if the group entity itself didn't.
          if (!shouldUpdate && this._popupType === 'switch' && this._activeView === 'group' && newEntity && Array.isArray(newEntity.attributes?.entity_id)) {
            const members = newEntity.attributes.entity_id || [];
            for (const mid of members) {
              const o = oldHass?.states?.[mid];
              const nn = this.hass?.states?.[mid];
              if ((o?.state !== nn?.state) || (JSON.stringify(o?.attributes) !== JSON.stringify(nn?.attributes))) {
                shouldUpdate = true;
                break;
              }
            }
          }
          if (!shouldUpdate && oldEntity && newEntity &&
              oldEntity.state === newEntity.state &&
              JSON.stringify(oldEntity.attributes) === JSON.stringify(newEntity.attributes)) {
            return;
          }
          
          const activeEl = this._popupPortal ? this._popupPortal.querySelector(':focus') : null;
          const isDropdownFocused = activeEl && activeEl.tagName === 'SELECT';

          if (!isDropdownFocused) {
            // Custom popup: update embedded card with new hass
            if (this._popupType === 'custom') {
              // If this custom popup was opened without an entity, there is nothing to
              // diff/track in hass. Re-rendering the entire portal on every hass update
              // causes rapid rebuilds ("go crazy") and can prevent closing.
              // In that case, only forward the latest hass to the embedded card.
              if (!trackedId) {
                const cardContainer = this._popupPortal?.querySelector('#customCardContainer');
                const cardElement = cardContainer?.querySelector('*:not([style])');
                if (cardElement && cardElement.hass !== this.hass) {
                  cardElement.hass = this.hass;
                }
                return;
              }

              const cardContainer = this._popupPortal?.querySelector('#customCardContainer');
              const cardElement = cardContainer?.querySelector('*:not([style])');
              if (cardElement && cardElement.hass !== this.hass) {
                cardElement.hass = this.hass;
              }
              // Still re-render to update header state/timestamp
              this._renderCustomPopupPortal(newEntity);
              return;
            }
            if (this._getDomain() === 'climate') {
              this._renderClimatePopupPortal(newEntity);
              return;
            }
            if (this._getDomain() === 'alarm_control_panel') {
              this._renderAlarmPopupPortal(newEntity);
              return;
            }
            if (this._getDomain() === 'cover') {
              this._renderCoverPopupPortal(newEntity);
              return;
            }
            if (this._getDomain() === 'humidifier') {
              this._renderHumidifierPopupPortal(newEntity);
              return;
            }
            if (this._getDomain() === 'fan') {
              this._renderFanPopupPortal(newEntity);
              return;
            }
            if (this._popupType === 'switch' || this._getDomain() === 'switch' || this._getDomain() === 'input_boolean') {
              this._renderSwitchPopupPortal(newEntity);
              return;
            }
            if (this._getDomain() === 'lock') {
              this._renderLockPopupPortal(newEntity);
              return;
            }

            this._syncState();
            this._updateHeaderIcon();
            
            if (this._activeView === 'brightness') {
              this._updateBrightnessDisplay();
            } else if (this._activeView === 'temperature') {
              this._updateTemperatureDisplay();
            } else if (this._activeView === 'color') {
              this._updateColorDisplay();
            }

            // If we're in the group member list view, re-render it so per-member
            // brightness/state updates reflect immediately.
            try {
              const viewType = this._popupPortal?.querySelector('[data-view-type]')?.dataset?.viewType;
              const entityIsGroup = Array.isArray(newEntity?.attributes?.entity_id) && newEntity.attributes.entity_id.length > 0;
              if (viewType === 'individual' && entityIsGroup) {
                const content = this._popupPortal?.querySelector('.hki-light-popup-content');
                if (content) {
                  content.innerHTML = this._renderIndividualView();
                  this._setupContentHandlers(this._popupPortal);
                }
              }
            } catch (e) {}
          }
        }
      }
    }
    _isEditMode() {
      // Robust detection for Lovelace edit/preview containers (works for header badges too).
      try {
        const seen = new Set();
        const walk = (node) => {
          while (node) {
            if (seen.has(node)) break;
            seen.add(node);

            if (node.nodeType === 1) {
              const tag = (node.tagName || '').toUpperCase();
              if (
                tag === 'HUI-CARD-PREVIEW' ||
                tag === 'HUI-SECTION-PREVIEW' ||
                tag === 'HUI-VIEW-PREVIEW' ||
                tag === 'HUI-ENTITY-CARD-EDITOR' ||
                tag === 'HUI-CARD-EDITOR'
              ) return true;

              if (node.hasAttribute && (node.hasAttribute('edit-mode') || node.hasAttribute('data-edit-mode') || node.getAttribute('mode') === 'edit')) {
                return true;
              }
            }

            // Walk up through light DOM
            if (node.parentNode) {
              node = node.parentNode;
              continue;
            }

            // Walk up through shadow DOM
            const root = node.getRootNode && node.getRootNode();
            node = root && root.host ? root.host : null;
          }
          return false;
        };

        if (walk(this)) return true;

        // URL fallback
        const p = window?.location?.pathname || '';
        if (p.includes('/config/') || (p.includes('/lovelace/') && p.includes('edit'))) return true;
      } catch (e) {}
      return false;
    }



    /* --- HELPER METHODS --- */


    _applyHostLayoutSizing() {
      try {
        const layout = (this._config?.card_layout || 'square');
        // In HA stacks (e.g. horizontal-stack), children are flex: 1 by default, which makes
        // "badge" layout leave large gaps. Force the host itself to size to content for badges.
        if (layout === 'badge') {
          this.style.setProperty('flex', '0 0 auto', 'important');
          this.style.setProperty('width', 'fit-content');
          this.style.setProperty('max-width', '100%');
          // Avoid unintended stretching from min-width constraints
          this.style.setProperty('min-width', '0');
        } else {
          // Reset so other layouts behave normally
          this.style.removeProperty('flex');
          this.style.removeProperty('width');
          this.style.removeProperty('max-width');
          this.style.removeProperty('min-width');
        }
      } catch (_) {}
    }


    _getTempGradient() {
      return 'linear-gradient(to top, #00D9FF 0%, #00E5A0 25%, #DFFF00 50%, #FFB800 75%, #FF8C00 100%)';
    }

    _getTempStep() {
      // Prefer an explicit configured step. If none is set, use HKI default 0.5
      // (do NOT fall back to entity target_temp_step, because many entities expose 0.1
      // while HKI's intended default/UX is 0.5 unless configured otherwise).
      const raw = this._config?.climate_temp_step;
      if (raw === undefined || raw === null || raw === "") return 0.5;
      const step = Number(raw);
      return (Number.isFinite(step) && step > 0) ? step : 0.5;
    }

    _clampTemp(value) {
      // Keep values inside entity min/max, with a small rounding to avoid floating errors
      return Math.max(this._tempMin, Math.min(this._tempMax, Math.round(Number(value) * 10) / 10));
    }

    _roundToStep(value, step) {
      const s = Number(step);
      if (!Number.isFinite(s) || s <= 0) return Number(value);
      const v = Number(value);
      const rounded = Math.round(v / s) * s;
      // limit precision to avoid 20.0000000004 style artifacts
      return Math.round(rounded * 1000) / 1000;
    }

    _getTempPercentage(value) {
      return ((value - this._tempMin) / (this._tempMax - this._tempMin)) * 100;
    }

    _updateCircularSliderUI(portal, value, unit) {
      const percentage = this._getTempPercentage(value);
      const maxArcLength = 628.32 * 0.75;
      const arcLength = (percentage / 100) * maxArcLength;
      const startAngle = 135 * (Math.PI / 180);
      const arcAngle = (percentage / 100) * 270 * (Math.PI / 180);
      const totalAngle = startAngle + arcAngle;
      const thumbX = 140 + 100 * Math.cos(totalAngle);
      const thumbY = 140 + 100 * Math.sin(totalAngle);
      const valueSize = this._config.popup_value_font_size || 64;
      
      const progress = portal.querySelector('#circularProgress');
      const thumb = portal.querySelector('#circularThumb');
      const valueDisplay = portal.querySelector('#circularTempValue');
      
      if (progress) progress.setAttribute('stroke-dasharray', `${arcLength} 628.32`);
      if (thumb) {
        thumb.setAttribute('cx', thumbX);
        thumb.setAttribute('cy', thumbY);
      }
      if (valueDisplay) valueDisplay.innerHTML = `${value}<span style="font-size: ${valueSize / 2}px;">${unit}</span>`;
    }

    /* --- POPUP DISPLAY UPDATES --- */
    _updateBrightnessDisplay() {
      if (!this._popupPortal) return;
      const brightness = this._getBrightness();
      const fill = this._popupPortal.querySelector('.vertical-slider-fill');
      const thumb = this._popupPortal.querySelector('.vertical-slider-thumb');
      const valueDisplay = this._popupPortal.querySelector('.value-display');
      
      if (fill) {
        fill.style.height = brightness + '%';
        if (this._config.dynamic_bar_color) {
          const color = this._getCurrentColor();
          fill.style.background = color;
        }
      }
      // Clamp thumb position so it stays visible at 0% and 100%
      const thumbPos = brightness <= 0 ? '0px' : brightness >= 100 ? 'calc(100% - 6px)' : 'calc(' + brightness + '% - 6px)';
      if (thumb) thumb.style.bottom = thumbPos;
      if (valueDisplay) valueDisplay.innerHTML = brightness + '<span>%</span>';
    }

    _updateTemperatureDisplay() {
      if (!this._popupPortal) return;
      const entity = this._getEntity();
      if (this._getDomain() === 'climate') { this._renderClimatePopupPortal(entity); return; }
      if (!entity || !entity.attributes.color_temp) return;
      
      const range = this._tempMax - this._tempMin;
      const currentTempPct = 100 - (((this._currentTemp - this._tempMin) / range) * 100);
      const kelvin = Math.round(1000000 / this._currentTemp);
      
      const fill = this._popupPortal.querySelector('.vertical-slider-fill');
      const thumb = this._popupPortal.querySelector('.vertical-slider-thumb');
      const valueDisplay = this._popupPortal.querySelector('.value-display');
      
      if (fill) fill.style.height = currentTempPct + '%';
      // Clamp thumb position so it stays visible at 0% and 100%
      const thumbPos = currentTempPct <= 0 ? '0px' : currentTempPct >= 100 ? 'calc(100% - 6px)' : 'calc(' + currentTempPct + '% - 6px)';
      if (thumb) thumb.style.bottom = thumbPos;
      if (valueDisplay) valueDisplay.textContent = this._getTempName(kelvin);
    }

    _updateColorDisplay() {
      if (!this._popupPortal) return;
      const indicator = this._popupPortal.querySelector('#colorIndicator');
      if (!indicator) return;
      
      const colorWheel = this._popupPortal.querySelector('#colorWheel');
      if (!colorWheel) return;
      
      const rect = colorWheel.getBoundingClientRect();
      const r = rect.width / 2;
      
      const theta = (this._hue - 90) * (Math.PI / 180);
      const dist = (this._saturation / 100) * r;
      
      const x = r + (dist * Math.cos(theta));
      const y = r + (dist * Math.sin(theta));
      
      indicator.style.left = x + 'px';
      indicator.style.top = y + 'px';
      indicator.style.background = 'hsl(' + this._hue + ', ' + this._saturation + '%, 50%)';
      
      const colorNameEl = this._popupPortal.querySelector('.value-display');
      if (colorNameEl) {
        colorNameEl.textContent = this._getColorName(this._hue, this._saturation);
      }
    }

    _updateHeaderIcon() {
      if (!this._popupPortal) return;
      const headerIcon = this._popupPortal.querySelector('.hki-light-popup-title ha-icon, .hki-light-popup-title ha-state-icon');
      if (headerIcon) {
        headerIcon.style.color = this._getPopupIconColor(this._getCurrentColor());
      }
      const stateEl = this._popupPortal.querySelector('.hki-light-popup-state');
      if (stateEl) {
          const entity = this._getEntity();
          const isOn = this._isOn();
          const isUnavailable = !!entity && String(entity.state || '').toLowerCase() === 'unavailable';
          const isOnEffective = isUnavailable ? false : isOn;
        const brightness = this._getBrightness();
          stateEl.textContent = this._getPopupHeaderState(isOnEffective ? brightness + '%' : 'Off');
      }
    }

    disconnectedCallback() {
      super.disconnectedCallback();
      this._closePopup();
    }

    _getDomain() {
      return this._config?.entity ? this._config.entity.split('.')[0] : '';
    }

    /**
     * Get localized state string using Home Assistant's translation system
     * Same approach as used in HKI Header Card for weather states
     */
    _getLocalizedState(state, domain) {
      if (!this.hass || !state) return state;
      
      // Get the entity object
      const entity = this.hass.states[this._config.entity];
      
      // Use HA's formatEntityState if available (same as header card)
      if (this.hass.formatEntityState && entity) {
        return this.hass.formatEntityState(entity);
      }
      
      // Fallback: title-case the state
      return String(state).replace(/_/g, ' ').toLowerCase().replace(/\b\w/g, (c) => c.toUpperCase());
    }

    /**
     * Get default icon for domain
     */
    _getDomainIcon(domain) {
      const iconMap = {
        'light': 'mdi:lightbulb',
        'switch': 'mdi:toggle-switch',
        'fan': 'mdi:fan',
        'cover': 'mdi:window-shutter',
        'lock': 'mdi:lock',
        'climate': 'mdi:thermostat',
        'alarm_control_panel': 'mdi:shield-home',
        'media_player': 'mdi:speaker',
        'vacuum': 'mdi:robot-vacuum',
        'camera': 'mdi:camera',
        'sensor': 'mdi:gauge',
        'binary_sensor': 'mdi:checkbox-marked-circle',
        'input_boolean': 'mdi:toggle-switch',
        'input_number': 'mdi:ray-vertex',
        'input_select': 'mdi:format-list-bulleted',
        'automation': 'mdi:robot',
        'script': 'mdi:script-text',
        'scene': 'mdi:palette',
        'remote': 'mdi:remote',
        'humidifier': 'mdi:air-humidifier',
      };
      return iconMap[domain] || 'mdi:gesture-tap-button';
    }

    /**
     * Return the resolved icon for popup headers.
     * Priority: configured icon (with template evaluation) â†’ entity attribute icon â†’ provided fallback
     */
    _getResolvedIcon(entity, fallback) {
      const cfgIcon = this._config.icon
        ? (this.renderTemplate('icon', this._config.icon) || '').toString().trim()
        : '';
      return cfgIcon || entity?.attributes?.icon || fallback || this._getDomainIcon(this._getDomain());
    }

    /**
     * Returns the display name for popup headers.
     * Priority: config name (template-resolved) â†’ entity friendly_name â†’ entity id
     */
    _getPopupName(entity) {
      if (this._config.name) {
        return this._isTemplate(this._config.name)
          ? (this._renderedName || entity?.attributes?.friendly_name || this._config.entity || '')
          : this._config.name;
      }
      return entity?.attributes?.friendly_name || this._config.entity || '';
    }

    /**
     * Returns the state string for popup headers.
     * If state_label is explicitly configured, it takes priority over the
     * domain-specific state string (e.g. brightness %, mode name, etc.).
     */
    _getPopupHeaderState(domainSpecificState) {
      if (this._config.state_label !== undefined && this._config.state_label !== '') {
        return this._isTemplate(this._config.state_label)
          ? (this._renderedState || domainSpecificState)
          : this._config.state_label;
      }
      return domainSpecificState;
    }

    /**
     * Returns the icon color to use in popup headers.
     * If icon_color is set in config it takes priority (template-aware).
     * Otherwise the domain-specific color (brightness-derived, state-based, etc.) is used.
     */
    // Returns either <img> or <ha-icon> HTML string for popup headers
    _getPopupHeaderIconHtml(entity, iconStr, color) {
      const useEntityPic = this._config?.use_entity_picture;
      if (useEntityPic) {
        const pic = this._config.entity_picture_override || entity?.attributes?.entity_picture;
        if (pic) return `<img src="${pic}" style="width:28px;height:28px;border-radius:50%;object-fit:cover;flex-shrink:0;" />`;
      }
      return `<ha-icon icon="${iconStr}" style="color:${color};flex-shrink:0;"></ha-icon>`;
    }

    _getPopupIconColor(domainColor) {
      if (this._config.icon_color) {
        const rendered = this.renderTemplate('iconColor', this._config.icon_color);
        if (rendered && rendered !== '[object Object]') return rendered;
      }
      return domainColor;
    }

    // Returns the best color for a climate entity by checking hvac_action first,
    // with smart temp-based inference when the action doesn't match reality.
    _getClimateColor(entity) {
      const action = entity?.attributes?.hvac_action;
      const mode = entity?.state;
      const currentTemp = entity?.attributes?.current_temperature;
      const targetTemp = entity?.attributes?.temperature;
      
      // Smart inference: if we have temp data, infer actual state from physics
      if (currentTemp !== undefined && targetTemp !== undefined) {
        // HEAT mode: simple logic
        if (mode === 'heat') {
          return targetTemp > currentTemp 
            ? (HVAC_COLORS.heating || 'darkorange')
            : (HVAC_COLORS.idle || '#4CAF50');
        }
        
        // COOL mode: simple logic
        if (mode === 'cool') {
          return targetTemp < currentTemp 
            ? (HVAC_COLORS.cooling || '#1E90FF')
            : (HVAC_COLORS.idle || '#4CAF50');
        }
        
        // AUTO/HEAT_COOL modes: more complex - need to check actual action
        if (mode === 'auto' || mode === 'heat_cool') {
          // Heating: target > current
          if (targetTemp > currentTemp) {
            return HVAC_COLORS.heating || 'darkorange';
          }
          // Cooling: target < current AND hvac_action confirms cooling
          if (targetTemp < currentTemp && action === 'cooling') {
            return HVAC_COLORS.cooling || '#1E90FF';
          }
          // Otherwise idle (target reached or not actively cooling)
          return HVAC_COLORS.idle || '#4CAF50';
        }
        
        // Other modes (fan_only, dry, etc.) - check if on
        if (mode !== 'off') {
          return HVAC_COLORS.idle || '#4CAF50';
        }
      }
      
      // Fallback to hvac_action if we have it and no temp data
      if (action && HVAC_COLORS[action] !== undefined) return HVAC_COLORS[action];
      // Final fallback to mode state
      return HVAC_COLORS?.[mode] || HVAC_COLORS?.off || 'var(--primary-color)';
    }
    
    _syncClimateState() {
      const entity = this._getEntity();
      if (!entity) return;
      const attrs = entity.attributes;
      this._tempMin = attrs.min_temp || 7;
      this._tempMax = attrs.max_temp || 35;
      this._step = this._getTempStep();
    }
    
    _getEntity() {
      if (!this.hass || !this._config.entity) return null;
      return this.hass.states[this._config.entity];
    }

    _isOn() {
      const entity = this._getEntity();
      if (!entity) return false;
      if (this._getDomain() === 'climate') return entity.state !== 'off';
      if (this._getDomain() === 'cover') return entity.state !== 'closed';
      if (this._getDomain() === 'alarm_control_panel') return entity.state !== 'disarmed';
      return entity.state === "on";
    }

    _getBrightness() {
      const entity = this._getEntity();
      if (entity && entity.attributes.brightness) {
        return Math.round((entity.attributes.brightness / 255) * 100);
      }
      return this._isOn() ? 100 : 0;
    }

    _getSliderValue() {
      // Get appropriate value for slider based on domain
      const entity = this._getEntity();
      if (!entity) return 0;

      const domain = this._getDomain();

      // Optimistic UI while dragging (and briefly after) so the slider feels realtime
      // even if HA/device state updates lag.
      const now = Date.now();
      const local = this._tileSliderValue;
      const localTs = this._tileSliderValueTs || 0;
      const useLocal = this._sliderDragging === true || (localTs && (now - localTs) < 800);
      if (useLocal && Number.isFinite(local)) return Math.round(local);
      
      if (domain === 'light') {
        // Light brightness (0-255 -> 0-100)
        if (entity.attributes.brightness) {
          return Math.round((entity.attributes.brightness / 255) * 100);
        }
        return this._isOn() ? 100 : 0;
      } else if (domain === 'media_player') {
        // Media player volume (0-1 -> 0-100)
        if (entity.attributes.volume_level !== undefined) {
          return Math.round(entity.attributes.volume_level * 100);
        }
        return 50;
      } else if (domain === 'fan') {
        // Fan percentage (0-100)
        if (entity.attributes.percentage !== undefined) {
          return Math.round(entity.attributes.percentage);
        }
        return this._isOn() ? 100 : 0;
      } else if (domain === 'cover') {
        // Cover position (0-100)
        if (entity.attributes.current_position !== undefined) {
          return Math.round(entity.attributes.current_position);
        }
        return 50;
      }
      
      return 0;
    }
    _sendSliderService(value, domain) {
      if (value === undefined || value === null || Number.isNaN(value)) return;

      if (domain === 'light') {
        this.hass.callService('light', 'turn_on', {
          entity_id: this._config.entity,
          brightness_pct: value
        });
      } else if (domain === 'media_player') {
        this.hass.callService('media_player', 'volume_set', {
          entity_id: this._config.entity,
          volume_level: value / 100
        });
      } else if (domain === 'fan') {
        this.hass.callService('fan', 'set_percentage', {
          entity_id: this._config.entity,
          percentage: value
        });
      } else if (domain === 'cover') {
        this.hass.callService('cover', 'set_cover_position', {
          entity_id: this._config.entity,
          position: value
        });
      }
    }

    _flushSliderUpdate(domain = this._getDomain()) {
      // Cancel any scheduled update and send the latest value immediately.
      if (this._sliderThrottleTimer) {
        clearTimeout(this._sliderThrottleTimer);
        this._sliderThrottleTimer = null;
      }
      const pending = this._sliderPendingValue;
      if (!pending || pending.value === undefined || pending.value === null) return;

      this._sendSliderService(pending.value, domain || pending.domain);
      this._sliderLastSentAt = Date.now();
      this._sliderLastSentValue = pending.value;
      this._sliderPendingValue = null;
    }

    _updateSliderDebounced(value, domain) {
  // HKI popup-style behavior:
  // - UI updates immediately (optimistic value handled elsewhere)
  // - Only send the command after the user stops moving the slider (debounce)
  // - Final value is flushed immediately on release via _flushSliderUpdate()
  const debounceMs = 200;

  this._sliderPendingValue = { value, domain };

  if (this._sliderThrottleTimer) {
    clearTimeout(this._sliderThrottleTimer);
    this._sliderThrottleTimer = null;
  }

  this._sliderThrottleTimer = setTimeout(() => {
    const pending = this._sliderPendingValue;
    this._sliderThrottleTimer = null;
    if (!pending || pending.value === undefined || pending.value === null) return;

    // Avoid resending identical values
    if (this._sliderLastSentValue === pending.value) return;

    this._sendSliderService(pending.value, pending.domain);
    this._sliderLastSentAt = Date.now();
    this._sliderLastSentValue = pending.value;

    // keep pending so release can still flush if needed; it'll be cleared there
  }, debounceMs);
    }

    _tileSliderClick(e) {
      // Prevent click from bubbling to card
      e.stopPropagation();
    }

    _tileSliderPointerDown(e) {
      // Track that we're dragging the slider (optimistic UI)
      this._sliderDragging = true;
      try {
        const v = parseInt(e?.target?.value, 10);
        if (!Number.isNaN(v)) {
          this._tileSliderValue = v;
          this._tileSliderValueTs = Date.now();
        }
      } catch (_) {}
      e.stopPropagation();
    }

    _tileSliderPointerMove(e) {
      // Only process if we're dragging
      if (!this._sliderDragging) return;
      e.stopPropagation();
    }

    _tileSliderPointerUp(e) {
      // Stop tracking drag
      this._sliderDragging = false;
      this._tileSliderLastSet = Date.now();

      // Ensure we flush the final value immediately (and cancel any scheduled trailing call)
      this._flushSliderUpdate(this._getDomain());

      // Keep optimistic value briefly while HA catches up
      this._tileSliderValueTs = Date.now();
      this.requestUpdate();
      e.stopPropagation();
    }

    _tileSliderInput(e, domain) {
      // Update value while dragging (optimistic UI)
      const value = parseInt(e.target.value, 10);
      if (!Number.isNaN(value)) {
        this._tileSliderValue = value;
        this._tileSliderValueTs = Date.now();
        // Update visuals immediately
        this.requestUpdate();
      }
      this._updateSliderDebounced(value, domain);
      e.stopPropagation();
    }

    _tileSliderChange(e, domain) {
      // Final value when released
      const value = parseInt(e.target.value, 10);
      if (!Number.isNaN(value)) {
        this._tileSliderValue = value;
        this._tileSliderLastSet = Date.now();
        this.requestUpdate();
      }
      this._updateSliderDebounced(value, domain);
      this._flushSliderUpdate(domain);
      e.stopPropagation();
    }

    async _renderTemplate(template) {
      if (!template || typeof template !== 'string') return template;
      // Check if it contains Jinja syntax
      if (!template.includes('{{') && !template.includes('{%')) return template;
      
      try {
        const result = await this.hass.callWS({
          type: 'render_template',
          template: template,
        });
        return result || template;
      } catch (err) {
        console.warn('Template rendering failed:', err);
        return template;
      }
    }

    // Get rendered template value or return plain value
    renderTemplate(key, fallback = '') {
      // For styling properties, use the rendered value from template subscription
      const rendered = this[`_rendered${key.charAt(0).toUpperCase() + key.slice(1)}`];
      // Return rendered value if it exists (could be empty string for templates that resolved to empty)
      // Otherwise return the fallback (plain value)
      return rendered !== undefined && rendered !== null ? rendered : fallback;
    }

    _isTemplate(str) {
      // Check if string contains Jinja2 template syntax
      return str && typeof str === 'string' && (str.includes('{{') || str.includes('{%'));
    }

    _buildTemplateVariables() {
      return { config: this._config ?? {} };
    }

    _setupTemplates() {
      if (!this.hass || !this._config) return;
      // Text templates
      this._setupTemplateKey("name", this._config.name || "");
      this._setupTemplateKey("state", this._config.state_label || "");
      this._setupTemplateKey("label", this._config.label || "");
      this._setupTemplateKey("info", this._config.info_display || "");
      this._setupTemplateKey("icon", this._config.icon || "");
      
      // Styling templates
      this._setupTemplateKey("cardColor", this._config.card_color || "");
      this._setupTemplateKey("cardOpacity", this._config.card_opacity || "");
      this._setupTemplateKey("boxShadow", this._config.box_shadow || "");
      this._setupTemplateKey("borderColor", this._config.border_color || "");
      this._setupTemplateKey("borderWidth", this._config.border_width || "");
      this._setupTemplateKey("borderStyle", this._config.border_style || "");
      this._setupTemplateKey("borderRadius", this._config.border_radius || "");
      this._setupTemplateKey("iconColor", this._config.icon_color || "");
      this._setupTemplateKey("iconCircleBg", this._config.icon_circle_bg || "");
      this._setupTemplateKey("iconCircleBorderColor", this._config.icon_circle_border_color || "");
      this._setupTemplateKey("iconCircleBorderWidth", this._config.icon_circle_border_width || "");
      this._setupTemplateKey("iconCircleBorderStyle", this._config.icon_circle_border_style || "");
      this._setupTemplateKey("badgeBg", this._config.badge_bg || "");
      this._setupTemplateKey("badgeBorderColor", this._config.badge_border_color || "");
      this._setupTemplateKey("badgeBorderWidth", this._config.badge_border_width || "");
      this._setupTemplateKey("badgeBorderStyle", this._config.badge_border_style || "");
      this._setupTemplateKey("nameColor", this._config.name_color || "");
      this._setupTemplateKey("stateColor", this._config.state_color || "");
      this._setupTemplateKey("labelColor", this._config.label_color || "");
      this._setupTemplateKey("brightnessColor", this._config.brightness_color || "");
      this._setupTemplateKey("brightnessColorOn", this._config.brightness_color_on || "");
      this._setupTemplateKey("brightnessColorOff", this._config.brightness_color_off || "");
      this._setupTemplateKey("iconAnimation", this._config.icon_animation || "");
    }

    _setupTemplateKey(key, raw) {
      const isTpl = this._isTemplate(raw);

      if (!isTpl) {
        this._unsubscribeTemplate(key);
        this._tpl[key].raw = raw;
        this._tpl[key].sig = "";
        this._setRendered(key, raw);
        return;
      }

      // Don't show raw template - keep previous value or empty until render completes
      // This prevents the flash of unrendered Jinja templates

      const vars = this._buildTemplateVariables();
      const sig = cacheKey(raw, vars);
      const state = this._tpl[key];

      this._unsubscribeTemplate(key);
      state.raw = raw;
      state.sig = sig;
      state.seq += 1;
      const seq = state.seq;

      const hadCache = this._applyCachedTemplate(key, sig);
      
      // If no cache was found, set to empty to avoid showing raw template
      if (!hadCache) {
        this._setRendered(key, "");
      }

      if (this.hass?.connection?.subscribeMessage) {
        this._subscribeTemplateImmediate(key, seq, raw, vars, sig);
      } else if (this.hass?.callWS && !hadCache) {
        this._renderTemplateOnce(key, seq, raw, vars, sig);
      }
    }

    _applyCachedTemplate(key, sig) {
      try {
        const cached = sessionStorage.getItem(sig);
        if (cached != null && cached !== "") {
          this._setRendered(key, cached);
          return true;
        }
      } catch (_) {}
      return false;
    }

    async _renderTemplateOnce(key, seq, raw, vars, sig) {
      if (!this.hass?.callWS) return;
      try {
        const res = await this.hass.callWS({
          type: "render_template",
          template: raw,
          variables: vars,
          strict: false,
        });
        if (this._tpl[key].seq !== seq) return;
        const text = res?.result == null ? "" : String(res.result);
        this._setRendered(key, text);
        this._storeTemplateCache(sig, text);
      } catch (err) {
        console.warn(`Template render failed for ${key}:`, err);
      }
    }

    async _subscribeTemplateImmediate(key, seq, raw, vars, sig) {
      if (!this.hass?.connection?.subscribeMessage) return;
      try {
        const unsub = await this.hass.connection.subscribeMessage(
          (msg) => this._onTemplateMsg(key, seq, sig, msg),
          { type: "render_template", template: raw, variables: vars, strict: false, report_errors: false }
        );
        const st = this._tpl[key];
        if (st.seq !== seq) { unsub?.(); return; }
        st.unsub = unsub;
      } catch (err) {
        console.warn(`Template subscription failed for ${key}:`, err);
        this._renderTemplateOnce(key, seq, raw, vars, sig);
      }
    }

    _onTemplateMsg(key, seq, sig, msg) {
      if (this._tpl[key].seq !== seq) return;
      if (msg?.error) { console.warn(`Template update error for ${key}:`, msg.error); return; }
      const text = msg?.result == null ? "" : String(msg.result);
      this._setRendered(key, text);
      this._storeTemplateCache(sig, text);
    }

    _storeTemplateCache(sig, value) {
      try { sessionStorage.setItem(sig, value); } catch (_) {}
    }

    _setRendered(key, value) {
      const v = value == null ? "" : String(value);
      const propName = `_rendered${key.charAt(0).toUpperCase() + key.slice(1)}`;
      if (this[propName] !== v) {
        this[propName] = v;
        this.requestUpdate();
      }
    }

    _unsubscribeTemplate(key) {
      const st = this._tpl[key];
      if (st?.unsub) { try { st.unsub(); } catch (_) {} }
      if (st) st.unsub = null;
    }

    _scheduleTemplateSetup(delayMs = 0) {
      // Debounce template setup to avoid too many subscriptions
      if (this._tpl.timer) clearTimeout(this._tpl.timer);
      this._tpl.timer = setTimeout(() => {
        this._setupTemplates();
        this._tpl.timer = null;
      }, Math.max(0, delayMs));
    }

    _rgbToHs(r, g, b) {
        r /= 255; g /= 255; b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;
        if (max === min) {
            h = s = 0; 
        } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return [h * 360, s * 100];
    }

    _stateColorToken(domain, state, isActive) {
      // Uses HAâ€™s built-in state/domain color rules via theme variables
      // Fallback chain per HA docs:
      // state-{domain}-{state}-color -> state-{domain}-{active|inactive}-color -> state-{active|inactive}-color
      const a = isActive ? 'active' : 'inactive';
      return `var(--state-${domain}-${state}-color, var(--state-${domain}-${a}-color, var(--state-${a}-color, var(--primary-text-color))))`;
    }

    _getCurrentColor() {
      const entity = this._getEntity();
      if (!entity) return 'var(--state-icon-color)';
    
      const domain = this._getDomain();
      const isActive = this._isOn(); // important: uses your domain-aware logic
    
      // --- Alarm: custom colors per state ---
      if (domain === 'alarm_control_panel') {
        const s = entity.state;
    
        // green = disarmed
        if (s === 'disarmed') return '#4CAF50';
    
        // orange = pending/arming
        if (s === 'pending' || s === 'arming') return '#FF9800';
    
        // red = armed (and triggered)
        if (s.startsWith('armed_') || s === 'triggered') return '#F44336';
    
        // fallback to HA token if some other state appears
        return this._stateColorToken(domain, s, isActive);
      }
    
      // --- Lights: keep your existing "actual light color" logic when active ---
      if (domain === 'light') {
        if (!isActive) return (this._config.icon_color || 'var(--primary-text-color)');
    
        const attrs = entity.attributes || {};
        if (attrs.rgb_color) return `rgb(${attrs.rgb_color.join(',')})`;
        if (attrs.hs_color) return `hsl(${attrs.hs_color[0]}, ${attrs.hs_color[1]}%, 50%)`;
        if (attrs.color_temp) {
          if (attrs.color_temp > 400) return '#FFD700';
          if (attrs.color_temp < 200) return '#E8F0FF';
          return '#FFF5E6';
        }
        // Default warm white for lights that are on but have no color info
        return '#FDB750';
      }
    
      // --- Climate: keep your HVAC palette when active (as you already do elsewhere) ---
      if (domain === 'climate') {
        if (!isActive) return (this._config.icon_color || 'var(--primary-text-color)');
        return (HVAC_COLORS?.[entity.state] || this._stateColorToken(domain, entity.state, true));
      }
    
      // --- Everything else (covers included): default to HA's built-in domain/state colors ---
      if (!isActive) return (this._config.icon_color || 'var(--primary-text-color)');
      return this._stateColorToken(domain, entity.state, true);
    }


    // Same as _getCurrentColor but for any given state object (e.g. group members)
    _getCurrentColorFromState(stateObj) {
      if (!stateObj || stateObj.state !== 'on') return null;
      const attrs = stateObj.attributes || {};
      if (Array.isArray(attrs.rgb_color)) return `rgb(${attrs.rgb_color.join(',')})`;
      if (Array.isArray(attrs.hs_color)) return `hsl(${attrs.hs_color[0]}, ${attrs.hs_color[1]}%, 50%)`;
      if (typeof attrs.color_temp === 'number') {
        // crude warm/cool approximation like the main icon
        if (attrs.color_temp > 400) return '#FFD700';
        if (attrs.color_temp < 200) return '#E8F0FF';
        return '#FFF5E6';
      }
      return '#FFD700';
    }

    _getEffectivePopupTimeFormat() {
      const opt = (this._config.popup_time_format || 'auto');
      if (opt === '12') return '12';
      if (opt === '24') return '24';

      const tf = this.hass?.locale?.time_format; // Home Assistant: 'am_pm' | '24' | 'language'
      if (tf === 'am_pm') return '12';
      if (tf === '24') return '24';
      return 'auto';
    }

    _formatHistoryTime(date) {
      const mode = this._getEffectivePopupTimeFormat();
      const base = { hour: '2-digit', minute: '2-digit' };
      if (mode === '12') return date.toLocaleTimeString([], { ...base, hour12: true });
      if (mode === '24') return date.toLocaleTimeString([], { ...base, hour12: false });
      return date.toLocaleTimeString([], base);
    }

    _syncState() {
      const entity = this._getEntity();
      if (!entity) return;
      const attrs = entity.attributes;

      if (attrs.min_mireds) this._tempMin = attrs.min_mireds;
      if (attrs.max_mireds) this._tempMax = attrs.max_mireds;
      if (attrs.color_temp) this._currentTemp = attrs.color_temp;
      
      if (attrs.hs_color && attrs.hs_color.length === 2) {
          this._hue = attrs.hs_color[0];
          this._saturation = attrs.hs_color[1];
      } else if (attrs.rgb_color && attrs.rgb_color.length === 3) {
          const [h, s] = this._rgbToHs(...attrs.rgb_color);
          this._hue = h;
          this._saturation = s;
      } else if (entity.state === 'on') {
          if (this._hue === 0 && this._saturation === 0) {
              this._hue = 30;
              this._saturation = 20;
          }
      }

      // Clear optimistic climate UI state once Home Assistant confirms it
      if (entity && entity.entity_id && entity.entity_id.startsWith('climate.')) {
        if (this._optimisticHvacMode != null && entity.state === this._optimisticHvacMode) {
          this._optimisticHvacMode = undefined;
        }
        const t = attrs.temperature;
        if (this._optimisticClimateTemp != null && typeof t === 'number' && Math.abs(t - this._optimisticClimateTemp) < 0.001) {
          this._optimisticClimateTemp = undefined;
        }
      }

      if (entity && entity.entity_id && entity.entity_id.startsWith('humidifier.')) {
        const h = attrs.humidity;
        if (this._optimisticHumidity != null && typeof h === 'number' && Math.abs(h - this._optimisticHumidity) < 0.001) {
          this._optimisticHumidity = undefined;
        }
        const hLow = attrs.target_humidity_low;
        if (this._optimisticHumidityLow != null && typeof hLow === 'number' && Math.abs(hLow - this._optimisticHumidityLow) < 0.001) {
          this._optimisticHumidityLow = undefined;
        }
        const hHigh = attrs.target_humidity_high;
        if (this._optimisticHumidityHigh != null && typeof hHigh === 'number' && Math.abs(hHigh - this._optimisticHumidityHigh) < 0.001) {
          this._optimisticHumidityHigh = undefined;
        }
      }

    }

    /* --- ACTION HANDLING --- */
    _startHold(e, actionConfig) {
        // IMPORTANT (mobile): calling preventDefault() on touchstart will often
        // suppress the synthetic click event, which breaks tap_action (including
        // fire-dom-event) on phones.
        //
        // We only prevent default for mouse-based interactions (text selection).
        // For touch/pointer inputs we allow the browser to generate the click.
        const isTouch = !!(e.touches && e.touches.length) || e.pointerType === 'touch';
        if (!isTouch && e.cancelable) {
          e.preventDefault();
        }
        
        // Prevent hold-action from firing while the user is scrolling.
        // We cancel the hold if the pointer moves beyond a small threshold.
        const start = (e.touches && e.touches[0]) ? e.touches[0] : e;
        this._holdStartX = start.clientX;
        this._holdStartY = start.clientY;
        this._holdMoved = false;

        // Clear any previous listeners
        if (this._holdMoveListener) {
          window.removeEventListener('mousemove', this._holdMoveListener);
          window.removeEventListener('touchmove', this._holdMoveListener);
        }
        if (this._holdEndListener) {
          window.removeEventListener('mouseup', this._holdEndListener);
          window.removeEventListener('touchend', this._holdEndListener);
          window.removeEventListener('touchcancel', this._holdEndListener);
        }

        this._holdMoveListener = (ev) => {
          const p = (ev.touches && ev.touches[0]) ? ev.touches[0] : ev;
          const dx = Math.abs(p.clientX - this._holdStartX);
          const dy = Math.abs(p.clientY - this._holdStartY);
          if (dx > 10 || dy > 10) {
            this._holdMoved = true;
            // User is scrolling / moving: cancel hold and allow normal tap.
            this._clearHold({ resetFired: true });
          }
        };
        this._holdEndListener = () => {
          // Pointer released: always clear the timer.
          // NOTE: do NOT reset _holdFired here, otherwise a completed hold would
          // immediately allow the subsequent click/tap event to fire tap_action.
          this._clearHold({ resetFired: false });
          if (this._holdMoveListener) {
            window.removeEventListener('mousemove', this._holdMoveListener);
            window.removeEventListener('touchmove', this._holdMoveListener);
          }
          if (this._holdEndListener) {
            window.removeEventListener('mouseup', this._holdEndListener);
            window.removeEventListener('touchend', this._holdEndListener);
            window.removeEventListener('touchcancel', this._holdEndListener);
          }
        };
        window.addEventListener('mousemove', this._holdMoveListener, { passive: true });
        window.addEventListener('touchmove', this._holdMoveListener, { passive: true });
        window.addEventListener('mouseup', this._holdEndListener, { passive: true });
        window.addEventListener('touchend', this._holdEndListener, { passive: true });
        window.addEventListener('touchcancel', this._holdEndListener, { passive: true });

        // Start fresh for this interaction
        this._holdFired = false;

        this._holdTimer = setTimeout(() => {
          if (this._holdMoved) return;
          // Mark as fired *before* handling, so any downstream events can be gated.
          // Even if no hold_action is configured (or it's action: none), we still
          // treat it as a completed hold to suppress tap_action on release.
          this._holdFired = true;
          this._handleAction(actionConfig);
        }, 500); // 500ms hold threshold
    }

    _clearHold(opts = { resetFired: false }) {
      clearTimeout(this._holdTimer);
      this._holdTimer = null;
      if (opts.resetFired) {
        this._holdFired = false;
      }
    }

    _inEditorPreview() {
      // Check if we're inside the card editor's preview area
      // Editor preview has specific parent elements we can detect
      let el = this;
      while (el) {
        if (el.classList && (el.classList.contains('element-preview') || el.classList.contains('card-config'))) {
          return true;
        }
        el = el.parentElement || el.getRootNode()?.host;
      }
      return false;
    }

    _handleDelayClick(tapAction, doubleTapAction) {
      // Prevent tap from firing if hold action already triggered
      if (this._holdFired) {
        this._holdFired = false;
        return;
      }
      
      // Resolve effective double tap action:
      // - If explicitly configured, honour it (including explicit 'none' to disable).
      // - If not configured at all (undefined), smart-default: hki-more-info for domains
      //   that support the HKI popup, otherwise treat as no double-tap.
      const effectiveDta = doubleTapAction !== undefined
        ? doubleTapAction
        : { action: this._defaultInfoActionType() };

      // If no double tap action is configured (or set to none), fire immediately to keep it snappy
      if (!effectiveDta || effectiveDta.action === 'none') {
        this._handleAction(tapAction);
        return;
      }

      // Cross-platform double-tap handling (works on mobile too).
      // If a timer is running, this is the 2nd tap: cancel the pending single-tap
      // and immediately fire the double tap action.
      if (this._tapTimer) {
        clearTimeout(this._tapTimer);
        this._tapTimer = null;
        this._handleAction(effectiveDta);
        return;
      }

      // First tap: wait briefly for a potential second tap.
      this._tapTimer = setTimeout(() => {
        this._handleAction(tapAction);
        this._tapTimer = null;
      }, 250);
    }

    _handleAction(actionConfig) {
      // No action configured -> do nothing (avoid fallback attempts like more-info without entity)
      if (!actionConfig || !actionConfig.action || actionConfig.action === "none") return;
      // Prevent actions from running in editor preview mode
      if (this._inEditorPreview()) return;

      // âœ… NEW: fire-dom-event (like custom:button-card / core cards)
      // Fires `ll-custom` with the entire action config in `detail`.
      if (actionConfig.action === "fire-dom-event") {
        const detail = { ...actionConfig };
        const rawEventData = typeof actionConfig.event_data === "string" ? actionConfig.event_data.trim() : "";
        if (rawEventData) {
          try {
            const parsed = window.jsyaml?.load ? window.jsyaml.load(rawEventData) : JSON.parse(rawEventData);
            if (parsed !== undefined) detail.data = parsed;
          } catch (_) {
            detail.data = rawEventData;
          }
        }
        this.dispatchEvent(
          new CustomEvent("ll-custom", {
            bubbles: true,
            composed: true,
            detail,
          })
        );
        return;
      }

      // HKI specific - custom popup
      if (actionConfig.action === "hki-more-info") {
        this._openPopup();
        return;
      }
    
      // Handle toggle action directly
      if (actionConfig.action === "toggle") {
        const domain = this._getDomain ? this._getDomain() : undefined;
        const entityId = this._config.entity;
        if (!entityId) return;

        // Climate: toggle OFF <-> last used HVAC mode
        if (domain === "climate") {
          const ent = this._getEntity && this._getEntity();
          const current = ent && ent.state;
          const key = `hki_climate_last_mode:${entityId}`;
    
          // If currently in a mode (not off): remember and turn off
          if (current && current !== "off") {
            try {
              localStorage.setItem(key, current);
            } catch (e) {}
            this.hass.callService("climate", "set_hvac_mode", {
              entity_id: entityId,
              hvac_mode: "off",
            });
            return;
          }
    
          // If currently off: restore last mode or fall back to first non-off hvac_mode
          let last = null;
          try {
            last = localStorage.getItem(key);
          } catch (e) {}
          const hvacModes =
            ent && ent.attributes && ent.attributes.hvac_modes
              ? ent.attributes.hvac_modes
              : [];
          const fallback =
            (Array.isArray(hvacModes)
              ? hvacModes.find((m) => m && m !== "off")
              : null) || "heat";
    
          this.hass.callService("climate", "set_hvac_mode", {
            entity_id: entityId,
            hvac_mode: last || fallback,
          });
          return;
        }
    
        // All other domains: HA generic toggle
        this.hass.callService("homeassistant", "toggle", { entity_id: entityId });
        return;
      }
    
      // âœ… NEW: Execute call-service directly (header-card style)
      // Expected shape:
      // { action: "call-service", service: "light.turn_on", service_data: {...} }
      if (actionConfig.action === "call-service" && actionConfig.service) {
        const [domain, service] = String(actionConfig.service).split(".");
        if (domain && service) {
          this.hass.callService(domain, service, actionConfig.service_data || {});
        }
        if (this._config?.popup_close_on_action === true && this._popupOpen) {
          setTimeout(() => this._closePopup(), 0);
        }
        return;
      }
    
      // âœ… NEW: Execute perform-action directly (treat like a service call)
      // Expected shape:
      // { action: "perform-action", perform_action: "light.turn_on", data: {...}, target: {...} }
      if (actionConfig.action === "perform-action" && actionConfig.perform_action) {
        const [domain, service] = String(actionConfig.perform_action).split(".");
        if (domain && service) {
          const data = actionConfig.data || {};
          const target = actionConfig.target;
    
          // Some HA builds accept target as a 4th arg. If not, merge entity_id into data.
          try {
            this.hass.callService(domain, service, data, target);
          } catch (e) {
            const merged =
              target?.entity_id ? { ...data, entity_id: target.entity_id } : data;
            this.hass.callService(domain, service, merged);
          }
        }
        if (this._config?.popup_close_on_action === true && this._popupOpen) {
          setTimeout(() => this._closePopup(), 0);
        }
        return;
      }
    
      // âœ… Handle more-info action - default to card's entity if none specified
      if (actionConfig.action === "more-info") {
        const entityId = actionConfig.entity || this._config.entity;
        if (entityId) {
          const event = new Event('hass-more-info', { bubbles: true, composed: true });
          event.detail = { entityId: entityId };
          this.dispatchEvent(event);
          return;
        }
      }
    
      // âœ… Handle navigate action directly
      if (actionConfig.action === "navigate") {
        if (actionConfig.navigation_path) {
          // Hash-based navigation (for Bubble Card)
          if (actionConfig.navigation_path.startsWith('#')) {
            window.location.hash = actionConfig.navigation_path.replace(/^#/, '');
            return;
          }
          // Regular HA navigation path
          window.history.pushState(null, '', actionConfig.navigation_path);
          const event = new Event('location-changed', { bubbles: true, composed: true });
          window.dispatchEvent(event);
          return;
        }
        // Fall through to dispatch event if no navigation_path specified
      }
    
      // âœ… Handle url action directly
      if (actionConfig.action === "url") {
        if (actionConfig.url_path) {
          window.open(actionConfig.url_path, '_blank');
          return;
        }
      }
    
      // For all other actions
      // âœ… Fire the standard Home Assistant action event properly
      this.dispatchEvent(
        new CustomEvent("hass-action", {
          bubbles: true,
          composed: true,
          detail: {
            config: actionConfig,
            action: actionConfig.action,
          },
        })
      );
    }

    _supportsHkiPopup() {
      // Allow HKI popup for any domain when Custom Popup is enabled,
      // because it doesn't depend on the entity domain. This also enables
      // dummy buttons (no entity) to open a Custom Popup.
      const customPopupEnabled = this._config?.custom_popup?.enabled || this._config?.custom_popup_enabled;
      const customPopupCard = this._config?.custom_popup?.card || this._config?.custom_popup_card;
      if (customPopupEnabled) return true; // card may be edited after enabling

      const domain = this._getDomain();
      return ['light', 'climate', 'alarm_control_panel', 'cover', 'humidifier', 'fan', 'switch', 'input_boolean', 'lock', 'group'].includes(domain);
    }

    _defaultInfoActionType() {
      return this._supportsHkiPopup() ? "hki-more-info" : "more-info";
    }

    _defaultTapActionConfig() {
      const domain = this._getDomain();
      const toggleDomains = new Set(["switch", "climate", "input_boolean", "automation", "light"]);
      return toggleDomains.has(domain) ? { action: "toggle" } : { action: this._defaultInfoActionType() };
    }

    _getPopupPortalStyle() {
      return window.HKI?.getPopupBackdropStyle?.(this._config) || '';
    }

    _getPopupCardStyle() {
      return window.HKI?.getPopupCardStyle?.(this._config) || '';
    }

    _getPopupDimensions() {
      return window.HKI?.getPopupDimensions?.(this._config) || { width: '95vw; max-width: 500px', height: '90vh; max-height: 800px' };
    }

    _openPopup() {
      if (this._inEditorPreview() || this._isEditMode()) return;
      if (this._popupOpen) return;
      
      const domain = this._getDomain();
      const entity = this._getEntity();

      // Check for custom popup first (support both nested and flat formats)
      const customPopupEnabled = this._config.custom_popup?.enabled || this._config.custom_popup_enabled;
      const customPopupCard = this._config.custom_popup?.card || this._config.custom_popup_card;
      
      if (customPopupEnabled && customPopupCard) {
        this._popupOpen = true;
        __hkiLockScroll();
        this._activeView = 'main';
        this._renderCustomPopupPortal(entity);
        return;
      }

      // Special handling: group.* entities
      if (domain === 'group') {
        const members = entity && entity.attributes && Array.isArray(entity.attributes.entity_id)
          ? entity.attributes.entity_id
          : [];
        if (members.length) {
          const allowed = new Set(['switch', 'input_boolean']);
          const memberDomains = members.map((e) => (typeof e === 'string' ? e.split('.')[0] : '')).filter(Boolean);
          const allSwitchLike = memberDomains.length && memberDomains.every((d) => allowed.has(d));
          if (allSwitchLike) {
            this._popupOpen = true;
            __hkiLockScroll();
            this._activeView = 'main';
            // Open directly in group members view for group entities
            this._switchGroupMode = true;
            this._renderSwitchPopupPortal(entity);
            return;
          }
        }
        // If group isn't switch-like, fall back to native more-info
        const event = new Event('hass-more-info', { bubbles: true, composed: true });
        event.detail = { entityId: this._config.entity };
        this.dispatchEvent(event);
        return;
      }

      // Check if we have HKI popup support for this domain
      const supportedDomains = ['light', 'climate', 'alarm_control_panel', 'cover', 'humidifier', 'fan', 'switch', 'input_boolean', 'lock', 'group', 'automation', 'sensor', 'binary_sensor', 'device_tracker', 'event', 'select', 'input_select', 'number', 'input_number', 'text', 'input_text', 'person'];
      if (!supportedDomains.includes(domain)) {
        // Fall back to native more-info for unsupported domains
        const event = new Event('hass-more-info', { bubbles: true, composed: true });
        event.detail = { entityId: this._config.entity };
        this.dispatchEvent(event);
        return;
      }
      
      this._popupOpen = true;
      __hkiLockScroll();

      if (domain === 'climate') {
        // Climate default view = Heat (sliders)
        this._activeView = 'main';
        this._syncClimateState();
        this._renderClimatePopupPortal(entity);
        return;
      }

      if (domain === 'alarm_control_panel') {
        this._alarmHistoryOpen = false;
        this._alarmCodeInput = '';
        this._renderAlarmPopupPortal(entity);
        return;
      }

      if (domain === 'cover') {
        // Cover default view
        this._activeView = 'controls';
        this._coverEditMode = false;
        this._coverGroupMode = false;
        this._ensureCoverFavorites();
        this._renderCoverPopupPortal(entity);
        return;
      }

      if (domain === 'humidifier') {
        this._activeView = 'main';
        this._renderHumidifierPopupPortal(entity);
        return;
      }

      if (domain === 'group') {
        const members = entity?.attributes?.entity_id;
        const memberDomains = Array.isArray(members) ? members.map((id) => String(id || '').split('.')[0]) : [];
        const isSwitchLikeGroup = memberDomains.length > 0 && memberDomains.every((d) => d === 'switch' || d === 'input_boolean');
        if (isSwitchLikeGroup) {
          this._activeView = 'main';
          this._switchGroupMode = false;
          this._renderSwitchPopupPortal(entity);
          return;
        }
      }

      if (domain === 'switch' || domain === 'input_boolean' || domain === 'automation') {
        this._activeView = 'main';
        this._switchGroupMode = false;
        this._renderSwitchPopupPortal(entity);
        return;
      }

      if (domain === 'lock') {
        this._activeView = 'main';
        this._renderLockPopupPortal(entity);
        return;
      }
      if (domain === 'fan') {
        this._activeView = 'main';
        this._renderFanPopupPortal(entity);
        return;
      }


      if (domain === 'sensor') {
        this._activeView = 'main';
        this._renderSensorPopupPortal(entity);
        return;
      }

      if (domain === 'binary_sensor' || domain === 'device_tracker' || domain === 'event') {
        this._activeView = 'main';
        this._renderBinarySensorPopupPortal(entity);
        return;
      }

      if (domain === 'select' || domain === 'input_select') {
        this._activeView = 'main';
        this._renderSelectPopupPortal(entity);
        return;
      }

      if (domain === 'number' || domain === 'input_number') {
        this._activeView = 'main';
        this._renderNumberPopupPortal(entity);
        return;
      }

      if (domain === 'text' || domain === 'input_text') {
        this._activeView = 'main';
        this._renderTextPopupPortal(entity);
        return;
      }

      if (domain === 'person') {
        this._activeView = 'main';
        this._renderPersonPopupPortal(entity);
        return;
      }

      // Light default view
      this._activeView = 'brightness';
      this._brightness = this._getBrightness();
      this._expandedEffects = false;
      this._syncState();

      // Favorites
      this._favoritesEditMode = false;
      this._ensureLightFavorites();

      this._renderPopupPortal();
    }

    _closePopup() {
      const portal = this._popupPortal;
      if (!portal) return;

      const cleanup = () => {
        this._popupOpen = false;
        this._isDragging = false;
        this._expandedEffects = false;
        this._detachPopupChromeObserver(portal);
        portal.remove();
        this._popupPortal = null;
        __hkiUnlockScroll();
      };

      if (window.HKI?.animatePopupClose) {
        window.HKI.animatePopupClose({
          portal,
          config: this._config,
          selector: '.hki-popup-container, .hki-light-popup-container',
          onDone: cleanup,
        });
      } else {
        cleanup();
      }
    }


    _applyPopupNavVisibility(portal) {
      if (this._config.popup_hide_bottom_bar === true) {
        portal.setAttribute('data-hide-nav', '');
        // Inject a persistent stylesheet once so the rule survives innerHTML re-renders
        if (!document.getElementById('hki-nav-hide-style')) {
          const s = document.createElement('style');
          s.id = 'hki-nav-hide-style';
          s.textContent = '[data-hide-nav] .hki-popup-nav { display: none !important; }';
          document.head.appendChild(s);
        }
      }
    }

    _applyOpenAnimation(portal) {
      this._attachPopupChromeObserver(portal);
      window.HKI?.animatePopupOpen?.({
        portal,
        config: this._config,
        selector: '.hki-popup-container, .hki-light-popup-container',
      });
      // Apply bottom-bar visibility for all popups
      this._applyPopupNavVisibility(portal);
    }

    _getColorName(hue, saturation) {
      if (saturation < 5) return 'White';
      if (saturation < 15) return 'Light Gray';
      if (saturation < 25) return 'Pale ' + this._getHueName(hue);
      if (saturation < 40) return 'Light ' + this._getHueName(hue);
      if (saturation > 90) return 'Vivid ' + this._getHueName(hue);
      if (saturation > 75) return 'Bright ' + this._getHueName(hue);
      return this._getHueName(hue);
    }

    _getHueName(hue) {
      if (hue >= 0 && hue < 10) return 'Red';
      if (hue >= 10 && hue < 20) return 'Scarlet';
      if (hue >= 20 && hue < 35) return 'Orange Red';
      if (hue >= 35 && hue < 50) return 'Orange';
      if (hue >= 50 && hue < 60) return 'Gold';
      if (hue >= 60 && hue < 70) return 'Yellow';
      if (hue >= 70 && hue < 80) return 'Yellow Green';
      if (hue >= 80 && hue < 100) return 'Chartreuse';
      if (hue >= 100 && hue < 130) return 'Green';
      if (hue >= 130 && hue < 150) return 'Spring Green';
      if (hue >= 150 && hue < 170) return 'Cyan';
      if (hue >= 170 && hue < 190) return 'Turquoise';
      if (hue >= 190 && hue < 210) return 'Sky Blue';
      if (hue >= 210 && hue < 230) return 'Azure';
      if (hue >= 230 && hue < 250) return 'Blue';
      if (hue >= 250 && hue < 270) return 'Indigo';
      if (hue >= 270 && hue < 290) return 'Purple';
      if (hue >= 290 && hue < 310) return 'Violet';
      if (hue >= 310 && hue < 330) return 'Magenta';
      if (hue >= 330 && hue < 345) return 'Pink';
      if (hue >= 345) return 'Rose';
      return 'Red';
    }

    _getTempName(kelvin) {
      if (kelvin < 2000) return 'Candle';
      if (kelvin < 2500) return 'Very Warm';
      if (kelvin < 2900) return 'Warm White';
      if (kelvin < 3500) return 'Soft White';
      if (kelvin < 4500) return 'Neutral';
      if (kelvin < 5500) return 'Cool White';
      if (kelvin < 6500) return 'Daylight';
      return 'Cool Daylight';
    }

    _ensureLightFavorites() {
      try {
        const entityId = this._config?.entity;
        if (!entityId) return;
        if (Array.isArray(this._lightFavorites) && this._lightFavorites._for === entityId) return;

        const raw = localStorage.getItem(__hkiFavKey(entityId));
        let favs = null;
        if (raw) {
          try { favs = JSON.parse(raw); } catch (e) { favs = null; }
        }
        if (!Array.isArray(favs) || favs.length === 0) {
          favs = __hkiSeedFavorites();
          localStorage.setItem(__hkiFavKey(entityId), JSON.stringify(favs));
        }
        favs._for = entityId;
        this._lightFavorites = favs;
      } catch (e) {
        // fallback to seeded list in-memory
        const favs = __hkiSeedFavorites();
        favs._for = this._config?.entity;
        this._lightFavorites = favs;
      }
    }

    _saveLightFavorites() {
      try {
        const entityId = this._config?.entity;
        if (!entityId || !Array.isArray(this._lightFavorites)) return;
        const toSave = this._lightFavorites.filter(f => f && typeof f === 'object' && f.id);
        localStorage.setItem(__hkiFavKey(entityId), JSON.stringify(toSave));
        toSave._for = entityId;
        this._lightFavorites = toSave;
      } catch (e) {}
    }

    _formatAttrLabel(attrKey) {
      if (!attrKey) return '';
      return String(attrKey)
        .replace(/_/g, ' ')
        .split(' ')
        .filter(Boolean)
        .map(w => w.charAt(0).toUpperCase() + w.slice(1))
        .join(' ');
    }


    _ensurePopupDialogStyles() {
      if (document.getElementById('hki-dialog-styles')) return;
      const st = document.createElement('style');
      st.id = 'hki-dialog-styles';
      st.textContent = `
        .hki-dialog-backdrop{position:fixed;inset:0;background:rgba(0,0,0,0.55);z-index:10001;display:flex;align-items:center;justify-content:center;}
        .hki-dialog{width:92%;max-width:360px;background:var(--card-background-color,#1c1c1c);border-radius:16px;box-shadow:0 10px 38px rgba(0,0,0,0.45);overflow:hidden;border:1px solid var(--divider-color, rgba(255,255,255,0.06));}
        .hki-dialog-h{padding:14px 16px;font-weight:600;font-size:14px;color:var(--primary-text-color);border-bottom:1px solid var(--divider-color, rgba(255,255,255,0.06));}
        .hki-dialog-b{padding:14px 16px;display:flex;flex-direction:column;gap:10px;}
        .hki-dialog-b p{margin:0;color:var(--primary-text-color);opacity:0.8;font-size:13px;line-height:1.3;}
        .hki-dialog-in{width:100%;box-sizing:border-box;background:var(--secondary-background-color, rgba(255,255,255,0.06));border:1px solid var(--divider-color, rgba(255,255,255,0.10));border-radius:12px;color:var(--primary-text-color);padding:10px 12px;font-size:14px;outline:none;}
        .hki-dialog-f{padding:12px 16px;display:flex;gap:10px;justify-content:flex-end;border-top:1px solid var(--divider-color, rgba(255,255,255,0.06));}
        .hki-dialog-btn{height:34px;padding:0 14px;border-radius:999px;border:1px solid var(--divider-color, rgba(255,255,255,0.12));background:var(--secondary-background-color, rgba(255,255,255,0.06));color:var(--primary-text-color);cursor:pointer;}
        .hki-dialog-btn.primary{background:var(--primary-color, rgba(255,255,255,0.14));color:var(--text-primary-color, var(--primary-text-color));}
      `;
      document.head.appendChild(st);
    }

    _promptText(title, defaultValue = '', opts = {}) {
      this._ensurePopupDialogStyles();
      const { message = '', okText = 'OK', cancelText = 'Skip', placeholder = '' } = opts;
      return new Promise((resolve) => {
        const bd = document.createElement('div');
        bd.className = 'hki-dialog-backdrop';
        bd.innerHTML = `
          <div class="hki-dialog" role="dialog" aria-modal="true">
            <div class="hki-dialog-h">${title}</div>
            <div class="hki-dialog-b">
              ${message ? `<p>${message}</p>` : ''}
              <input class="hki-dialog-in" id="hkiDlgIn" placeholder="${placeholder}" />
            </div>
            <div class="hki-dialog-f">
              <button class="hki-dialog-btn" id="hkiDlgCancel">${cancelText}</button>
              <button class="hki-dialog-btn primary" id="hkiDlgOk">${okText}</button>
            </div>
          </div>`;
        document.body.appendChild(bd);
        const input = bd.querySelector('#hkiDlgIn');
        if (input) {
          input.value = String(defaultValue ?? '');
          setTimeout(() => input.focus(), 0);
          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') bd.querySelector('#hkiDlgOk')?.click();
            if (e.key === 'Escape') bd.querySelector('#hkiDlgCancel')?.click();
          });
        }
        const cleanup = (val) => {
          bd.remove();
          resolve(val);
        };
        // Clicking outside the dialog is a true cancel (return null)
        bd.addEventListener('click', (e) => { if (e.target === bd) cleanup(null); });
        // "Skip" should not cancel the operation; it means "use empty/default"
        bd.querySelector('#hkiDlgCancel')?.addEventListener('click', () => cleanup(''));
        bd.querySelector('#hkiDlgOk')?.addEventListener('click', () => cleanup(input ? input.value : ''));
      });
    }

    _promptYesNo(title, message, opts = {}) {
      this._ensurePopupDialogStyles();
      const { yesText = 'Yes', noText = 'Skip' } = opts;
      return new Promise((resolve) => {
        const bd = document.createElement('div');
        bd.className = 'hki-dialog-backdrop';
        bd.innerHTML = `
          <div class="hki-dialog" role="dialog" aria-modal="true">
            <div class="hki-dialog-h">${title}</div>
            <div class="hki-dialog-b"><p>${message}</p></div>
            <div class="hki-dialog-f">
              <button class="hki-dialog-btn" id="hkiDlgNo">${noText}</button>
              <button class="hki-dialog-btn primary" id="hkiDlgYes">${yesText}</button>
            </div>
          </div>`;
        document.body.appendChild(bd);
        const cleanup = (val) => { bd.remove(); resolve(val); };
        bd.addEventListener('click', (e) => { if (e.target === bd) cleanup(false); });
        bd.querySelector('#hkiDlgNo')?.addEventListener('click', () => cleanup(false));
        bd.querySelector('#hkiDlgYes')?.addEventListener('click', () => cleanup(true));
      });
    }

    _renderFavoritesView() {
      this._ensureLightFavorites();
      const favs = Array.isArray(this._lightFavorites) ? this._lightFavorites : [];
      // Note: edit button is rendered in a sticky header so it never scrolls with the grid.
      let html = `
        <div class="favorites-view" data-view-type="scenes">
          <div class="favorites-sticky-header">
            <button class="favorites-edit-btn" id="favoritesEditBtn">
              <ha-icon icon="${this._favoritesEditMode ? 'mdi:check' : 'mdi:pencil'}"></ha-icon>
              <span>${this._favoritesEditMode ? 'Done' : 'Edit'}</span>
            </button>
          </div>
          <div class="presets-container favorites-grid">
      `;

      favs.forEach((fav, idx) => {
        const color = fav.color || (fav.rgb_color ? `rgb(${fav.rgb_color.join(',')})` : '#888');
        const picture = fav.picture ? String(fav.picture) : '';
        html += `
          <button class="preset-btn" data-fav-index="${idx}">
            ${picture
              ? `<img class="preset-picture" src="${picture}" />`
              : `<div class="preset-color" style="background: ${color}"></div>`
            }
            <span class="preset-name">${fav.name || 'Favorite'}</span>
            ${this._favoritesEditMode ? `<span class="fav-delete-badge" data-fav-del="${idx}"><ha-icon icon="mdi:close"></ha-icon></span>` : ''}
          </button>
        `;
      });

      html += `</div></div>`;
      return html;
    }

    async _addCurrentLightToFavorites() {
      this._ensureLightFavorites();
      const entity = this._getEntity();
      if (!entity) return;
      const attrs = entity.attributes || {};

      // Default name: use color names (Warm White, Indigo, etc.) when applicable.
      const defaultName = (this._activeView === 'temperature')
        ? this._getTempName(Math.round(1000000 / (this._currentTemp || attrs.color_temp || 326)))
        : (this._activeView === 'color')
          ? this._getColorName(this._hue, this._saturation)
          : (this._config.name || attrs.friendly_name || 'Favorite');

      // Ask for a friendly name (optional). 'Skip' keeps the default name.
      const nameInput = await this._promptText('Favorite name', defaultName, {
        okText: 'Save',
        cancelText: 'Skip',
        placeholder: 'Optional'
      });
      const finalName = (nameInput === null) ? defaultName : (String(nameInput).trim() || defaultName);

      // Group entities: saving from the wheel/temp tabs should create a normal favorite
      // applied to the group entity (since the picker already sets all members).

      // Single light favorites: never prompt here; use the default color name.
      const fav = {
        id: `fav_${Date.now()}_${Math.floor(Math.random() * 10000)}`,
        name: finalName,
      };

      // Capture brightness/effect
      if (typeof attrs.brightness === 'number') fav.brightness = attrs.brightness;
      if (attrs.effect) fav.effect = attrs.effect;

      // IMPORTANT: Save only ONE color descriptor based on the current view
      if (this._activeView === 'temperature') {
        const ct = (typeof this._currentTemp === 'number' ? this._currentTemp : attrs.color_temp);
        if (typeof ct === 'number' && !Number.isNaN(ct)) {
          fav.type = 'temp';
          fav.color_temp = ct;
          fav.kelvin = Math.round(1000000 / ct);
          fav.color = (fav.kelvin < 3500) ? '#FFE4B5' : (fav.kelvin < 5000 ? '#FFF5E6' : '#E8F0FF');
        }
      } else if (this._activeView === 'color') {
        const h = (typeof this._hue === 'number' ? this._hue : (Array.isArray(attrs.hs_color) ? attrs.hs_color[0] : 0));
        const sat = (typeof this._saturation === 'number' ? this._saturation : (Array.isArray(attrs.hs_color) ? attrs.hs_color[1] : 100));
        const rgb = _hsvToRgb(h, sat, 100);
        fav.type = 'rgb';
        fav.rgb_color = rgb;
        fav.color = `rgb(${rgb.join(',')})`;
      }

      if (!Array.isArray(this._lightFavorites)) this._lightFavorites = [];
      this._lightFavorites.unshift(fav);
      this._saveLightFavorites();
    }

    async _addGroupSnapshotToFavorites(opts = {}) {
      this._ensureLightFavorites();
      const entity = this._getEntity();
      if (!entity) return;
      const attrs = entity.attributes || {};
      const members = Array.isArray(attrs.entity_id) ? attrs.entity_id.slice() : [];
      if (members.length === 0) return;

      const defaultName = (opts.name || this._config.name || attrs.friendly_name || 'Group Scene');

      // Only the group list should ask for a custom name.
      // Saving from the color wheel / temperature views should auto-name (color name) and never prompt.
      let name = defaultName;
      if (!opts.skipPrompt) {
        const nameInput = await this._promptText('Favorite name', defaultName, {
          message: 'This will save the current state of each group member.',
          okText: 'Save',
          cancelText: 'Skip'
        });
        if (nameInput === null) return;
        name = String(nameInput).trim() || defaultName;
      }

      // Snapshot member states
      const states = {};
      const colors = [];
      const temps = [];

      for (const eid of members) {
        const st = this.hass?.states?.[eid];
        if (!st) continue;
        const a = st.attributes || {};
        const snap = { state: st.state };
        if (typeof a.brightness === 'number') snap.brightness = a.brightness;
        if (a.effect) snap.effect = a.effect;

        // If this popup is controlling a group, each row can be in a different mode.
        // When saving a group favorite, respect the visible slider mode per member:
        // - temp slider => save temp
        // - color slider => save color
        // - brightness slider => don't force a color descriptor
        const memberMode = opts.pickerMode || this._groupMemberModes?.[eid] || 'brightness';
        if (memberMode === 'temp') {
          if (typeof a.color_temp === 'number') {
            snap.type = 'temp';
            snap.color_temp = a.color_temp;
          }
        } else if (memberMode === 'color') {
          if (Array.isArray(a.rgb_color)) {
            snap.type = 'rgb';
            snap.rgb_color = a.rgb_color;
          } else if (Array.isArray(a.hs_color)) {
            snap.type = 'hs';
            snap.hs_color = a.hs_color;
          }
        } else {
          // brightness view: keep whatever HA reports, but don't try to mix descriptors
          // (avoids "Color descriptors" conflict)
        }
        states[eid] = snap;
      }

      // Determine swatch color if consistent, otherwise ask for custom color/picture
      let picture = '';
      let swatch = (opts.forceSwatch ? String(opts.forceSwatch).trim() : '');
      try {
        // compute if all members share same rgb_color
        const rgbs = [];
        for (const eid of Object.keys(states)) {
          const s = states[eid];
          if (s.type === 'rgb' && Array.isArray(s.rgb_color)) rgbs.push(s.rgb_color.join(','));
          else rgbs.push('');
        }
      } catch (e) {}

      // We'll do JS-side uniqueness below
      const rgbKeys = Object.values(states).map(s => (s.type === 'rgb' && Array.isArray(s.rgb_color)) ? s.rgb_color.join(',') : '');
      const uniqRgb = Array.from(new Set(rgbKeys.filter(Boolean)));
      if (uniqRgb.length === 1) {
        swatch = `rgb(${uniqRgb[0]})`;
      }

      if (!opts.nameOnly && (opts.alwaysPromptMeta || !swatch)) {
        const colorInput = await this._promptText('Optional button color', '', { message: 'Optional: enter a hex/rgb color for the favorite button (e.g. #ff00aa).', okText: 'Use', cancelText: 'Skip' });
        if (colorInput) swatch = String(colorInput).trim();

        const picInput = await this._promptText('Optional picture path', '', { message: 'Optional: enter an image path/URL (e.g. /local/favs/scene.png).', okText: 'Use', cancelText: 'Skip' });
        if (picInput) picture = String(picInput).trim();
      }

      const fav = {
        id: `fav_${Date.now()}_${Math.floor(Math.random() * 10000)}`,
        name,
        type: 'scene',
        targets: members,
        states,
        ...(swatch ? { color: swatch } : {}),
        ...(picture ? { picture } : {}),
      };

      if (!Array.isArray(this._lightFavorites)) this._lightFavorites = [];
      this._lightFavorites.unshift(fav);
      this._saveLightFavorites();
    }



    _applyFavorite(fav) {
      if (!fav) return;

      // Group scene favorite: apply per-target snapshots
      if (fav.type === 'scene' && Array.isArray(fav.targets) && fav.states && this.hass) {
        for (const eid of fav.targets) {
          const snap = fav.states[eid];
          if (!snap) continue;
          if (snap.state === 'off') {
            this.hass.callService('light', 'turn_off', { entity_id: eid });
            continue;
          }
          const d = { entity_id: eid };
          if (typeof snap.brightness === 'number') d.brightness = snap.brightness;
          if (snap.effect) d.effect = snap.effect;
          if (snap.type === 'temp') {
            if (typeof snap.kelvin === 'number') d.kelvin = snap.kelvin;
            else if (typeof snap.color_temp === 'number') d.color_temp = snap.color_temp;
          } else if (snap.type === 'rgb') {
            if (Array.isArray(snap.rgb_color)) d.rgb_color = snap.rgb_color;
          } else if (snap.type === 'hs') {
            if (Array.isArray(snap.hs_color)) d.hs_color = snap.hs_color;
          }
          this.hass.callService('light', 'turn_on', d);
        }
        return;
      }
      const data = { entity_id: this._config.entity };

      // Common fields
      if (typeof fav.brightness === 'number') data.brightness = fav.brightness;
      if (fav.effect) data.effect = fav.effect;

      // IMPORTANT: only one color descriptor per service call
      if (fav.type === 'temp') {
        if (typeof fav.kelvin === 'number' && !Number.isNaN(fav.kelvin)) {
          data.kelvin = fav.kelvin;
        } else if (typeof fav.color_temp === 'number' && !Number.isNaN(fav.color_temp)) {
          data.color_temp = fav.color_temp;
        }
      } else if (fav.type === 'rgb') {
        if (Array.isArray(fav.rgb_color)) data.rgb_color = fav.rgb_color;
      } else if (fav.type === 'hs') {
        if (Array.isArray(fav.hs_color)) data.hs_color = fav.hs_color;
      } else {
        // Backward compatibility for older saved favorites
        if (Array.isArray(fav.rgb_color)) data.rgb_color = fav.rgb_color;
        else if (Array.isArray(fav.hs_color)) data.hs_color = fav.hs_color;
        else if (typeof fav.kelvin === 'number') data.kelvin = fav.kelvin;
        else if (typeof fav.color_temp === 'number') data.color_temp = fav.color_temp;
      }

      this.hass.callService('light', 'turn_on', data);
    }



    _getPopupButtonStyle(isActive = false) {
      if (isActive) {
        // Highlighted button styles
        const styles = [];
        if (this._config.popup_highlight_color) styles.push(`background: ${this._config.popup_highlight_color}`);
        if (this._config.popup_highlight_text_color) styles.push(`color: ${this._config.popup_highlight_text_color}`);
        if (this._config.popup_highlight_radius !== undefined && this._config.popup_highlight_radius !== null && this._config.popup_highlight_radius !== '') styles.push(`border-radius: ${this._config.popup_highlight_radius}px`);
        if (this._config.popup_highlight_opacity !== undefined && this._config.popup_highlight_opacity !== null && this._config.popup_highlight_opacity !== '') styles.push(`opacity: ${this._config.popup_highlight_opacity}`);
        
        // Use configured shadow or default shadow (flat design, no inset)
        const shadow = this._config.popup_highlight_box_shadow || '0 2px 8px rgba(0,0,0,0.15)';
        styles.push(`box-shadow: ${shadow}`);
        
        const borderStyle = this._config.popup_highlight_border_style || 'none';
        const borderWidth = this._config.popup_highlight_border_width || '0';
        const borderColor = this._config.popup_highlight_border_color || 'transparent';
        if (borderStyle !== 'none') styles.push(`border: ${borderWidth}px ${borderStyle} ${borderColor}`);
        
        return styles.length ? styles.join('; ') + ';' : '';
      } else {
        // Non-highlighted button styles
        const styles = [];
        if (this._config.popup_button_bg) styles.push(`background: ${this._config.popup_button_bg}`);
        if (this._config.popup_button_text_color) styles.push(`color: ${this._config.popup_button_text_color}`);
        if (this._config.popup_button_radius !== undefined && this._config.popup_button_radius !== null && this._config.popup_button_radius !== '') styles.push(`border-radius: ${this._config.popup_button_radius}px`);
        if (this._config.popup_button_opacity !== undefined && this._config.popup_button_opacity !== null && this._config.popup_button_opacity !== '') styles.push(`opacity: ${this._config.popup_button_opacity}`);
        
        const borderStyle = this._config.popup_button_border_style || 'none';
        const borderWidth = this._config.popup_button_border_width || '0';
        const borderColor = this._config.popup_button_border_color || 'transparent';
        if (borderStyle !== 'none') styles.push(`border: ${borderWidth}px ${borderStyle} ${borderColor}`);
        
        return styles.length ? styles.join('; ') + ';' : '';
      }
    }

    _applyPopupChromeToPortal(portal) {
      if (!portal) return;
      const hideTopBar = this._config?.popup_hide_top_bar === true;
      const showCloseWhenHidden = hideTopBar && this._config?.popup_show_close_button !== false;
      const headerSelectors = ".hki-popup-header, .hki-light-popup-header, .popup-header";
      portal.querySelectorAll(headerSelectors).forEach((el) => {
        el.style.display = hideTopBar ? "none" : "";
      });
      const existingFloat = portal.querySelector(".hki-floating-popup-close");
      if (existingFloat) existingFloat.remove();
      if (!showCloseWhenHidden) return;
      const container = portal.querySelector(".hki-light-popup-container, .hki-popup-container, .popup-container");
      if (!container) return;
      if (!container.style.position) container.style.position = "relative";
      const btn = document.createElement("button");
      btn.className = "hki-floating-popup-close";
      btn.type = "button";
      btn.innerHTML = '<ha-icon icon="mdi:close"></ha-icon>';
      btn.style.cssText = "position:absolute;top:12px;right:12px;z-index:30;width:36px;height:36px;border-radius:50%;border:1px solid rgba(255,255,255,0.12);background:rgba(0,0,0,0.22);color:var(--primary-text-color);display:flex;align-items:center;justify-content:center;cursor:pointer;";
      btn.addEventListener("click", (e) => {
        e.stopPropagation();
        this._closePopup();
      });
      container.appendChild(btn);
    }

    _attachPopupChromeObserver(portal) {
      if (!portal) return;
      this._applyPopupChromeToPortal(portal);
      if (portal.__hkiPopupChromeObserverAttached) return;
      portal.__hkiPopupChromeObserverAttached = true;
      const observer = new MutationObserver(() => this._applyPopupChromeToPortal(portal));
      observer.observe(portal, { childList: true, subtree: true });
      portal.__hkiPopupChromeObserver = observer;
      const actionHandler = (ev) => {
        if (this._config?.popup_close_on_action !== true) return;
        const action = ev?.detail?.config?.action || ev?.detail?.action;
        if (action === "perform-action" || action === "call-service") {
          setTimeout(() => this._closePopup(), 0);
        }
      };
      portal.addEventListener("hass-action", actionHandler);
      portal.__hkiPopupActionHandler = actionHandler;
    }

    _detachPopupChromeObserver(portal) {
      if (!portal) return;
      try {
        portal.__hkiPopupChromeObserver?.disconnect?.();
      } catch (_) {}
      if (portal.__hkiPopupActionHandler) {
        portal.removeEventListener("hass-action", portal.__hkiPopupActionHandler);
      }
      delete portal.__hkiPopupChromeObserver;
      delete portal.__hkiPopupChromeObserverAttached;
      delete portal.__hkiPopupActionHandler;
    }


    _renderPopupPortal() {
      // Reuse existing portal to avoid flicker on hass updates.
      const entity = this._getEntity();
      const entityName = this._getPopupName(entity);
      const isOn = this._isOn();
      const isUnavailable = !entity || String(entity.state || '').toLowerCase() === 'unavailable';
      const isOnEffective = isUnavailable ? false : isOn;
      const brightness = this._getBrightness();
      const supportsColor = entity && entity.attributes.supported_color_modes && 
        entity.attributes.supported_color_modes.some(m => ['hs', 'rgb', 'xy', 'rgbw'].includes(m));
      const supportsTemp = entity && entity.attributes.supported_color_modes && 
        entity.attributes.supported_color_modes.some(m => m === 'color_temp');
      
      const effectList = entity && entity.attributes.effect_list ? entity.attributes.effect_list : [];
      const currentEffect = entity && entity.attributes.effect ? entity.attributes.effect : 'None';

      const isGroup = entity && entity.attributes.entity_id && Array.isArray(entity.attributes.entity_id);

      // Check default view configuration
      const defaultView = this._config.popup_default_view; // 'main', 'individual', or undefined
      const defaultSection = this._config.popup_default_section; // 'brightness', 'color', 'temperature', 'last', or undefined
      
      // For main entity view, only set brightness as default if _activeView is not already set
      // This allows tabs (temperature/color) to work properly
      if (!this._activeView || this._activeView === 'main') {
        this._activeView = 'brightness';
      }

      // Use coalescing for border radius so 0 is valid
      const borderRadius = this._config.popup_slider_radius ?? 12;
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();
      
      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-light-popup-portal';
      // Clear previous content when reusing.
      portal.innerHTML = '';

      const safeTitle = (t) => String(t || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');

      portal.innerHTML = `
        <style>
          .hki-light-popup-portal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
            ${this._getPopupPortalStyle()}
            display: flex; align-items: center; justify-content: center; z-index: 9999;
          }
          .hki-light-popup-container {
            ${this._getPopupCardStyle()}
            border-radius: ${popupBorderRadius}px; 
            width: ${popupWidth}; height: ${popupHeight};
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex; flex-direction: column;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
          }
          .hki-light-popup-header {
            display: flex; justify-content: space-between; align-items: center; padding: 16px 20px;
            background: rgba(255, 255, 255, 0.03); border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .hki-light-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-light-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-light-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; color: var(--primary-text-color); }
          .hki-light-popup-state { font-size: 12px; opacity: 0.6; text-transform: capitalize; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-light-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: var(--divider-color, rgba(255, 255, 255, 0.05)); border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
          }
          .header-btn:hover { background: rgba(255, 255, 255, 0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }

          .graphs-container { padding: 0; height: 100%; box-sizing: border-box; display: flex; flex-direction: column; }
          .graphs-container #sensorTiles { height: 100%; overflow-y: auto; }
          .graphs-container hui-history-graph-card { display: block; height: 100%; }
          .graphs-container ha-card { height: 100%; overflow: hidden; }

          .sensor-tiles { display: flex; flex-direction: column; gap: 24px; width: 100%; height: 100%; box-sizing: border-box; padding: 16px; align-self: stretch; justify-content: flex-start; }
          .sensor-tile { background: rgba(255,255,255,0.05); border-radius: 18px; padding: 18px; box-shadow: 0 6px 18px rgba(0,0,0,0.25); flex: 1; display: flex; flex-direction: column; min-height: 0; }
          .sensor-tile-top { display: flex; justify-content: space-between; align-items: baseline; gap: 10px; margin-bottom: 12px; }
          .sensor-tile-title { font-size: 14px; font-weight: 600; opacity: 0.9; }
          .sensor-tile-value { font-size: 28px; font-weight: 700; letter-spacing: -0.5px; }
          .sensor-tile-graph { flex: 1; width: 100%; min-height: 120px; overflow: hidden; border-radius: 14px; background: rgba(0,0,0,0.12); padding: 8px; box-sizing: border-box; }
          .sensor-tile-graph svg { width: 100%; height: 100%; display: block; }


          .hki-light-popup-tabs {
            display: flex; gap: 8px; padding: 8px 20px;
            background: rgba(255, 255, 255, 0.03);
            border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .hki-light-popup-tab {
            flex: 1; height: 40px; border-radius: 8px;
            background: transparent; border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center; gap: 8px;
            transition: all 0.2s; font-size: 14px; font-weight: 500;
          }
          .hki-light-popup-tab:hover { background: var(--secondary-background-color, rgba(255, 255, 255, 0.08)); }
          .hki-light-popup-tab.active { 
            background: var(--primary-color, rgba(255, 255, 255, 0.15)); 
            color: var(--text-primary-color, var(--primary-text-color));
          }
          .hki-light-popup-tab ha-icon { --mdc-icon-size: 18px; }
          
          .hki-light-popup-content {
            flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column;
            align-items: center; justify-content: center; gap: 12px;
            min-height: 0;
            position: relative;
            overflow-x: hidden;
          }

          .hki-light-popup-content.view-favorites {
            align-items: stretch;
          justify-items: stretch;
            justify-content: flex-start;
          }

          .save-favorite-fab {
            position: absolute; right: 16px; bottom: 16px;
            width: 44px; height: 44px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.10);
            color: var(--primary-text-color);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            transition: transform 0.15s, background 0.15s;
          }
          .save-favorite-fab:hover { background: rgba(255, 255, 255, 0.14); transform: scale(1.05); }
          .save-favorite-fab ha-icon { --mdc-icon-size: 20px; }

          .favorites-view { width: 100%; height: 100%; position: relative; }

          /* Sticky header so the Edit button never scrolls with the grid */
          .favorites-sticky-header {
            position: sticky;
            top: 0;
            z-index: 6;
            display: flex;
            justify-content: flex-end;
            padding: 8px 0 8px 0;
            background: transparent;
            backdrop-filter: none;
          }

          .favorites-grid { width: 100%; padding-top: 16px; }
          .preset-picture {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            object-fit: cover;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
          }


          /* Edit button under top tabs (top-right) */
          .favorites-edit-btn {
            position: relative;
            z-index: 1;
            display: flex; align-items: center; gap: 8px;
            background: var(--divider-color, rgba(255, 255, 255, 0.06));
            border: 1px solid rgba(255, 255, 255, 0.10);
            color: var(--primary-text-color);
            height: 34px; padding: 0 12px; border-radius: 999px;
            cursor: pointer;
          }
          .favorites-edit-btn:hover { background: rgba(255, 255, 255, 0.10); }
          .favorites-edit-btn ha-icon { --mdc-icon-size: 18px; }

          .preset-btn { position: relative; }
          .fav-delete-badge {
            position: absolute; top: 8px; right: 8px;
            width: 20px; height: 20px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.10);
            border: 1px solid rgba(255, 255, 255, 0.12);
            display: flex; align-items: center; justify-content: center;
            color: var(--primary-text-color);
          }
          .fav-delete-badge:hover { background: rgba(255, 80, 80, 0.25); border-color: rgba(255, 80, 80, 0.35); }
          .fav-delete-badge ha-icon { --mdc-icon-size: 14px; }

          .value-display {
            font-size: 16px; font-weight: 500; color: var(--primary-text-color); 
            margin-bottom: 8px; opacity: 0.9; text-align: center;
            min-height: 22px;
          }
          .value-display span { font-size: 16px; opacity: 0.9; }
          
          .vertical-slider-container { width: 80px; height: 280px; position: relative; }
          .vertical-slider-track {
            width: 100%; height: 100%; background: var(--secondary-background-color, rgba(255, 255, 255, 0.1));
            border-radius: ${borderRadius}px; position: relative; overflow: hidden; cursor: pointer;
          }
          .vertical-slider-fill {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: transparent;
            border-radius: 0 0 ${borderRadius}px ${borderRadius}px;
          }
          .vertical-slider-thumb {
            position: absolute; left: 50%; transform: translateX(-50%);
            width: 90px; height: 6px; background: white;
            border-radius: 4px; box-shadow: 0 0 0 2px rgba(0,0,0,0.1), 0 2px 8px rgba(0,0,0,0.3);
            cursor: grab; pointer-events: none;
          }
          .vertical-slider-thumb:active { cursor: grabbing; }

          .temp-gradient {
            background: linear-gradient(to bottom, 
              rgb(166, 209, 255) 0%,
              rgb(255, 255, 255) 50%,
              rgb(255, 200, 130) 100%) !important;
          }
          .temp-fill { background: transparent !important; }

          .color-section-container {
            display: flex; flex-direction: column; align-items: center; gap: 12px; width: 100%;
          }
          .color-name {
            font-size: 16px; font-weight: 500; color: var(--primary-text-color);
            opacity: 0.9; text-transform: capitalize; text-align: center;
            min-height: 22px;
          }
          .color-wheel {
            width: 280px; height: 280px; border-radius: 50%;
            background: conic-gradient(hsl(0, 100%, 50%), hsl(60, 100%, 50%), hsl(120, 100%, 50%), hsl(180, 100%, 50%), hsl(240, 100%, 50%), hsl(300, 100%, 50%), hsl(360, 100%, 50%));
            position: relative; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          }
          .color-wheel::after {
            content: ''; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40%; height: 40%; border-radius: 50%; background: radial-gradient(circle, white 0%, transparent 70%);
          }
          .color-wheel-indicator {
            position: absolute; width: 28px; height: 28px; border-radius: 50%;
            border: 3px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transform: translate(-50%, -50%); pointer-events: none; top: 50%; left: 50%;
            transition: top 0.3s, left 0.3s; 
          }

          .presets-container { 
            display: grid; 
            /* fixed 4-per-row grid (matches HKI style) */
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 12px; 
            width: 100%;
            box-sizing: border-box;
          }
          /* Favorites spacing under the fixed Edit header */
          .favorites-grid { padding-top: 16px; }
          .preset-picture { width: 32px; height: 32px; border-radius: 50%; object-fit: cover; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
          .preset-btn {
            aspect-ratio: 1; border-radius: 12px; border: 2px solid var(--divider-color, rgba(255, 255, 255, 0.1));
            background: transparent; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: flex-start;
            gap: 6px; transition: all 0.2s; padding: 10px 8px 8px 8px; outline: none;
            min-width: 0;
          }
          .preset-btn:hover { transform: scale(1.05); border-color: rgba(255, 255, 255, 0.3); }
          .preset-btn:active { transform: scale(0.95); }
          .preset-color { width: 32px; height: 32px; border-radius: 50%; box-shadow: 0 2px 6px rgba(0,0,0,0.2); }
          .preset-name {
            font-size: 10px;
            color: var(--primary-text-color);
            text-align: center;
            opacity: 0.8;
            max-width: 100%;
            word-break: break-word;
            /* keep circles aligned even with long text */
            height: 26px;
            overflow: hidden;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
          }

          .individual-container { width: 100%; flex: 1; overflow-y: auto; max-height: none; }
          .individual-item {
            padding: 12px 0; border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            display: flex; align-items: center; gap: 12px;
          }
          .individual-item:last-child { border-bottom: none; }
          .individual-icon {
            width: 40px; height: 40px; border-radius: 50%;
            background: var(--divider-color, rgba(255, 255, 255, 0.05));
            display: flex; align-items: center; justify-content: center; flex-shrink: 0;
          }
          .individual-icon ha-icon { --mdc-icon-size: 20px; }
          .individual-info { flex: 1; display: flex; flex-direction: column; gap: 4px; min-width: 0; }
          .individual-name { font-size: 14px; font-weight: 500; }
          .individual-state { font-size: 12px; opacity: 0.6; }
          .individual-slider {
            flex: 2; height: 40px; background: var(--secondary-background-color, rgba(255, 255, 255, 0.1));
            border: 2px solid var(--divider-color, rgba(255, 255, 255, 0.1));
            border-radius: ${borderRadius}px; position: relative; overflow: hidden; cursor: pointer;
          }
          .individual-slider-fill {
            height: 100%; background: rgba(255, 255, 255, 0.18);
            border-radius: ${borderRadius}px 0 0 ${borderRadius}px;
            transition: width 0.2s;
          }
          /* For horizontal color/temp pickers we only show the handle (no fill) */
          .individual-slider[data-mode="color"] .individual-slider-fill,
          .individual-slider[data-mode="temp"] .individual-slider-fill { display: none; }
          .individual-slider[data-mode="brightness"] .individual-slider-fill { display: block !important; }
          .individual-slider-thumb {
            position: absolute; top: 0; transform: translateX(-50%);
            width: 12px; height: 100%; background: white; border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3); pointer-events: none; transition: left 0.2s;
          }
          
          .individual-item.switch-style .individual-icon {
            cursor: pointer;
            transition: background 0.2s;
          }
          .individual-item.switch-style .individual-icon:hover {
            background: var(--divider-color, rgba(255, 255, 255, 0.1));
          }
          .individual-switch-container {
            flex: 0 0 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
          }
          .individual-switch {
            width: 52px;
            height: 32px;
            background: var(--divider-color, rgba(255, 255, 255, 0.1));
            border-radius: 16px;
            position: relative;
            transition: background 0.3s;
          }
          .individual-switch.on {
            background: var(--primary-color, #03a9f4);
          }
          .individual-switch-thumb {
            position: absolute;
            top: 3px;
            left: 3px;
            width: 26px;
            height: 26px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
          }
          .individual-switch.on .individual-switch-thumb {
            transform: translateX(20px);
          }

          .effects-list-container { width: 100%; }
          .effects-trigger {
            width: 100%; padding: 16px; background: var(--divider-color, rgba(255, 255, 255, 0.05));
            border: 2px solid var(--divider-color, rgba(255, 255, 255, 0.1)); border-radius: 12px;
            display: flex; align-items: center; justify-content: space-between;
            cursor: pointer; transition: all 0.2s; color: var(--primary-text-color);
          }
          .effects-trigger:hover { border-color: rgba(255, 255, 255, 0.3); }
          .effects-trigger-content { display: flex; align-items: center; gap: 12px; }
          .effects-trigger-content ha-icon { --mdc-icon-size: 24px; }
          .effects-trigger-arrow { transition: transform 0.3s; }
          .effects-trigger-arrow.expanded { transform: rotate(90deg); }
          .effects-list {
            margin-top: 12px; display: none; flex-direction: column; gap: 8px;
          }
          .effects-list.expanded { display: flex; }
          .effect-item {
            padding: 14px; background: rgba(255, 255, 255, 0.03);
            border: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05)); border-radius: 8px;
            cursor: pointer; transition: all 0.2s;
            margin-bottom: 4px;
          }
          .effect-item:hover { background: rgba(255, 255, 255, 0.08); }
          .effect-item.active {
            background: rgba(255, 215, 0, 0.1); border-color: #FFD700;
          }

          .timeline-container { width: 100%; height: 100%; padding: 0 10px 10px 10px; box-sizing: border-box; overflow-y: auto; align-self: stretch; }
          /* Timeline styles (make line continuous like other popups) */
          .timeline-item { display: flex; gap: 16px; margin-bottom: 0; min-height: 40px; position: relative; }
          .timeline-visual { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
          .timeline-dot {
            width: 10px; height: 10px; border-radius: 50%;
            z-index: 2; border: 2px solid var(--card-background-color, #1c1c1c);
            margin-top: 3px;
          }
          .timeline-line { width: 2px; flex-grow: 1; background: var(--divider-color, rgba(255,255,255,0.12)); margin-top: -2px; margin-bottom: -4px; }

          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content {
            flex: 1; padding-bottom: 16px; font-size: 13px; color: var(--primary-text-color);
          }
          .timeline-detail { font-size: 11px; opacity: 0.6; display: block; margin-top: 4px; }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .timeline-trigger { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; font-style: italic; }
          .history-loading { width: 100%; text-align: center; padding: 20px; opacity: 0.6; }

          .bottom-nav {
            display: flex; justify-content: space-around; align-items: center;
            padding: 8px 20px; border-top: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            background: rgba(255, 255, 255, 0.03); gap: 8px;
            flex-shrink: 0;
          }
          .nav-btn {
            flex: 1; height: 46px; border-radius: 8px;
            background: transparent; border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            gap: 2px;
            transition: all 0.2s; position: relative;
          }
          .nav-btn:hover { background: var(--secondary-background-color, rgba(255, 255, 255, 0.08)); }
          .nav-btn.active { 
            background: var(--primary-color, rgba(255, 255, 255, 0.15)); 
            color: var(--text-primary-color, var(--primary-text-color));
          }
          .nav-btn.power-on { color: #FFD700; }
          .nav-btn ha-icon { --mdc-icon-size: 20px; }
          .nav-label { font-size: 10px; line-height: 10px; opacity: 0.75; letter-spacing: 0.4px; }

          /* Climate Specific */
          .climate-slider-group { display: flex; flex-direction: column; align-items: center; gap: 12px; }
          .climate-dual-wrapper { display: flex; gap: 24px; justify-content: center; width: 100%; }
          .climate-label { font-size: 12px; opacity: 0.5; text-transform: uppercase; letter-spacing: 1px; }


        </style>
        <div class="hki-light-popup-container">
          <div class="hki-light-popup-header">
            <span class="hki-light-popup-title">
              <span id="hkiHeaderIconSlot"></span>
              <span class="hki-light-popup-title-text">
                ${safeTitle(entityName)}
                <span class="hki-light-popup-state">${this._getPopupHeaderState(isOnEffective ? brightness + '%' : (isUnavailable ? 'Unavailable' : 'Off'))}${this._formatLastTriggered(entity) ? ` - ${this._formatLastTriggered(entity)}` : ''}</span>
              </span>
            </span>
            <div class="hki-light-popup-header-controls">
              ${isGroup ? '<button class="header-btn" id="individualLightsBtn"><ha-icon icon="mdi:lightbulb-group-outline"></ha-icon></button>' : ''}
              <button class="header-btn" id="historyBtn">
                <ha-icon icon="mdi:chart-box-outline"></ha-icon>
              </button>
              <button class="header-btn" id="closeBtn">
                <ha-icon icon="mdi:close"></ha-icon>
              </button>
            </div>
          </div>
          
          <div class="hki-light-popup-tabs">
            ${this._config.popup_show_favorites !== false ? `
              <button class="hki-light-popup-tab ${this._activeView === 'favorites' ? 'active' : ''}" id="scenesBtn" style="${this._activeView === 'favorites' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}"><ha-icon icon="mdi:star"></ha-icon><span>Favorites</span></button>
            ` : ''}
            ${this._config.popup_show_effects !== false ? `
              <button class="hki-light-popup-tab ${this._activeView === 'effects' ? 'active' : ''}" id="effectsBtn" style="${this._activeView === 'effects' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}"><ha-icon icon="mdi:auto-fix"></ha-icon><span>Effects</span></button>
            ` : ''}
          </div>
          
          <div class="hki-light-popup-content ${this._activeView === 'favorites' ? 'view-favorites' : ''}">
            ${this._getDomain() === 'climate' 
              ? this._renderClimateContent(entity) 
              : this._renderContent(isOn, brightness, supportsTemp, supportsColor, effectList, currentEffect, isGroup)
            }
          </div>
          
          <div class="bottom-nav">
            ${
              this._getDomain() === "climate"
                ? this._renderClimateNav(entity)
                : `
                  <button class="nav-btn ${isOnEffective ? "power-on" : ""}" id="powerBtn" style="${isOnEffective ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
                    <ha-icon icon="mdi:power"></ha-icon>
                    ${this._config.popup_hide_button_text ? '' : '<span class="nav-label">Power</span>'}
                  </button>
                  <button class="nav-btn ${this._activeView === "brightness" ? "active" : ""}" id="brightnessBtn" style="${this._activeView === "brightness" ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
                    <ha-icon icon="mdi:brightness-6"></ha-icon>
                    ${this._config.popup_hide_button_text ? '' : '<span class="nav-label">Bright</span>'}
                  </button>
                  ${
                    supportsTemp
                      ? `<button class="nav-btn ${this._activeView === "temperature" ? "active" : ""}" id="temperatureBtn" style="${this._activeView === "temperature" ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
                          <ha-icon icon="mdi:thermometer"></ha-icon>
                          ${this._config.popup_hide_button_text ? '' : '<span class="nav-label">Temp</span>'}
                        </button>`
                      : ""
                  }
                  ${
                    supportsColor
                      ? `<button class="nav-btn ${this._activeView === "color" ? "active" : ""}" id="colorBtn" style="${this._activeView === "color" ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
                          <ha-icon icon="mdi:palette"></ha-icon>
                          ${this._config.popup_hide_button_text ? '' : '<span class="nav-label">Color</span>'}
                        </button>`
                      : ""
                  }
                `
            }
          </div>
        </div>
      `;

      const container = portal.querySelector('.hki-light-popup-container');
      if (container) container.addEventListener('click', (e) => e.stopPropagation());

      let isBackgroundClick = false;

      portal.addEventListener('mousedown', (e) => {
        isBackgroundClick = (e.target === portal);
      });
      portal.addEventListener('touchstart', (e) => {
        isBackgroundClick = (e.target === portal);
      }, { passive: true });

      portal.addEventListener('click', (e) => {
        if (isBackgroundClick && e.target === portal) {
          this._closePopup();
        }
        isBackgroundClick = false;
      });

      if (!this._popupPortal) {
        document.body.appendChild(portal);
        this._applyOpenAnimation(portal);
      }
      this._popupPortal = portal;

      // Populate header icon (avoid rendering lit-html objects into innerHTML)
      try {
        const slot = portal.querySelector('#hkiHeaderIconSlot');
        if (slot) {
          slot.innerHTML = '';
          const __cfgIconRendered = ((this.renderTemplate('icon', this._config.icon || '') || '').toString().trim());
          const cfgIcon = (__cfgIconRendered && __cfgIconRendered !== '[object Object]') ? __cfgIconRendered : null;
          {
            // Always use ha-state-icon so we can keep HA-native coloring behavior
            const el = document.createElement('ha-state-icon');
            el.hass = this.hass;
            el.stateObj = entity;
            el.style.setProperty('--mdc-icon-size', '22px');

            if (cfgIcon) {
              // Allow custom icon, but keep entity state/color behavior
              el.icon = cfgIcon;
            }

            // Apply custom icon_color if configured, else actual light/entity color
            const _slotIconColor = this._getPopupIconColor(this._getCurrentColor());
            if (_slotIconColor) {
              el.style.color = _slotIconColor;
            }

            slot.appendChild(el);
          }
        }
      } catch (e) {
        // ignore
      }

      this._setupPopupHandlers(portal);
      this._setupContentHandlers(portal);
      
      // Auto-switch to individual view if configured and it's a group
      if (defaultView === 'individual' && isGroup) {
        const content = portal.querySelector('.hki-light-popup-content');
        if (content) {
          content.innerHTML = this._renderIndividualView();
          this._setupContentHandlers(portal);
        }
      }
      
      if (this._activeView === 'color') {
          setTimeout(() => this._setInitialColorIndicator(), 100);
      }
    }

    _renderClimatePopupPortal(entity) {
      // Reuse existing portal to avoid flicker on hass updates.

      const name = this._getPopupName(entity);
      const attrs = entity.attributes || {};
      const mode = entity.state;
      const unit = 'Â°';
      const color = this._getClimateColor(entity);
      const borderRadius = this._config.popup_slider_radius ?? 12;
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();

      // Keep temp constraints in sync (also used by slider handlers)
      this._tempMin = attrs.min_temp || 7;
      this._tempMax = attrs.max_temp || 35;
      this._step = this._getTempStep();

      const presetList = attrs.preset_modes || [];
      const fanList = attrs.fan_modes || [];

      const valueSize = this._config.popup_value_font_size || 36;
      const valueWeight = this._config.popup_value_font_weight || 300;

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-popup-portal';
      // Clear previous content when reusing.
      portal.innerHTML = '';

      const renderStateLine = () => {
        const cur = this._getClimateBadgeTemperature(entity);
        const curText = (cur !== undefined && cur !== null && cur !== '') ? ` â€¢ ${cur}${unit}` : '';
        return `${String(mode).replace(/_/g, ' ')}${curText}`;
      };

      portal.innerHTML = `
        <style>
          .hki-popup-portal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            ${this._getPopupPortalStyle()}
            display: flex; align-items: center; justify-content: center; z-index: 9999;
          }
          .hki-popup-container {
            ${this._getPopupCardStyle()};
            border-radius: ${popupBorderRadius}px;
            width: ${popupWidth}; height: ${popupHeight};
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex; flex-direction: column; overflow: hidden; user-select: none; -webkit-user-select: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
          }
          .hki-popup-header {
            display: flex; justify-content: space-between; align-items: center; padding: 16px 20px;
            background: rgba(255, 255, 255, 0.03); border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .hki-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-popup-title img { width:28px;height:28px;border-radius:50%;object-fit:cover;flex-shrink:0; }
          .hki-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; }
          .hki-popup-state { font-size: 12px; opacity: 0.6; text-transform: capitalize; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: var(--divider-color, rgba(255, 255, 255, 0.05)); border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
          }
          .header-btn:hover { background: rgba(255, 255, 255, 0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }

          .hki-tabs {
            display: flex; gap: 8px; padding: 8px 20px;
            background: rgba(255, 255, 255, 0.02);
            border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .tab-btn {
            flex: 1; height: 40px; border-radius: 8px;
            background: transparent; border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center; gap: 8px;
            transition: all 0.2s; font-size: 14px; font-weight: 500;
          }
          .tab-btn:hover { background: var(--secondary-background-color, rgba(255,255,255,0.08)); }
          .tab-btn.active { 
            background: var(--primary-color, rgba(255,255,255,0.12)); 
            color: var(--text-primary-color, var(--primary-text-color));
          }

          .hki-popup-content { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; align-items: stretch; justify-content: flex-start; min-height: 0; }
          .climate-controls-view { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; }
          .sliders-wrapper { display: flex; gap: 24px; justify-content: center; width: 100%; align-items: center; }
          .slider-group { display: flex; flex-direction: column; align-items: center; gap: 12px; height: 320px; width: 80px; }
          .value-display { font-size: ${valueSize}px; font-weight: ${valueWeight}; text-align: center; }
          .value-display span { font-size: ${Math.max(14, Math.round(valueSize/2))}px; opacity: 0.7; }
          .slider-label { font-size: 12px; opacity: 0.5; text-transform: uppercase; letter-spacing: 1px; }

          .vertical-slider-track {
            width: 100%; flex: 1; 
            background: var(--secondary-background-color, rgba(255, 255, 255, 0.1));
            border: 2px solid var(--divider-color, rgba(255, 255, 255, 0.1));
            border-radius: ${borderRadius}px; position: relative; overflow: hidden; cursor: pointer;
          }
          .vertical-slider-fill {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: ${color}; transition: background 0.3s;
            border-radius: 0 0 ${borderRadius}px ${borderRadius}px;
          }
          .vertical-slider-thumb {
            position: absolute; left: 50%; transform: translateX(-50%);
            width: 90px; height: 6px; background: white;
            border-radius: 4px; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            pointer-events: none;
          }

          /* Vertical slider with +/- buttons */
          .slider-with-buttons {
            position: relative;
            width: 100%;
            display: block;
          }
          .slider-center {
            width: fit-content;
            margin: 0 auto;
          }
          .vertical-temp-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            position: absolute;
            right: 24px;
            top: 50%;
            transform: translateY(-50%);
          }
          .vertical-temp-btn {
            width: 48px; height: 48px; border-radius: 50%; border: none;
            background: var(--secondary-background-color, rgba(255,255,255,0.1));
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
          }
          .vertical-temp-btn:hover {
            background: var(--primary-color, rgba(255,255,255,0.2));
            transform: scale(1.1);
          }
          .vertical-temp-btn:active {
            transform: scale(0.95);
          }
          .vertical-temp-btn ha-icon {
            --mdc-icon-size: 24px;
          }

          /* Circular slider styles */
          .circular-slider-wrapper {
            display: flex; align-items: center; justify-content: center; gap: 24px; width: 100%;
            position: relative;
          }
          .circular-slider-container {
            position: relative; width: 280px; height: 280px; display: flex; align-items: center; justify-content: center;
            cursor: pointer; user-select: none; flex-shrink: 0;
          }
          .circular-slider-svg {
            position: absolute; top: 0; left: 0; filter: drop-shadow(0 4px 12px rgba(0,0,0,0.3));
          }
          .circular-value-display {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; pointer-events: none;
          }
          .circular-temp-label-top {
            opacity: 0.6; text-transform: uppercase; letter-spacing: 1.5px;
            margin-bottom: 12px;
          }
          .circular-temp-value {
            color: var(--primary-text-color);
            line-height: 1;
          }
          .circular-temp-value span {
            opacity: 0.7;
          }
          .circular-temp-buttons {
            display: flex; flex-direction: column; gap: 12px;
            position: absolute; right: 0px;
          }
          .circular-temp-btn {
            width: 48px; height: 48px; border-radius: 50%; border: none;
            background: var(--secondary-background-color, rgba(255,255,255,0.1));
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
          }
          .circular-temp-btn:hover {
            background: var(--primary-color, rgba(255,255,255,0.2));
            transform: scale(1.1);
          }
          .circular-temp-btn:active {
            transform: scale(0.95);
          }
          .circular-temp-btn ha-icon {
            --mdc-icon-size: 24px;
          }

          .hki-popup-nav {
            display: flex; justify-content: space-evenly; padding: 12px;
            background: rgba(255, 255, 255, 0.03); border-top: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            gap: 8px; overflow-x: auto;
            flex-shrink: 0;
          }
          .nav-btn {
            min-width: 64px; height: 52px; border-radius: 12px; border: none;
            background: transparent; color: var(--primary-text-color);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            gap: 2px;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0;
          }
          .nav-btn:hover { background: var(--secondary-background-color, rgba(255, 255, 255, 0.1)); }
          .nav-btn.active { 
            background: var(--primary-color, rgba(255, 255, 255, 0.15)); 
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            color: var(--text-primary-color, var(--primary-text-color));
          }
          .nav-btn ha-icon { --mdc-icon-size: 22px; }
          .nav-label { font-size: 10px; line-height: 10px; opacity: 0.75; letter-spacing: 0.4px; text-transform: uppercase; }

          .timeline-container { width: 100%; height: 100%; padding: 0 10px 10px 10px; box-sizing: border-box; overflow-y: auto; align-self: stretch; }
          .timeline-item { display: flex; gap: 16px; margin-bottom: 0; min-height: 40px; position: relative; }
          .timeline-visual { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
          .timeline-dot { width: 10px; height: 10px; border-radius: 50%; background: var(--primary-color, #FFD700); z-index: 2; border: 2px solid var(--card-background-color, #1c1c1c); margin-top: 3px; }
          .timeline-line { width: 2px; flex-grow: 1; background: var(--divider-color, rgba(255,255,255,0.12)); margin-top: -2px; margin-bottom: -4px; }
          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content { flex: 1; padding-bottom: 16px; font-size: 13px; color: var(--primary-text-color); }
          .timeline-detail { font-size: 11px; opacity: 0.6; display: block; margin-top: 4px; }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .timeline-trigger { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; font-style: italic; }
          .history-loading { width: 100%; text-align: center; padding: 20px; opacity: 0.6; }

          .list-container { width: 100%; display: flex; flex-direction: column; gap: 8px; overflow-y: auto; max-height: 100%; }
          .list-item { padding: 14px; background: rgba(255,255,255,0.05); border-radius: 8px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; }
          .list-item.active { background: ${color}; color: white; }
        </style>

        <div class="hki-popup-container">
          <div class="hki-popup-header">
            <div class="hki-popup-title">
              ${this._getPopupHeaderIconHtml(entity, ((this.renderTemplate('icon', this._config.icon || '') || '').toString().trim()) || (entity.attributes && entity.attributes.icon) || HVAC_ICONS[mode] || 'mdi:thermostat', this._getPopupIconColor(color))}
              <div class="hki-popup-title-text">
                ${name}
                <span class="hki-popup-state">${this._getPopupHeaderState(renderStateLine())}${this._formatLastTriggered(entity) ? ` - ${this._formatLastTriggered(entity)}` : ''}</span>
              </div>
            </div>
            <div class="hki-popup-header-controls">
                            <button class="header-btn" id="graphBtn"><ha-icon icon="mdi:chart-line"></ha-icon></button>
              <button class="header-btn" id="historyBtn"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>
              <button class="header-btn" id="closeBtn"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>

          <div class="hki-tabs">
            <button class="tab-btn ${this._activeView === 'main' ? 'active' : ''}" id="tabMain" style="${this._activeView === 'main' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}"><ha-icon icon="mdi:fire"></ha-icon><span>Heat</span></button>
            ${(this._config.popup_show_presets !== false && presetList.length) ? `<button class="tab-btn ${this._activeView === 'presets' ? 'active' : ''}" id="tabPresets" style="${this._activeView === 'presets' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}"><ha-icon icon="mdi:tune"></ha-icon><span>Presets</span></button>` : ''}
            ${fanList.length ? `<button class="tab-btn ${this._activeView === 'fan' ? 'active' : ''}" id="tabFan" style="${this._activeView === 'fan' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}"><ha-icon icon="mdi:fan"></ha-icon><span>Fan</span></button>` : ''}
          </div>

          <div class="hki-popup-content" id="popupContent">
            ${this._renderClimatePopupContent(entity, color)}
          </div>

          <div class="hki-popup-nav">
            ${this._renderClimatePopupHvacModes(entity)}
          </div>
        </div>
      `;

      const container = portal.querySelector('.hki-popup-container');
      if (container) container.addEventListener('click', (e) => e.stopPropagation());

      let isBackgroundClick = false;
      portal.addEventListener('mousedown', (e) => { isBackgroundClick = (e.target === portal); });
      portal.addEventListener('touchstart', (e) => { isBackgroundClick = (e.target === portal); }, { passive: true });
      portal.addEventListener('click', (e) => {
        if (isBackgroundClick && e.target === portal) this._closePopup();
        isBackgroundClick = false;
      });

      if (!this._popupPortal) {
        document.body.appendChild(portal);
        this._applyOpenAnimation(portal);
      }
      this._popupPortal = portal;

      const closeBtn = portal.querySelector('#closeBtn');
      if (closeBtn) closeBtn.addEventListener('click', () => this._closePopup());

      // Bottom bar entity buttons
      if (this._config.popup_hide_bottom_bar !== true) {
        const _bbNav = portal.querySelector('.hki-popup-nav');
        if (_bbNav) this._renderBottomBarEntityButtons(_bbNav);
      }
      const historyBtn = portal.querySelector('#historyBtn');
      if (historyBtn) {
        historyBtn.addEventListener('click', () => {
          this._activeView = 'history';
          const content = portal.querySelector('#popupContent');
          if (content) {
            content.innerHTML = `<div class="timeline-container" data-view-type="history" id="historyContainer"><div class="history-loading">Loading Timeline...</div></div>`;
            setTimeout(() => this._loadHistory(), 100);
          }
          portal.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        });
      }

      const graphBtn = portal.querySelector('#graphBtn');
      if (graphBtn) {
        graphBtn.addEventListener('click', () => {
          this._activeView = 'graphs';
          const content = portal.querySelector('#popupContent');
          if (content) {
            content.innerHTML = `<div class="graphs-container" id="graphsContainer"></div>`;
            setTimeout(() => this._mountClimateSensorTiles(portal), 50);
          }
          portal.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        });
      }

      const tabMain = portal.querySelector('#tabMain');
      const tabPresets = portal.querySelector('#tabPresets');
      const tabFan = portal.querySelector('#tabFan');

      const switchView = (view) => {
        this._activeView = view;
        if (tabMain) tabMain.classList.toggle('active', view === 'main');
        if (tabPresets) tabPresets.classList.toggle('active', view === 'presets');
        if (tabFan) tabFan.classList.toggle('active', view === 'fan');

        const content = portal.querySelector('#popupContent');
        if (content) content.innerHTML = this._renderClimatePopupContent(this._getEntity(), color);

        if (view === 'main') {
          if (this._config.climate_use_circular_slider) {
            const ent2 = this._getEntity();
            const a2 = ent2?.attributes || {};
            const isR2 = (ent2?.state === 'heat_cool' || ent2?.state === 'auto') && a2.target_temp_high !== undefined && this._config.climate_show_target_range !== false;
            if (isR2) this._setupDualCircularSliderHandlers(portal); else this._setupCircularSliderHandlers(portal);
          } else {
            this._setupClimatePopupSliders(portal);
            this._setupVerticalPlusMinusButtons(portal);
          }
        }
        if (view === 'presets') this._setupClimatePopupListHandlers(portal, 'preset');
        if (view === 'fan') this._setupClimatePopupListHandlers(portal, 'fan');
      };

      if (tabMain) tabMain.addEventListener('click', () => switchView('main'));
      if (tabPresets) tabPresets.addEventListener('click', () => switchView('presets'));
      if (tabFan) tabFan.addEventListener('click', () => switchView('fan'));

      // HVAC mode buttons
      portal.querySelectorAll('.nav-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          const hvacMode = btn.dataset.mode;
          if (!hvacMode) return;
          if (hvacMode !== 'off') {
            try { localStorage.setItem(`hki_climate_last_mode:${this._config.entity}`, hvacMode); } catch (e) {}
          }
          // Optimistic UI: highlight immediately
          this._optimisticHvacMode = hvacMode;
          portal.querySelectorAll('.nav-btn').forEach(b => {
            b.classList.remove('active');
            b.style.background = '';
            b.style.color = '';
          });
          btn.classList.add('active');
          if (HVAC_COLORS && HVAC_COLORS[hvacMode]) btn.style.color = HVAC_COLORS[hvacMode];

          this.hass.callService('climate', 'set_hvac_mode', { entity_id: this._config.entity, hvac_mode: hvacMode });
        });
      });

      if (this._activeView === 'main') {
        if (this._config.climate_use_circular_slider) {
          const ent3 = this._getEntity();
          const a3 = ent3?.attributes || {};
          const isR3 = (ent3?.state === 'heat_cool' || ent3?.state === 'auto') && a3.target_temp_high !== undefined && this._config.climate_show_target_range !== false;
          if (isR3) this._setupDualCircularSliderHandlers(portal); else this._setupCircularSliderHandlers(portal);
        } else {
          this._setupClimatePopupSliders(portal);
          this._setupVerticalPlusMinusButtons(portal);
        }
      }
      if (this._activeView === 'presets') this._setupClimatePopupListHandlers(portal, 'preset');
      if (this._activeView === 'fan') this._setupClimatePopupListHandlers(portal, 'fan');
    }

    _renderClimatePopupContent(entity, color) {
      if (!entity) return '';
      const attrs = entity.attributes || {};
      const mode = entity.state;

      if (this._activeView === 'history') {
        return `<div class=\"timeline-container\" data-view-type=\"history\" id=\"historyContainer\"><div class=\"history-loading\">Loading Timeline...</div></div>`;
      }

      if (this._activeView === 'graphs') {
        return `<div class=\"graphs-container\" id=\"graphsContainer\"></div>`;
      }

      if (this._activeView === 'presets') return this._renderClimatePopupList(attrs.preset_modes, attrs.preset_mode, 'preset', color);
      if (this._activeView === 'fan') return this._renderClimatePopupList(attrs.fan_modes, attrs.fan_mode, 'fan', color);

      if (mode === 'off') {
        return `<div class="climate-controls-view"><div style="opacity: 0.5; font-size: 18px; font-weight: 500;">System is Off</div></div>`;
      }

      // Use circular slider if enabled
      if (this._config.climate_use_circular_slider) {
        const isRange = (mode === 'heat_cool' || mode === 'auto') && (attrs.target_temp_high !== undefined && attrs.target_temp_low !== undefined) && (this._config.climate_show_target_range !== false);
        if (isRange) {
          return this._renderDualCircularTemperatureControl(entity, mode, color);
        }
        return this._renderCircularTemperatureControl(entity, mode, color);
      }

      const isRange = (mode === 'heat_cool' || mode === 'auto') && (attrs.target_temp_high !== undefined && attrs.target_temp_low !== undefined) && (this._config.climate_show_target_range !== false);
      const range = this._tempMax - this._tempMin;
      const unit = attrs.temperature_unit || this.hass?.config?.unit_system?.temperature || 'Â°';
      const showButtons = this._config.climate_show_plus_minus === true;

      const renderSlider = (id, value, label) => {
        const v = (value === undefined || value === null) ? '--' : value;
        const pct = (value === undefined || value === null) ? 0 : ((value - this._tempMin) / range) * 100;
        const background = this._config.climate_show_gradient === false ? color : this._getTempGradient();
        // Clamp thumb position so it's always visible (at 0% and 100%)
        const thumbPos = pct <= 0 ? '0px' : pct >= 100 ? 'calc(100% - 6px)' : `calc(${pct}% - 6px)`;
        return `
          <div class="slider-group">
            <div class="value-display" id="display-${id}">${v}<span>${unit}</span></div>
            <div class="vertical-slider-track" id="slider-${id}" data-type="${id}">
              <div class="vertical-slider-fill" style="height: ${pct}%; background: ${background};"></div>
              <div class="vertical-slider-thumb" style="bottom: ${thumbPos}"></div>
            </div>
            ${label ? `<div class="slider-label">${label}</div>` : ''}
          </div>
        `;
      };

      const wrapWithButtons = (sliderContent) => {
        if (!showButtons) return sliderContent;
        return `
          <div class="slider-with-buttons">
            <div class="slider-center">${sliderContent}</div>
            <div class="vertical-temp-buttons">
              <button class="vertical-temp-btn plus" data-action="plus">
                <ha-icon icon="mdi:plus"></ha-icon>
              </button>
              <button class="vertical-temp-btn minus" data-action="minus">
                <ha-icon icon="mdi:minus"></ha-icon>
              </button>
            </div>
          </div>
        `;
      };

      if (isRange) {
        const sliders = `<div class="sliders-wrapper">
          ${renderSlider('target_temp_low', attrs.target_temp_low, 'Low')}
          ${renderSlider('target_temp_high', attrs.target_temp_high, 'High')}
        </div>`;
        return `<div class="climate-controls-view">${wrapWithButtons(sliders)}</div>`;
      }

      const slider = `<div class="sliders-wrapper">
        ${renderSlider('temperature', attrs.temperature ?? attrs.current_temperature, 'Target')}
      </div>`;
      return `<div class="climate-controls-view">${wrapWithButtons(slider)}</div>`;
    }

    _renderCircularTemperatureControl(entity, mode, color) {
      const attrs = entity.attributes || {};
      const temperature = this._optimisticClimateTemp ?? attrs.temperature ?? attrs.current_temperature;
      const unit = attrs.temperature_unit || this.hass?.config?.unit_system?.temperature || 'Â°';
      const range = this._tempMax - this._tempMin;
      const value = temperature ?? this._tempMin;
      const percentage = ((value - this._tempMin) / range) * 100;
      const showButtons = this._config.climate_show_plus_minus === true;
      const useGradient = this._config.climate_show_gradient !== false; // Default true
      
      // Calculate arc length for partial circle (270 degrees = 75% of circle)
      const maxArcLength = 628.32 * 0.75; // 75% of full circumference
      const arcLength = (percentage / 100) * maxArcLength;
      
      // Calculate thumb position on 270-degree arc
      // Arc starts at 135 degrees and spans 270 degrees
      const startAngle = 135 * (Math.PI / 180); // Convert to radians
      const arcAngle = (percentage / 100) * 270 * (Math.PI / 180); // Angle within the arc
      const totalAngle = startAngle + arcAngle;
      const thumbX = 140 + 100 * Math.cos(totalAngle);
      const thumbY = 140 + 100 * Math.sin(totalAngle);
      
      // Get mode label
      const modeLabels = {
        'heat': 'HEATING',
        'cool': 'COOLING',
        'heat_cool': 'AUTO',
        'auto': 'AUTO',
        'dry': 'DRY',
        'fan_only': 'FAN',
        'off': 'OFF'
      };
      const modeLabel = modeLabels[mode] || mode.toUpperCase();
      
      // Get font sizes from config
      const valueSize = this._config.popup_value_font_size || 64;
      const labelSize = this._config.popup_label_font_size || 11;
      const valueWeight = this._config.popup_value_font_weight || 200;
      const labelWeight = this._config.popup_label_font_weight || 500;
      
      // Gradient goes from cold (cyan) at start to hot (orange) at end
      const strokeColor = useGradient ? 'url(#tempGradient)' : color;
      
      return `
        <div class="climate-controls-view">
          <div class="circular-slider-wrapper">
            <div class="circular-slider-container" id="circularSlider">
              <svg class="circular-slider-svg" viewBox="0 0 280 280" width="280" height="280">
                ${useGradient ? `
                <defs>
                  <linearGradient id="tempGradient" x1="100%" y1="0%" x2="0%" y2="0%">
                    <stop offset="0%" style="stop-color:#00D9FF;stop-opacity:1" />
                    <stop offset="25%" style="stop-color:#00E5A0;stop-opacity:1" />
                    <stop offset="50%" style="stop-color:#DFFF00;stop-opacity:1" />
                    <stop offset="75%" style="stop-color:#FFB800;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#FF8C00;stop-opacity:1" />
                  </linearGradient>
                </defs>
                ` : ''}
                
                <!-- Background arc (partial circle) -->
                <circle 
                  cx="140" cy="140" r="100" 
                  fill="none" 
                  stroke="var(--divider-color, rgba(255,255,255,0.05))" 
                  stroke-width="20"
                  stroke-dasharray="${maxArcLength} 628.32"
                  transform="rotate(135 140 140)"
                />
                
                <!-- Progress arc with gradient (partial circle) -->
                <circle 
                  cx="140" cy="140" r="100" 
                  fill="none" 
                  stroke="${strokeColor}" 
                  stroke-width="20"
                  stroke-linecap="round"
                  stroke-dasharray="${arcLength} 628.32"
                  transform="rotate(135 140 140)"
                  class="circular-progress"
                  id="circularProgress"
                />
                
                <!-- Thumb handle -->
                <circle 
                  cx="${thumbX}" 
                  cy="${thumbY}" 
                  r="12" 
                  fill="white"
                  stroke="var(--card-background-color, #1c1c1c)"
                  stroke-width="3"
                  class="circular-thumb"
                  id="circularThumb"
                  style="filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));"
                />
              </svg>
              
              <div class="circular-value-display">
                <div class="circular-temp-label-top" style="font-size: ${labelSize}px; font-weight: ${labelWeight};">${modeLabel} TO</div>
                <div class="circular-temp-value" id="circularTempValue" style="font-size: ${valueSize}px; font-weight: ${valueWeight};">${value}<span style="font-size: ${valueSize / 2}px;">${unit}</span></div>
              </div>
            </div>
            
            ${showButtons ? `
              <div class="circular-temp-buttons">
                <button class="circular-temp-btn plus" data-action="plus">
                  <ha-icon icon="mdi:plus"></ha-icon>
                </button>
                <button class="circular-temp-btn minus" data-action="minus">
                  <ha-icon icon="mdi:minus"></ha-icon>
                </button>
              </div>
            ` : ''}
          </div>
        </div>
      `;
    }

    _renderDualCircularTemperatureControl(entity, mode, color) {
      const attrs = entity.attributes || {};
      const unit = attrs.temperature_unit || this.hass?.config?.unit_system?.temperature || 'Â°';
      const range = this._tempMax - this._tempMin;
      const showButtons = this._config.climate_show_plus_minus === true;
      const valueSize = this._config.popup_value_font_size || 48;
      const labelSize = this._config.popup_label_font_size || 11;
      const valueWeight = this._config.popup_value_font_weight || 200;
      const labelWeight = this._config.popup_label_font_weight || 500;

      const renderMiniCircle = (id, value, label, accent) => {
        const pct = Math.max(0, Math.min(100, ((value - this._tempMin) / range) * 100));
        const maxArc = 628.32 * 0.75;
        const arcLen = (pct / 100) * maxArc;
        const startAngle = 135 * (Math.PI / 180);
        const arcAngle = (pct / 100) * 270 * (Math.PI / 180);
        const totalAngle = startAngle + arcAngle;
        const tx = 110 + 78 * Math.cos(totalAngle);
        const ty = 110 + 78 * Math.sin(totalAngle);
        return `
          <div style="display:flex;flex-direction:column;align-items:center;gap:8px;">
            <div style="font-size:${labelSize}px;font-weight:${labelWeight};opacity:0.6;text-transform:uppercase;letter-spacing:1.5px;">${label}</div>
            <div style="position:relative;width:220px;height:220px;display:flex;align-items:center;justify-content:center;cursor:pointer;" id="circularSlider_${id}">
              <svg style="position:absolute;top:0;left:0;filter:drop-shadow(0 4px 12px rgba(0,0,0,0.3));" viewBox="0 0 220 220" width="220" height="220">
                <circle cx="110" cy="110" r="78" fill="none" stroke="var(--divider-color,rgba(255,255,255,0.05))" stroke-width="16" stroke-dasharray="${628.32*0.75}" transform="rotate(135 110 110)"/>
                <circle cx="110" cy="110" r="78" fill="none" stroke="${accent}" stroke-width="16" stroke-linecap="round" stroke-dasharray="${arcLen} 628.32" transform="rotate(135 110 110)" id="circularProgress_${id}"/>
                <circle cx="${tx}" cy="${ty}" r="10" fill="white" stroke="var(--card-background-color,#1c1c1c)" stroke-width="3" id="circularThumb_${id}" style="filter:drop-shadow(0 2px 4px rgba(0,0,0,0.3));"/>
              </svg>
              <div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);text-align:center;pointer-events:none;">
                <div id="circularTempValue_${id}" style="font-size:${valueSize}px;font-weight:${valueWeight};line-height:1;">${value !== null && value !== undefined ? value : '--'}<span style="font-size:${valueSize/2}px;opacity:0.7;">${unit}</span></div>
              </div>
            </div>
            ${showButtons ? `
              <div style="display:flex;gap:12px;">
                <button class="circular-temp-btn minus" data-action="minus" data-slider="${id}" style="width:44px;height:44px;border-radius:50%;border:none;background:var(--secondary-background-color,rgba(255,255,255,0.1));color:var(--primary-text-color);cursor:pointer;display:flex;align-items:center;justify-content:center;"><ha-icon icon="mdi:minus"></ha-icon></button>
                <button class="circular-temp-btn plus" data-action="plus" data-slider="${id}" style="width:44px;height:44px;border-radius:50%;border:none;background:var(--secondary-background-color,rgba(255,255,255,0.1));color:var(--primary-text-color);cursor:pointer;display:flex;align-items:center;justify-content:center;"><ha-icon icon="mdi:plus"></ha-icon></button>
              </div>
            ` : ''}
          </div>
        `;
      };

      const low = this._optimisticTempLow ?? attrs.target_temp_low;
      const high = this._optimisticTempHigh ?? attrs.target_temp_high;

      return `
        <div class="climate-controls-view">
          <div style="display:flex;gap:24px;justify-content:center;align-items:flex-start;width:100%;flex-wrap:wrap;">
            ${renderMiniCircle('low', low, 'Cool to', '#1E90FF')}
            ${renderMiniCircle('high', high, 'Heat to', 'darkorange')}
          </div>
        </div>
      `;
    }

    _renderClimatePopupList(items, current, type, color) {
      if (!items || !items.length) return '<div style="opacity:0.6">Not available</div>';
      return `
        <div class="list-container">
          ${items.map(item => `
            <div class="list-item ${item === current ? 'active' : ''}" data-value="${item}" data-type="${type}">
              <span>${item}</span>
              ${item === current ? '<ha-icon icon="mdi:check"></ha-icon>' : ''}
            </div>
          `).join('')}
        </div>
      `;
    }

    _renderClimatePopupHvacModes(entity) {
      const modes = entity?.attributes?.hvac_modes || [];
      const current = this._optimisticHvacMode ?? entity?.state;
      const labelize = (s) => String(s || '').replace(/_/g, ' ').replace(/\b\w/g, (m) => m.toUpperCase());
      return modes.map(m => {
        const isActive = m === current;
        const customStyle = isActive ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false);
        const colorStyle = isActive ? `color:${(m === 'off') ? 'var(--primary-text-color)' : ((HVAC_COLORS && HVAC_COLORS[m]) || '')}` : '';
        const combinedStyle = [customStyle, colorStyle].filter(s => s).join('; ');
        
        return `
        <button class="nav-btn ${isActive ? 'active' : ''}" data-mode="${m}" style="${combinedStyle}">
          <ha-icon icon="${HVAC_ICONS[m] || 'mdi:thermostat'}"></ha-icon>
          ${this._config.popup_hide_button_text ? '' : `<span class="nav-label">${labelize(m)}</span>`}
        </button>
      `;
      }).join('');
    }





    
    async _mountClimateSensorTiles(portal) {
      try {
        const host = portal.querySelector('#graphsContainer');
        if (!host) return;
        host.innerHTML = '';

        const climateEnt = this._getEntity();
        if (!climateEnt) {
          host.innerHTML = '<div class="history-loading">No entity selected</div>';
          return;
        }

        const attrs = climateEnt.attributes || {};

        const exists = (eid) => !!(eid && this.hass && this.hass.states && this.hass.states[eid]);

        // Prefer explicit overrides; fall back to auto-discovery; finally fall back to attributes history on the climate entity
        const tempOverride = this._config.climate_current_temperature_entity || '';
        const humOverride = this._config.climate_humidity_entity || '';
        const pressOverride = this._config.climate_pressure_entity || '';

        const base = (climateEnt.entity_id || '').replace('climate.', '');
        const firstExisting = (candidates) => candidates.find(exists) || '';

        const tempAuto = firstExisting([
          `sensor.${base}_temperature`,
          `sensor.${base}_temp`,
          `sensor.${base}_current_temperature`,
          `sensor.${base}_current_temp`,
          `sensor.${base}_temp_current`,
        ]);
        const humAuto = firstExisting([
          `sensor.${base}_humidity`,
          `sensor.${base}_current_humidity`,
          `sensor.${base}_rh`,
          `sensor.${base}_relative_humidity`,
        ]);
        const pressAuto = firstExisting([
          `sensor.${base}_pressure`,
          `sensor.${base}_air_pressure`,
          `sensor.${base}_barometric_pressure`,
        ]);

        // Attribute fallbacks (for value display) â€” these are common on climate entities
        const attrKeys = {
          temperature: ['current_temperature', 'temperature'],
          humidity: ['current_humidity', 'humidity'],
          pressure: ['current_pressure', 'pressure', 'air_pressure'],
        };
        const pickAttrKey = (keys) => keys.find((k) => attrs[k] !== undefined && attrs[k] !== null);

        const tiles = [];

        const addTile = (key, titleKey, unitFallback, overrideId, autoId, attrKeyCandidates, titleOverride) => {
          const graphEntity = overrideId || autoId || '';
          const hasGraphEntity = exists(graphEntity);
          const attrKey = pickAttrKey(attrKeyCandidates);

          // If we have neither a sensor entity nor an attribute to show, skip
          if (!hasGraphEntity && !attrKey) return;

          tiles.push({
            key,
            titleKey,
            titleOverride,
            graphEntity: hasGraphEntity ? graphEntity : null,
            attrKey: hasGraphEntity ? null : attrKey, // only use attribute-series when no override/auto entity exists
            unitFallback,
          });
        };

        addTile('temperature', 'current_temperature', this._getTempUnit(climateEnt), tempOverride, tempAuto, attrKeys.temperature, this._config.climate_temperature_name);
        addTile('humidity', 'current_humidity', '%', humOverride, humAuto, attrKeys.humidity, this._config.climate_humidity_name);
        addTile('pressure', 'current_pressure', 'hPa', pressOverride, pressAuto, attrKeys.pressure, this._config.climate_pressure_name);

        if (!tiles.length) {
          host.innerHTML = '<div class="history-loading">No sensor data found. Configure Climate: Current Temp / Humidity / Pressure entities.</div>';
          return;
        }

        host.innerHTML = `<div class="sensor-tiles" id="sensorTiles"></div>`;
        const tilesHost = host.querySelector('#sensorTiles');

        const colorFor = (n) => {
          const nn = Math.max(0, Math.min(1, n));
          const hue = 200 * (1 - nn); // 200=blue, 0=red
          return `hsl(${hue}, 90%, 60%)`;
        };

        const parseSeries = (history, attrKey = null) => {
          const points = [];
          for (const it of (history || [])) {
            const ts = (it?.lu ?? it?.last_updated ?? it?.last_changed);
            if (!ts) continue;
            let raw = null;
            if (attrKey) {
              const a = it?.a ?? it?.attributes;
              raw = a ? a[attrKey] : null;
            } else {
              raw = (it?.s ?? it?.state);
            }
            const n = (typeof raw === 'number') ? raw : parseFloat(String(raw));
            if (!Number.isFinite(n)) continue;
            points.push({ t: new Date(ts).getTime(), v: n });
          }
          points.sort((a, b) => a.t - b.t);
          return points;
        };

        const downsample = (pts, maxN = 60) => {
          if (pts.length <= maxN) return pts;
          const step = Math.ceil(pts.length / maxN);
          const out = [];
          for (let i = 0; i < pts.length; i += step) out.push(pts[i]);
          if (out[out.length - 1] !== pts[pts.length - 1]) out.push(pts[pts.length - 1]);
          return out;
        };

        const buildSvg = (pts, width = 260, height = 56) => {
          if (!pts || pts.length < 2) return null;
          const minV = Math.min(...pts.map(p => p.v));
          const maxV = Math.max(...pts.map(p => p.v));
          const span = (maxV - minV) || 1;
          const t0 = pts[0].t;
          const t1 = pts[pts.length - 1].t;
          const tSpan = (t1 - t0) || 1;

          const xy = pts.map(p => {
            const x = (p.t - t0) / tSpan * width;
            const y = height - ((p.v - minV) / span * height);
            return { x, y, v: p.v };
          });

          const gradId = `grad-${Math.random().toString(16).slice(2)}`;
          const stops = [];
          const stopCount = Math.min(12, xy.length);
          for (let i = 0; i < stopCount; i++) {
            const idx = Math.round(i * (xy.length - 1) / (stopCount - 1 || 1));
            const p = xy[idx];
            const n = (p.v - minV) / span;
            const offset = (p.x / width) * 100;
            stops.push(`<stop offset="${offset.toFixed(1)}%" stop-color="${colorFor(n)}" />`);
          }

          const line = xy.map(p => `${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ');
          const area = `0,${height.toFixed(1)} ${line} ${width.toFixed(1)},${height.toFixed(1)}`;

          return {
            svg: `
              <svg viewBox="0 0 ${width} ${height}" preserveAspectRatio="none" class="sparkline">
                <defs>
                  <linearGradient id="${gradId}" x1="0" y1="0" x2="1" y2="0">
                    ${stops.join('')}
                  </linearGradient>
                </defs>
                <polygon points="${area}" fill="url(#${gradId})" opacity="0.12"></polygon>
                <polyline points="${line}" fill="none" stroke="url(#${gradId})" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"></polyline>
              </svg>`
          };
        };

        const climateName = this._config.name || attrs.friendly_name || climateEnt.entity_id;
        const pretty = (s) => String(s || '')
          .split('_')
          .filter(Boolean)
          .map(w => w.charAt(0).toUpperCase() + w.slice(1))
          .join(' ');

        // Render shells first
        tilesHost.innerHTML = tiles.map((t, idx) => {
          // Title should be: <Climate Name> <Attribute>
          // If we are charting a sensor override/auto entity, we still use the tile label
          // If we are charting a climate attribute series, we use the attribute key prettified
          const attrTitle = t.titleOverride || pretty(t.titleKey || t.attrKey || t.key);
          let name = `${climateName} ${attrTitle}`;
          let unit = t.unitFallback || '';
          let value = '--';

          if (t.graphEntity) {
            const st = this.hass.states[t.graphEntity];
            unit = st?.attributes?.unit_of_measurement || unit;
            value = st?.state ?? '--';
          } else if (t.attrKey) {
            value = attrs[t.attrKey];
          }

          return `
            <div class="sensor-tile" data-key="${t.key}">
              <div class="sensor-tile-top">
                <div class="sensor-tile-title">${name}</div>
                <div class="sensor-tile-value">${value}<span class="sensor-tile-unit">${unit}</span></div>
              </div>
              <div class="sensor-tile-graph" id="tileGraph-${idx}">
                <div class="history-loading" style="padding: 10px 0;">Loadingâ€¦</div>
              </div>
            </div>`;
        }).join('');

        const startTs = new Date(Date.now() - (24 * 60 * 60 * 1000));

        // Fetch history + render sparklines
        await Promise.all(tiles.map(async (t, idx) => {
          const holder = portal.querySelector(`#tileGraph-${idx}`);
          if (!holder) return;
          try {
            // If we are charting a sensor entity, we can use minimal_response
            // If we are charting attributes from the climate entity, we must request full history to get attributes
            const entityId = t.graphEntity || climateEnt.entity_id;
            const wantAttrs = !t.graphEntity && !!t.attrKey;
            const url = wantAttrs
              ? `history/period/${startTs.toISOString()}?filter_entity_id=${encodeURIComponent(entityId)}`
              : `history/period/${startTs.toISOString()}?filter_entity_id=${encodeURIComponent(entityId)}&minimal_response`;

            const data = await this.hass.callApi('GET', url);
            const series = (Array.isArray(data) && data[0]) ? data[0] : [];
            const pts = parseSeries(series, wantAttrs ? t.attrKey : null);
            const ds = downsample(pts, 80);
            if (!ds.length) {
              holder.innerHTML = '<div class="history-loading" style="padding: 10px 0;">No history</div>';
              return;
            }
            const res = buildSvg(ds, 260, 56);
            holder.innerHTML = res ? res.svg : '<div class="history-loading" style="padding: 10px 0;">No data</div>';
          } catch (e) {
            console.warn('sparkline error', t.key, e);
            holder.innerHTML = '<div class="history-loading" style="padding: 10px 0;">Error</div>';
          }
        }));

      } catch (e) {
        console.error('Failed to mount sensor tiles', e);
      }
    }

    _setupClimatePopupSliders(portal) {
      const tracks = portal.querySelectorAll('.vertical-slider-track');
      const ent = this._getEntity();
      const unit = ent?.attributes?.temperature_unit || this.hass?.config?.unit_system?.temperature || 'Â°';
      tracks.forEach(track => {
        const type = track.dataset.type; // temperature, target_temp_low, target_temp_high

        const update = (e) => {
          this._isDragging = true;
          const rect = track.getBoundingClientRect();
          const y = Math.max(0, Math.min(1, 1 - (e.clientY - rect.top) / rect.height));
          let rawVal = this._tempMin + (y * (this._tempMax - this._tempMin));
          let val = Math.round(rawVal / this._step) * this._step;
          val = Math.round(val * 10) / 10;

          const pct = ((val - this._tempMin) / (this._tempMax - this._tempMin)) * 100;
          const fill = track.querySelector('.vertical-slider-fill');
          const thumb = track.querySelector('.vertical-slider-thumb');
          const display = portal.querySelector(`#display-${type}`);

          if (fill) fill.style.height = `${pct}%`;
          // Clamp thumb position so it stays visible at 0% and 100%
          const thumbPos = pct <= 0 ? '0px' : pct >= 100 ? 'calc(100% - 6px)' : `calc(${pct}% - 6px)`;
          if (thumb) thumb.style.bottom = thumbPos;
          if (display) display.innerHTML = `${val}<span>${unit}</span>`;

          return val;
        };

        const finish = (e) => {
          const ev = e.changedTouches ? e.changedTouches[0] : e;
          const val = update(ev);
          this._isDragging = false;

          const payload = { entity_id: this._config.entity };
          if (type === 'temperature') payload.temperature = val;
          else if (type === 'target_temp_low') payload.target_temp_low = val;
          else if (type === 'target_temp_high') payload.target_temp_high = val;

          // Validate ranges
          const ent = this._getEntity();
          if (ent && (type === 'target_temp_low' || type === 'target_temp_high')) {
            if (type === 'target_temp_low' && val >= ent.attributes.target_temp_high) return;
            if (type === 'target_temp_high' && val <= ent.attributes.target_temp_low) return;
          }

          this.hass.callService('climate', 'set_temperature', payload);

          document.removeEventListener('mousemove', updateWrapper);
          document.removeEventListener('mouseup', finish);
          document.removeEventListener('touchmove', touchWrapper);
          document.removeEventListener('touchend', finish);
        };

        const updateWrapper = (e) => update(e);
        const touchWrapper = (e) => { e.preventDefault(); update(e.touches[0]); };

        track.addEventListener('mousedown', (e) => {
          updateWrapper(e);
          document.addEventListener('mousemove', updateWrapper);
          document.addEventListener('mouseup', finish);
        });

        track.addEventListener('touchstart', (e) => {
          touchWrapper(e);
          document.addEventListener('touchmove', touchWrapper, { passive: false });
          document.addEventListener('touchend', finish);
        });
      });
    }

    _setupCircularSliderHandlers(portal) {
      const circularSlider = portal.querySelector('#circularSlider');
      if (!circularSlider) return;

      const ent = this._getEntity();
      const unit = ent?.attributes?.temperature_unit || this.hass?.config?.unit_system?.temperature || 'Â°';
      
      // +/- button handlers
      let minusBtn = portal.querySelector('.circular-temp-btn.minus');
      let plusBtn = portal.querySelector('.circular-temp-btn.plus');

      // Prevent duplicate listeners when the popup re-renders
      if (minusBtn && minusBtn.parentNode) {
        const clone = minusBtn.cloneNode(true);
        minusBtn.parentNode.replaceChild(clone, minusBtn);
        minusBtn = clone;
      }
      if (plusBtn && plusBtn.parentNode) {
        const clone = plusBtn.cloneNode(true);
        plusBtn.parentNode.replaceChild(clone, plusBtn);
        plusBtn = clone;
      }

      const applyDelta = (dir) => {
        const ent = this._getEntity();
        const attrs = ent?.attributes || {};
        const step = this._getTempStep();
        this._step = step;

        const currentRaw = this._optimisticClimateTemp ?? attrs.temperature ?? attrs.current_temperature ?? this._tempMin;
        const current = this._roundToStep(currentRaw, step);
        let newVal = this._roundToStep(current + (dir * step), step);
        newVal = this._clampTemp(newVal);

        // Keep UI stable until HA confirms the new temperature
        this._optimisticClimateTemp = newVal;
        this._updateCircularSliderUI(portal, newVal, unit);

        this.hass.callService('climate', 'set_temperature', {
          entity_id: this._config.entity,
          temperature: newVal
        });
      };

      if (minusBtn) {
        minusBtn.addEventListener('click', () => applyDelta(-1));
      }

      if (plusBtn) {
        plusBtn.addEventListener('click', () => applyDelta(1));
      }

      // Circular slider drag handlers
      const svg = circularSlider.querySelector('.circular-slider-svg');
      const progress = circularSlider.querySelector('#circularProgress');
      const thumb = circularSlider.querySelector('#circularThumb');
      const valueDisplay = circularSlider.querySelector('#circularTempValue');
      
      const maxArcLength = 628.32 * 0.75; // 75% of full circumference (270 degrees)
      
      const updateFromPoint = (clientX, clientY) => {
        this._isDragging = true;
        const rect = svg.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        // Calculate angle from center
        let angle = Math.atan2(clientY - centerY, clientX - centerX);
        
        // Convert to degrees
        let degrees = angle * 180 / Math.PI;
        
        // Normalize to 0-360
        if (degrees < 0) degrees += 360;
        
        // The arc starts at 135 degrees and goes to 405 degrees (135 + 270)
        // Adjust the angle to be relative to the start of the arc
        let arcDegrees = degrees - 135;
        if (arcDegrees < 0) arcDegrees += 360;
        
        // Constrain to 270-degree range
        if (arcDegrees > 270) {
          // Snap to closest end
          if (arcDegrees < 315) {
            arcDegrees = 270; // Snap to end
          } else {
            arcDegrees = 0; // Snap to start
          }
        }
        
        const percentage = (arcDegrees / 270) * 100;
        let rawVal = this._tempMin + (percentage / 100) * (this._tempMax - this._tempMin);
        const step = this._getTempStep();
        this._step = step;
        let val = this._roundToStep(rawVal, step);
        val = this._clampTemp(val);
        this._optimisticClimateTemp = val;
        
        const finalPct = ((val - this._tempMin) / (this._tempMax - this._tempMin)) * 100;
        const arcLength = (finalPct / 100) * maxArcLength;
        
        // Calculate thumb position
        const startAngle = 135 * (Math.PI / 180);
        const arcAngle = (finalPct / 100) * 270 * (Math.PI / 180);
        const totalAngle = startAngle + arcAngle;
        const thumbX = 140 + 100 * Math.cos(totalAngle);
        const thumbY = 140 + 100 * Math.sin(totalAngle);
        
        if (progress) progress.setAttribute('stroke-dasharray', `${arcLength} 628.32`);
        if (thumb) {
          thumb.setAttribute('cx', thumbX);
          thumb.setAttribute('cy', thumbY);
        }
        if (valueDisplay) {
          const valueSize = this._config.popup_value_font_size || 64;
          valueDisplay.innerHTML = `${val}<span style="font-size: ${valueSize / 2}px;">${unit}</span>`;
        }
        
        return val;
      };
      
      const finish = (e) => {
        const ev = e.changedTouches ? e.changedTouches[0] : e;
        const val = updateFromPoint(ev.clientX, ev.clientY);
        this._isDragging = false;
        
        this.hass.callService('climate', 'set_temperature', { 
          entity_id: this._config.entity, 
          temperature: val 
        });
        
        document.removeEventListener('mousemove', moveWrapper);
        document.removeEventListener('mouseup', finish);
        document.removeEventListener('touchmove', touchWrapper);
        document.removeEventListener('touchend', finish);
      };
      
      const moveWrapper = (e) => updateFromPoint(e.clientX, e.clientY);
      const touchWrapper = (e) => { 
        e.preventDefault(); 
        updateFromPoint(e.touches[0].clientX, e.touches[0].clientY); 
      };
      
      circularSlider.addEventListener('mousedown', (e) => {
        updateFromPoint(e.clientX, e.clientY);
        document.addEventListener('mousemove', moveWrapper);
        document.addEventListener('mouseup', finish);
      });
      
      circularSlider.addEventListener('touchstart', (e) => {
        updateFromPoint(e.touches[0].clientX, e.touches[0].clientY);
        document.addEventListener('touchmove', touchWrapper, { passive: false });
        document.addEventListener('touchend', finish);
      });
      
      // Setup vertical +/- buttons if they exist
      this._setupVerticalPlusMinusButtons(portal);
    }

    _setupDualCircularSliderHandlers(portal) {
      const step = this._getTempStep();

      const setupOne = (slotId, attrLow, attrHigh, optimisticKey, serviceParam) => {
        const el = portal.querySelector(`#circularSlider_${slotId}`);
        if (!el) return;
        const svg = el.querySelector('svg');
        const progress = el.querySelector(`#circularProgress_${slotId}`);
        const thumb = el.querySelector(`#circularThumb_${slotId}`);
        const valueDisplay = el.querySelector(`#circularTempValue_${slotId}`);
        const unit = this._getEntity()?.attributes?.temperature_unit || this.hass?.config?.unit_system?.temperature || 'Â°';
        const maxArc = 628.32 * 0.75;
        const valueSize = this._config.popup_value_font_size || 48;

        const applyValue = (val) => {
          this[optimisticKey] = val;
          const pct = ((val - this._tempMin) / (this._tempMax - this._tempMin)) * 100;
          const arcLen = (pct / 100) * maxArc;
          const startAngle = 135 * (Math.PI / 180);
          const arcAngle = (pct / 100) * 270 * (Math.PI / 180);
          const totalAngle = startAngle + arcAngle;
          const tx = 110 + 78 * Math.cos(totalAngle);
          const ty = 110 + 78 * Math.sin(totalAngle);
          if (progress) progress.setAttribute('stroke-dasharray', `${arcLen} 628.32`);
          if (thumb) { thumb.setAttribute('cx', tx); thumb.setAttribute('cy', ty); }
          if (valueDisplay) valueDisplay.innerHTML = `${val}<span style="font-size:${valueSize/2}px;opacity:0.7;">${unit}</span>`;
        };

        const getFromPoint = (clientX, clientY) => {
          const rect = svg.getBoundingClientRect();
          const cx = rect.left + rect.width / 2, cy = rect.top + rect.height / 2;
          let angle = Math.atan2(clientY - cy, clientX - cx) * 180 / Math.PI;
          if (angle < 0) angle += 360;
          let arcDeg = angle - 135;
          if (arcDeg < 0) arcDeg += 360;
          if (arcDeg > 270) arcDeg = arcDeg < 315 ? 270 : 0;
          let raw = this._tempMin + (arcDeg / 270) * (this._tempMax - this._tempMin);
          return this._clampTemp(this._roundToStep(raw, step));
        };

        const commit = (val) => {
          const ent = this._getEntity();
          const attrs = ent?.attributes || {};
          const lowVal = slotId === 'low' ? val : (this._optimisticTempLow ?? attrs.target_temp_low);
          const highVal = slotId === 'high' ? val : (this._optimisticTempHigh ?? attrs.target_temp_high);
          this.hass.callService('climate', 'set_temperature', {
            entity_id: this._config.entity,
            target_temp_low: lowVal,
            target_temp_high: highVal,
          });
        };

        // +/- buttons
        portal.querySelectorAll(`.circular-temp-btn[data-slider="${slotId}"]`).forEach(btn => {
          btn.addEventListener('click', () => {
            const ent = this._getEntity();
            const attrs = ent?.attributes || {};
            const cur = this[optimisticKey] ?? attrs[attrLow] ?? attrs[attrHigh] ?? this._tempMin;
            const dir = btn.dataset.action === 'plus' ? 1 : -1;
            const val = this._clampTemp(this._roundToStep(cur + dir * step, step));
            applyValue(val);
            commit(val);
          });
        });

        let dragging = false;
        el.addEventListener('mousedown', (e) => { dragging = true; applyValue(getFromPoint(e.clientX, e.clientY)); });
        el.addEventListener('touchstart', (e) => { dragging = true; applyValue(getFromPoint(e.touches[0].clientX, e.touches[0].clientY)); }, { passive: true });

        const onMove = (e) => { if (dragging) applyValue(getFromPoint(e.clientX, e.clientY)); };
        const onTouchMove = (e) => { if (dragging) applyValue(getFromPoint(e.touches[0].clientX, e.touches[0].clientY)); };
        const onUp = (e) => {
          if (!dragging) return;
          dragging = false;
          const val = this[optimisticKey];
          if (val !== undefined) commit(val);
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);
          document.removeEventListener('touchmove', onTouchMove);
          document.removeEventListener('touchend', onUp);
        };
        el.addEventListener('mousedown', () => {
          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp);
        });
        el.addEventListener('touchstart', () => {
          document.addEventListener('touchmove', onTouchMove, { passive: true });
          document.addEventListener('touchend', onUp);
        }, { passive: true });
      };

      setupOne('low', 'target_temp_low', 'target_temp_low', '_optimisticTempLow', 'target_temp_low');
      setupOne('high', 'target_temp_high', 'target_temp_high', '_optimisticTempHigh', 'target_temp_high');
    }

    _setupVerticalPlusMinusButtons(portal) {
      let minusBtn = portal.querySelector('.vertical-temp-btn.minus');
      let plusBtn = portal.querySelector('.vertical-temp-btn.plus');

      if (!minusBtn && !plusBtn) return;

      // Prevent duplicate listeners when the popup re-renders
      if (minusBtn && minusBtn.parentNode) {
        const clone = minusBtn.cloneNode(true);
        minusBtn.parentNode.replaceChild(clone, minusBtn);
        minusBtn = clone;
      }
      if (plusBtn && plusBtn.parentNode) {
        const clone = plusBtn.cloneNode(true);
        plusBtn.parentNode.replaceChild(clone, plusBtn);
        plusBtn = clone;
      }

      
      const useGradient = this._config.climate_show_gradient !== false;
      
      if (minusBtn) {
        minusBtn.addEventListener('click', () => {
          const ent = this._getEntity();
          const attrs = ent?.attributes || {};
          const step = this._getTempStep();
          const current = this._optimisticClimateTemp ?? attrs.temperature ?? attrs.current_temperature ?? this._tempMin;
          const unit = attrs.temperature_unit || this.hass?.config?.unit_system?.temperature || 'Â°';
          let newVal = this._clampTemp(this._roundToStep(current - step, step));
          this._optimisticClimateTemp = newVal;
          
          // Optimistic UI update
          const percentage = this._getTempPercentage(newVal);
          const color = (HVAC_COLORS && HVAC_COLORS[ent.state]) || HVAC_COLORS.off || 'var(--primary-color)';
          const background = useGradient ? this._getTempGradient() : color;
          
          const fill = portal.querySelector('.vertical-slider-fill');
          const thumb = portal.querySelector('.vertical-slider-thumb');
          const valueDisplay = portal.querySelector('.value-display');
          
          if (fill) {
            fill.style.height = percentage + '%';
            fill.style.background = background;
          }
          // Clamp thumb position so it stays visible at 0% and 100%
          const thumbPos = percentage <= 0 ? '0px' : percentage >= 100 ? 'calc(100% - 6px)' : `calc(${percentage}% - 6px)`;
          if (thumb) thumb.style.bottom = thumbPos;
          if (valueDisplay) valueDisplay.innerHTML = `${newVal}<span>${unit}</span>`;
          
          this.hass.callService('climate', 'set_temperature', { 
            entity_id: this._config.entity, 
            temperature: newVal 
          });
        });
      }
      
      if (plusBtn) {
        plusBtn.addEventListener('click', () => {
          const ent = this._getEntity();
          const attrs = ent?.attributes || {};
          const step = this._getTempStep();
          const current = this._optimisticClimateTemp ?? attrs.temperature ?? attrs.current_temperature ?? this._tempMin;
          const unit = attrs.temperature_unit || this.hass?.config?.unit_system?.temperature || 'Â°';
          let newVal = this._clampTemp(this._roundToStep(current + step, step));
          this._optimisticClimateTemp = newVal;
          
          // Optimistic UI update
          const percentage = this._getTempPercentage(newVal);
          const color = (HVAC_COLORS && HVAC_COLORS[ent.state]) || HVAC_COLORS.off || 'var(--primary-color)';
          const background = useGradient ? this._getTempGradient() : color;
          
          const fill = portal.querySelector('.vertical-slider-fill');
          const thumb = portal.querySelector('.vertical-slider-thumb');
          const valueDisplay = portal.querySelector('.value-display');
          
          if (fill) {
            fill.style.height = percentage + '%';
            fill.style.background = background;
          }
          // Clamp thumb position so it stays visible at 0% and 100%
          const thumbPos = percentage <= 0 ? '0px' : percentage >= 100 ? 'calc(100% - 6px)' : `calc(${percentage}% - 6px)`;
          if (thumb) thumb.style.bottom = thumbPos;
          if (valueDisplay) valueDisplay.innerHTML = `${newVal}<span>${unit}</span>`;
          
          this.hass.callService('climate', 'set_temperature', { 
            entity_id: this._config.entity, 
            temperature: newVal 
          });
        });
      }
    }

    _setupClimatePopupListHandlers(portal, type) {
      portal.querySelectorAll('.list-item').forEach(item => {
        item.addEventListener('click', () => {
          const value = item.dataset.value;
          if (!value) return;

          if (type === 'preset') {
            this.hass.callService('climate', 'set_preset_mode', { entity_id: this._config.entity, preset_mode: value });
          } else if (type === 'fan') {
            this.hass.callService('climate', 'set_fan_mode', { entity_id: this._config.entity, fan_mode: value });
          }
        });
      });
    }



    _renderContent(isOn, brightness, supportsTemp, supportsColor, effectList, currentEffect, isGroup) {
      const valueStyle = `font-size: ${this._config.popup_value_font_size || 36}px; font-weight: ${this._config.popup_value_font_weight || 300};`;
      const labelStyle = `font-size: ${this._config.popup_label_font_size || 16}px; font-weight: ${this._config.popup_label_font_weight || 400};`;
      
      if (this._activeView === 'brightness') {
        const barColor = this._config.dynamic_bar_color ? this._getCurrentColor() : 'linear-gradient(to top, #FFD700, #FFA500)';
        // Clamp thumb position so it's always visible (at 0% and 100%)
        const thumbPos = brightness <= 0 ? '0px' : brightness >= 100 ? 'calc(100% - 6px)' : `calc(${brightness}% - 6px)`;
        return `
          <div class="value-display" style="${valueStyle}"><span style="${valueStyle}">${brightness}</span><span style="${labelStyle}">%</span></div>
          <div class="vertical-slider-container">
            <div class="vertical-slider-track" id="brightnessTrack">
              <div class="vertical-slider-fill" style="height: ${brightness}%; background: ${barColor}"></div>
              <div class="vertical-slider-thumb" style="bottom: ${thumbPos}"></div>
            </div>
          </div>
        `;
      } else if (this._activeView === 'temperature') {
        const range = this._tempMax - this._tempMin;
        const currentTempPct = 100 - (((this._currentTemp - this._tempMin) / range) * 100);
        const kelvin = Math.round(1000000 / this._currentTemp);
        const tempName = this._getTempName(kelvin);
        // Clamp thumb position so it's always visible (at 0% and 100%)
        const thumbPos = currentTempPct <= 0 ? '0px' : currentTempPct >= 100 ? 'calc(100% - 6px)' : `calc(${currentTempPct}% - 6px)`;
        return `
          <div class="value-display" style="${labelStyle}">${tempName}</div>
          <div class="vertical-slider-container">
            <div class="vertical-slider-track temp-gradient" id="tempTrackVertical">
              <div class="vertical-slider-fill temp-fill" style="height: ${currentTempPct}%"></div>
              <div class="vertical-slider-thumb" style="bottom: ${thumbPos}"></div>
            </div>
          </div>
          ${this._config.popup_show_favorites !== false ? `
          <button class="save-favorite-fab" id="saveFavoriteBtn" title="Save to Favorites">
            <ha-icon icon="mdi:star-plus"></ha-icon>
          </button>
          ` : ''}
        `;
      } else if (this._activeView === 'color') {
        const colorName = this._getColorName(this._hue, this._saturation);
        return `
          <div class="value-display" style="${labelStyle}">${colorName}</div>
          <div class="color-wheel" id="colorWheel">
            <div class="color-wheel-indicator" id="colorIndicator"></div>
          </div>
          ${this._config.popup_show_favorites !== false ? `
          <button class="save-favorite-fab" id="saveFavoriteBtn" title="Save to Favorites">
            <ha-icon icon="mdi:star-plus"></ha-icon>
          </button>
          ` : ''}
        `;
      }
      
      const view = this._popupPortal ? this._popupPortal.querySelector('[data-view-type]')?.dataset.viewType : null;
      
      if (view === 'scenes') {
        return this._renderFavoritesView();
      } else if (view === 'individual' && isGroup) {
        return this._renderIndividualView();
      } else if (view === 'effects' && effectList.length > 0) {
        return this._renderEffectsView(effectList, currentEffect);
      } else if (view === 'history') {
        return `<div class="timeline-container" data-view-type="history" id="historyContainer">
          <div class="history-loading">Loading Timeline...</div>
        </div>`;
      }

      return '';
    }

    _renderClimateContent(entity) {
        if (this._activeView === 'presets') return this._renderList(entity.attributes.preset_modes, entity.attributes.preset_mode, 'preset');
        if (this._activeView === 'fan') return this._renderList(entity.attributes.fan_modes, entity.attributes.fan_mode, 'fan');
    
        // Main Sliders
        const attrs = entity.attributes;
        const mode = entity.state;
        const color = HVAC_COLORS[mode] || HVAC_COLORS.off;
        const isRange = (mode === 'heat_cool' || mode === 'auto') && attrs.target_temp_high;
        const range = this._tempMax - this._tempMin;
        const borderRadius = this._config.popup_slider_radius ?? 12;
    
        const renderSlider = (id, val, label) => {
            const pct = ((val - this._tempMin) / range) * 100;
            // Clamp thumb position so it's always visible (at 0% and 100%)
            const thumbPos = pct <= 0 ? '0px' : pct >= 100 ? 'calc(100% - 6px)' : `calc(${pct}% - 6px)`;
            return `
                <div class="climate-slider-group">
                    <div class="value-display" id="disp-${id}">${val}<span>Â°</span></div>
                    <div class="vertical-slider-container">
                        <div class="vertical-slider-track" id="track-${id}" data-type="${id}">
                            <div class="vertical-slider-fill" style="height: ${pct}%; background: ${color}; border-radius: 0 0 ${borderRadius}px ${borderRadius}px;"></div>
                            <div class="vertical-slider-thumb" style="bottom: ${thumbPos}"></div>
                        </div>
                    </div>
                    ${label ? `<div class="climate-label">${label}</div>` : ''}
                </div>`;
        };
    
        if (mode === 'off') return `<div style="opacity:0.5; font-size:24px; font-weight:300;">System is Off</div>`;
        
        if (isRange) {
            return `<div class="climate-dual-wrapper">
                ${renderSlider('low', attrs.target_temp_low, 'Low')}
                ${renderSlider('high', attrs.target_temp_high, 'High')}
            </div>`;
        }
        return renderSlider('single', attrs.temperature || attrs.current_temperature, 'Target');
    }
    
    _renderClimateNav(entity) {
        const modes = entity.attributes.hvac_modes || [];
        const currentMode = this._optimisticHvacMode ?? entity.state;
        const title = (s) => String(s || '')
          .replace(/_/g, ' ')
          .replace(/\b\w/g, (c) => c.toUpperCase());
        return modes.map(m => {
            const isActive = m === currentMode;
            return `
            <button class="nav-btn ${isActive ? 'active' : ''}" id="mode-${m}" style="${isActive ? `color:${HVAC_COLORS[m]}` : ''}">
                <ha-icon icon="${HVAC_ICONS[m]}"></ha-icon>
                ${this._config.popup_hide_button_text ? '' : `<span class="nav-label">${title(m)}</span>`}
            </button>
        `;
        }).join('');
    }


    /* --- COVER POPUP --- */
    _coverFavoritesKey() {
      return `hki_cover_favorites__${this._config.entity}`;
    }

    _ensureCoverFavorites() {
      try {
        const raw = localStorage.getItem(this._coverFavoritesKey());
        this._coverFavorites = raw ? JSON.parse(raw) : [];
        if (!Array.isArray(this._coverFavorites)) this._coverFavorites = [];
      } catch (e) {
        this._coverFavorites = [];
      }
    }

    _persistCoverFavorites() {
      try {
        localStorage.setItem(this._coverFavoritesKey(), JSON.stringify(this._coverFavorites || []));
      } catch (e) {}
    }

    _getCoverPosition(ent) {
      if (!ent) return 0;
      const pos = ent.attributes && ent.attributes.current_position;
      if (typeof pos === 'number') return Math.max(0, Math.min(100, pos));
      if (ent.state === 'open') return 100;
      if (ent.state === 'closed') return 0;
      return 0;
    }

    async _applyCoverFavorite(fav) {
      if (!fav) return;
      try {
        if (Array.isArray(fav.members) && fav.members.length) {
          for (const m of fav.members) {
            if (!m?.entity_id) continue;
            const p = typeof m.position === 'number' ? m.position : 0;
            await this.hass.callService('cover', 'set_cover_position', { entity_id: m.entity_id, position: Math.max(0, Math.min(100, p)) });
          }
          return;
        }
        const position = typeof fav.position === 'number' ? fav.position : null;
        if (position === null) return;
        await this.hass.callService('cover', 'set_cover_position', { entity_id: this._config.entity, position: Math.max(0, Math.min(100, position)) });
      } catch (e) {
        console.error('HKI cover favorite apply failed', e);
      }
    }

    async _promptCoverGroupFavoriteMeta(defaultName) {
      const name = await this._promptText('Favorite name', defaultName || 'Preset');
      if (name === null) return null;
      const color = await this._promptText('Button color (optional)', '');
      if (color === null) return null;
      const image = await this._promptText('Image path/URL (optional)', '');
      if (image === null) return null;
      return { name: name || defaultName || 'Preset', color: color || '', image: image || '' };
    }

    _renderCoverPopupPortal(entity) {
      if (!entity) entity = this._getEntity();
      // Reuse existing portal to avoid flicker on hass updates.
      const isGroup = Array.isArray(entity.attributes?.entity_id) && entity.attributes.entity_id.length > 1;
      const entityName = this._getPopupName(entity);
      const pos = this._getCoverPosition(entity);

      // Check default view configuration for groups
      const defaultView = this._config.popup_default_view; // 'main', 'individual', or undefined
      
      // Auto-switch to individual/group view if configured and it's a group
      // Only set if not already explicitly set by user
      if (defaultView === 'individual' && isGroup && this._coverGroupMode === undefined) {
        this._coverGroupMode = true;
      } else if (this._coverGroupMode === undefined) {
        this._coverGroupMode = false;
      }

      // Use same visual overrides as other popups
      const popupRadius = this._config.popup_border_radius ?? 16;
      const borderRadius = this._config.popup_slider_radius ?? 12;
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-light-popup-portal';
      // Clear previous content when reusing.
      portal.innerHTML = '';

      const safeTitle = (s) => String(s || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');

      const controlsIcon = this._getResolvedIcon(entity, 'mdi:window-shutter');

      const groupBtn = isGroup ? `
        <button class="header-btn" id="coverGroupBtn" title="Group">
          <ha-icon icon="mdi:format-list-bulleted"></ha-icon>
        </button>
      ` : '';

      portal.innerHTML = `
        <style>
          /* Base popup styles (mirrors light/climate popups) */
          .hki-light-popup-portal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            ${this._getPopupPortalStyle()}
            display: flex; align-items: center; justify-content: center; z-index: 9999;
          }
          .hki-light-popup-container {
            ${this._getPopupCardStyle()};
            border-radius: ${popupRadius}px;
            width: ${popupWidth}; height: ${popupHeight};
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex; flex-direction: column;
            overflow: hidden;
          }
          .hki-light-popup-header {
            display: flex; justify-content: space-between; align-items: center; padding: 16px 20px;
            background: rgba(255, 255, 255, 0.03); border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .hki-light-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-light-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-light-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; color: var(--primary-text-color); }
          .hki-light-popup-state { font-size: 12px; opacity: 0.6; text-transform: capitalize; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-light-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: var(--divider-color, rgba(255, 255, 255, 0.05)); border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
          }
          .header-btn:hover { background: rgba(255, 255, 255, 0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }

          .hki-light-popup-tabs {
            display: flex; gap: 8px; padding: 8px 20px;
            background: rgba(255, 255, 255, 0.03);
            border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .hki-light-popup-tab {
            flex: 1; height: 40px; border-radius: 8px;
            background: transparent; border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center; gap: 8px;
            transition: all 0.2s; font-size: 14px; font-weight: 500;
          }
          .hki-light-popup-tab:hover { background: var(--secondary-background-color, rgba(255, 255, 255, 0.08)); }
          .hki-light-popup-tab.active { 
            background: var(--primary-color, rgba(255, 255, 255, 0.15)); 
            color: var(--text-primary-color, var(--primary-text-color));
          }
          .hki-light-popup-tab ha-icon { --mdc-icon-size: 18px; }

          .hki-light-popup-content {
            flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column;
            align-items: stretch; justify-content: flex-start; gap: 12px;
            min-height: 0;
            position: relative;
            overflow-x: hidden;
          }
          .hki-light-popup-content.view-favorites { align-items: stretch;
          justify-items: stretch; justify-content: flex-start; }

          .hki-light-popup-nav {
            display: flex; justify-content: space-evenly; padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-top: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            gap: 8px;
            flex-shrink: 0;
          }
          .nav-btn {
            min-width: 60px; height: 50px; border-radius: 12px;
            border: none; background: transparent;
            color: var(--primary-text-color); opacity: 0.5;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            cursor: pointer; transition: all 0.2s;
            flex: 1;
          }
          .nav-btn:hover { opacity: 1; background: var(--divider-color, rgba(255, 255, 255, 0.05)); }
          .nav-btn:active { background: rgba(255, 255, 255, 0.1); }
          .nav-btn ha-icon { --mdc-icon-size: 24px; margin-bottom: 2px; }
          .nav-btn .nav-label { font-size: 9px; font-weight: 600; text-transform: uppercase; }

          .save-favorite-fab {
            position: absolute; right: 16px; bottom: 16px;
            width: 44px; height: 44px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.10);
            color: var(--primary-text-color);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer;
            transition: transform 0.15s, background 0.15s;
            z-index: 5;
          }
          .save-favorite-fab:hover { background: rgba(255, 255, 255, 0.14); transform: scale(1.05); }
          .save-favorite-fab ha-icon { --mdc-icon-size: 20px; }

          .favorites-view { width: 100%; height: 100%; position: relative; }
          .favorites-sticky-header {
            position: sticky; top: 0; z-index: 6;
            display: flex; justify-content: flex-end;
            padding: 8px 0 8px 0;
            background: transparent;
            backdrop-filter: none;
          }
          .favorites-edit-btn {
            position: relative; z-index: 1;
            display: flex; align-items: center; gap: 8px;
            background: var(--divider-color, rgba(255, 255, 255, 0.06));
            border: 1px solid rgba(255, 255, 255, 0.10);
            color: var(--primary-text-color);
            height: 34px; padding: 0 12px; border-radius: 999px;
            cursor: pointer;
          }
          .favorites-edit-btn:hover { background: rgba(255, 255, 255, 0.10); }
          .favorites-edit-btn ha-icon { --mdc-icon-size: 18px; }

          .preset-btn {
            position: relative;
            height: 82px;
            border-radius: ${popupBorderRadius}px;
            background: var(--divider-color, rgba(255, 255, 255, 0.06));
            border: 1px solid rgba(255, 255, 255, 0.08);
            display:flex; flex-direction:column; align-items:center; justify-content:center;
            gap: 8px;
            cursor:pointer;
            overflow:hidden;
          }
          .preset-name {
            font-size: 11px;
            opacity: 0.85;
            max-width: 88%;
            text-align:center;
            overflow:hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            line-height: 1.1;
            min-height: 2.2em;
          }
          .preset-picture {
            width: 32px; height: 32px; border-radius: 50%;
            object-fit: cover;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
          }
          .fav-delete-badge {
            position: absolute; top: 8px; right: 8px;
            width: 20px; height: 20px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.10);
            border: 1px solid rgba(255, 255, 255, 0.12);
            display: flex; align-items: center; justify-content: center;
            color: var(--primary-text-color);
          }
          .fav-delete-badge:hover { background: rgba(255, 80, 80, 0.25); border-color: rgba(255, 80, 80, 0.35); }
          .fav-delete-badge ha-icon { --mdc-icon-size: 14px; }

          .timeline-container { width: 100%; height: 100%; padding: 0 10px 10px 10px; box-sizing: border-box; overflow-y: auto; align-self: stretch; }
          .timeline-item { display: flex; gap: 16px; margin-bottom: 0; min-height: 40px; position: relative; }
          .timeline-visual {
            display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0;
          }
          .timeline-dot {
            width: 10px; height: 10px; border-radius: 50%; background: var(--primary-color, #FFD700);
            z-index: 2; border: 2px solid var(--card-background-color, #1c1c1c); margin-top: 3px;
          }
          .timeline-line {
            width: 2px; flex-grow: 1; background: var(--divider-color, rgba(255,255,255,0.12)); margin-top: -2px; margin-bottom: -4px;
          }
          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content {
            flex: 1; padding-bottom: 16px; font-size: 13px; color: var(--primary-text-color);
          }
          .timeline-detail { font-size: 11px; opacity: 0.6; display: block; margin-top: 4px; }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .timeline-trigger { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; font-style: italic; }
          .history-loading { width: 100%; text-align: center; padding: 20px; opacity: 0.6; }

          /* Cover-specific */

          /* Shared vertical slider styles (match light/climate) */
          .vertical-slider-container { width: 80px; height: 280px; position: relative; }
          .vertical-slider-track {
            width: 100%; height: 100%; background: var(--secondary-background-color, rgba(255, 255, 255, 0.1));
            border-radius: ${borderRadius}px; position: relative; overflow: hidden; cursor: pointer;
          }
          .vertical-slider-fill {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: rgba(33,150,243,0.85);
            border-radius: 0 0 ${borderRadius}px ${borderRadius}px;
          }
          .vertical-slider-thumb {
            position: absolute; left: 50%; transform: translateX(-50%);
            width: 90px; height: 6px; background: white;
            border-radius: 6px;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.1), 0 2px 8px rgba(0,0,0,0.3);
            pointer-events: none;
          }
          .hki-cover-content { height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; }
          .cover-controls-wrap { display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 14px; }
          .cover-slider-wrap { width: 160px; height: 360px; display: flex; flex-direction: column; align-items: center; gap: 12px; }
          .cover-value { font-size: 40px; font-weight: 300; }
          .cover-value span { font-size: 18px; opacity: 0.7; }
          .cover-track { width: 100%; flex: 1; background: rgba(255,255,255,0.10); border-radius: ${borderRadius}px; position: relative; overflow: hidden; cursor: pointer; }
          .cover-fill { position: absolute; left: 0; right: 0; bottom: 0; background: rgba(33,150,243,0.85); }
          .cover-thumb { position: absolute; left: 50%; transform: translateX(-50%); width: 110%; height: 6px; background: #fff; border-radius: 4px; box-shadow: 0 2px 6px rgba(0,0,0,0.30); pointer-events: none; }
          .cover-actions { display: flex; gap: 10px; width: 100%; justify-content: center; }
          .cover-chip { height: 38px; padding: 0 14px; border-radius: 999px; border: 1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.06); color: var(--primary-text-color); display:flex; align-items:center; gap:8px; cursor:pointer; }
          .cover-chip:hover { background: rgba(255,255,255,0.10); }

          .cover-members { width: 100%; flex: 1; overflow-y: auto; display: flex; flex-direction: column; }
          .cover-row { 
            display: flex; align-items: center; gap: 12px; padding: 12px 0; 
            border-bottom: 1px solid rgba(255,255,255,0.05);
          }
          .cover-row:last-child { border-bottom: none; }
          .cover-row-left { display:flex; align-items:center; gap:12px; min-width: 0; flex: 1; }
          .cover-row-name { font-weight: 500; font-size: 14px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .cover-row-state { font-size: 12px; opacity: 0.6; }
          .cover-row-slider { 
            flex: 2; height: 40px; border-radius: 999px; 
            background: var(--secondary-background-color, rgba(255,255,255,0.1)); 
            border: 2px solid var(--divider-color, rgba(255,255,255,0.1));
            position: relative; overflow: hidden; cursor: pointer; 
          }
          .cover-row-fill { 
            height: 100%; background: rgba(255,255,255,0.18);
            border-radius: 999px 0 0 999px;
            transition: width 0.2s ease; 
          }
          .cover-row-thumb { 
            position: absolute; top: 0; transform: translateX(-50%); 
            width: 12px; height: 100%; border-radius: 6px; background: #fff; 
            box-shadow: 0 2px 6px rgba(0,0,0,0.3); transition: left 0.2s ease; 
          }

          .hki-light-popup-container { border-radius: ${popupRadius}px; }
        </style>
        <div class="hki-light-popup-container">
          <div class="hki-light-popup-header">
            <div class="hki-light-popup-title">
              ${this._getPopupHeaderIconHtml(entity, controlsIcon, this._getPopupIconColor('rgba(33,150,243,0.95)'))}
              <div class="hki-light-popup-title-text">
                ${safeTitle(entityName)}
                <span class="hki-light-popup-state">${this._getPopupHeaderState(pos + '%')}${this._formatLastTriggered(entity) ? ` - ${this._formatLastTriggered(entity)}` : ''}</span>
              </div>
            </div>
            <div class="hki-light-popup-header-controls">
              ${groupBtn}
              <button class="header-btn" id="historyBtn" title="History"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>
              <button class="header-btn" id="closeBtn" title="Close"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>

          <div class="hki-light-popup-tabs">
            ${this._config.popup_show_favorites !== false ? `
              <button class="hki-light-popup-tab ${this._activeView === 'favorites' ? 'active' : ''}" id="coverTabFavorites" style="${this._activeView === 'favorites' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
                <ha-icon icon="mdi:star"></ha-icon> Favorites
              </button>
            ` : ''}
            <button class="hki-light-popup-tab ${this._activeView !== 'favorites' ? 'active' : ''}" id="coverTabControls" style="${this._activeView !== 'favorites' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
              <ha-icon icon="mdi:tune-vertical"></ha-icon> Controls
            </button>
          </div>

          <div class="hki-light-popup-content ${this._activeView === 'favorites' ? 'view-favorites' : ''}">
            <div class="hki-cover-content">
              ${this._renderCoverPopupContent(entity)}
            </div>
          </div>

          <div class="hki-light-popup-nav">
            <button class="nav-btn" id="coverOpen" style="${this._getPopupButtonStyle(false)}"><ha-icon icon="mdi:arrow-up"></ha-icon>${this._config.popup_hide_button_text ? '' : '<span class="nav-label">Open</span>'}</button>
            <button class="nav-btn" id="coverStop" style="${this._getPopupButtonStyle(false)}"><ha-icon icon="mdi:stop"></ha-icon>${this._config.popup_hide_button_text ? '' : '<span class="nav-label">Stop</span>'}</button>
            <button class="nav-btn" id="coverClose" style="${this._getPopupButtonStyle(false)}"><ha-icon icon="mdi:arrow-down"></ha-icon>${this._config.popup_hide_button_text ? '' : '<span class="nav-label">Close</span>'}</button>
          </div>
        </div>
      `;

      
      // Close cover popup when clicking on the backdrop (outside the popup container)
      const container = portal.querySelector('.hki-light-popup-container');
      if (container) container.addEventListener('click', (e) => e.stopPropagation());

      let isBackgroundClick = false;
      portal.addEventListener('mousedown', (e) => { isBackgroundClick = (e.target === portal); });
      portal.addEventListener('touchstart', (e) => { isBackgroundClick = (e.target === portal); }, { passive: true });
      portal.addEventListener('click', (e) => {
        if (isBackgroundClick && e.target === portal) this._closePopup();
        isBackgroundClick = false;
      });

      if (!this._popupPortal) {
        document.body.appendChild(portal);
        this._applyOpenAnimation(portal);
      }
      this._popupPortal = portal;
      this._setupCoverPopupHandlers(portal);

      // Bottom bar entity buttons
      if (this._config.popup_hide_bottom_bar !== true) {
        const _bbNav = portal.querySelector('.hki-popup-nav');
        if (_bbNav) this._renderBottomBarEntityButtons(_bbNav);
      }

      // If history is active (header button), load it
      if (this._coverHistoryOpen) {
        this._loadHistory();
      }
    }

    _renderCoverPopupContent(entity) {
      const borderRadius = this._config.popup_slider_radius ?? 12;
      const isGroup = Array.isArray(entity.attributes?.entity_id) && entity.attributes.entity_id.length > 1;
      if (this._coverHistoryOpen) {
        return `<div class="timeline-container" data-view-type="history" id="historyContainer"><div class="history-loading">Loading Timeline...</div></div>`;
      }

      if (this._activeView === 'favorites') {
        const favs = Array.isArray(this._coverFavorites) ? this._coverFavorites : [];
        if (favs.length === 0) {
          return `<div style="padding: 18px; text-align:center; opacity:0.6;">No favorites yet</div>`;
        }
        const tiles = favs.map((f, idx) => {
          const label = (f && f.name) ? f.name : `Preset ${idx + 1}`;
          const color = f.color || 'rgba(255,255,255,0.12)';
          const pic = f.image ? `<img class="preset-picture" src="${f.image}" alt="" />` : `<div class="preset-icon" style="width:32px;height:32px;border-radius:50%;background:${color};"></div>`;
          const del = (this._coverEditMode ? `<div class="fav-delete-badge" data-del="${idx}"><ha-icon icon="mdi:close"></ha-icon></div>` : '');
          return `
            <div class="preset-btn" data-idx="${idx}" style="position:relative;">
              ${del}
              ${pic}
              <div class="preset-name">${label}</div>
            </div>
          `;
        }).join('');

        return `
          <div class="favorites-view">
            <div class="favorites-sticky-header">
              <button class="favorites-edit-btn" id="coverFavEdit"><ha-icon icon="mdi:pencil"></ha-icon> Edit</button>
            </div>
            <div class="favorites-grid" style="display:grid;grid-template-columns:repeat(4,1fr);gap:12px;">
              ${tiles}
            </div>
          </div>
        `;
      }

      if (this._coverGroupMode && isGroup) {
        const rows = entity.attributes.entity_id.map((id) => {
          const st = this.hass.states[id];
          if (!st) return '';
          const p = this._getCoverPosition(st);
          const name = (st.attributes?.friendly_name) || id;
          return `
            <div class="cover-row" data-entity-id="${id}">
              <div class="cover-row-left">
                <div style="display:flex;flex-direction:column;min-width:0;flex:1;">
                  <div class="cover-row-name">${name}</div>
                  <div class="cover-row-state">${p}%</div>
                </div>
              </div>
              <div class="cover-row-slider" data-slider="pos">
                <div class="cover-row-fill" style="width:${p}%"></div>
                <div class="cover-row-thumb" style="left:${p}%"></div>
              </div>
            </div>
          `;
        }).join('');

        return `
          <div class="cover-members" data-view-type="cover-individual">
            ${rows}
          </div>
          ${this._config.popup_show_favorites !== false ? `<button class="save-favorite-fab" id="coverGroupSave" title="Save favorite"><ha-icon icon="mdi:star-plus"></ha-icon></button>` : ''}
        `;
      }

      // Controls view
      const pos = this._getCoverPosition(entity);
      // Clamp thumb so it is always visible (at 0% it would otherwise be rendered outside the track)
      const thumbBottom = (pos <= 0) ? '0px' : `calc(${pos}% - 6px)`;
      return `
        <div class="cover-controls-wrap">
          <div class="cover-slider-wrap">
            <div class="cover-value" id="coverPosDisp" style="font-size:${this._config.popup_value_font_size ?? 36}px; font-weight:${this._config.popup_value_font_weight ?? 300};">${pos}<span>%</span></div>
            <div class="vertical-slider-container">
              <div class="vertical-slider-track" id="coverPosTrack">
                <div class="vertical-slider-fill" style="height:${pos}%;"></div>
              <div class="vertical-slider-thumb" style="bottom:${thumbBottom}"></div>
              </div>
            </div>
            <div style="opacity:0.55; letter-spacing:0.08em; font-size:${this._config.popup_label_font_size ?? 16}px; font-weight:${this._config.popup_label_font_weight ?? 400};">POSITION</div>
          </div>
        </div>
        ${this._config.popup_show_favorites !== false ? `<button class="save-favorite-fab" id="coverSave" title="Save favorite"><ha-icon icon="mdi:star-plus"></ha-icon></button>` : ''}
      `;
    }

    _setupCoverPopupHandlers(portal) {
      const closeBtn = portal.querySelector('#closeBtn');
      if (closeBtn) closeBtn.addEventListener('click', () => this._closePopup());

      const historyBtn = portal.querySelector('#historyBtn');
      if (historyBtn) {
        historyBtn.addEventListener('click', () => {
          this._coverHistoryOpen = !this._coverHistoryOpen;
          this._renderCoverPopupPortal(this._getEntity());
        });
      }

      const groupBtn = portal.querySelector('#coverGroupBtn');
      if (groupBtn) {
        groupBtn.addEventListener('click', () => {
          this._coverGroupMode = !this._coverGroupMode;
          this._coverHistoryOpen = false;
          this._renderCoverPopupPortal(this._getEntity());
        });
      }

      const tabFav = portal.querySelector('#coverTabFavorites');
      if (tabFav) tabFav.addEventListener('click', () => { this._activeView = 'favorites'; this._coverHistoryOpen = false; this._renderCoverPopupPortal(this._getEntity()); });
      const tabCtl = portal.querySelector('#coverTabControls');
      if (tabCtl) tabCtl.addEventListener('click', () => { this._activeView = 'controls'; this._coverHistoryOpen = false; this._renderCoverPopupPortal(this._getEntity()); });

      const openBtn = portal.querySelector('#coverOpen');
      if (openBtn) openBtn.addEventListener('click', () => this.hass.callService('cover', 'open_cover', { entity_id: this._config.entity }));
      const stopBtn = portal.querySelector('#coverStop');
      if (stopBtn) stopBtn.addEventListener('click', () => this.hass.callService('cover', 'stop_cover', { entity_id: this._config.entity }));
      const closeBtn2 = portal.querySelector('#coverClose');
      if (closeBtn2) closeBtn2.addEventListener('click', () => this.hass.callService('cover', 'close_cover', { entity_id: this._config.entity }));

      const groupSave = portal.querySelector('#coverGroupSave');
      if (groupSave) {
        groupSave.addEventListener('click', async () => {
          const ent = this._getEntity();
          if (!ent) return;
          const members = (ent.attributes?.entity_id || []).map((id) => {
            const st = this.hass.states[id];
            return { entity_id: id, position: this._getCoverPosition(st) };
          });
          const meta = await this._promptCoverGroupFavoriteMeta(ent.attributes?.friendly_name || 'Group preset');
          if (!meta) return;
          const fav = { name: meta.name, members, color: meta.color, image: meta.image };
          this._coverFavorites = Array.isArray(this._coverFavorites) ? this._coverFavorites : [];
          this._coverFavorites.unshift(fav);
          this._persistCoverFavorites();
          this._activeView = 'favorites';
          this._coverGroupMode = false;
          this._renderCoverPopupPortal(this._getEntity());
        });
      }



      const coverSave = portal.querySelector('#coverSave');
      if (coverSave) {
        coverSave.addEventListener('click', async () => {
          const ent = this._getEntity();
          if (!ent) return;
          const position = this._getCoverPosition(ent);
          const meta = await this._promptCoverGroupFavoriteMeta(position + '%');
          if (!meta) return;
          const fav = { name: meta.name, position, color: meta.color, image: meta.image };
          this._coverFavorites = Array.isArray(this._coverFavorites) ? this._coverFavorites : [];
          this._coverFavorites.unshift(fav);
          this._persistCoverFavorites();
          this._activeView = 'favorites';
          this._coverGroupMode = false;
          this._renderCoverPopupPortal(this._getEntity());
        });
      }
      const editBtn = portal.querySelector('#coverFavEdit');
      if (editBtn) {
        editBtn.addEventListener('click', () => {
          this._coverEditMode = !this._coverEditMode;
          this._renderCoverPopupPortal(this._getEntity());
        });
      }

      // Favorites click / delete
      portal.querySelectorAll('.preset-btn').forEach((el) => {
        el.addEventListener('click', async (e) => {
          const del = e.target.closest('[data-del]');
          if (del) {
            const idx = parseInt(del.getAttribute('data-del'));
            if (!Number.isNaN(idx)) {
              this._coverFavorites.splice(idx, 1);
              this._persistCoverFavorites();
              this._renderCoverPopupPortal(this._getEntity());
            }
            e.stopPropagation();
            return;
          }
          const idx = parseInt(el.getAttribute('data-idx'));
          const fav = this._coverFavorites[idx];
          await this._applyCoverFavorite(fav);
        });
      });

      // Main position slider
      const track = portal.querySelector('#coverPosTrack');
      if (track) {
        const applyVisual = (val) => {
          const fill = track.querySelector('.vertical-slider-fill');
          const thumb = track.querySelector('.vertical-slider-thumb');
          const disp = portal.querySelector('#coverPosDisp');
          if (fill) fill.style.height = `${val}%`;
          if (thumb) thumb.style.bottom = (val <= 0) ? '0px' : `calc(${val}% - 6px)`;
          if (disp) disp.innerHTML = `${val}<span>%</span>`;
        };
        const calcVal = (clientY) => {
          const rect = track.getBoundingClientRect();
          const pct = 1 - ((clientY - rect.top) / rect.height);
          return Math.round(Math.max(0, Math.min(1, pct)) * 100);
        };
        let dragging = false;
        const onMove = (e) => {
          if (!dragging) return;
          const y = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
          applyVisual(calcVal(y));
        };
        const onUp = async (e) => {
          if (!dragging) return;
          dragging = false;
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);
          document.removeEventListener('touchmove', onMove);
          document.removeEventListener('touchend', onUp);
          const y = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientY : e.clientY;
          const v = calcVal(y);
          applyVisual(v);
          await this.hass.callService('cover', 'set_cover_position', { entity_id: this._config.entity, position: v });
        };
        const onDown = (e) => {
          dragging = true;
          const y = (e.touches && e.touches[0]) ? e.touches[0].clientY : e.clientY;
          applyVisual(calcVal(y));
          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp);
          document.addEventListener('touchmove', onMove, { passive: true });
          document.addEventListener('touchend', onUp);
        };
        track.addEventListener('mousedown', onDown);
        track.addEventListener('touchstart', onDown, { passive: true });
      }

      // Group row sliders
      portal.querySelectorAll('.cover-row').forEach((row) => {
        const entityId = row.getAttribute('data-entity-id');
        const slider = row.querySelector('.cover-row-slider');
        if (!entityId || !slider) return;
        const applyVisual = (pct) => {
          const fill = slider.querySelector('.cover-row-fill');
          const thumb = slider.querySelector('.cover-row-thumb');
          if (fill) fill.style.width = `${pct}%`;
          if (thumb) thumb.style.left = `${pct}%`;
          const st = row.querySelector('.cover-row-state');
          if (st) st.textContent = `${pct}%`;
        };
        const calcPct = (clientX) => {
          const rect = slider.getBoundingClientRect();
          const pct = ((clientX - rect.left) / rect.width) * 100;
          return Math.round(Math.max(0, Math.min(100, pct)));
        };
        let dragging = false;
        const onMove = (e) => {
          if (!dragging) return;
          const x = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
          applyVisual(calcPct(x));
        };
        const onUp = async (e) => {
          if (!dragging) return;
          dragging = false;
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);
          document.removeEventListener('touchmove', onMove);
          document.removeEventListener('touchend', onUp);
          const x = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX : e.clientX;
          const pct = calcPct(x);
          applyVisual(pct);
          await this.hass.callService('cover', 'set_cover_position', { entity_id: entityId, position: pct });
        };
        const onDown = (e) => {
          dragging = true;
          const x = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
          applyVisual(calcPct(x));
          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp);
          document.addEventListener('touchmove', onMove, { passive: true });
          document.addEventListener('touchend', onUp);
        };
        slider.addEventListener('mousedown', onDown);
        slider.addEventListener('touchstart', onDown, { passive: true });
      });

      // If history view, load content
      if (this._coverHistoryOpen) {
        this._loadHistory();
      }
    }


    /* ------------------------------------------------------------------
     * Alarm Control Panel Popup (Alarmo)
     * ------------------------------------------------------------------ */
    _renderAlarmPopupPortal(entity) {
      if (!entity) entity = this._getEntity();
      // Reuse existing portal to avoid flicker on hass updates.

      const entityName = this._getPopupName(entity);
      const state = entity.state || 'unknown';
      const popupRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();

      const icon = this._getResolvedIcon(entity, (state === 'disarmed') ? 'mdi:shield-check' : 'mdi:shield-lock');
      const iconColor = (state === 'disarmed') ? '#4CAF50' : '#F44336';

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-light-popup-portal';
      // Clear previous content when reusing.
      portal.innerHTML = '';

      const safeTitle = (t) => String(t || '').replace(/</g, '&lt;').replace(/>/g, '&gt;');

      portal.innerHTML = `
        <style>
          /* Reuse the same base popup styling as other HKI popups */
          .hki-light-popup-portal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            ${this._getPopupPortalStyle()}
            display: flex; align-items: center; justify-content: center; z-index: 9999;
          }
          .hki-light-popup-container {
            ${this._getPopupCardStyle()};
            border-radius: ${popupRadius}px;
            width: ${popupWidth}; height: ${popupHeight};
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex; flex-direction: column;
            overflow: hidden;
          }
          .hki-light-popup-header {
            display: flex; justify-content: space-between; align-items: center; padding: 16px 20px;
            background: rgba(255, 255, 255, 0.03); border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .hki-light-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-light-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-light-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; color: var(--primary-text-color); }
          .hki-light-popup-state { font-size: 12px; opacity: 0.6; text-transform: capitalize; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-light-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: var(--divider-color, rgba(255, 255, 255, 0.05)); border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
          }
          .header-btn:hover { background: rgba(255, 255, 255, 0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }

          .hki-light-popup-body { flex: 1; display:flex; align-items:center; justify-content:center; padding: 18px 20px; box-sizing: border-box; overflow: hidden; }
          .hki-alarm-content { width: 100%; height: 100%; display:flex; flex-direction:column; align-items:center; justify-content:center; }

          /* Code display */
          .alarm-code-wrapper { height: 40px; display:flex; align-items:center; justify-content:center; margin-bottom: 22px; width: 100%; }
          .alarm-code-placeholder { font-size: 13px; opacity: 0.3; letter-spacing: 1px; text-transform: uppercase; }
          .alarm-code-dots { display:flex; gap: 12px; height: 14px; align-items:center; }
          .alarm-code-dot { 
            width: 12px; height: 12px; border-radius: 50%; 
            background: var(--primary-text-color); 
            box-shadow: 0 0 10px var(--primary-color, rgba(255,255,255,0.3)); 
          }

          /* --- Code feedback (wrong/right) --- */
          .alarm-code-wrapper.is-error { animation: hkiShake 0.35s ease-in-out; }
          .alarm-code-wrapper.is-error .alarm-code-dot {
            background: #F44336;
            box-shadow: 0 0 12px rgba(244,67,54,0.55);
          }
          
          .alarm-code-wrapper.is-success .alarm-code-dot {
            background: #4CAF50;
            box-shadow: 0 0 12px rgba(76,175,80,0.55);
          }
          
          /* shake animation */
          @keyframes hkiShake {
            0% { transform: translateX(0); }
            15% { transform: translateX(-8px); }
            30% { transform: translateX(8px); }
            45% { transform: translateX(-6px); }
            60% { transform: translateX(6px); }
            75% { transform: translateX(-4px); }
            100% { transform: translateX(0); }
          }

          /* Keypad */
          .alarm-keypad { display:grid; grid-template-columns: repeat(3, 1fr); row-gap: 16px; column-gap: 24px; width: 100%; max-width: 280px; }
          .alarm-key {
            width: 72px; height: 72px; border-radius: 50%; border: none;
            background: var(--secondary-background-color, rgba(255,255,255,0.06));
            border: 2px solid var(--divider-color, rgba(255, 255, 255, 0.1));
            color: var(--primary-text-color); font-size: 26px; font-weight: 300;
            cursor: pointer; justify-self: center;
            display:flex; align-items:center; justify-content:center;
            transition: all 0.15s ease-out;
            user-select: none; -webkit-tap-highlight-color: transparent;
          }
          .alarm-key:active { background: rgba(255,255,255,0.2); transform: scale(0.95); }
          .alarm-key.action { background: transparent; font-size: 16px; font-weight: 600; color: var(--secondary-text-color, rgba(255,255,255,0.6)); }

          /* Bottom nav matches alarmo popup look */
          .hki-alarm-nav { display: flex; justify-content: space-evenly; padding: 12px; background: rgba(255, 255, 255, 0.03); border-top: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05)); gap: 8px; flex-shrink: 0; }
          .alarm-nav-btn {
            width: 60px; height: 50px; border-radius: 12px; border: none;
            background: transparent; color: var(--primary-text-color);
            opacity: 0.5; display:flex; flex-direction:column; align-items:center; justify-content:center;
            cursor:pointer; transition: all 0.3s;
          }
          .alarm-nav-btn:hover { opacity: 1; background: rgba(255,255,255,0.05); }
          .alarm-nav-btn ha-icon { --mdc-icon-size: 24px; margin-bottom: 2px; }
          .alarm-nav-btn span { font-size: 9px; font-weight: 600; text-transform: uppercase; }
          .alarm-nav-btn.active { 
            opacity: 1; 
            background: var(--primary-color, rgba(255,255,255,0.10));
            color: var(--text-primary-color, var(--primary-text-color));
          }
          .alarm-nav-btn.active.disarm { color: #4CAF50; }
          .alarm-nav-btn.active.home { color: #FF9800; }
          .alarm-nav-btn.active.away { color: #F44336; }
          .alarm-nav-btn.active.night { color: #FF9800; }

          /* Timeline styles (shared look with other popups) */
          .timeline-container { width: 100%; height: 100%; padding: 0 10px 10px 10px; box-sizing: border-box; overflow-y: auto; align-self: stretch; }
          .history-loading { padding: 40px 20px; text-align: center; opacity: 0.6; font-size: 14px; }
          .timeline-item { display: flex; gap: 16px; margin-bottom: 0; min-height: 40px; position: relative; }
          .timeline-visual { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
          .timeline-dot { width: 10px; height: 10px; border-radius: 50%; z-index: 2; border: 2px solid var(--card-background-color, #1c1c1c); margin-top: 3px; }
          .timeline-line { width: 2px; flex-grow: 1; background: var(--divider-color, rgba(255,255,255,0.12)); margin-top: -2px; margin-bottom: -4px; }
          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content { flex: 1; padding-bottom: 16px; font-size: 13px; color: var(--primary-text-color); }
          .timeline-detail { font-size: 11px; opacity: 0.6; display: block; margin-top: 4px; }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .timeline-trigger { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; font-style: italic; }

          /* History view container scrolling */
          .alarm-history-scroll { width:100%; height:100%; overflow:auto; padding: 6px 6px 0 6px; box-sizing: border-box; }
        </style>

        <div class="hki-light-popup-container">
          <div class="hki-light-popup-header">
            <div class="hki-light-popup-title">
              ${this._getPopupHeaderIconHtml(entity, icon, this._getPopupIconColor(iconColor))}
              <div class="hki-light-popup-title-text">
                ${safeTitle(entityName)}
                <span class="hki-light-popup-state">${this._getPopupHeaderState(String(state).replace(/_/g,' '))}${this._formatLastTriggered(entity) ? ` - ${this._formatLastTriggered(entity)}` : ''}</span>
              </div>
            </div>
            <div class="hki-light-popup-header-controls">
              <button class="header-btn" id="alarmHistoryBtn" title="History"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>
              <button class="header-btn" id="closeBtn" title="Close"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>

          <div class="hki-light-popup-body" id="alarmBody">
            ${this._renderAlarmPopupContent(entity)}
          </div>

          <div class="hki-alarm-nav" id="alarmBottomNav">
            <button class="alarm-nav-btn disarm ${state === 'disarmed' ? 'active' : ''}" id="btnDisarm" style="${state === 'disarmed' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
              <ha-icon icon="mdi:lock-open-variant"></ha-icon>${this._config.popup_hide_button_text ? '' : '<span>Disarm</span>'}
            </button>
            <button class="alarm-nav-btn home ${state === 'armed_home' ? 'active' : ''}" id="btnHome" style="${state === 'armed_home' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
              <ha-icon icon="mdi:home-lock"></ha-icon>${this._config.popup_hide_button_text ? '' : '<span>Home</span>'}
            </button>
            <button class="alarm-nav-btn away ${state === 'armed_away' ? 'active' : ''}" id="btnAway" style="${state === 'armed_away' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
              <ha-icon icon="mdi:lock"></ha-icon>${this._config.popup_hide_button_text ? '' : '<span>Away</span>'}
            </button>
            <button class="alarm-nav-btn night ${state === 'armed_night' ? 'active' : ''}" id="btnNight" style="${state === 'armed_night' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
              <ha-icon icon="mdi:weather-night"></ha-icon>${this._config.popup_hide_button_text ? '' : '<span>Night</span>'}
            </button>
          </div>
        </div>
      `;

      if (!this._popupPortal) {
        document.body.appendChild(portal);
        this._applyOpenAnimation(portal);
      }
      this._popupPortal = portal;
      this._setupAlarmPopupHandlers(portal);

      if (this._alarmHistoryOpen) this._loadHistory();
    }

    _renderAlarmPopupContent(entity) {
      if (this._alarmHistoryOpen) {
        return `
          <div class="alarm-history-scroll">
            <div class="timeline-container" data-view-type="history" id="historyContainer">
              <div class="history-loading">Loading Timeline...</div>
            </div>
          </div>
        `;
      }

      const code = String(this._alarmCodeInput || '');
      const dots = code.length > 0
        ? `<div class="alarm-code-dots">${Array.from({length: code.length}).map(()=>'<div class="alarm-code-dot"></div>').join('')}</div>`
        : `<span class="alarm-code-placeholder">Enter Code</span>`;

      return `
        <div class="hki-alarm-content" data-view-type="main">
          <div class="alarm-code-wrapper" id="alarmCodeWrapper">${dots}</div>
          <div class="alarm-keypad">
            ${[1,2,3,4,5,6,7,8,9].map(n => `<button class="alarm-key" data-key="${n}">${n}</button>`).join('')}
            <button class="alarm-key action" data-key="clear">CLR</button>
            <button class="alarm-key" data-key="0">0</button>
            <div style="width:72px;"></div>
          </div>
        </div>
      `;
    }

    _setupAlarmPopupHandlers(portal) {
      const closeBtn = portal.querySelector('#closeBtn');
      if (closeBtn) closeBtn.addEventListener('click', () => this._closePopup());

      // Bottom bar entity buttons
      if (this._config.popup_hide_bottom_bar !== true) {
        const _bbNav = portal.querySelector('.hki-popup-nav');
        if (_bbNav) this._renderBottomBarEntityButtons(_bbNav);
      }

      const historyBtn = portal.querySelector('#alarmHistoryBtn');
      if (historyBtn) {
        historyBtn.addEventListener('click', () => {
          this._alarmHistoryOpen = !this._alarmHistoryOpen;
          // When opening history, render and then load
          this._renderAlarmPopupPortal(this._getEntity());
          if (this._alarmHistoryOpen) setTimeout(() => this._loadHistory(), 50);
        });
      }

      // keypad (only in main view)
      portal.querySelectorAll('.alarm-key').forEach((b) => {
        b.addEventListener('click', (e) => {
          const k = e.currentTarget?.dataset?.key;
          if (!k) return;
          if (k === 'clear') this._alarmCodeInput = '';
          else this._alarmCodeInput = `${this._alarmCodeInput || ''}${k}`;
          // update just the code wrapper
          const w = portal.querySelector('#alarmCodeWrapper');
          if (w) {
            const code = String(this._alarmCodeInput || '');
            w.innerHTML = code.length > 0
              ? `<div class="alarm-code-dots">${Array.from({length: code.length}).map(()=>'<div class="alarm-code-dot"></div>').join('')}</div>`
              : `<span class="alarm-code-placeholder">Enter Code</span>`;
          }
        });
      });

      const doAction = async (service) => {
        const entityId = this._config.entity;
        if (!entityId) return;
      
        const data = { entity_id: entityId };
        const code = String(this._alarmCodeInput || '').trim();
        if (code) data.code = code;
      
        const wrapper = portal.querySelector('#alarmCodeWrapper');
      
        const flash = (cls) => {
          if (!wrapper) return;
          wrapper.classList.remove('is-error', 'is-success');
          // force reflow so the animation triggers every time
          void wrapper.offsetWidth;
          wrapper.classList.add(cls);
          setTimeout(() => wrapper.classList.remove(cls), 500);
        };
      
        try {
          await this.hass.callService('alarm_control_panel', service, data);
      
          // âœ… correct (or accepted) -> glow green then close popup
          flash('is-success');
          this._alarmCodeInput = '';
          setTimeout(() => this._closePopup(), 350);
      
        } catch (e) {
          // âŒ wrong code -> glow red + shake, then clear input
          console.warn('Alarm service call failed', e);
          flash('is-error');
      
          setTimeout(() => {
            this._alarmCodeInput = '';
            if (wrapper) {
              wrapper.innerHTML = `<span class="alarm-code-placeholder">Enter Code</span>`;
            }
          }, 350);
      
          // keep popup open; optionally re-render after a short delay if you want state refresh
          // setTimeout(() => this._renderAlarmPopupPortal(this._getEntity()), 250);
        }
      };

      const btnDisarm = portal.querySelector('#btnDisarm');
      if (btnDisarm) btnDisarm.addEventListener('click', () => doAction('alarm_disarm'));
      const btnHome = portal.querySelector('#btnHome');
      if (btnHome) btnHome.addEventListener('click', () => doAction('alarm_arm_home'));
      const btnAway = portal.querySelector('#btnAway');
      if (btnAway) btnAway.addEventListener('click', () => doAction('alarm_arm_away'));
      const btnNight = portal.querySelector('#btnNight');
      if (btnNight) btnNight.addEventListener('click', () => doAction('alarm_arm_night'));
    }



    /**
     * Humidifier Popup
     */
    /**
     * Humidifier Popup
     */
    _renderHumidifierPopupPortal(entity) {
      // Reuse existing portal to avoid flicker on hass updates.

      const name = this._getPopupName(entity);
      const attrs = entity.attributes || {};
      const state = entity.state;
      const isOn = state === 'on';
      const currentHumidity = attrs.current_humidity ?? 0;
      const targetHumidity = this._optimisticHumidity ?? attrs.humidity ?? 50;
      const minHumidity = attrs.min_humidity ?? 0;
      const maxHumidity = attrs.max_humidity ?? 100;
      const modes = attrs.available_modes || [];
      const currentMode = attrs.mode || 'normal';
      
      // Fan speed entity (configured separately)
      const fanEntityId = this._config.humidifier_fan_entity || '';
      const fanEntity = fanEntityId ? this.hass?.states?.[fanEntityId] : null;
      const fanModes = fanEntity?.attributes?.options || fanEntity?.attributes?.fan_modes || [];
      const currentFanMode = fanEntity?.state || '';
      const hasFan = !!(fanEntityId && fanEntity && fanModes.length);

      const color = isOn ? 'var(--primary-color, #03a9f4)' : 'var(--disabled-text-color, #6f6f6f)';
      const icon = this._getResolvedIcon(entity, isOn ? 'mdi:air-humidifier' : 'mdi:air-humidifier-off');
      const borderRadius = this._config.popup_slider_radius ?? 12;
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();
      const valueSize = this._config.popup_value_font_size || 36;
      const valueWeight = this._config.popup_value_font_weight || 300;
      const useCircular = this._config.humidifier_use_circular_slider === true;

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-popup-portal';
      portal.innerHTML = '';

      portal.innerHTML = `
        <style>
          .hki-popup-portal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            ${this._getPopupPortalStyle()}
            display: flex; align-items: center; justify-content: center; z-index: 9999;
          }
          .hki-popup-container {
            ${this._getPopupCardStyle()};
            border-radius: ${popupBorderRadius}px;
            width: ${popupWidth}; height: ${popupHeight};
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex; flex-direction: column; overflow: hidden; user-select: none; -webkit-user-select: none;
          }
          .hki-popup-header {
            display: flex; justify-content: space-between; align-items: center; padding: 16px 20px;
            background: rgba(255, 255, 255, 0.03); border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .hki-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-popup-title img { width:28px;height:28px;border-radius:50%;object-fit:cover;flex-shrink:0; }
          .hki-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; }
          .hki-popup-state { font-size: 12px; opacity: 0.6; text-transform: capitalize; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: var(--divider-color, rgba(255, 255, 255, 0.05)); border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center; transition: all 0.2s;
          }
          .header-btn:hover { background: rgba(255, 255, 255, 0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }
          .hki-tabs {
            display: flex; gap: 8px; padding: 8px 20px;
            background: rgba(255, 255, 255, 0.02);
            border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .tab-btn {
            flex: 1; height: 40px; border-radius: 8px;
            background: transparent; border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center; gap: 8px;
            transition: all 0.2s; font-size: 14px; font-weight: 500;
          }
          .tab-btn:hover { background: var(--secondary-background-color, rgba(255,255,255,0.08)); }
          .tab-btn.active { background: var(--primary-color, rgba(255,255,255,0.12)); color: var(--text-primary-color, var(--primary-text-color)); }
          .hki-popup-content { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 0; }
          /* Vertical slider */
          .slider-with-buttons { display: block; position: relative; width: 100%; }
          .slider-center { width: fit-content; margin: 0 auto; }
          .humidifier-current-display { display: flex; flex-direction: column; align-items: center; gap: 6px; position: absolute; left: 24px; top: 50%; transform: translateY(-50%); pointer-events: none; }
          .humidifier-current-label { font-size: 11px; opacity: 0.5; text-transform: uppercase; letter-spacing: 1px; }
          .humidifier-current-value { font-size: 28px; font-weight: 300; }
          .humidifier-slider-group { display: flex; flex-direction: column; align-items: center; gap: 12px; height: 320px; width: 80px; }
          .sliders-wrapper { display: flex; gap: 24px; justify-content: center; width: 100%; align-items: center; }
          .value-display { font-size: ${valueSize}px; font-weight: ${valueWeight}; text-align: center; }
          .value-display span { font-size: ${Math.max(14, Math.round(valueSize/2))}px; opacity: 0.7; }
          .slider-label { font-size: 12px; opacity: 0.5; text-transform: uppercase; letter-spacing: 1px; }
          .vertical-slider-track {
            width: 100%; flex: 1; background: var(--secondary-background-color, rgba(255,255,255,0.1));
            border: 2px solid var(--divider-color, rgba(255,255,255,0.1));
            border-radius: ${borderRadius}px; position: relative; overflow: hidden; cursor: pointer;
          }
          .vertical-slider-fill { position: absolute; bottom: 0; left: 0; right: 0; transition: background 0.3s; border-radius: 0 0 ${borderRadius}px ${borderRadius}px; }
          .vertical-slider-thumb { position: absolute; left: 50%; transform: translateX(-50%); width: 90px; height: 6px; background: white; border-radius: 4px; box-shadow: 0 2px 6px rgba(0,0,0,0.3); pointer-events: none; }
          /* +/- buttons */
          .vertical-temp-buttons { display: flex; flex-direction: column; gap: 12px; position: absolute; right: 0px; top: 50%; transform: translateY(-50%); }
          .vertical-temp-btn { width: 48px; height: 48px; border-radius: 50%; border: none; background: var(--secondary-background-color,rgba(255,255,255,0.1)); color: var(--primary-text-color); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
          .vertical-temp-btn:hover { background: var(--primary-color,rgba(255,255,255,0.2)); transform: scale(1.1); }
          .vertical-temp-btn:active { transform: scale(0.95); }
          .vertical-temp-btn ha-icon { --mdc-icon-size: 24px; }
          /* Circular slider */
          .circular-slider-wrapper { display: flex; align-items: center; justify-content: center; gap: 24px; width: 100%; position: relative; }
          .circular-slider-container { position: relative; width: 280px; height: 280px; display: flex; align-items: center; justify-content: center; cursor: pointer; user-select: none; flex-shrink: 0; }
          .circular-slider-svg { position: absolute; top: 0; left: 0; filter: drop-shadow(0 4px 12px rgba(0,0,0,0.3)); }
          .circular-value-display { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); text-align: center; pointer-events: none; }
          .circular-temp-label-top { opacity: 0.6; text-transform: uppercase; letter-spacing: 1.5px; margin-bottom: 12px; }
          .circular-temp-value { color: var(--primary-text-color); line-height: 1; }
          .circular-temp-value span { opacity: 0.7; }
          .circular-temp-buttons { display: flex; flex-direction: column; gap: 12px; position: absolute; right: 0px; }
          .circular-temp-btn { width: 48px; height: 48px; border-radius: 50%; border: none; background: var(--secondary-background-color,rgba(255,255,255,0.1)); color: var(--primary-text-color); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
          .circular-temp-btn:hover { background: var(--primary-color,rgba(255,255,255,0.2)); transform: scale(1.1); }
          .circular-temp-btn:active { transform: scale(0.95); }
          .circular-temp-btn ha-icon { --mdc-icon-size: 24px; }
          /* Nav */
          .hki-popup-nav { display: flex; justify-content: space-evenly; padding: 12px; background: rgba(255,255,255,0.03); border-top: 1px solid var(--divider-color,rgba(255,255,255,0.05)); gap: 8px; flex-shrink: 0; min-height: 74px; box-sizing: border-box; }
          .nav-btn { flex: 1; height: 50px; border-radius: 12px; border: none; background: transparent; color: var(--primary-text-color); opacity: 0.5; cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px; transition: all 0.2s; font-size: 11px; }
          .nav-btn:hover { opacity: 0.8; background: rgba(255,255,255,0.05); }
          .nav-btn.active { opacity: 1; background: var(--primary-color,rgba(255,255,255,0.1)); color: var(--text-primary-color,var(--primary-text-color)); }
          .nav-btn ha-icon { --mdc-icon-size: 24px; }
          /* Mode / fan list */
          .mode-list { width: 100%; display: flex; flex-direction: column; gap: 8px; }
          .mode-item { padding: 14px; background: rgba(255,255,255,0.05); border-radius: 8px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: all 0.2s; }
          .mode-item:hover { background: rgba(255,255,255,0.08); }
          .mode-item.active { background: ${color}; color: white; }
          /* Timeline / history */
          .timeline-container { width: 100%; height: 100%; padding: 0 10px 10px 10px; box-sizing: border-box; overflow-y: auto; align-self: stretch; }
          .timeline-item { display: flex; gap: 16px; margin-bottom: 0; min-height: 40px; position: relative; }
          .timeline-visual { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
          .timeline-dot { width: 10px; height: 10px; border-radius: 50%; background: var(--primary-color,#FFD700); z-index: 2; border: 2px solid var(--card-background-color,#1c1c1c); margin-top: 3px; }
          .timeline-line { width: 2px; flex-grow: 1; background: var(--divider-color,rgba(255,255,255,0.12)); margin-top: -2px; margin-bottom: -4px; }
          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content { flex: 1; padding-bottom: 16px; font-size: 13px; color: var(--primary-text-color); }
          .timeline-detail { font-size: 11px; opacity: 0.6; display: block; margin-top: 4px; }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .timeline-trigger { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; font-style: italic; }
          .history-loading { width: 100%; text-align: center; padding: 20px; opacity: 0.6; }
        </style>

        <div class="hki-popup-container">
          <div class="hki-popup-header">
            <div class="hki-popup-title">
              ${this._getPopupHeaderIconHtml(entity, icon, this._getPopupIconColor(color))}
              <div class="hki-popup-title-text">
                ${name}
                <span class="hki-popup-state">${this._getPopupHeaderState(isOn ? 'On' : 'Off')}${this._formatLastTriggered(entity) ? ` - ${this._formatLastTriggered(entity)}` : ''}</span>
              </div>
            </div>
            <div class="hki-popup-header-controls">
              <button class="header-btn" id="humidifierHistoryBtn"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>
              <button class="header-btn" id="closeBtn"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>

          <div class="hki-tabs">
            <button class="tab-btn ${this._activeView === 'main' ? 'active' : ''}" id="tabMain" style="${this._activeView === 'main' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}"><ha-icon icon="mdi:water-percent"></ha-icon>${this._config.popup_hide_button_text ? '' : '<span>Humidity</span>'}</button>
            ${modes.length > 0 ? `<button class="tab-btn ${this._activeView === 'modes' ? 'active' : ''}" id="tabModes" style="${this._activeView === 'modes' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}"><ha-icon icon="mdi:tune"></ha-icon>${this._config.popup_hide_button_text ? '' : '<span>Mode</span>'}</button>` : ''}
            ${hasFan ? `<button class="tab-btn ${this._activeView === 'fan' ? 'active' : ''}" id="tabFan" style="${this._activeView === 'fan' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}"><ha-icon icon="mdi:fan"></ha-icon>${this._config.popup_hide_button_text ? '' : '<span>Fan</span>'}</button>` : ''}
          </div>

          <div class="hki-popup-content" id="humidifierContent">
            ${this._renderHumidifierPopupContent(entity, color, minHumidity, maxHumidity, targetHumidity, currentHumidity, valueSize, valueWeight, borderRadius, hasFan, fanModes, currentFanMode)}
          </div>

          <div class="hki-popup-nav">
            <button class="nav-btn ${isOn ? 'active' : ''}" id="humidifierToggle" style="${isOn ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
              <ha-icon icon="${isOn ? 'mdi:power' : 'mdi:power-off'}"></ha-icon>
              <span>${isOn ? 'On' : 'Off'}</span>
            </button>
          </div>
        </div>
      `;

      const container = portal.querySelector('.hki-popup-container');
      if (container) container.addEventListener('click', (e) => e.stopPropagation());

      let isBackgroundClick = false;
      portal.addEventListener('mousedown', (e) => { isBackgroundClick = (e.target === portal); });
      portal.addEventListener('touchstart', (e) => { isBackgroundClick = (e.target === portal); }, { passive: true });
      portal.addEventListener('click', (e) => { if (isBackgroundClick && e.target === portal) this._closePopup(); isBackgroundClick = false; });

      if (!this._popupPortal) {
        document.body.appendChild(portal);
        this._applyOpenAnimation(portal);
      }
      this._popupPortal = portal;

      const closeBtn = portal.querySelector('#closeBtn');
      if (closeBtn) closeBtn.addEventListener('click', () => this._closePopup());

      // Bottom bar entity buttons
      if (this._config.popup_hide_bottom_bar !== true) {
        const _bbNav = portal.querySelector('.hki-popup-nav');
        if (_bbNav) this._renderBottomBarEntityButtons(_bbNav);
      }

      const historyBtn = portal.querySelector('#humidifierHistoryBtn');
      if (historyBtn) {
        historyBtn.addEventListener('click', () => {
          this._activeView = this._activeView === 'history' ? 'main' : 'history';
          const content = portal.querySelector('#humidifierContent');
          if (content) {
            content.innerHTML = this._renderHumidifierPopupContent(entity, color, minHumidity, maxHumidity, targetHumidity, currentHumidity, valueSize, valueWeight, borderRadius, hasFan, fanModes, currentFanMode);
            if (this._activeView === 'history') {
              setTimeout(() => this._loadHistory(), 100);
            } else {
              this._setupHumidifierContentHandlers(portal, entity, minHumidity, maxHumidity, fanEntity, fanEntityId);
            }
          }
        });
      }

      const toggleBtn = portal.querySelector('#humidifierToggle');
      if (toggleBtn) {
        toggleBtn.addEventListener('click', () => {
          this.hass.callService('humidifier', isOn ? 'turn_off' : 'turn_on', { entity_id: this._config.entity });
        });
      }

      const switchTab = (view) => {
        this._activeView = view;
        portal.querySelectorAll('.tab-btn').forEach(b => { b.classList.remove('active'); b.style = this._getPopupButtonStyle(false); });
        const id = 'tab' + view.charAt(0).toUpperCase() + view.slice(1);
        const activeTab = portal.querySelector('#' + id);
        if (activeTab) { activeTab.classList.add('active'); activeTab.style = this._getPopupButtonStyle(true); }
        const content = portal.querySelector('#humidifierContent');
        if (content) {
          content.innerHTML = this._renderHumidifierPopupContent(entity, color, minHumidity, maxHumidity, targetHumidity, currentHumidity, valueSize, valueWeight, borderRadius, hasFan, fanModes, currentFanMode);
          this._setupHumidifierContentHandlers(portal, entity, minHumidity, maxHumidity, fanEntity, fanEntityId);
        }
      };

      const tabMain = portal.querySelector('#tabMain');
      if (tabMain) tabMain.addEventListener('click', () => { if (this._activeView !== 'main') switchTab('main'); });
      const tabModes = portal.querySelector('#tabModes');
      if (tabModes) tabModes.addEventListener('click', () => { if (this._activeView !== 'modes') switchTab('modes'); });
      const tabFan = portal.querySelector('#tabFan');
      if (tabFan) tabFan.addEventListener('click', () => { if (this._activeView !== 'fan') switchTab('fan'); });

      this._setupHumidifierContentHandlers(portal, entity, minHumidity, maxHumidity, fanEntity, fanEntityId);
    }

    _renderHumidifierPopupContent(entity, color, minHumidity, maxHumidity, targetHumidity, currentHumidity, valueSize, valueWeight, borderRadius, hasFan, fanModes, currentFanMode) {
      if (this._activeView === 'history') {
        return `<div class="timeline-container" data-view-type="history" id="historyContainer"><div class="history-loading">Loading Timeline...</div></div>`;
      }
      if (this._activeView === 'modes') {
        const modes = entity.attributes.available_modes || [];
        const currentMode = entity.attributes.mode || 'normal';
        return this._renderHumidifierModesList(modes, currentMode, color);
      }
      if (this._activeView === 'fan') {
        const liveFanEntityId = this._config.humidifier_fan_entity || '';
        const liveFanEntity = liveFanEntityId ? this.hass?.states?.[liveFanEntityId] : null;
        const liveFanModes = liveFanEntity?.attributes?.options || liveFanEntity?.attributes?.fan_modes || fanModes || [];
        const liveFanMode = liveFanEntity?.state || currentFanMode || '';
        return this._renderHumidifierFanList(liveFanModes, liveFanMode, color);
      }
      if (entity.state === 'off') {
        return `<div style="display:flex;align-items:center;justify-content:center;width:100%;height:100%;"><div style="opacity:0.5;font-size:18px;font-weight:500;">Humidifier is Off</div></div>`;
      }

      const attrs = entity.attributes || {};
      const useCircular = this._config.humidifier_use_circular_slider === true;
      const showButtons = this._config.humidifier_show_plus_minus === true;
      const labelSize = this._config.popup_label_font_size || 11;
      const labelWeight = this._config.popup_label_font_weight || 500;
      const vSize = this._config.popup_value_font_size || 64;
      const vWeight = this._config.popup_value_font_weight || 200;
      const range = maxHumidity - minHumidity;

      // Range (min/max target) support
      const humLow = this._optimisticHumidityLow ?? attrs.target_humidity_low ?? null;
      const humHigh = this._optimisticHumidityHigh ?? attrs.target_humidity_high ?? null;
      const isRange = humLow !== null && humHigh !== null && this._config.humidifier_show_target_range !== false;

      if (useCircular) {
        if (isRange) {
          return this._buildHumidifierDualCircle(humLow, humHigh, minHumidity, maxHumidity, color, labelSize, labelWeight, vSize, vWeight, showButtons);
        }
        return this._buildHumidifierSingleCircle(targetHumidity, currentHumidity, minHumidity, maxHumidity, color, labelSize, labelWeight, vSize, vWeight, showButtons);
      }

      // â”€â”€ Vertical slider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      const humBlue = '#03a9f4';
      const useGradientV = this._config.humidifier_show_gradient !== false;
      const humVerticalGradient = 'linear-gradient(to top, #8BC34A 0%, #29B6F6 50%, #0277BD 100%)';
      const sliderBg = useGradientV ? humVerticalGradient : humBlue;
      const renderSlider = (id, value, label) => {
        const v = value ?? '--';
        const pct = value == null ? 0 : ((value - minHumidity) / range) * 100;
        const thumbPos = pct <= 0 ? '0px' : pct >= 100 ? 'calc(100% - 6px)' : `calc(${pct}% - 6px)`;
        return `
          <div class="humidifier-slider-group">
            <div class="value-display" id="display-${id}">${v}<span>%</span></div>
            <div class="vertical-slider-track" id="slider-${id}" data-type="${id}">
              <div class="vertical-slider-fill" style="height:${pct}%;background:${sliderBg};"></div>
              <div class="vertical-slider-thumb" style="bottom:${thumbPos}"></div>
            </div>
            <div class="slider-label">${label}</div>
          </div>
        `;
      };

      if (isRange) {
        const slidersHtml = `
          <div class="sliders-wrapper">
            ${renderSlider('humidity_low', humLow, 'Low')}
            ${renderSlider('humidity_high', humHigh, 'High')}
          </div>
        `;
        if (showButtons) {
          return `
            <div class="slider-with-buttons">
              <div class="slider-center">${slidersHtml}</div>
              <div class="vertical-temp-buttons">
                <button class="vertical-temp-btn plus" data-hum-action="plus-high"><ha-icon icon="mdi:plus"></ha-icon></button>
                <button class="vertical-temp-btn minus" data-hum-action="minus-high"><ha-icon icon="mdi:minus"></ha-icon></button>
              </div>
            </div>
          `;
        }
        return `<div class="slider-with-buttons"><div class="slider-center">${slidersHtml}</div></div>`;
      }

      const sliderHtml = `<div class="sliders-wrapper">${renderSlider('humidity', targetHumidity, 'Target')}</div>`;

      return `
        <div class="slider-with-buttons">
          <div class="humidifier-current-display">
            <div class="humidifier-current-label">Current</div>
            <div class="humidifier-current-value">${currentHumidity}<span style="font-size:18px;opacity:0.7;">%</span></div>
          </div>
          <div class="slider-center">${sliderHtml}</div>
          ${showButtons ? `
            <div class="vertical-temp-buttons">
              <button class="vertical-temp-btn plus" data-hum-action="plus"><ha-icon icon="mdi:plus"></ha-icon></button>
              <button class="vertical-temp-btn minus" data-hum-action="minus"><ha-icon icon="mdi:minus"></ha-icon></button>
            </div>
          ` : ''}
        </div>
      `;
    }

    _buildHumidifierSingleCircle(targetHumidity, currentHumidity, minHumidity, maxHumidity, color, labelSize, labelWeight, vSize, vWeight, showButtons) {
      const range = maxHumidity - minHumidity;
      const pct = Math.max(0, Math.min(100, ((targetHumidity - minHumidity) / range) * 100));
      const maxArcLen = 628.32 * 0.75;
      const arcLen = (pct / 100) * maxArcLen;
      const sa = 135 * (Math.PI / 180);
      const aa = (pct / 100) * 270 * (Math.PI / 180);
      const tx = 140 + 100 * Math.cos(sa + aa);
      const ty = 140 + 100 * Math.sin(sa + aa);
      const useGradient = this._config.humidifier_show_gradient !== false;
      const stroke = useGradient ? 'url(#humGradient)' : color;
      const gradDefs = useGradient ? '<defs><linearGradient id="humGradient" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" style="stop-color:#0277BD;stop-opacity:1"/><stop offset="60%" style="stop-color:#29B6F6;stop-opacity:1"/><stop offset="100%" style="stop-color:#8BC34A;stop-opacity:1"/></linearGradient></defs>' : '';
      return `
        <div class="circular-slider-wrapper">
          <div class="circular-slider-container" id="circularSliderHum">
            <svg class="circular-slider-svg" viewBox="0 0 280 280" width="280" height="280">
              ${gradDefs}
              <circle cx="140" cy="140" r="100" fill="none" stroke="var(--divider-color,rgba(255,255,255,0.05))" stroke-width="20" stroke-dasharray="${maxArcLen} 628.32" transform="rotate(135 140 140)"/>
              <circle cx="140" cy="140" r="100" fill="none" stroke="${stroke}" stroke-width="20" stroke-linecap="round" stroke-dasharray="${arcLen} 628.32" transform="rotate(135 140 140)" id="humCircularProgress"/>
              <circle cx="${tx}" cy="${ty}" r="12" fill="white" stroke="var(--card-background-color,#1c1c1c)" stroke-width="3" id="humCircularThumb" style="filter:drop-shadow(0 2px 4px rgba(0,0,0,0.3));"/>
            </svg>
            <div class="circular-value-display">
              <div class="circular-temp-label-top" style="font-size:${labelSize}px;font-weight:${labelWeight};">TARGET</div>
              <div class="circular-temp-value" id="humCircularValue" style="font-size:${vSize}px;font-weight:${vWeight};">${targetHumidity}<span style="font-size:${vSize/2}px;">%</span></div>
              <div style="font-size:13px;opacity:0.5;margin-top:8px;">Now: ${currentHumidity}%</div>
            </div>
          </div>
          ${showButtons ? `
            <div class="circular-temp-buttons">
              <button class="circular-temp-btn plus" data-hum-action="plus"><ha-icon icon="mdi:plus"></ha-icon></button>
              <button class="circular-temp-btn minus" data-hum-action="minus"><ha-icon icon="mdi:minus"></ha-icon></button>
            </div>
          ` : ''}
        </div>
      `;
    }

    _buildHumidifierDualCircle(humLow, humHigh, minHumidity, maxHumidity, color, labelSize, labelWeight, vSize, vWeight, showButtons) {
      const range = maxHumidity - minHumidity;
      const sz = Math.round(vSize * 0.75);
      const buildArc = (val, idSuffix, gradId, col1, col2) => {
        const pct = Math.max(0, Math.min(100, ((val - minHumidity) / range) * 100));
        const maxArcLen = 628.32 * 0.75;
        const arcLen = (pct / 100) * maxArcLen;
        const sa = 135 * (Math.PI / 180);
        const aa = (pct / 100) * 270 * (Math.PI / 180);
        const tx = 140 + 100 * Math.cos(sa + aa);
        const ty = 140 + 100 * Math.sin(sa + aa);
        const useGradient = this._config.humidifier_show_gradient !== false;
        const stroke = useGradient ? ('url(#' + gradId + ')') : color;
        const gradDefs = useGradient ? ('<defs><linearGradient id="' + gradId + '" x1="0%" y1="0%" x2="100%" y2="0%"><stop offset="0%" style="stop-color:' + col1 + ';stop-opacity:1"/><stop offset="100%" style="stop-color:' + col2 + ';stop-opacity:1"/></linearGradient></defs>') : '';
        return `
          <div style="display:flex;flex-direction:column;align-items:center;gap:8px;">
            <div style="font-size:${labelSize}px;font-weight:${labelWeight};opacity:0.6;text-transform:uppercase;letter-spacing:1.5px;">${idSuffix}</div>
            <div class="circular-slider-container" id="circularSliderHum${idSuffix}" style="width:200px;height:200px;">
              <svg class="circular-slider-svg" viewBox="0 0 280 280" width="200" height="200">
                ${gradDefs}
                <circle cx="140" cy="140" r="100" fill="none" stroke="var(--divider-color,rgba(255,255,255,0.05))" stroke-width="15" stroke-dasharray="${maxArcLen} 628.32" transform="rotate(135 140 140)"/>
                <circle cx="140" cy="140" r="100" fill="none" stroke="${stroke}" stroke-width="15" stroke-linecap="round" stroke-dasharray="${arcLen} 628.32" transform="rotate(135 140 140)" id="humCircularProgress${idSuffix}"/>
                <circle cx="${tx}" cy="${ty}" r="12" fill="white" stroke="var(--card-background-color,#1c1c1c)" stroke-width="3" id="humCircularThumb${idSuffix}" style="filter:drop-shadow(0 2px 4px rgba(0,0,0,0.3));"/>
              </svg>
              <div class="circular-value-display">
                <div class="circular-temp-label-top" style="font-size:${labelSize}px;font-weight:${labelWeight};">TARGET</div>
                <div class="circular-temp-value" id="humCircularValue${idSuffix}" style="font-size:${sz}px;font-weight:${vWeight};">${val}<span style="font-size:${sz/2}px;">%</span></div>
              </div>
            </div>
          </div>
        `;
      };
      return `
        <div class="circular-slider-wrapper">
          ${buildArc(humLow, 'Low', 'humGradLow', '#29B6F6', '#8BC34A')}
          ${buildArc(humHigh, 'High', 'humGradHigh', '#0277BD', '#29B6F6')}
          ${showButtons ? `
            <div class="circular-temp-buttons">
              <button class="circular-temp-btn plus" data-hum-action="plus-high"><ha-icon icon="mdi:plus"></ha-icon></button>
              <button class="circular-temp-btn minus" data-hum-action="minus-high"><ha-icon icon="mdi:minus"></ha-icon></button>
            </div>
          ` : ''}
        </div>
      `;
    }
    _renderHumidifierModesList(modes, currentMode, color) {
      return `
        <div class="mode-list">
          ${modes.map(mode => `
            <div class="mode-item ${mode === currentMode ? 'active' : ''}" data-mode="${mode}">
              <span style="text-transform:capitalize;">${mode.replace(/_/g, ' ')}</span>
              ${mode === currentMode ? '<ha-icon icon="mdi:check"></ha-icon>' : ''}
            </div>
          `).join('')}
        </div>
      `;
    }

    _renderHumidifierFanList(fanModes, currentFanMode, color) {
      if (!fanModes || !fanModes.length) return `<div style="opacity:0.6;padding:20px;">No fan modes available</div>`;
      return `
        <div class="mode-list">
          ${fanModes.map(mode => `
            <div class="mode-item ${mode === currentFanMode ? 'active' : ''}" data-fan-mode="${mode}">
              <span style="text-transform:capitalize;">${mode.replace(/_/g, ' ')}</span>
              ${mode === currentFanMode ? '<ha-icon icon="mdi:check"></ha-icon>' : ''}
            </div>
          `).join('')}
        </div>
      `;
    }

    _setupHumidifierContentHandlers(portal, entity, minHumidity, maxHumidity, fanEntity, fanEntityId) {
      if (this._activeView === 'history') return;

      if (this._activeView === 'modes') {
        portal.querySelectorAll('.mode-item').forEach(item => {
          item.addEventListener('click', () => {
            this.hass.callService('humidifier', 'set_mode', { entity_id: this._config.entity, mode: item.getAttribute('data-mode') });
          });
        });
        return;
      }

      if (this._activeView === 'fan') {
        // Refresh live state from hass at call time (not stale closure)
        const liveFanEntity = fanEntityId ? this.hass?.states?.[fanEntityId] : null;
        portal.querySelectorAll('[data-fan-mode]').forEach(item => {
          item.addEventListener('click', () => {
            if (!fanEntityId) return;
            const mode = item.getAttribute('data-fan-mode');
            // Optimistic UI: mark clicked item active immediately
            portal.querySelectorAll('[data-fan-mode]').forEach(el => {
              el.classList.remove('active');
              el.querySelector('ha-icon[icon="mdi:check"]')?.remove();
            });
            item.classList.add('active');
            item.insertAdjacentHTML('beforeend', '<ha-icon icon="mdi:check"></ha-icon>');
            // Call service
            const domainGuess = fanEntityId.split('.')[0];
            if (domainGuess === 'select') {
              this.hass.callService('select', 'select_option', { entity_id: fanEntityId, option: mode });
            } else if (domainGuess === 'input_select') {
              this.hass.callService('input_select', 'select_option', { entity_id: fanEntityId, option: mode });
            } else if (domainGuess === 'fan') {
              this.hass.callService('fan', 'set_preset_mode', { entity_id: fanEntityId, preset_mode: mode });
            } else {
              // Fallback: try select first
              this.hass.callService('select', 'select_option', { entity_id: fanEntityId, option: mode });
            }
          });
        });
        return;
      }

      const attrs = entity.attributes || {};
      const useCircular = this._config.humidifier_use_circular_slider === true;
      const step = this._config.humidifier_humidity_step ? parseFloat(this._config.humidifier_humidity_step) : 1;
      const range = maxHumidity - minHumidity;
      const humLowAttr = attrs.target_humidity_low ?? null;
      const humHighAttr = attrs.target_humidity_high ?? null;
      const isRange = humLowAttr !== null && humHighAttr !== null && this._config.humidifier_show_target_range !== false;

      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, Math.round(v / step) * step));
      const commitRange = (low, high) => {
        // Route range to climate.set_temperature directly (target_temp_low / target_temp_high)
        // because HA humidifier domain doesn't have a native range service.
        // Our custom component also handles this via climate entity id stored in hass state attributes.
        const climateEntityId = entity.attributes?.source_climate_entity;
        if (climateEntityId) {
          this.hass.callService('climate', 'set_temperature', {
            entity_id: climateEntityId,
            target_temp_low: low,
            target_temp_high: high,
          });
        } else {
          // Fallback: call humidifier set_humidity with range params (custom component handles it)
          this.hass.callService('humidifier', 'set_humidity', {
            entity_id: this._config.entity,
            humidity: low,
          });
        }
      };

      if (useCircular) {
        const maxArc = 628.32 * 0.75;

        const setupCircle = (idSuffix, getOptimistic, setOptimistic, commitFn) => {
          const circEl = portal.querySelector(`#circularSliderHum${idSuffix}`);
          if (!circEl) return null;
          const svg = circEl.querySelector('svg');
          const progress = circEl.querySelector(`#humCircularProgress${idSuffix}`);
          const thumb = circEl.querySelector(`#humCircularThumb${idSuffix}`);
          const valDisplay = circEl.querySelector(`#humCircularValue${idSuffix}`);
          const vSize = this._config.popup_value_font_size || 64;
          const sz = isRange ? Math.round(vSize * 0.75) : vSize;

          const updateFromVal = (val) => {
            setOptimistic(val);
            const pct = ((val - minHumidity) / range) * 100;
            const arcLen = (pct / 100) * maxArc;
            const sa = 135 * (Math.PI / 180);
            const aa = (pct / 100) * 270 * (Math.PI / 180);
            const tx = 140 + 100 * Math.cos(sa + aa);
            const ty = 140 + 100 * Math.sin(sa + aa);
            if (progress) progress.setAttribute('stroke-dasharray', `${arcLen} 628.32`);
            if (thumb) { thumb.setAttribute('cx', tx); thumb.setAttribute('cy', ty); }
            if (valDisplay) valDisplay.innerHTML = `${val}<span style="font-size:${sz/2}px;">%</span>`;
          };

          const getValFromPoint = (clientX, clientY) => {
            const rect = svg.getBoundingClientRect();
            const cx = rect.left + rect.width / 2, cy = rect.top + rect.height / 2;
            let angle = Math.atan2(clientY - cy, clientX - cx) * 180 / Math.PI;
            if (angle < 0) angle += 360;
            let arcDeg = angle - 135;
            if (arcDeg < 0) arcDeg += 360;
            if (arcDeg > 270) arcDeg = arcDeg < 315 ? 270 : 0;
            return clamp(minHumidity + (arcDeg / 270) * range, minHumidity, maxHumidity);
          };

          let dragging = false;
          const onDown = (x, y) => { dragging = true; this._isDragging = true; updateFromVal(getValFromPoint(x, y)); };
          const onMove = (x, y) => { if (dragging) updateFromVal(getValFromPoint(x, y)); };
          const onUp = () => {
            if (!dragging) return;
            dragging = false;
            this._isDragging = false;
            commitFn(getOptimistic());
            document.removeEventListener('mousemove', mouseMove);
            document.removeEventListener('mouseup', mouseUp);
            document.removeEventListener('touchmove', touchMove);
            document.removeEventListener('touchend', touchEnd);
          };
          const mouseMove = (e) => onMove(e.clientX, e.clientY);
          const mouseUp = onUp;
          const touchMove = (e) => onMove(e.touches[0].clientX, e.touches[0].clientY);
          const touchEnd = onUp;

          circEl.addEventListener('mousedown', (e) => { onDown(e.clientX, e.clientY); document.addEventListener('mousemove', mouseMove); document.addEventListener('mouseup', mouseUp); });
          circEl.addEventListener('touchstart', (e) => { onDown(e.touches[0].clientX, e.touches[0].clientY); document.addEventListener('touchmove', touchMove, { passive: true }); document.addEventListener('touchend', touchEnd); }, { passive: true });

          return updateFromVal;
        };

        if (isRange) {
          const updateHigh = setupCircle('High',
            () => this._optimisticHumidityHigh ?? humHighAttr,
            (v) => { this._optimisticHumidityHigh = v; },
            (v) => commitRange(this._optimisticHumidityLow ?? humLowAttr, v)
          );
          setupCircle('Low',
            () => this._optimisticHumidityLow ?? humLowAttr,
            (v) => { this._optimisticHumidityLow = v; },
            (v) => commitRange(v, this._optimisticHumidityHigh ?? humHighAttr)
          );
          // +/- buttons act on High in range mode
          portal.querySelectorAll('[data-hum-action]').forEach(btn => {
            btn.addEventListener('click', () => {
              const action = btn.getAttribute('data-hum-action');
              if (action === 'plus-high' || action === 'minus-high') {
                const dir = action.startsWith('plus') ? 1 : -1;
                const cur = this._optimisticHumidityHigh ?? humHighAttr;
                const val = clamp(cur + dir * step, minHumidity, maxHumidity);
                this._isDragging = true;
                clearTimeout(this._humidifierDebounce);
                this._humidifierDebounce = setTimeout(() => { this._isDragging = false; }, 2000);
                if (updateHigh) updateHigh(val);
                commitRange(this._optimisticHumidityLow ?? humLowAttr, val);
              }
            });
          });
        } else {
          const updateCircle = setupCircle('',
            () => this._optimisticHumidity ?? attrs.humidity,
            (v) => { this._optimisticHumidity = v; },
            (v) => this.hass.callService('humidifier', 'set_humidity', { entity_id: this._config.entity, humidity: v })
          );
          portal.querySelectorAll('[data-hum-action]').forEach(btn => {
            btn.addEventListener('click', () => {
              const cur = this._optimisticHumidity ?? attrs.humidity ?? minHumidity;
              const dir = btn.getAttribute('data-hum-action') === 'plus' ? 1 : -1;
              const val = clamp(cur + dir * step, minHumidity, maxHumidity);
              this._isDragging = true;
              clearTimeout(this._humidifierDebounce);
              this._humidifierDebounce = setTimeout(() => { this._isDragging = false; }, 2000);
              if (updateCircle) updateCircle(val);
              this.hass.callService('humidifier', 'set_humidity', { entity_id: this._config.entity, humidity: val });
            });
          });
        }
        return;
      }

      // â”€â”€ Vertical slider handlers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      if (isRange) {
        const setupVertical = (idSuffix, getOptimistic, setOptimistic, commitFn) => {
          const slider = portal.querySelector(`#slider-${idSuffix}`);
          if (!slider) return;
          const update = (clientY) => {
            const rect = slider.getBoundingClientRect();
            const pct = Math.max(0, Math.min(1, (rect.bottom - clientY) / rect.height));
            const val = clamp(minHumidity + pct * range, minHumidity, maxHumidity);
            setOptimistic(val);
            const display = portal.querySelector(`#display-${idSuffix}`);
            const fill = slider.querySelector('.vertical-slider-fill');
            const thumb = slider.querySelector('.vertical-slider-thumb');
            if (display) display.innerHTML = `${val}<span>%</span>`;
            const ap = ((val - minHumidity) / range) * 100;
            if (fill) fill.style.height = `${ap}%`;
            if (thumb) thumb.style.bottom = ap <= 0 ? '0px' : ap >= 100 ? 'calc(100% - 6px)' : `calc(${ap}% - 6px)`;
            return val;
          };
          let isDragging = false;
          slider.addEventListener('mousedown', (e) => { isDragging = true; this._isDragging = true; update(e.clientY); });
          document.addEventListener('mousemove', (e) => { if (isDragging) update(e.clientY); });
          document.addEventListener('mouseup', (e) => { if (!isDragging) return; isDragging = false; this._isDragging = false; commitFn(update(e.clientY)); });
          slider.addEventListener('touchstart', (e) => { isDragging = true; this._isDragging = true; update(e.touches[0].clientY); }, { passive: true });
          document.addEventListener('touchmove', (e) => { if (isDragging) update(e.touches[0].clientY); }, { passive: true });
          document.addEventListener('touchend', (e) => { if (isDragging && e.changedTouches.length > 0) { isDragging = false; this._isDragging = false; commitFn(update(e.changedTouches[0].clientY)); } }, { passive: true });
        };

        setupVertical('humidity_low',
          () => this._optimisticHumidityLow ?? humLowAttr,
          (v) => { this._optimisticHumidityLow = v; },
          (v) => commitRange(v, this._optimisticHumidityHigh ?? humHighAttr)
        );
        setupVertical('humidity_high',
          () => this._optimisticHumidityHigh ?? humHighAttr,
          (v) => { this._optimisticHumidityHigh = v; },
          (v) => commitRange(this._optimisticHumidityLow ?? humLowAttr, v)
        );

        portal.querySelectorAll('[data-hum-action]').forEach(btn => {
          btn.addEventListener('click', () => {
            const action = btn.getAttribute('data-hum-action');
            if (action === 'plus-high' || action === 'minus-high') {
              const dir = action.startsWith('plus') ? 1 : -1;
              const cur = this._optimisticHumidityHigh ?? humHighAttr;
              const val = clamp(cur + dir * step, minHumidity, maxHumidity);
              this._optimisticHumidityHigh = val;
              this._isDragging = true;
              clearTimeout(this._humidifierDebounce);
              this._humidifierDebounce = setTimeout(() => { this._isDragging = false; }, 2000);
              commitRange(this._optimisticHumidityLow ?? humLowAttr, val);
            }
          });
        });
        return;
      }

      // Single vertical slider
      const slider = portal.querySelector('#slider-humidity');
      if (!slider) return;

      const updateHumidity = (clientY) => {
        const rect = slider.getBoundingClientRect();
        const pct = Math.max(0, Math.min(1, (rect.bottom - clientY) / rect.height));
        const value = clamp(minHumidity + pct * range, minHumidity, maxHumidity);
        const display = portal.querySelector('#display-humidity');
        const fill = slider.querySelector('.vertical-slider-fill');
        const thumb = slider.querySelector('.vertical-slider-thumb');
        if (display) display.innerHTML = `${value}<span>%</span>`;
        const actualPct = ((value - minHumidity) / range) * 100;
        if (fill) fill.style.height = `${actualPct}%`;
        if (thumb) thumb.style.bottom = actualPct <= 0 ? '0px' : actualPct >= 100 ? 'calc(100% - 6px)' : `calc(${actualPct}% - 6px)`;
        return value;
      };

      portal.querySelectorAll('[data-hum-action]').forEach(btn => {
        btn.addEventListener('click', () => {
          const cur = this._optimisticHumidity ?? attrs.humidity ?? minHumidity;
          const dir = btn.getAttribute('data-hum-action') === 'plus' ? 1 : -1;
          const val = clamp(cur + dir * step, minHumidity, maxHumidity);
          this._optimisticHumidity = val;
          this._isDragging = true;
          clearTimeout(this._humidifierDebounce);
          this._humidifierDebounce = setTimeout(() => { this._isDragging = false; }, 2000);
          const display = portal.querySelector('#display-humidity');
          const fill = slider.querySelector('.vertical-slider-fill');
          const thumb = slider.querySelector('.vertical-slider-thumb');
          if (display) display.innerHTML = `${val}<span>%</span>`;
          const ap = ((val - minHumidity) / range) * 100;
          if (fill) fill.style.height = `${ap}%`;
          if (thumb) thumb.style.bottom = ap <= 0 ? '0px' : ap >= 100 ? 'calc(100% - 6px)' : `calc(${ap}% - 6px)`;
          this.hass.callService('humidifier', 'set_humidity', { entity_id: this._config.entity, humidity: val });
        });
      });

      let isDragging = false;
      slider.addEventListener('mousedown', (e) => { isDragging = true; this._isDragging = true; updateHumidity(e.clientY); });
      document.addEventListener('mousemove', (e) => { if (isDragging) updateHumidity(e.clientY); });
      document.addEventListener('mouseup', (e) => {
        if (!isDragging) return;
        isDragging = false;
        this._isDragging = false;
        const value = updateHumidity(e.clientY);
        this._optimisticHumidity = value;
        this.hass.callService('humidifier', 'set_humidity', { entity_id: this._config.entity, humidity: value });
      });
      slider.addEventListener('touchstart', (e) => { isDragging = true; this._isDragging = true; updateHumidity(e.touches[0].clientY); }, { passive: true });
      document.addEventListener('touchmove', (e) => { if (isDragging) updateHumidity(e.touches[0].clientY); }, { passive: true });
      document.addEventListener('touchend', (e) => {
        if (isDragging && e.changedTouches.length > 0) {
          isDragging = false;
          this._isDragging = false;
          const value = updateHumidity(e.changedTouches[0].clientY);
          this._optimisticHumidity = value;
          this.hass.callService('humidifier', 'set_humidity', { entity_id: this._config.entity, humidity: value });
        }
      }, { passive: true });
    }


    /**
     * Fan Popup
     */
    _renderFanPopupPortal(entity) {
      // Reuse existing portal to avoid flicker on hass updates.

      const name = this._getPopupName(entity);
      const attrs = entity.attributes || {};
      const state = entity.state;
      const isOn = state === 'on';
      const speed = attrs.percentage || 0;
      const presetModes = attrs.preset_modes || [];
      const currentPreset = attrs.preset_mode || null;
      const direction = attrs.direction || 'forward';
      const oscillating = attrs.oscillating || false;
      const supportsDirection = attrs.supported_features ? (attrs.supported_features & 2) !== 0 : false;
      const supportsOscillate = attrs.supported_features ? (attrs.supported_features & 4) !== 0 : false;
      
      const color = isOn ? 'var(--primary-color, #03a9f4)' : 'var(--disabled-text-color, #6f6f6f)';
      const icon = this._getResolvedIcon(entity, isOn ? 'mdi:fan' : 'mdi:fan-off');
      const borderRadius = this._config.popup_slider_radius ?? 12;
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();

      const valueSize = this._config.popup_value_font_size || 36;
      const valueWeight = this._config.popup_value_font_weight || 300;

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-popup-portal';
      // Clear previous content when reusing.
      portal.innerHTML = '';

      portal.innerHTML = `
        <style>
          .hki-popup-portal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            ${this._getPopupPortalStyle()}
            display: flex; align-items: center; justify-content: center; z-index: 9999;
          }
          .hki-popup-container {
            ${this._getPopupCardStyle()};
            border-radius: ${popupBorderRadius}px;
            width: ${popupWidth}; height: ${popupHeight};
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex; flex-direction: column; overflow: hidden; user-select: none; -webkit-user-select: none;
          }
          .hki-popup-header {
            display: flex; justify-content: space-between; align-items: center; padding: 16px 20px;
            background: rgba(255, 255, 255, 0.03); border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .hki-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-popup-title img { width:28px;height:28px;border-radius:50%;object-fit:cover;flex-shrink:0; }
          .hki-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; }
          .hki-popup-state { font-size: 12px; opacity: 0.6; text-transform: capitalize; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: var(--divider-color, rgba(255, 255, 255, 0.05)); border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
          }
          .header-btn:hover { background: rgba(255, 255, 255, 0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }

          .hki-tabs {
            display: flex; gap: 8px; padding: 8px 20px;
            background: rgba(255, 255, 255, 0.02);
            border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .tab-btn {
            flex: 1; height: 40px; border-radius: 8px;
            background: transparent; border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center; gap: 8px;
            transition: all 0.2s; font-size: 14px; font-weight: 500;
          }
          .tab-btn:hover { background: var(--secondary-background-color, rgba(255,255,255,0.08)); }
          .tab-btn.active { 
            background: var(--primary-color, rgba(255,255,255,0.12)); 
            color: var(--text-primary-color, var(--primary-text-color));
          }

          .hki-popup-content { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 0; }
          
          .fan-slider-wrapper {
            display: flex; align-items: center; justify-content: center; width: 100%;
          }
          .fan-slider-group { display: flex; flex-direction: column; align-items: center; gap: 12px; height: 320px; width: 80px; }
          .value-display { font-size: ${valueSize}px; font-weight: ${valueWeight}; text-align: center; }
          .value-display span { font-size: ${Math.max(14, Math.round(valueSize/2))}px; opacity: 0.7; }
          .slider-label { font-size: 12px; opacity: 0.5; text-transform: uppercase; letter-spacing: 1px; }

          .vertical-slider-track {
            width: 100%; flex: 1; 
            background: var(--secondary-background-color, rgba(255, 255, 255, 0.1));
            border: 2px solid var(--divider-color, rgba(255, 255, 255, 0.1));
            border-radius: ${borderRadius}px; position: relative; overflow: hidden; cursor: pointer;
          }
          .vertical-slider-fill {
            position: absolute; bottom: 0; left: 0; right: 0;
            background: ${color}; transition: background 0.3s;
            border-radius: 0 0 ${borderRadius}px ${borderRadius}px;
          }
          .vertical-slider-thumb {
            position: absolute; left: 50%; transform: translateX(-50%);
            width: 90px; height: 6px; background: white;
            border-radius: 4px; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            pointer-events: none;
          }

          .hki-popup-nav {
            display: flex; justify-content: space-evenly; padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-top: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            gap: 8px;
            flex-shrink: 0;
            min-height: 74px; /* keep consistent even when empty */
            box-sizing: border-box;
          }
          .nav-btn {
            flex: 1; height: 50px; border-radius: 12px;
            border: none; background: transparent;
            color: var(--primary-text-color); opacity: 0.5;
            cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;
            transition: all 0.2s; font-size: 11px;
          }
          .nav-btn:hover { opacity: 0.8; background: rgba(255, 255, 255, 0.05); }
          .nav-btn.active { 
            opacity: 1; 
            background: var(--primary-color, rgba(255,255,255,0.1)); 
            color: var(--text-primary-color, var(--primary-text-color));
          }
          .nav-btn ha-icon { --mdc-icon-size: 24px; }

          .preset-list { width: 100%; display: flex; flex-direction: column; gap: 8px; }
          .preset-item { 
            padding: 14px; 
            background: rgba(255,255,255,0.05); 
            border-radius: 8px; 
            cursor: pointer; 
            display: flex; 
            justify-content: space-between; 
            align-items: center;
            transition: all 0.2s;
          }
          .preset-item:hover { background: rgba(255,255,255,0.08); }
          .preset-item.active { background: ${color}; color: white; }

          .timeline-container { width: 100%; height: 100%; padding: 0 10px 10px 10px; box-sizing: border-box; overflow-y: auto; align-self: stretch; }
          .timeline-item { display: flex; gap: 16px; margin-bottom: 0; min-height: 40px; position: relative; }
          .timeline-visual { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
          .timeline-dot { width: 10px; height: 10px; border-radius: 50%; background: var(--primary-color, #FFD700); z-index: 2; border: 2px solid var(--card-background-color, #1c1c1c); margin-top: 3px; }
          .timeline-line { width: 2px; flex-grow: 1; background: var(--divider-color, rgba(255,255,255,0.12)); margin-top: -2px; margin-bottom: -4px; }
          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content { flex: 1; padding-bottom: 16px; font-size: 13px; color: var(--primary-text-color); }
          .timeline-detail { font-size: 11px; opacity: 0.6; display: block; margin-top: 4px; }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .timeline-trigger { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; font-style: italic; }
          .history-loading { width: 100%; text-align: center; padding: 20px; opacity: 0.6; }
        </style>

        <div class="hki-popup-container">
          <div class="hki-popup-header">
            <div class="hki-popup-title">
              ${this._getPopupHeaderIconHtml(entity, icon, this._getPopupIconColor(color))}
              <div class="hki-popup-title-text">
                ${name}
                <span class="hki-popup-state">${this._getPopupHeaderState(isOn ? speed + '%' : 'Off')}${this._formatLastTriggered(entity) ? ` - ${this._formatLastTriggered(entity)}` : ''}</span>
              </div>
            </div>
            <div class="hki-popup-header-controls">
              <button class="header-btn" id="fanHistoryBtn"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>
              <button class="header-btn" id="closeBtn"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>

          <div class="hki-tabs">
            <button class="tab-btn ${this._activeView === 'main' ? 'active' : ''}" id="tabMain" style="${this._activeView === 'main' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}"><ha-icon icon="mdi:fan"></ha-icon>${this._config.popup_hide_button_text ? '' : '<span>Speed</span>'}</button>
            ${presetModes.length > 0 ? `<button class="tab-btn ${this._activeView === 'presets' ? 'active' : ''}" id="tabPresets" style="${this._activeView === 'presets' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}"><ha-icon icon="mdi:tune"></ha-icon><span>Presets</span></button>` : ''}
          </div>

          <div class="hki-popup-content" id="fanContent">
            ${this._renderFanPopupContent(entity, color, speed, valueSize, valueWeight, borderRadius)}
          </div>

          <div class="hki-popup-nav">
            <button class="nav-btn ${isOn ? 'active' : ''}" id="fanToggle" style="${isOn ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
              <ha-icon icon="${isOn ? 'mdi:power' : 'mdi:power-off'}"></ha-icon>
              <span>${isOn ? 'On' : 'Off'}</span>
            </button>
            ${supportsDirection ? `
              <button class="nav-btn ${direction === 'reverse' ? 'active' : ''}" id="fanDirection" style="${direction === 'reverse' ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
                <ha-icon icon="${direction === 'reverse' ? 'mdi:rotate-left' : 'mdi:rotate-right'}"></ha-icon>
                <span>${direction === 'reverse' ? 'Reverse' : 'Forward'}</span>
              </button>
            ` : ''}
            ${supportsOscillate ? `
              <button class="nav-btn ${oscillating ? 'active' : ''}" id="fanOscillate" style="${oscillating ? this._getPopupButtonStyle(true) : this._getPopupButtonStyle(false)}">
                <ha-icon icon="${oscillating ? 'mdi:arrow-oscillating' : 'mdi:arrow-oscillating-off'}"></ha-icon>
                <span>Oscillate</span>
              </button>
            ` : ''}
          </div>
        </div>
      `;

      const container = portal.querySelector('.hki-popup-container');
      if (container) container.addEventListener('click', (e) => e.stopPropagation());

      let isBackgroundClick = false;
      portal.addEventListener('mousedown', (e) => { isBackgroundClick = (e.target === portal); });
      portal.addEventListener('touchstart', (e) => { isBackgroundClick = (e.target === portal); }, { passive: true });
      portal.addEventListener('click', (e) => {
        if (isBackgroundClick && e.target === portal) this._closePopup();
        isBackgroundClick = false;
      });

      if (!this._popupPortal) {
        document.body.appendChild(portal);
        this._applyOpenAnimation(portal);
      }
      this._popupPortal = portal;

      const closeBtn = portal.querySelector('#closeBtn');
      if (closeBtn) closeBtn.addEventListener('click', () => this._closePopup());

      // Bottom bar entity buttons
      if (this._config.popup_hide_bottom_bar !== true) {
        const _bbNav = portal.querySelector('.hki-popup-nav');
        if (_bbNav) this._renderBottomBarEntityButtons(_bbNav);
      }

      const historyBtn = portal.querySelector('#fanHistoryBtn');
      if (historyBtn) {
        historyBtn.addEventListener('click', () => {
          this._activeView = this._activeView === 'history' ? 'main' : 'history';
          const content = portal.querySelector('#fanContent');
          if (content) {
            content.innerHTML = this._renderFanPopupContent(entity, color, speed, valueSize, valueWeight, borderRadius);
            if (this._activeView === 'history') {
              setTimeout(() => this._loadHistory(), 100);
            } else {
              this._setupFanContentHandlers(portal, entity);
            }
          }
        });
      }

      const toggleBtn = portal.querySelector('#fanToggle');
      if (toggleBtn) {
        toggleBtn.addEventListener('click', () => {
          this.hass.callService('fan', isOn ? 'turn_off' : 'turn_on', { entity_id: this._config.entity });
        });
      }

      const directionBtn = portal.querySelector('#fanDirection');
      if (directionBtn) {
        directionBtn.addEventListener('click', () => {
          this.hass.callService('fan', 'set_direction', {
            entity_id: this._config.entity,
            direction: direction === 'forward' ? 'reverse' : 'forward'
          });
        });
      }

      const oscillateBtn = portal.querySelector('#fanOscillate');
      if (oscillateBtn) {
        oscillateBtn.addEventListener('click', () => {
          this.hass.callService('fan', 'oscillate', {
            entity_id: this._config.entity,
            oscillating: !oscillating
          });
        });
      }

      const tabMain = portal.querySelector('#tabMain');
      if (tabMain) {
        tabMain.addEventListener('click', () => {
          if (this._activeView === 'main') return;
          this._activeView = 'main';
          const content = portal.querySelector('#fanContent');
          if (content) {
            content.innerHTML = this._renderFanPopupContent(entity, color, speed, valueSize, valueWeight, borderRadius);
            this._setupFanContentHandlers(portal, entity);
          }
          tabMain.classList.add('active');
          tabMain.style = this._getPopupButtonStyle(true);
          const tabPresets = portal.querySelector('#tabPresets');
          if (tabPresets) {
            tabPresets.classList.remove('active');
            tabPresets.style = this._getPopupButtonStyle(false);
          }
        });
      }

      const tabPresets = portal.querySelector('#tabPresets');
      if (tabPresets) {
        tabPresets.addEventListener('click', () => {
          if (this._activeView === 'presets') return;
          this._activeView = 'presets';
          const content = portal.querySelector('#fanContent');
          if (content) {
            content.innerHTML = this._renderFanPresetsList(presetModes, currentPreset, color);
            this._setupFanContentHandlers(portal, entity);
          }
          tabPresets.classList.add('active');
          tabPresets.style = this._getPopupButtonStyle(true);
          if (tabMain) {
            tabMain.classList.remove('active');
            tabMain.style = this._getPopupButtonStyle(false);
          }
        });
      }

      this._setupFanContentHandlers(portal, entity);
    }

    _renderFanPopupContent(entity, color, speed, valueSize, valueWeight, borderRadius) {
      if (this._activeView === 'history') {
        return `<div class="timeline-container" data-view-type="history" id="historyContainer"><div class="history-loading">Loading Timeline...</div></div>`;
      }

      if (this._activeView === 'presets') {
        const presetModes = entity.attributes.preset_modes || [];
        const currentPreset = entity.attributes.preset_mode || null;
        return this._renderFanPresetsList(presetModes, currentPreset, color);
      }

      if (entity.state === 'off') {
        return `<div class="climate-controls-view"><div style="opacity: 0.5; font-size: 18px; font-weight: 500;">Fan is Off</div></div>`;
      }

      const pct = speed;
      // Clamp thumb position so it's always visible (at 0% and 100%)
      const thumbPos = pct <= 0 ? '0px' : pct >= 100 ? 'calc(100% - 6px)' : `calc(${pct}% - 6px)`;

      return `
        <div class="fan-slider-wrapper">
          <div class="fan-slider-group">
            <div class="value-display" id="displaySpeed">${speed}<span>%</span></div>
            <div class="vertical-slider-track" id="sliderSpeed">
              <div class="vertical-slider-fill" style="height: ${pct}%; background: ${color};"></div>
              <div class="vertical-slider-thumb" style="bottom: ${thumbPos}"></div>
            </div>
            <div class="slider-label">Speed</div>
          </div>
        </div>
      `;
    }

    _renderFanPresetsList(presetModes, currentPreset, color) {
      return `
        <div class="preset-list">
          ${presetModes.map(preset => `
            <div class="preset-item ${preset === currentPreset ? 'active' : ''}" data-preset="${preset}">
              <span style="text-transform: capitalize;">${preset.replace(/_/g, ' ')}</span>
              ${preset === currentPreset ? '<ha-icon icon="mdi:check"></ha-icon>' : ''}
            </div>
          `).join('')}
        </div>
      `;
    }

    _setupFanContentHandlers(portal, entity) {
      if (this._activeView === 'presets') {
        const presetItems = portal.querySelectorAll('.preset-item');
        presetItems.forEach(item => {
          item.addEventListener('click', () => {
            const preset = item.getAttribute('data-preset');
            this.hass.callService('fan', 'set_preset_mode', {
              entity_id: this._config.entity,
              preset_mode: preset
            });
          });
        });
        return;
      }

      if (this._activeView === 'history') {
        return;
      }

      const slider = portal.querySelector('#sliderSpeed');
      if (!slider) return;

      const updateSpeed = (clientY) => {
        const rect = slider.getBoundingClientRect();
        const pct = Math.max(0, Math.min(100, Math.round(((rect.bottom - clientY) / rect.height) * 100)));
        
        const display = portal.querySelector('#displaySpeed');
        const fill = slider.querySelector('.vertical-slider-fill');
        const thumb = slider.querySelector('.vertical-slider-thumb');
        
        if (display) display.innerHTML = `${pct}<span>%</span>`;
        if (fill) fill.style.height = `${pct}%`;
        // Clamp thumb position so it stays visible at 0% and 100%
        const thumbPos = pct <= 0 ? '0px' : pct >= 100 ? 'calc(100% - 6px)' : `calc(${pct}% - 6px)`;
        if (thumb) thumb.style.bottom = thumbPos;
        
        return pct;
      };

      let isDragging = false;
      const handleMove = (clientY) => {
        if (!isDragging) return;
        updateSpeed(clientY);
      };

      const handleEnd = (clientY) => {
        if (!isDragging) return;
        isDragging = false;
        const value = updateSpeed(clientY);
        this.hass.callService('fan', 'set_percentage', {
          entity_id: this._config.entity,
          percentage: value
        });
      };

      slider.addEventListener('mousedown', (e) => {
        isDragging = true;
        updateSpeed(e.clientY);
      });
      document.addEventListener('mousemove', (e) => handleMove(e.clientY));
      document.addEventListener('mouseup', (e) => handleEnd(e.clientY));

      slider.addEventListener('touchstart', (e) => {
        isDragging = true;
        updateSpeed(e.touches[0].clientY);
      }, { passive: true });
      document.addEventListener('touchmove', (e) => {
        if (isDragging) handleMove(e.touches[0].clientY);
      }, { passive: true });
      document.addEventListener('touchend', (e) => {
        if (isDragging && e.changedTouches.length > 0) {
          handleEnd(e.changedTouches[0].clientY);
        }
      }, { passive: true });
    }


    /**
     * Switch Popup
     */
    /**
     * Switch Popup - HomeKit Style Vertical Toggle
     */
    /**
     * Switch Popup - HomeKit Style Vertical Toggle
     */
    /**
     * Switch Popup - Centered Vertical Slider
     */
    /**
     * Switch Popup - Matching Light/Climate Slider Style
     */
    /**
     * Switch Popup - Large Prominent Thumb
     */
    /**
     * Switch Popup - Large Prominent Handle
     */
    /**
     * Switch Popup - Extra Thick Handle
     */
    /**
     * Switch Popup - Super Thick Pill Handle
     */
    /**
     * Switch Popup - Thick Pill Handle Matching Screenshot
     */
    /**
     * Switch Popup - Thick Pill Handle with Matching Border-Radius
     */
    /**
     * Switch Popup - Handle Follows Slider Border Radius
     */

    _renderSwitchPopupPortal(entity) {
      // Reuse existing portal to avoid flicker on hass updates.
      this._popupType = 'switch';
      this._popupEntityId = entity?.entity_id || this._config?.entity || null;
      const hasRealEntity = !!entity;
      if (!entity) {
        entity = {
          entity_id: this._config?.entity || 'hki.dummy',
          state: '',
          attributes: { friendly_name: this._config?.name || 'Popup' },
          last_changed: new Date().toISOString(),
        };
      }


      const domain = (entity.entity_id || this._config.entity || '').split('.')[0] || this._getDomain();
      const serviceDomain = domain === 'group' ? 'homeassistant' : (domain === 'input_boolean' ? 'input_boolean' : 'switch');

      const name = this._getPopupName(entity);
      const state = entity.state;
      const isOn = state === 'on';

      const isGroup = Array.isArray(entity.attributes?.entity_id) && entity.attributes.entity_id.length > 1;

      // Check default view configuration for groups
      const defaultView = this._config.popup_default_view; // 'main', 'individual', or undefined
      
      // Auto-switch to individual/group view if configured and it's a group
      // Only set on initial render (when _activeView is not already 'group')
      if (defaultView === 'individual' && isGroup && this._activeView !== 'group') {
        this._activeView = 'group';
      } else if (!this._activeView || this._activeView === 'brightness') {
        // Reset to main view if not set or coming from light popup
        this._activeView = 'main';
      }

      const color = isOn ? 'var(--primary-color, #03a9f4)' : 'var(--disabled-text-color, #6f6f6f)';
      const icon = this._getResolvedIcon(entity, isOn ? 'mdi:toggle-switch' : 'mdi:toggle-switch-off');
      const borderRadius = this._config.popup_slider_radius ?? 12;
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();
      const handleRadius = Math.round(borderRadius * 0.7); // Handle radius follows slider radius proportionally
      const valueSize = this._config.popup_value_font_size || 36;
      const valueWeight = this._config.popup_value_font_weight || 300;

      const groupBtn = isGroup ? `
        <button class="header-btn" id="switchGroupBtn" title="Group">
          <ha-icon icon="mdi:format-list-bulleted"></ha-icon>
        </button>
      ` : '';

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-popup-portal';
      // Clear previous content when reusing.
      portal.innerHTML = '';

      portal.innerHTML = `
        <style>
          .hki-popup-portal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            ${this._getPopupPortalStyle()}
            display: flex; align-items: center; justify-content: center; z-index: 9999;
          }
          .hki-popup-container {
            ${this._getPopupCardStyle()};
            border-radius: ${popupBorderRadius}px;
            width: ${popupWidth}; height: ${popupHeight};
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex; flex-direction: column; overflow: hidden; user-select: none; -webkit-user-select: none;
          }
          .hki-popup-header {
            display: flex; justify-content: space-between; align-items: center; padding: 16px 20px;
            background: rgba(255, 255, 255, 0.03); border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .hki-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-popup-title img { width:28px;height:28px;border-radius:50%;object-fit:cover;flex-shrink:0; }
          .hki-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; }
          .hki-popup-state { font-size: 12px; opacity: 0.6; text-transform: capitalize; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: var(--divider-color, rgba(255, 255, 255, 0.05)); border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
          }
          .header-btn:hover { background: rgba(255, 255, 255, 0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }

          .hki-popup-content { 
            flex: 1; padding: 20px; overflow-y: auto; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            min-height: 0; 
          }

          .switch-slider-container {
            display: flex; flex-direction: column; align-items: center; gap: 12px;
            width: 80px; height: 320px;
          }

          .switch-group-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: stretch;
            justify-content: flex-start;
          }
          .switch-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            padding: 12px 14px;
            border-radius: 14px;
            background: var(--divider-color, rgba(255, 255, 255, 0.06));
            border: 1px solid rgba(255, 255, 255, 0.08);
          }
          .switch-row-left { display:flex; gap: 12px; align-items:center; min-width:0; }
          .switch-row-name { font-size: 14px; font-weight: 500; overflow:hidden; text-overflow: ellipsis; white-space: nowrap; }
          .switch-row-state { font-size: 11px; opacity: 0.6; text-transform: capitalize; margin-top: 2px; }
          .switch-row-text { display:flex; flex-direction:column; min-width:0; }
          .switch-row-toggle {
            width: 46px; height: 30px; border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(255,255,255,0.06);
            position: relative;
            cursor: pointer;
            flex-shrink: 0;
          }
          .switch-row-toggle.on { background: var(--primary-color, rgba(3,169,244,0.35)); border-color: rgba(3,169,244,0.45); }
          .switch-row-toggle-knob {
            width: 24px; height: 24px; border-radius: 50%;
            background: #fff;
            position: absolute; top: 50%;
            transform: translateY(-50%);
            left: 3px;
            transition: left 0.18s ease;
            box-shadow: 0 2px 10px rgba(0,0,0,0.35);
          }
          .switch-row-toggle.on .switch-row-toggle-knob { left: 19px; }

          .value-display {
            font-size: ${valueSize}px;
            font-weight: ${valueWeight};
            text-align: center;
          }

          .slider-label {
            font-size: 12px;
            opacity: 0.5;
            text-transform: uppercase;
            letter-spacing: 1px;
          }

          .vertical-slider-track {
            width: 100%; flex: 1;
            background: var(--secondary-background-color, rgba(255, 255, 255, 0.1));
            border: 2px solid var(--divider-color, rgba(255, 255, 255, 0.1));
            border-radius: ${borderRadius}px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
          }

          .vertical-slider-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: ${color};
            transition: background 0.3s ease, height 0.3s ease;
            height: ${isOn ? '100%' : '0%'};
            border-radius: 0 0 ${borderRadius}px ${borderRadius}px;
          }

          .vertical-slider-thumb {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 74px;
            height: 120px;
            background: white;
            border-radius: ${handleRadius}px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6), 0 2px 8px rgba(0,0,0,0.4);
            cursor: grab;
            pointer-events: none;
            transition: bottom 0.3s ease;
            bottom: ${isOn ? 'calc(100% - 124px)' : '4px'};
          }

          .timeline-container { width: 100%; height: 100%; padding: 0 10px 10px 10px; box-sizing: border-box; overflow-y: auto; align-self: stretch; }
          .timeline-item { display: flex; gap: 12px; position: relative; }
          .timeline-visual { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
          .timeline-dot { width: 10px; height: 10px; border-radius: 50%; background: var(--primary-color, #FFD700); z-index: 2; border: 2px solid var(--card-background-color, #1c1c1c); }
          .timeline-line { width: 2px; flex-grow: 1; background: var(--divider-color, rgba(255,255,255,0.1)); margin-top: -2px; margin-bottom: -4px; }
          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content { flex: 1; padding-bottom: 16px; font-size: 13px; color: var(--primary-text-color); }
          .timeline-detail { font-size: 11px; opacity: 0.6; display: block; margin-top: 4px; }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .timeline-trigger { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; font-style: italic; }
          .history-loading { width: 100%; text-align: center; padding: 20px; opacity: 0.6; }

          .hki-popup-nav {
            display: flex; justify-content: space-evenly; padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-top: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            gap: 8px;
            flex-shrink: 0;
            min-height: 74px;
            box-sizing: border-box;
          }
        </style>

        <div class="hki-popup-container">
          <div class="hki-popup-header">
            <div class="hki-popup-title">
              ${this._getPopupHeaderIconHtml(entity, icon, this._getPopupIconColor(color))}
              <div class="hki-popup-title-text">
                ${name}
                <span class="hki-popup-state">${this._getPopupHeaderState(isOn ? 'On' : 'Off')}${this._formatLastTriggered(entity) ? ` - ${this._formatLastTriggered(entity)}` : ''}</span>
              </div>
            </div>
            <div class="hki-popup-header-controls">
              ${groupBtn}
              <button class="header-btn" id="switchHistoryBtn" title="History"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>
              <button class="header-btn" id="closeBtn" title="Close"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>

          <div class="hki-popup-content" id="switchContent">
            ${this._renderSwitchPopupContent(entity, color, icon, isOn, borderRadius, valueSize, valueWeight)}
          </div>

          <div class="hki-popup-nav"></div>
        </div>
      `;

      const container = portal.querySelector('.hki-popup-container');
      if (container) container.addEventListener('click', (e) => e.stopPropagation());

      let isBackgroundClick = false;
      portal.addEventListener('mousedown', (e) => { isBackgroundClick = (e.target === portal); });
      portal.addEventListener('touchstart', (e) => { isBackgroundClick = (e.target === portal); }, { passive: true });
      portal.addEventListener('click', (e) => {
        if (isBackgroundClick && e.target === portal) this._closePopup();
        isBackgroundClick = false;
      });

      if (!this._popupPortal) {
        document.body.appendChild(portal);
        this._applyOpenAnimation(portal);
      }
      this._popupPortal = portal;

      const closeBtn = portal.querySelector('#closeBtn');
      if (closeBtn) closeBtn.addEventListener('click', () => this._closePopup());

      // Bottom bar entity buttons
      if (this._config.popup_hide_bottom_bar !== true) {
        const _bbNav = portal.querySelector('.hki-popup-nav');
        if (_bbNav) this._renderBottomBarEntityButtons(_bbNav);
      }

      const historyBtn = portal.querySelector('#switchHistoryBtn');
      if (historyBtn) {
        historyBtn.addEventListener('click', () => {
          this._activeView = this._activeView === 'history' ? 'main' : 'history';
          this._renderSwitchPopupPortal(this._getEntity());
          if (this._activeView === 'history') {
            setTimeout(() => this._loadHistory(), 100);
          }
        });
      }

      const groupBtnEl = portal.querySelector('#switchGroupBtn');
      if (groupBtnEl) {
        groupBtnEl.addEventListener('click', () => {
          this._activeView = (this._activeView === 'group') ? 'main' : 'group';
          this._renderSwitchPopupPortal(this._getEntity());
        });
      }

      this._setupSwitchHandlers(portal, entity, serviceDomain);
    }

    _renderSwitchPopupContent(entity, color, icon, isOn, borderRadius, valueSize, valueWeight) {
      if (this._activeView === 'history') {
        return `<div class="timeline-container" data-view-type="history" id="historyContainer"><div class="history-loading">Loading Timeline...</div></div>`;
      }

      const isGroup = Array.isArray(entity.attributes?.entity_id) && entity.attributes.entity_id.length > 1;
      if (this._activeView === 'group' && isGroup) {
        const rows = (entity.attributes.entity_id || []).map((id) => {
          const st = this.hass?.states?.[id];
          if (!st) return '';
          const on = st.state === 'on';
          const nm = st.attributes?.friendly_name || id;
          return `
            <div class="switch-row" data-entity-id="${id}">
              <div class="switch-row-left">
                <ha-icon icon="${on ? 'mdi:toggle-switch' : 'mdi:toggle-switch-off'}" style="color:${on ? 'var(--primary-color, #03a9f4)' : 'var(--disabled-text-color, #6f6f6f)'}; --mdc-icon-size:22px;"></ha-icon>
                <div class="switch-row-text">
                  <div class="switch-row-name">${nm}</div>
                  <div class="switch-row-state">${on ? 'On' : 'Off'}</div>
                </div>
              </div>
              <div class="switch-row-toggle ${on ? 'on' : ''}" data-toggle="1">
                <div class="switch-row-toggle-knob"></div>
              </div>
            </div>
          `;
        }).join('');

        return `<div class="switch-group-container" data-view-type="group">${rows || '<div style="opacity:0.6;text-align:center;padding:12px;">No members</div>'}</div>`;
      }

      return `
        <div class="switch-slider-container">
          <div class="value-display">${isOn ? 'On' : 'Off'}</div>
          <div class="vertical-slider-track" id="switchSlider">
            <div class="vertical-slider-fill"></div>
            <div class="vertical-slider-thumb"></div>
          </div>
          <div class="slider-label">Switch</div>
        </div>
      `;
    }

    _renderCustomPopupPortal(entity) {
      // Reuse existing portal to avoid flicker on hass updates.
      this._popupType = 'custom';
      this._popupEntityId = entity?.entity_id || this._config?.entity || null;
      const hasRealEntity = !!entity;
      if (!entity) {
        entity = {
          entity_id: this._config?.entity || 'hki.dummy',
          state: '',
          attributes: { friendly_name: this._config?.name || 'Popup' },
          last_changed: new Date().toISOString(),
        };
      }


      const name = this._getPopupName(entity) || 'Popup';
      const state = entity?.state || '';
      const domain = entity ? this._getDomain() : '';
      const icon = entity ? this._getResolvedIcon(entity, this._getDomainIcon(domain)) : (this._config?.icon || 'mdi:information');
      
      // Get state color based on domain and state
      let color;
      if (!entity) {
        color = 'var(--primary-color, #03a9f4)';
      } else if (domain === 'climate') {
        color = this._getClimateColor(entity);
      } else if (domain === 'light' && state === 'on') {
        color = this._getCurrentColor() || '#ffc107';
      } else {
        color = (state === 'on' || state === 'open' || state === 'locked') 
          ? 'var(--primary-color, #03a9f4)' 
          : 'var(--disabled-text-color, #6f6f6f)';
      }

      const borderRadius = this._config.popup_slider_radius ?? 12;
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-popup-portal';
      // Clear previous content when reusing.
      portal.innerHTML = '';

      portal.innerHTML = `
        <style>
          .hki-popup-portal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            ${this._getPopupPortalStyle()}
            display: flex; align-items: center; justify-content: center; z-index: 9999;
          }
          .hki-popup-container {
            ${this._getPopupCardStyle()};
            border-radius: ${popupBorderRadius}px;
            width: ${popupWidth}; height: ${popupHeight};
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex; flex-direction: column; overflow: hidden; user-select: none; -webkit-user-select: none;
          }
          .hki-popup-header {
            display: flex; justify-content: space-between; align-items: center; padding: 16px 20px;
            background: rgba(255, 255, 255, 0.03); border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .hki-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-popup-title img { width:28px;height:28px;border-radius:50%;object-fit:cover;flex-shrink:0; }
          .hki-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; }
          .hki-popup-state { font-size: 12px; opacity: 0.6; text-transform: capitalize; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: var(--divider-color, rgba(255, 255, 255, 0.05)); border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
          }
          .header-btn:hover { background: rgba(255, 255, 255, 0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }

          .hki-popup-content { 
            flex: 1; padding: 20px; overflow-y: auto; 
            display: flex; flex-direction: column;
            min-height: 0; 
          }

          .custom-card-container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: stretch;
            justify-content: flex-start;
            gap: 12px;
          }

          /* Timeline history - consistent with other popups */
          .timeline-container { width: 100%; height: 100%; padding: 0 10px 10px 10px; box-sizing: border-box; overflow-y: auto; align-self: stretch; }
          .timeline-item { display: flex; gap: 16px; margin-bottom: 0; min-height: 40px; position: relative; }
          .timeline-visual { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
          .timeline-dot { width: 10px; height: 10px; border-radius: 50%; background: var(--primary-color, #FFD700); z-index: 2; border: 2px solid var(--card-background-color, #1c1c1c); margin-top: 3px; }
          .timeline-line { width: 2px; flex-grow: 1; background: var(--divider-color, rgba(255,255,255,0.12)); margin-top: -2px; margin-bottom: -4px; }
          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content { flex: 1; padding-bottom: 16px; font-size: 13px; color: var(--primary-text-color); }
          .timeline-detail { font-size: 11px; opacity: 0.6; display: block; margin-top: 4px; }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .timeline-trigger { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; font-style: italic; }
          .history-loading { width: 100%; text-align: center; padding: 20px; opacity: 0.6; }

          .hki-popup-nav {
            padding: 12px 20px;
            background: rgba(255, 255, 255, 0.02);
            border-top: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
            min-height: 74px;
            box-sizing: border-box;
          }
        </style>

        <div class="hki-popup-container">
          <div class="hki-popup-header">
            <div class="hki-popup-title">
              ${this._getPopupHeaderIconHtml(entity, icon, this._getPopupIconColor(color))}
              <div class="hki-popup-title-text">
                ${name}
                <span class="hki-popup-state">${this._getPopupHeaderState(this._getLocalizedState(state, domain))}${hasRealEntity && this._formatLastTriggered(entity) ? ` - ${this._formatLastTriggered(entity)}` : ''}</span>
              </div>
            </div>
            <div class="hki-popup-header-controls">
              ${hasRealEntity ? `<button class="header-btn" id="historyBtn" title="History"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>` : ''}
              <button class="header-btn" id="closeBtn" title="Close"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>

          <div class="hki-popup-content" id="customContent">
            ${this._renderCustomPopupContent(entity)}
          </div>

          <div class="hki-popup-nav"></div>
        </div>
      `;

      // No stopPropagation on container - embedded cards need click events for their actions.
      // Background-click-to-close is handled below via the isBackgroundClick flag instead.

      let isBackgroundClick = false;
      portal.addEventListener('mousedown', (e) => { isBackgroundClick = (e.target === portal); });
      portal.addEventListener('touchstart', (e) => { isBackgroundClick = (e.target === portal); }, { passive: true });
      portal.addEventListener('click', (e) => {
        if (isBackgroundClick && e.target === portal) this._closePopup();
        isBackgroundClick = false;
      });

      // Forward hass-action events from built-in HA cards (button, tile, etc.).
      // These cards fire hass-action events that need to reach the Lovelace handler.
      // The portal lives on document.body (outside the HA tree), so we re-dispatch
      // from `this` which IS inside the tree and will bubble to the correct handler.
      portal.addEventListener('hass-action', (e) => {
        e.stopPropagation();
        this.dispatchEvent(new CustomEvent('hass-action', {
          detail: e.detail,
          bubbles: true,
          composed: true,
        }));
      });

      // Forward more-info and dialog events â€” tile/button cards fire these directly
      // and they must reach the HA root to open the dialog.
      // Close our popup first so the dialog is fully visible.
      ['hass-more-info', 'hass-show-dialog', 'show-dialog'].forEach(evtName => {
        portal.addEventListener(evtName, (e) => {
          e.stopPropagation();
          this._closePopup();
          this.dispatchEvent(new CustomEvent(evtName, {
            detail: e.detail,
            bubbles: true,
            composed: true,
          }));
        });
      });

      if (!this._popupPortal) {
        document.body.appendChild(portal);
        this._applyOpenAnimation(portal);
      }
      this._popupPortal = portal;

      const closeBtn = portal.querySelector('#closeBtn');
      if (closeBtn) closeBtn.addEventListener('click', () => this._closePopup());

      const historyBtn = portal.querySelector('#historyBtn');
      if (historyBtn) {
        historyBtn.addEventListener('click', () => {
          this._activeView = this._activeView === 'history' ? 'main' : 'history';
          const content = portal.querySelector('#customContent');
          if (content) {
            content.innerHTML = this._renderCustomPopupContent(entity);
            if (this._activeView === 'history') {
              setTimeout(() => this._loadHistory(), 100);
            } else {
              this._renderCustomCard();
            }
          }
        });
      }

      // Render the custom card after portal is in DOM
      this._renderCustomCard();
      // Bottom bar entity buttons
      if (this._config.popup_hide_bottom_bar !== true) {
        const nav = portal.querySelector('.hki-popup-nav');
        if (nav && Array.isArray(this._config.popup_bottom_bar_entities) && this._config.popup_bottom_bar_entities.length > 0) {
          this._renderBottomBarEntityButtons(nav);
        }
      }
    }

    _renderCustomPopupContent(entity) {
      if (this._activeView === 'history') {
        return `<div class="timeline-container" data-view-type="history" id="historyContainer"><div class="history-loading">Loading Timeline...</div></div>`;
      }

      return `<div class="custom-card-container" id="customCardContainer"></div>`;
    }

    _renderCustomCard() {
      const container = this._popupPortal?.querySelector('#customCardContainer');
      const cardConfig = this._config.custom_popup?.card || this._config.custom_popup_card;
      
      if (!container || !cardConfig) return;

      try {
        // Try to use Home Assistant's helpers if available
        let cardElement;
        
        if (window.loadCardHelpers) {
          // Modern HA - use card helpers
          window.loadCardHelpers().then(helpers => {
            if (helpers && helpers.createCardElement) {
              cardElement = helpers.createCardElement(cardConfig);
              cardElement.hass = this.hass;
              container.innerHTML = '';
              container.appendChild(cardElement);
            }
          }).catch(err => {
            console.warn('Card helpers not available, falling back to createElement:', err);
            this._createCardElementFallback(container, cardConfig);
          });
        } else {
          // Fallback for older HA or when helpers unavailable
          this._createCardElementFallback(container, cardConfig);
        }
      } catch (error) {
        console.error('Failed to render custom popup card:', error);
        container.innerHTML = `
          <div style="padding: 20px; text-align: center; opacity: 0.6;">
            <ha-icon icon="mdi:alert-circle" style="--mdc-icon-size: 48px; color: var(--error-color);"></ha-icon>
            <div style="margin-top: 12px;">Failed to load custom card</div>
            <div style="font-size: 12px; margin-top: 8px;">${error.message}</div>
          </div>
        `;
      }
    }

    _createCardElementFallback(container, cardConfig) {
      try {
        // Built-in HA cards are registered as hui-<type>-card, not as their YAML type name.
        // Custom cards (type starts with 'custom:') use the registered custom element name.
        const type = cardConfig.type || 'hui-error-card';
        let tagName;
        if (type.startsWith('custom:')) {
          tagName = type.replace('custom:', '');
        } else {
          tagName = `hui-${type}-card`;
        }
        const cardElement = document.createElement(tagName);
        
        // Set config first (some cards need this before hass)
        if (cardElement.setConfig) {
          cardElement.setConfig(cardConfig);
        }
        
        // Then set hass
        cardElement.hass = this.hass;

        // Clear container and add card
        container.innerHTML = '';
        container.appendChild(cardElement);
      } catch (error) {
        console.error('Fallback card creation failed:', error);
        container.innerHTML = `
          <div style="padding: 20px; text-align: center; opacity: 0.6;">
            <ha-icon icon="mdi:alert-circle" style="--mdc-icon-size: 48px; color: var(--error-color);"></ha-icon>
            <div style="margin-top: 12px;">Card type "${cardConfig.type}" not found</div>
            <div style="font-size: 11px; margin-top: 8px;">Make sure the card is installed and registered</div>
          </div>
        `;
      }
    }

    _setupSwitchHandlers(portal, entity, serviceDomain = null) {
      if (!portal || !entity) return;

      const getServiceDomainForId = (id) => {
        const d = String(id || '').split('.')[0];
        if (d === 'group') return 'homeassistant';
        return d === 'input_boolean' ? 'input_boolean' : 'switch';
      };
      const sd = serviceDomain || getServiceDomainForId(entity.entity_id || this._config.entity);

      // Group view handlers
      if (this._activeView === 'group') {
        portal.querySelectorAll('.switch-row').forEach((row) => {
          const id = row.getAttribute('data-entity-id');
          const toggle = row.querySelector('.switch-row-toggle');
          if (!id || !toggle) return;

          toggle.addEventListener('click', (ev) => {
            ev.stopPropagation();
            const st = this.hass?.states?.[id];
            const isOn = st?.state === 'on';
            const dom = getServiceDomainForId(id);
            this.hass.callService(dom, isOn ? 'turn_off' : 'turn_on', { entity_id: id });
          });
        });
        return;
      }

      // Main view: click track toggles
      if (this._activeView === 'history') return;

      const switchEl = portal.querySelector('#switchSlider');
      if (!switchEl) return;

      switchEl.addEventListener('click', () => {
        const isOn = entity.state === 'on';
        this.hass.callService(sd, isOn ? 'turn_off' : 'turn_on', { entity_id: this._config.entity });
      });
    }
    _renderLockPopupPortal(entity) {
      // Reuse existing portal to avoid flicker on hass updates.

      const name = this._getPopupName(entity);
      const state = entity.state;
      const isLocked = state === 'locked';
      const isUnlocked = state === 'unlocked';
      const isJammed = state === 'jammed';
      const isLocking = state === 'locking';
      const isUnlocking = state === 'unlocking';
      
      // Check contact sensor
      const contactSensorEntity = this._config.lock_contact_sensor_entity ? this.hass.states[this._config.lock_contact_sensor_entity] : null;
      const contactSensorState = contactSensorEntity ? contactSensorEntity.state : null;
      const isContactOpen = contactSensorState === 'on' || contactSensorState === 'open' || contactSensorState === true || contactSensorState === 'True';
      const contactOpenLabel = this._config.lock_contact_sensor_label || "Door Open";
      
      // Override color and state text if contact sensor is open
      let color = isLocked ? '#4CAF50' : (isJammed ? '#F44336' : '#FFC107');
      let icon = this._getResolvedIcon(entity, isLocked ? 'mdi:lock' : (isJammed ? 'mdi:lock-alert' : 'mdi:lock-open'));
      let stateText = this._getLocalizedState(state, 'lock');
      
      if (isContactOpen) {
        color = '#F44336'; // Red when contact sensor is open
        icon = this._getResolvedIcon(entity, 'mdi:lock-alert');
        stateText = contactOpenLabel;
      }
      
      const borderRadius = this._config.popup_slider_radius ?? 12;
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();
      const handleRadius = Math.round(borderRadius * 0.7); // Handle radius follows slider radius proportionally
      const valueSize = this._config.popup_value_font_size || 36;
      const valueWeight = this._config.popup_value_font_weight || 300;

      // Supported features: bit 0 (1) indicates "open" support for locks in Home Assistant
      const canOpenDoor = ((Number(entity?.attributes?.supported_features) || 0) & 1) === 1;

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-popup-portal';
      // Clear previous content when reusing.
      portal.innerHTML = '';

      // Calculate slider position (locked = top/100%, unlocked = bottom/0%)
      // Use actual state for slider position, not transition states
      const sliderPosition = (isLocked || isLocking) ? 100 : 0;
      
      // Calculate proper bottom position to keep handle inside container (handle is 120px tall, 50% of ~240px slider track)
      let handleBottom;
      if (sliderPosition === 0) {
        handleBottom = '4px';
      } else if (sliderPosition === 100) {
        handleBottom = 'calc(100% - 124px)';
      } else {
        handleBottom = `calc(${sliderPosition}% - 60px)`;
      }

      portal.innerHTML = `
        <style>
          .hki-popup-portal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            ${this._getPopupPortalStyle()}
            display: flex; align-items: center; justify-content: center; z-index: 9999;
          }
          .hki-popup-container {
            ${this._getPopupCardStyle()};
            border-radius: ${popupBorderRadius}px;
            width: ${popupWidth}; height: ${popupHeight};
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            display: flex; flex-direction: column; overflow: hidden; user-select: none; -webkit-user-select: none;
          }
          .hki-popup-header {
            display: flex; justify-content: space-between; align-items: center; padding: 16px 20px;
            background: rgba(255, 255, 255, 0.03); border-bottom: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            flex-shrink: 0;
          }
          .hki-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-popup-title img { width:28px;height:28px;border-radius:50%;object-fit:cover;flex-shrink:0; }
          .hki-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; }
          .hki-popup-state { font-size: 12px; opacity: 0.6; text-transform: capitalize; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: var(--divider-color, rgba(255, 255, 255, 0.05)); border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
          }
          .header-btn:hover { background: rgba(255, 255, 255, 0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }

          .hki-popup-content { 
            flex: 1; padding: 20px; overflow-y: auto; 
            display: flex; flex-direction: column; align-items: center; justify-content: center; 
            min-height: 0; 
          }

          .lock-slider-container {
            display: flex; flex-direction: column; align-items: center; gap: 12px;
            width: 80px; height: 320px;
          }
          
          .value-display {
            font-size: ${valueSize}px;
            font-weight: ${valueWeight};
            text-align: center;
          }
          
          .slider-label {
            font-size: 12px;
            opacity: 0.5;
            text-transform: uppercase;
            letter-spacing: 1px;
          }
          
          .vertical-slider-track {
            width: 100%; flex: 1;
            background: var(--secondary-background-color, rgba(255, 255, 255, 0.1));
            border: 2px solid var(--divider-color, rgba(255, 255, 255, 0.1));
            border-radius: ${borderRadius}px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
          }
          
          .vertical-slider-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: ${color};
            transition: height 0.3s ease, background 0.3s ease;
            height: ${sliderPosition}%;
            border-radius: 0 0 ${Math.max(0, borderRadius - 2)}px ${Math.max(0, borderRadius - 2)}px;
          }
          
          .vertical-slider-thumb {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            width: 74px;
            height: 120px;
            background: white;
            border-radius: ${handleRadius}px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6), 0 2px 8px rgba(0,0,0,0.4);
            cursor: grab;
            pointer-events: none;
            transition: bottom 0.3s ease;
            bottom: ${handleBottom};
          }

          .hki-popup-nav {
            display: flex; justify-content: space-evenly; padding: 12px;
            background: rgba(255, 255, 255, 0.03);
            border-top: 1px solid var(--divider-color, rgba(255, 255, 255, 0.05));
            gap: 8px;
            flex-shrink: 0;
            min-height: 74px; /* keep consistent even when empty */
            box-sizing: border-box;
          }
          .nav-btn {
            flex: 1; height: 50px; border-radius: 12px;
            border: none; background: transparent;
            color: var(--primary-text-color); opacity: 0.5;
            cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;
            transition: all 0.2s; font-size: 11px;
          }
          .nav-btn:hover { opacity: 0.8; background: rgba(255, 255, 255, 0.05); }
          .nav-btn.active { 
            opacity: 1; 
            background: var(--primary-color, rgba(255,255,255,0.1)); 
            color: var(--text-primary-color, var(--primary-text-color));
          }
          .nav-btn ha-icon { --mdc-icon-size: 24px; }

          .timeline-container { width: 100%; height: 100%; padding: 0 10px 10px 10px; box-sizing: border-box; overflow-y: auto; align-self: stretch; }
          .timeline-item { display: flex; gap: 16px; margin-bottom: 0; min-height: 40px; position: relative; }
          .timeline-visual { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
          .timeline-dot { width: 10px; height: 10px; border-radius: 50%; background: var(--primary-color, #FFD700); z-index: 2; border: 2px solid var(--card-background-color, #1c1c1c); margin-top: 3px; }
          .timeline-line { width: 2px; flex-grow: 1; background: var(--divider-color, rgba(255,255,255,0.12)); margin-top: -2px; margin-bottom: -4px; }
          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content { flex: 1; padding-bottom: 16px; font-size: 13px; color: var(--primary-text-color); }
          .timeline-detail { font-size: 11px; opacity: 0.6; display: block; margin-top: 4px; }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .timeline-trigger { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; font-style: italic; }
          .history-loading { width: 100%; text-align: center; padding: 20px; opacity: 0.6; }
        </style>

        <div class="hki-popup-container">
          <div class="hki-popup-header">
            <div class="hki-popup-title">
              ${this._getPopupHeaderIconHtml(entity, icon, this._getPopupIconColor(color))}
              <div class="hki-popup-title-text">
                ${name}
                <span class="hki-popup-state">${this._getPopupHeaderState(stateText)}${this._formatLastTriggered(entity) ? ` - ${this._formatLastTriggered(entity)}` : ''}</span>
              </div>
            </div>
            <div class="hki-popup-header-controls">
              <button class="header-btn" id="lockHistoryBtn"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>
              <button class="header-btn" id="closeBtn"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>

          <div class="hki-popup-content" id="lockContent">
            ${this._renderLockPopupContent(entity, color, icon, stateText, sliderPosition, borderRadius, valueSize, valueWeight)}
          </div>

          <div class="hki-popup-nav">
            ${canOpenDoor ? `
              <button class="nav-btn" id="openDoorBtn" style="${this._getPopupButtonStyle(false)}">
                <ha-icon icon="mdi:door-open"></ha-icon>
                ${this._config.popup_hide_button_text ? '' : '<span>Open Door</span>'}
              </button>
            ` : ''}
          </div>
        </div>
      `;

      const container = portal.querySelector('.hki-popup-container');
      if (container) container.addEventListener('click', (e) => e.stopPropagation());

      let isBackgroundClick = false;
      portal.addEventListener('mousedown', (e) => { isBackgroundClick = (e.target === portal); });
      portal.addEventListener('touchstart', (e) => { isBackgroundClick = (e.target === portal); }, { passive: true });
      portal.addEventListener('click', (e) => {
        if (isBackgroundClick && e.target === portal) this._closePopup();
        isBackgroundClick = false;
      });

      if (!this._popupPortal) {
        document.body.appendChild(portal);
        this._applyOpenAnimation(portal);
      }
      this._popupPortal = portal;

      const closeBtn = portal.querySelector('#closeBtn');
      if (closeBtn) closeBtn.addEventListener('click', () => this._closePopup());

      // Bottom bar entity buttons
      if (this._config.popup_hide_bottom_bar !== true) {
        const _bbNav = portal.querySelector('.hki-popup-nav');
        if (_bbNav) this._renderBottomBarEntityButtons(_bbNav);
      }

      const historyBtn = portal.querySelector('#lockHistoryBtn');
      if (historyBtn) {
        historyBtn.addEventListener('click', () => {
          this._activeView = this._activeView === 'history' ? 'main' : 'history';
          const content = portal.querySelector('#lockContent');
          if (content) {
            content.innerHTML = this._renderLockPopupContent(entity, color, icon, stateText, sliderPosition, borderRadius, valueSize, valueWeight);
            if (this._activeView === 'history') {
              setTimeout(() => this._loadHistory(), 100);
            } else {
              this._setupLockHandlers(portal, entity);
            }
          }
        });
      }

      const openDoorBtn = portal.querySelector('#openDoorBtn');
      if (openDoorBtn && canOpenDoor) {
        openDoorBtn.addEventListener('click', () => {
          this.hass.callService('lock', 'open', { entity_id: this._config.entity });
        });
      }

      this._setupLockHandlers(portal, entity);
    }

    _renderLockPopupContent(entity, color, icon, stateText, sliderPosition, borderRadius, valueSize, valueWeight) {
      if (this._activeView === 'history') {
        return `<div class="timeline-container" data-view-type="history" id="historyContainer"><div class="history-loading">Loading Timeline...</div></div>`;
      }

      return `
        <div class="lock-slider-container">
          <div class="value-display">${stateText}</div>
          <div class="vertical-slider-track" id="lockSlider">
            <div class="vertical-slider-fill"></div>
            <div class="vertical-slider-thumb"></div>
          </div>
          <div class="slider-label">Lock</div>
        </div>
      `;
    }

    _setupLockHandlers(portal, entity) {
      if (this._activeView === 'history') return;

      const slider = portal.querySelector('#lockSlider');
      if (!slider) return;
      
      const fill = slider.querySelector('.vertical-slider-fill');
      const thumb = slider.querySelector('.vertical-slider-thumb');
      const display = portal.querySelector('.value-display');
      
      slider.addEventListener('click', (e) => {
        const rect = slider.getBoundingClientRect();
        const clickY = e.clientY - rect.top;
        const clickPercent = (rect.height - clickY) / rect.height;
        
        // Optimistically update UI immediately
        if (clickPercent > 0.5) {
          // Locking
          if (fill) {
            fill.style.height = '100%';
            fill.style.background = '#4CAF50';
          }
          if (thumb) thumb.style.bottom = 'calc(100% - 60px)';
          if (display) display.textContent = 'Locking';
          
          this.hass.callService('lock', 'lock', { entity_id: this._config.entity });
        } else {
          // Unlocking
          if (fill) {
            fill.style.height = '0%';
            fill.style.background = '#FFC107';
          }
          if (thumb) thumb.style.bottom = '4px';
          if (display) display.textContent = 'Unlocking';
          
          this.hass.callService('lock', 'unlock', { entity_id: this._config.entity });
        }
      });
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // SENSOR POPUP
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    async _renderSensorPopupPortal(entity) {
      const name = this._getPopupName(entity);
      const domain = 'sensor';
      const state = entity.state;
      const unit = entity.attributes?.unit_of_measurement || '';
      const icon = this._getResolvedIcon(entity, 'mdi:chart-line');
      const color = 'var(--primary-color, #2196F3)';
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();
      const graphColor = this._config.sensor_graph_color || null;
      const useGradient = this._config.sensor_graph_gradient !== false;
      const lineWidth = this._config.sensor_line_width ?? 3;
      const sensorHours = parseInt(this._config.sensor_hours ?? 24, 10);
      this._currentSensorHours = sensorHours;
      const showBottomBar = this._config.popup_hide_bottom_bar !== true;

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-popup-portal';
      portal.innerHTML = '';

      portal.innerHTML = `
        <style>
          .hki-popup-portal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            ${this._getPopupPortalStyle()}
            display: flex; align-items: center; justify-content: center; z-index: 9999;
          }
          .hki-popup-container {
            ${this._getPopupCardStyle()};
            border-radius: ${popupBorderRadius}px;
            width: ${popupWidth}; height: ${popupHeight};
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            display: flex; flex-direction: column; overflow: hidden; user-select: none;
          }
          .hki-popup-header {
            display: flex; justify-content: space-between; align-items: center; padding: 16px 20px;
            background: rgba(255,255,255,0.03); border-bottom: 1px solid var(--divider-color, rgba(255,255,255,0.05));
            flex-shrink: 0;
          }
          .hki-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-popup-title img { width:28px;height:28px;border-radius:50%;object-fit:cover;flex-shrink:0; }
          .hki-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; }
          .hki-popup-state { font-size: 12px; opacity: 0.6; text-transform: capitalize; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn {
            width: 40px; height: 40px; border-radius: 50%;
            background: var(--divider-color, rgba(255,255,255,0.05)); border: none;
            color: var(--primary-text-color); cursor: pointer;
            display: flex; align-items: center; justify-content: center; transition: all 0.2s;
          }
          .header-btn:hover { background: rgba(255,255,255,0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }
          .hki-popup-content { flex: 1; overflow-y: auto; display: flex; flex-direction: column; min-height: 0; padding: 16px; gap: 0; }
          .sensor-tile { background: rgba(255,255,255,0.05); border-radius: 18px; padding: 18px; box-shadow: 0 6px 18px rgba(0,0,0,0.25); display: flex; flex-direction: column; gap: 12px; }
          .sensor-value-row { display: flex; align-items: baseline; justify-content: flex-end; }
          .sensor-tile-value { font-size: 36px; font-weight: 700; letter-spacing: -1px; }
          .sensor-tile-unit { font-size: 18px; font-weight: 400; opacity: 0.7; margin-left: 3px; }
          .sensor-tile-graph { width: 100%; height: 160px; overflow: hidden; border-radius: 14px; background: rgba(0,0,0,0.12); box-sizing: border-box; position: relative; }
          .sensor-tile-graph svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; }
          .sensor-yaxis { position: absolute; top: 0; left: 0; height: 100%; width: 38px; display: flex; flex-direction: column; justify-content: space-between; padding: 11px 4px 16px 0; box-sizing: border-box; pointer-events: none; }
          .sensor-yaxis span { font-size: 9px; color: rgba(255,255,255,0.4); font-family: sans-serif; text-align: right; display: block; line-height: 1; white-space: nowrap; }
          .sensor-hours-row { display: flex; justify-content: flex-end; gap: 6px; }
          .sensor-hour-btn { padding: 3px 10px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.12); background: rgba(255,255,255,0.06); color: var(--primary-text-color); font-size: 11px; cursor: pointer; transition: all 0.15s; }
          .sensor-hour-btn.active { background: var(--primary-color,#03a9f4); border-color: var(--primary-color,#03a9f4); font-weight: 600; }
          .sensor-hour-btn:hover:not(.active) { background: rgba(255,255,255,0.12); }
          .timeline-container { width: 100%; display: flex; flex-direction: column; gap: 0; }
          .timeline-item { display: flex; gap: 12px; position: relative; }
          .timeline-visual { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
          .timeline-dot { width: 10px; height: 10px; border-radius: 50%; background: #2196F3; z-index: 2; border: 2px solid var(--card-background-color, #1c1c1c); }
          .timeline-line { width: 2px; flex-grow: 1; background: var(--divider-color, rgba(255,255,255,0.1)); margin-top: -2px; margin-bottom: -4px; }
          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content { flex: 1; padding-bottom: 16px; font-size: 13px; color: var(--primary-text-color); }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .timeline-trigger { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; font-style: italic; }
          .history-loading { width: 100%; text-align: center; padding: 20px; opacity: 0.6; }
          .hki-popup-nav {
            display: flex; justify-content: space-evenly; padding: 12px;
            background: rgba(255,255,255,0.03);
            border-top: 1px solid var(--divider-color, rgba(255,255,255,0.05));
            flex-shrink: 0; min-height: 74px; box-sizing: border-box;
            ${showBottomBar ? '' : 'display: none !important;'}
          }
        </style>
        <div class="hki-popup-container">
          <div class="hki-popup-header">
            <div class="hki-popup-title">
              ${this._getPopupHeaderIconHtml(entity, icon, this._getPopupIconColor(color))}
              <div class="hki-popup-title-text">
                ${name}
                <span class="hki-popup-state">${this._getPopupHeaderState(state + (unit ? ' ' + unit : ''))}${this._formatLastTriggered(entity) ? ' - ' + this._formatLastTriggered(entity) : ''}</span>
              </div>
            </div>
            <div class="hki-popup-header-controls">
              <button class="header-btn" id="sensorHistoryBtn" title="History"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>
              <button class="header-btn" id="closeBtn" title="Close"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>
          <div class="hki-popup-content" id="sensorContent">
            <div class="sensor-tile">
              <div class="sensor-value-row"><span class="sensor-tile-value">${state}</span><span class="sensor-tile-unit">${unit}</span></div>
              <div class="sensor-tile-graph" id="sensorSparkline"><div class="history-loading" style="padding:10px 0">Loading chartâ€¦</div></div>
              <div class="sensor-hours-row">${[12,24,48,72].map(h => `<button class="sensor-hour-btn${h === sensorHours ? ' active' : ''}" data-hours="${h}">${h}h</button>`).join('')}</div>
            </div>
          </div>
          <div class="hki-popup-nav"></div>
        </div>
      `;

      const container = portal.querySelector('.hki-popup-container');
      if (container) container.addEventListener('click', (e) => e.stopPropagation());
      let isBackgroundClick = false;
      portal.addEventListener('mousedown', (e) => { isBackgroundClick = (e.target === portal); });
      portal.addEventListener('touchstart', (e) => { isBackgroundClick = (e.target === portal); }, { passive: true });
      portal.addEventListener('click', (e) => { if (isBackgroundClick && e.target === portal) this._closePopup(); isBackgroundClick = false; });

      if (!this._popupPortal) { document.body.appendChild(portal); this._applyOpenAnimation(portal); }
      this._popupPortal = portal;

      portal.querySelector('#closeBtn')?.addEventListener('click', () => this._closePopup());

      // Bottom bar entity buttons
      if (this._config.popup_hide_bottom_bar !== true) {
        const _bbNav = portal.querySelector('.hki-popup-nav');
        if (_bbNav) this._renderBottomBarEntityButtons(_bbNav);
      }
      portal.querySelector('#sensorHistoryBtn')?.addEventListener('click', () => {
        this._activeView = this._activeView === 'history' ? 'main' : 'history';
        this._renderSensorPopupPortal(this._getEntity());
        if (this._activeView === 'history') setTimeout(() => this._loadHistory(), 100);
      });

      if (this._activeView === 'history') {
        const content = portal.querySelector('#sensorContent');
        if (content) content.innerHTML = '<div id="historyContainer" class="timeline-container"><div class="history-loading">Loading historyâ€¦</div></div>';
        setTimeout(() => this._loadHistory(), 100);
      } else {
        // Load sparkline and wire hour picker
        setTimeout(() => {
          const graphStyle = this._config.sensor_graph_style || 'line';
          this._loadSensorSparkline(portal, entity, graphColor, useGradient, lineWidth, sensorHours, graphStyle);
          portal.querySelectorAll('.sensor-hour-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.stopPropagation();
              const h = parseInt(btn.dataset.hours, 10);
              this._currentSensorHours = h;
              portal.querySelectorAll('.sensor-hour-btn').forEach(b => b.classList.toggle('active', b === btn));
              this._loadSensorSparkline(portal, this._getEntity(), graphColor, useGradient, lineWidth, h, this._config.sensor_graph_style || 'line');
            });
          });
        }, 50);
      }
    }

    async _loadSensorSparkline(portal, entity, graphColor, useGradient, lineWidth, hours = 24, graphStyle = 'line') {
      const wrap = portal.querySelector('#sensorSparkline');
      if (!wrap) return;
      try {
        const entityId = entity.entity_id;
        const startTs = new Date(Date.now() - hours * 60 * 60 * 1000);
        const data = await this.hass.callApi('GET', `history/period/${startTs.toISOString()}?filter_entity_id=${encodeURIComponent(entityId)}&minimal_response`);
        const series = (Array.isArray(data) && data[0]) ? data[0] : [];
        const pts = [];
        for (const it of series) {
          const ts = it?.lu ?? it?.last_updated ?? it?.last_changed;
          if (!ts) continue;
          const n = parseFloat(String(it?.s ?? it?.state));
          if (!Number.isFinite(n)) continue;
          pts.push({ t: new Date(ts).getTime(), v: n });
        }
        pts.sort((a, b) => a.t - b.t);
        if (pts.length < 2) { wrap.innerHTML = '<div class="history-loading">Not enough data</div>'; return; }
        // Downsample
        const maxN = 80;
        const ds = pts.length > maxN ? pts.filter((_, i) => i % Math.ceil(pts.length / maxN) === 0) : pts;

        // Layout: left pad for y-axis labels, top/bottom pad so line stays inset
        const FULL_W = 300, FULL_H = 140;
        const PAD_L = 36, PAD_R = 6, PAD_T = 10, PAD_B = 14;
        const W = FULL_W - PAD_L - PAD_R;
        const H = FULL_H - PAD_T - PAD_B;

        const minV = Math.min(...ds.map(p => p.v));
        const maxV = Math.max(...ds.map(p => p.v));
        const span = (maxV - minV) || 1;
        const t0 = ds[0].t, t1 = ds[ds.length - 1].t, tSpan = (t1 - t0) || 1;

        const mapX = t => PAD_L + ((t - t0) / tSpan) * W;
        const mapY = v => PAD_T + (1 - (v - minV) / span) * H;
        const xy = ds.map(p => ({ x: mapX(p.t), y: mapY(p.v), v: p.v }));

        const gradId = 'sg' + Math.random().toString(16).slice(2);
        const clipId = 'cl' + Math.random().toString(16).slice(2);
        const strokeColor = graphColor || 'var(--primary-color, #2196F3)';

        // Build defs: clipPath always + optional gradient
        let defsInner = `<clipPath id="${clipId}"><rect x="${PAD_L}" y="${PAD_T}" width="${W}" height="${H}"/></clipPath>`;
        if (useGradient && !graphColor) {
          const stops = [];
          const cnt = Math.min(10, xy.length);
          for (let i = 0; i < cnt; i++) {
            const idx = Math.round(i * (xy.length - 1) / (cnt - 1 || 1));
            const p = xy[idx];
            const n = (p.v - minV) / span;
            const hue = 200 * (1 - n);
            const offset = ((p.x - PAD_L) / W * 100).toFixed(1);
            stops.push(`<stop offset="${offset}%" stop-color="hsl(${hue},90%,60%)" />`);
          }
          defsInner += `<linearGradient id="${gradId}" x1="0" y1="0" x2="1" y2="0">${stops.join('')}</linearGradient>`;
        } else if (graphColor) {
          defsInner += `<linearGradient id="${gradId}" x1="0" y1="0" x2="1" y2="0"><stop offset="0%" stop-color="${graphColor}" stop-opacity="0.7"/><stop offset="100%" stop-color="${graphColor}"/></linearGradient>`;
        }

        const lineStroke = (useGradient || graphColor) ? `url(#${gradId})` : strokeColor;
        const line = xy.map(p => `${p.x.toFixed(1)},${p.y.toFixed(1)}`).join(' ');
        const areaBottom = PAD_T + H;
        const area = `${PAD_L},${areaBottom} ${line} ${PAD_L + W},${areaBottom}`;

        // Y-axis: 3 levels with gridlines + labels
        const fmt = v => {
          const abs = Math.abs(v);
          if (abs >= 1000) return (v/1000).toFixed(1) + 'k';
          if (abs >= 100) return v.toFixed(0);
          if (abs >= 10) return v.toFixed(1);
          return v.toFixed(2);
        };
        const yLevels = [
          { v: maxV, y: PAD_T },
          { v: (minV + maxV) / 2, y: PAD_T + H / 2 },
          { v: minV, y: PAD_T + H },
        ];
        const gridLines = yLevels.map(l =>
          `<line x1="${PAD_L}" y1="${l.y.toFixed(1)}" x2="${(PAD_L + W).toFixed(1)}" y2="${l.y.toFixed(1)}" stroke="rgba(255,255,255,0.07)" stroke-width="1"/>`
        ).join('');
        const yAxisLine = `<line x1="${PAD_L}" y1="${PAD_T}" x2="${PAD_L}" y2="${PAD_T + H}" stroke="rgba(255,255,255,0.1)" stroke-width="1"/>`;
        // Y labels rendered as HTML (not SVG text) to avoid distortion from preserveAspectRatio:none
        const yHtmlLabels = `<div class="sensor-yaxis"><span>${fmt(maxV)}</span><span>${fmt((minV+maxV)/2)}</span><span>${fmt(minV)}</span></div>`;

        let chartBody = '';
        if (graphStyle === 'bar') {
          // Bar chart: one rect per data point
          const barW = Math.max(1, (W / ds.length) * 0.7);
          const gap = W / ds.length;
          chartBody = ds.map((p, idx) => {
            const x = mapX(p.t) - barW / 2;
            const yTop = mapY(p.v);
            const barH = Math.max(1, (PAD_T + H) - yTop);
            const n = (p.v - minV) / span;
            const hue = 200 * (1 - n);
            const col = (useGradient && !graphColor) ? `hsl(${hue},90%,60%)` : lineStroke;
            return `<rect x="${x.toFixed(1)}" y="${yTop.toFixed(1)}" width="${barW.toFixed(1)}" height="${barH.toFixed(1)}" fill="${col}" rx="2" opacity="0.85"/>`;
          }).join('');
        } else {
          chartBody = `<polygon points="${area}" fill="${lineStroke}" opacity="0.12"/>
            <polyline points="${line}" fill="none" stroke="${lineStroke}" stroke-width="${lineWidth}" stroke-linecap="round" stroke-linejoin="round"/>`;
        }

        wrap.innerHTML = yHtmlLabels + `<svg viewBox="0 0 ${FULL_W} ${FULL_H}" preserveAspectRatio="none" style="display:block;width:100%;height:100%;">
          <defs>${defsInner}</defs>
          ${gridLines}
          ${yAxisLine}
          <g clip-path="url(#${clipId})">${chartBody}</g>
        </svg>`;
      } catch (e) {
        console.warn('sensor sparkline error', e);
        wrap.innerHTML = '<div class="history-loading">Error loading chart</div>';
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // BINARY SENSOR / DEVICE TRACKER / EVENT POPUP
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _renderBinarySensorPopupPortal(entity) {
      const name = this._getPopupName(entity);
      const domain = (entity.entity_id || '').split('.')[0];
      const state = entity.state;
      const deviceClass = entity.attributes?.device_class || '';
      const showBottomBar = this._config.popup_hide_bottom_bar !== true;
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();

      // Determine if entity is "active"
      const activeStates = new Set(['on', 'home', 'detected', 'open', 'motion', 'occupied', 'connected', 'locked', 'problem', 'leak', 'smoke', 'fire', 'vibration', 'sound', 'power']);
      const isActive = activeStates.has(state);
      
      // Pick icon and color based on device class + state
      const dcIconMap = {
        motion: { on: 'mdi:motion-sensor', off: 'mdi:motion-sensor-off' },
        occupancy: { on: 'mdi:home-account', off: 'mdi:home-outline' },
        door: { on: 'mdi:door-open', off: 'mdi:door-closed' },
        window: { on: 'mdi:window-open', off: 'mdi:window-closed' },
        lock: { on: 'mdi:lock-open', off: 'mdi:lock' },
        smoke: { on: 'mdi:smoke-detector-alert', off: 'mdi:smoke-detector' },
        moisture: { on: 'mdi:water', off: 'mdi:water-off' },
        battery: { on: 'mdi:battery-alert', off: 'mdi:battery' },
        connectivity: { on: 'mdi:wifi', off: 'mdi:wifi-off' },
        plug: { on: 'mdi:power-plug', off: 'mdi:power-plug-off' },
        presence: { on: 'mdi:home-account', off: 'mdi:home-outline' },
      };
      const dcColor = { on: '#4CAF50', off: '#546E7A' };
      const dcBadMap = { smoke: true, moisture: true, battery: true, problem: true, gas: true, tamper: true, sound: true, vibration: true, power: true };
      const isBadActive = dcBadMap[deviceClass];
      const activeColor = isBadActive ? '#F44336' : '#4CAF50';

      const iconPair = dcIconMap[deviceClass];
      const icon = this._getResolvedIcon(entity, iconPair ? (isActive ? iconPair.on : iconPair.off) : (domain === 'device_tracker' ? 'mdi:map-marker-account' : 'mdi:radiobox-marked'));
      const color = isActive ? activeColor : '#546E7A';

      const stateLabel = this._getLocalizedState(state, domain) || state;

      // Build a state bar (like the HA history card)
      const stateBarInner = this._activeView === 'history' ? '' : this._buildStateBars(entity, domain, deviceClass, isActive, color);

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-popup-portal';
      portal.innerHTML = '';

      portal.innerHTML = `
        <style>
          .hki-popup-portal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; ${this._getPopupPortalStyle()} display: flex; align-items: center; justify-content: center; z-index: 9999; }
          .hki-popup-container { ${this._getPopupCardStyle()}; border-radius: ${popupBorderRadius}px; width: ${popupWidth}; height: ${popupHeight}; box-shadow: 0 8px 32px rgba(0,0,0,0.4); display: flex; flex-direction: column; overflow: hidden; user-select: none; }
          .hki-popup-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; background: rgba(255,255,255,0.03); border-bottom: 1px solid var(--divider-color, rgba(255,255,255,0.05)); flex-shrink: 0; }
          .hki-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-popup-title img { width:28px;height:28px;border-radius:50%;object-fit:cover;flex-shrink:0; }
          .hki-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; }
          .hki-popup-state { font-size: 12px; opacity: 0.6; text-transform: capitalize; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn { width: 40px; height: 40px; border-radius: 50%; background: var(--divider-color, rgba(255,255,255,0.05)); border: none; color: var(--primary-text-color); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
          .header-btn:hover { background: rgba(255,255,255,0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }
          .hki-popup-content { flex: 1; padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 16px; min-height: 0; }
          .bs-state-card { background: rgba(255,255,255,0.05); border-radius: 18px; padding: 24px; display: flex; flex-direction: column; align-items: center; gap: 16px; }
          .bs-icon-wrap { width: 80px; height: 80px; border-radius: 50%; display: flex; align-items: center; justify-content: center; background: ${color}22; border: 2px solid ${color}; }
          .bs-icon-wrap ha-icon { --mdc-icon-size: 40px; color: ${color}; }
          .bs-state-label { font-size: 28px; font-weight: 700; text-align: center; }
          .bs-state-sub { font-size: 13px; opacity: 0.6; text-align: center; }
          .state-bar-section { width: 100%; }
          .state-bar-title { font-size: 12px; font-weight: 600; opacity: 0.7; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 1px; }
          .state-bar-container { width: 100%; height: 28px; border-radius: 6px; overflow: hidden; display: flex; }
          .state-bar-segment { height: 100%; transition: width 0.3s; cursor: default; position: relative; }
          .state-bar-segment:hover::after { content: attr(data-tip); position: absolute; top: -28px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; font-size: 10px; padding: 2px 6px; border-radius: 4px; white-space: nowrap; pointer-events: none; }
          .state-bar-labels { display: flex; justify-content: space-between; margin-top: 4px; font-size: 10px; opacity: 0.5; }
          .timeline-container { width: 100%; }
          .timeline-item { display: flex; gap: 12px; position: relative; }
          .timeline-visual { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
          .timeline-dot { width: 10px; height: 10px; border-radius: 50%; z-index: 2; border: 2px solid var(--card-background-color, #1c1c1c); }
          .timeline-line { width: 2px; flex-grow: 1; background: var(--divider-color, rgba(255,255,255,0.1)); margin-top: -2px; margin-bottom: -4px; }
          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content { flex: 1; padding-bottom: 14px; font-size: 13px; }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .history-loading { width: 100%; text-align: center; padding: 20px; opacity: 0.6; }
          .hki-popup-nav { display: flex; justify-content: space-evenly; padding: 12px; background: rgba(255,255,255,0.03); border-top: 1px solid var(--divider-color, rgba(255,255,255,0.05)); flex-shrink: 0; min-height: 74px; box-sizing: border-box; ${showBottomBar ? '' : 'display: none !important;'} }
        </style>
        <div class="hki-popup-container">
          <div class="hki-popup-header">
            <div class="hki-popup-title">
              ${this._getPopupHeaderIconHtml(entity, icon, this._getPopupIconColor(color))}
              <div class="hki-popup-title-text">
                ${name}
                <span class="hki-popup-state">${this._getPopupHeaderState(stateLabel)}${this._formatLastTriggered(entity) ? ' - ' + this._formatLastTriggered(entity) : ''}</span>
              </div>
            </div>
            <div class="hki-popup-header-controls">
              <button class="header-btn" id="bsHistoryBtn" title="History"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>
              <button class="header-btn" id="closeBtn" title="Close"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>
          <div class="hki-popup-content" id="bsContent">
            ${this._activeView === 'history'
              ? '<div id="historyContainer" class="timeline-container"><div class="history-loading">Loadingâ€¦</div></div>'
              : `<div class="bs-state-card">
                  <div class="bs-icon-wrap"><ha-icon icon="${icon}"></ha-icon></div>
                  <div class="bs-state-label">${stateLabel}</div>
                  <div class="bs-state-sub">${entity.attributes?.friendly_name || name}</div>
                </div>
                ${stateBarInner}`}
          </div>
          <div class="hki-popup-nav"></div>
        </div>
      `;

      const container = portal.querySelector('.hki-popup-container');
      if (container) container.addEventListener('click', (e) => e.stopPropagation());
      let isBackgroundClick = false;
      portal.addEventListener('mousedown', (e) => { isBackgroundClick = (e.target === portal); });
      portal.addEventListener('touchstart', (e) => { isBackgroundClick = (e.target === portal); }, { passive: true });
      portal.addEventListener('click', (e) => { if (isBackgroundClick && e.target === portal) this._closePopup(); isBackgroundClick = false; });

      if (!this._popupPortal) { document.body.appendChild(portal); this._applyOpenAnimation(portal); }
      this._popupPortal = portal;

      portal.querySelector('#closeBtn')?.addEventListener('click', () => this._closePopup());

      // Bottom bar entity buttons
      if (this._config.popup_hide_bottom_bar !== true) {
        const _bbNav = portal.querySelector('.hki-popup-nav');
        if (_bbNav) this._renderBottomBarEntityButtons(_bbNav);
      }
      portal.querySelector('#bsHistoryBtn')?.addEventListener('click', () => {
        this._activeView = this._activeView === 'history' ? 'main' : 'history';
        this._renderBinarySensorPopupPortal(this._getEntity());
        if (this._activeView === 'history') setTimeout(() => this._loadHistory(), 100);
      });

      if (this._activeView === 'history') setTimeout(() => this._loadHistory(), 100);
      else setTimeout(() => this._loadBinaryStateBars(portal, entity, domain, deviceClass, isActive, color), 80);
    }

    async _loadBinaryStateBars(portal, entity, domain, deviceClass, isActive, activeColor) {
      const wrap = portal.querySelector('#bsStateBar');
      if (!wrap) return;
      try {
        const entityId = entity.entity_id;
        const startTs = new Date(Date.now() - 24 * 60 * 60 * 1000);
        const data = await this.hass.callApi('GET', `history/period/${startTs.toISOString()}?filter_entity_id=${encodeURIComponent(entityId)}&minimal_response`);
        const series = (Array.isArray(data) && data[0]) ? data[0] : [];
        if (series.length < 2) { wrap.innerHTML = '<div class="history-loading" style="padding:8px 0;">No history data</div>'; return; }

        const pts = series.map(it => ({
          t: new Date(it?.lu ?? it?.last_updated ?? it?.last_changed ?? 0).getTime(),
          s: String(it?.s ?? it?.state ?? '')
        })).filter(p => p.t > 0);
        pts.sort((a, b) => a.t - b.t);

        const now = Date.now();
        const t0 = pts[0].t;
        const tSpan = now - t0;
        const segments = [];
        const activeSet = new Set(['on', 'home', 'detected', 'open', 'motion', 'occupied', 'connected', 'locked', 'problem', 'leak', 'smoke', 'fire', 'vibration', 'sound', 'power']);

        for (let i = 0; i < pts.length; i++) {
          const s = pts[i].s;
          const start = pts[i].t;
          const end = i + 1 < pts.length ? pts[i + 1].t : now;
          const width = ((end - start) / tSpan * 100).toFixed(2);
          const active = activeSet.has(s);
          const segColor = active ? activeColor : 'rgba(128,128,128,0.25)';
          const stateLabel = this._getLocalizedState(s, domain) || s;
          const dur = this._getTimeAgo(new Date(start));
          segments.push(`<div class="state-bar-segment" style="width:${width}%;background:${segColor}" data-tip="${stateLabel} ${dur}"></div>`);
        }

        const tFmt = (ts) => {
          const d = new Date(ts);
          return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        };

        wrap.innerHTML = `
          <div class="state-bar-title">Activity (24h)</div>
          <div class="state-bar-container">${segments.join('')}</div>
          <div class="state-bar-labels"><span>${tFmt(t0)}</span><span>${tFmt(now)}</span></div>
        `;
      } catch (e) {
        wrap.innerHTML = '<div class="history-loading" style="padding:8px 0;">Error</div>';
      }
    }

    _buildStateBars(entity, domain, deviceClass, isActive, color) {
      // Returns placeholder â€” actual bar is loaded async via _loadBinaryStateBars
      return `<div class="state-bar-section" id="bsStateBar"><div class="history-loading" style="padding:8px 0;">Loading activityâ€¦</div></div>`;
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // SELECT / INPUT_SELECT POPUP
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _renderSelectPopupPortal(entity) {
      const name = this._getPopupName(entity);
      const domain = (entity.entity_id || '').split('.')[0];
      const currentOption = entity.state;
      const options = entity.attributes?.options || [];
      const icon = this._getResolvedIcon(entity, 'mdi:format-list-bulleted');
      const color = 'var(--primary-color, #9C27B0)';
      const showBottomBar = this._config.popup_hide_bottom_bar !== true;
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();
      const hlColor = this._config.popup_highlight_color || 'var(--primary-color, #03a9f4)';
      const hlRadius = this._config.popup_highlight_radius ?? 14;

      const optionRows = options.map(opt => {
        const sel = opt === currentOption;
        const bg = sel ? hlColor : 'rgba(255,255,255,0.05)';
        const border = sel ? hlColor : 'rgba(255,255,255,0.08)';
        const fw = sel ? '600' : '400';
        return `<button class="select-option ${sel ? 'active' : ''}" data-option="${opt}" style="background:${bg};border-color:${border};font-weight:${fw};border-radius:${hlRadius}px;">${opt}</button>`;
      }).join('');

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-popup-portal';
      portal.innerHTML = '';

      portal.innerHTML = `
        <style>
          .hki-popup-portal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; ${this._getPopupPortalStyle()} display: flex; align-items: center; justify-content: center; z-index: 9999; }
          .hki-popup-container { ${this._getPopupCardStyle()}; border-radius: ${popupBorderRadius}px; width: ${popupWidth}; height: ${popupHeight}; box-shadow: 0 8px 32px rgba(0,0,0,0.4); display: flex; flex-direction: column; overflow: hidden; user-select: none; }
          .hki-popup-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; background: rgba(255,255,255,0.03); border-bottom: 1px solid var(--divider-color, rgba(255,255,255,0.05)); flex-shrink: 0; }
          .hki-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-popup-title img { width:28px;height:28px;border-radius:50%;object-fit:cover;flex-shrink:0; }
          .hki-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; }
          .hki-popup-state { font-size: 12px; opacity: 0.6; text-transform: capitalize; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn { width: 40px; height: 40px; border-radius: 50%; background: var(--divider-color, rgba(255,255,255,0.05)); border: none; color: var(--primary-text-color); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
          .header-btn:hover { background: rgba(255,255,255,0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }
          .hki-popup-content { flex: 1; padding: 16px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; min-height: 0; }
          .select-option { width: 100%; padding: 16px 20px; border: 2px solid; cursor: pointer; font-size: 15px; color: var(--primary-text-color); text-align: left; transition: all 0.15s ease; }
          .select-option:hover { opacity: 0.85; transform: scale(1.01); }
          .select-option.active { box-shadow: 0 2px 12px rgba(0,0,0,0.25); }
          .timeline-container { width: 100%; }
          .timeline-item { display: flex; gap: 12px; position: relative; }
          .timeline-visual { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
          .timeline-dot { width: 10px; height: 10px; border-radius: 50%; background: #9C27B0; z-index: 2; border: 2px solid var(--card-background-color, #1c1c1c); }
          .timeline-line { width: 2px; flex-grow: 1; background: var(--divider-color, rgba(255,255,255,0.1)); margin-top: -2px; margin-bottom: -4px; }
          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content { flex: 1; padding-bottom: 14px; font-size: 13px; }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .timeline-trigger { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; font-style: italic; }
          .history-loading { width: 100%; text-align: center; padding: 20px; opacity: 0.6; }
          .hki-popup-nav { display: flex; justify-content: space-evenly; padding: 12px; background: rgba(255,255,255,0.03); border-top: 1px solid var(--divider-color, rgba(255,255,255,0.05)); flex-shrink: 0; min-height: 74px; box-sizing: border-box; ${showBottomBar ? '' : 'display: none !important;'} }
        </style>
        <div class="hki-popup-container">
          <div class="hki-popup-header">
            <div class="hki-popup-title">
              ${this._getPopupHeaderIconHtml(entity, icon, this._getPopupIconColor(color))}
              <div class="hki-popup-title-text">
                ${name}
                <span class="hki-popup-state">${this._getPopupHeaderState(currentOption)}${this._formatLastTriggered(entity) ? ' - ' + this._formatLastTriggered(entity) : ''}</span>
              </div>
            </div>
            <div class="hki-popup-header-controls">
              <button class="header-btn" id="selectHistoryBtn" title="History"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>
              <button class="header-btn" id="closeBtn" title="Close"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>
          <div class="hki-popup-content" id="selectContent">
            ${this._activeView === 'history'
              ? '<div id="historyContainer" class="timeline-container"><div class="history-loading">Loadingâ€¦</div></div>'
              : optionRows}
          </div>
          <div class="hki-popup-nav"></div>
        </div>
      `;

      const container = portal.querySelector('.hki-popup-container');
      if (container) container.addEventListener('click', (e) => e.stopPropagation());
      let isBackgroundClick = false;
      portal.addEventListener('mousedown', (e) => { isBackgroundClick = (e.target === portal); });
      portal.addEventListener('touchstart', (e) => { isBackgroundClick = (e.target === portal); }, { passive: true });
      portal.addEventListener('click', (e) => { if (isBackgroundClick && e.target === portal) this._closePopup(); isBackgroundClick = false; });

      if (!this._popupPortal) { document.body.appendChild(portal); this._applyOpenAnimation(portal); }
      this._popupPortal = portal;

      portal.querySelector('#closeBtn')?.addEventListener('click', () => this._closePopup());

      // Bottom bar entity buttons
      if (this._config.popup_hide_bottom_bar !== true) {
        const _bbNav = portal.querySelector('.hki-popup-nav');
        if (_bbNav) this._renderBottomBarEntityButtons(_bbNav);
      }
      portal.querySelector('#selectHistoryBtn')?.addEventListener('click', () => {
        this._activeView = this._activeView === 'history' ? 'main' : 'history';
        this._renderSelectPopupPortal(this._getEntity());
        if (this._activeView === 'history') setTimeout(() => this._loadHistory(), 100);
      });

      portal.querySelectorAll('.select-option').forEach(btn => {
        btn.addEventListener('click', () => {
          const opt = btn.dataset.option;
          const svc = domain === 'input_select' ? 'input_select' : 'select';
          const svcCall = domain === 'input_select' ? 'select_option' : 'select_option';
          this.hass.callService(svc, svcCall, { entity_id: this._config.entity, option: opt });
          setTimeout(() => this._renderSelectPopupPortal(this._getEntity()), 300);
        });
      });

      if (this._activeView === 'history') setTimeout(() => this._loadHistory(), 100);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // NUMBER / INPUT_NUMBER POPUP
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _renderNumberPopupPortal(entity) {
      const name = this._getPopupName(entity);
      const domain = (entity.entity_id || '').split('.')[0];
      const rawVal = parseFloat(entity.state) || 0;
      const min = parseFloat(entity.attributes?.min) ?? 0;
      const max = parseFloat(entity.attributes?.max) ?? 100;
      const step = parseFloat(entity.attributes?.step) ?? 1;
      const unit = entity.attributes?.unit_of_measurement || '';
      const icon = this._getResolvedIcon(entity, 'mdi:numeric');
      const color = 'var(--primary-color, #FF9800)';
      const showBottomBar = this._config.popup_hide_bottom_bar !== true;
      const borderRadius = this._config.popup_slider_radius ?? 12;
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();
      const handleRadius = Math.round(borderRadius * 0.7);
      const valueSize = this._config.popup_value_font_size ?? 36;
      const valueWeight = this._config.popup_value_font_weight ?? 300;
      const pct = Math.max(0, Math.min(100, ((rawVal - min) / (max - min)) * 100));

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-popup-portal';
      portal.innerHTML = '';

      portal.innerHTML = `
        <style>
          .hki-popup-portal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; ${this._getPopupPortalStyle()} display: flex; align-items: center; justify-content: center; z-index: 9999; }
          .hki-popup-container { ${this._getPopupCardStyle()}; border-radius: ${popupBorderRadius}px; width: ${popupWidth}; height: ${popupHeight}; box-shadow: 0 8px 32px rgba(0,0,0,0.4); display: flex; flex-direction: column; overflow: hidden; user-select: none; }
          .hki-popup-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; background: rgba(255,255,255,0.03); border-bottom: 1px solid var(--divider-color, rgba(255,255,255,0.05)); flex-shrink: 0; }
          .hki-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-popup-title img { width:28px;height:28px;border-radius:50%;object-fit:cover;flex-shrink:0; }
          .hki-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; }
          .hki-popup-state { font-size: 12px; opacity: 0.6; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn { width: 40px; height: 40px; border-radius: 50%; background: var(--divider-color, rgba(255,255,255,0.05)); border: none; color: var(--primary-text-color); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
          .header-btn:hover { background: rgba(255,255,255,0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }
          .hki-popup-content { flex: 1; padding: 20px; overflow-y: auto; display: flex; align-items: center; justify-content: center; min-height: 0; }
          .number-slider-wrap { display: flex; flex-direction: column; align-items: center; gap: 12px; width: 80px; height: 320px; }
          .value-display { font-size: ${valueSize}px; font-weight: ${valueWeight}; text-align: center; min-width: 80px; }
          .slider-unit { font-size: 14px; opacity: 0.6; margin-left: 3px; }
          .vertical-slider-track { width: 100%; flex: 1; background: var(--secondary-background-color, rgba(255,255,255,0.1)); border: 2px solid var(--divider-color, rgba(255,255,255,0.1)); border-radius: ${borderRadius}px; position: relative; overflow: hidden; cursor: pointer; }
          .vertical-slider-fill { position: absolute; bottom: 0; left: 0; right: 0; background: ${color}; height: ${pct}%; border-radius: 0 0 ${borderRadius}px ${borderRadius}px; }
          .vertical-slider-thumb { position: absolute; left: 50%; transform: translateX(-50%); width: 74px; height: 32px; background: white; border-radius: ${handleRadius}px; box-shadow: 0 4px 20px rgba(0,0,0,0.6); cursor: grab; pointer-events: none; bottom: calc(${pct}% - 16px); }
          .timeline-container { width: 100%; }
          .timeline-item { display: flex; gap: 12px; position: relative; }
          .timeline-visual { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
          .timeline-dot { width: 10px; height: 10px; border-radius: 50%; background: #FF9800; z-index: 2; border: 2px solid var(--card-background-color, #1c1c1c); }
          .timeline-line { width: 2px; flex-grow: 1; background: var(--divider-color, rgba(255,255,255,0.1)); margin-top: -2px; margin-bottom: -4px; }
          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content { flex: 1; padding-bottom: 14px; font-size: 13px; }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .timeline-trigger { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; font-style: italic; }
          .history-loading { width: 100%; text-align: center; padding: 20px; opacity: 0.6; }
          .hki-popup-nav { display: flex; justify-content: space-evenly; padding: 12px; background: rgba(255,255,255,0.03); border-top: 1px solid var(--divider-color, rgba(255,255,255,0.05)); flex-shrink: 0; min-height: 74px; box-sizing: border-box; ${showBottomBar ? '' : 'display: none !important;'} }
        </style>
        <div class="hki-popup-container">
          <div class="hki-popup-header">
            <div class="hki-popup-title">
              ${this._getPopupHeaderIconHtml(entity, icon, this._getPopupIconColor(color))}
              <div class="hki-popup-title-text">
                ${name}
                <span class="hki-popup-state">${this._getPopupHeaderState(rawVal + (unit ? ' ' + unit : ''))}${this._formatLastTriggered(entity) ? ' - ' + this._formatLastTriggered(entity) : ''}</span>
              </div>
            </div>
            <div class="hki-popup-header-controls">
              <button class="header-btn" id="numHistoryBtn" title="History"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>
              <button class="header-btn" id="closeBtn" title="Close"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>
          <div class="hki-popup-content" id="numContent">
            ${this._activeView === 'history'
              ? '<div id="historyContainer" class="timeline-container"><div class="history-loading">Loadingâ€¦</div></div>'
              : `<div class="number-slider-wrap">
                  <div class="value-display" id="numDisplay">${rawVal}<span class="slider-unit">${unit}</span></div>
                  <div class="vertical-slider-track" id="numTrack">
                    <div class="vertical-slider-fill" id="numFill"></div>
                    <div class="vertical-slider-thumb" id="numThumb"></div>
                </div>
                </div>`}
          </div>
          <div class="hki-popup-nav"></div>
        </div>
      `;

      const container = portal.querySelector('.hki-popup-container');
      if (container) container.addEventListener('click', (e) => e.stopPropagation());
      let isBackgroundClick = false;
      portal.addEventListener('mousedown', (e) => { isBackgroundClick = (e.target === portal); });
      portal.addEventListener('touchstart', (e) => { isBackgroundClick = (e.target === portal); }, { passive: true });
      portal.addEventListener('click', (e) => { if (isBackgroundClick && e.target === portal) this._closePopup(); isBackgroundClick = false; });

      if (!this._popupPortal) { document.body.appendChild(portal); this._applyOpenAnimation(portal); }
      this._popupPortal = portal;

      portal.querySelector('#closeBtn')?.addEventListener('click', () => this._closePopup());

      // Bottom bar entity buttons
      if (this._config.popup_hide_bottom_bar !== true) {
        const _bbNav = portal.querySelector('.hki-popup-nav');
        if (_bbNav) this._renderBottomBarEntityButtons(_bbNav);
      }
      portal.querySelector('#numHistoryBtn')?.addEventListener('click', () => {
        this._activeView = this._activeView === 'history' ? 'main' : 'history';
        this._renderNumberPopupPortal(this._getEntity());
        if (this._activeView === 'history') setTimeout(() => this._loadHistory(), 100);
      });

      if (this._activeView === 'history') {
        setTimeout(() => this._loadHistory(), 100);
      } else {
        const track = portal.querySelector('#numTrack');
        const fill = portal.querySelector('#numFill');
        const thumb = portal.querySelector('#numThumb');
        const display = portal.querySelector('#numDisplay');
        let isDragging = false;
        let pendingValue = null;
        let debounceTimer = null;

        const updateUI = (val) => {
          const p = Math.max(0, Math.min(100, ((val - min) / (max - min)) * 100));
          if (fill) fill.style.height = p + '%';
          if (thumb) thumb.style.bottom = `calc(${p}% - 16px)`;
          if (display) display.innerHTML = `${val}<span class="slider-unit">${unit}</span>`;
        };

        const getVal = (e) => {
          const rect = track.getBoundingClientRect();
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          const y = 1 - Math.max(0, Math.min(1, (clientY - rect.top) / rect.height));
          let v = min + y * (max - min);
          v = Math.round(v / step) * step;
          v = Math.round(v * 1000) / 1000;
          return Math.max(min, Math.min(max, v));
        };

        const commit = (val) => {
          clearTimeout(debounceTimer);
          debounceTimer = setTimeout(() => {
            const svc = domain === 'input_number' ? 'input_number' : 'number';
            this.hass.callService(svc, 'set_value', { entity_id: this._config.entity, value: val });
          }, 300);
        };

        if (track) {
          track.addEventListener('mousedown', (e) => { isDragging = true; track.style.cursor = 'grabbing'; const v = getVal(e); pendingValue = v; updateUI(v); });
          track.addEventListener('touchstart', (e) => { isDragging = true; const v = getVal(e); pendingValue = v; updateUI(v); }, { passive: true });
          window.addEventListener('mousemove', (e) => { if (!isDragging) return; const v = getVal(e); pendingValue = v; updateUI(v); });
          window.addEventListener('touchmove', (e) => { if (!isDragging) return; const v = getVal(e); pendingValue = v; updateUI(v); }, { passive: true });
          const end = () => { if (!isDragging) return; isDragging = false; track.style.cursor = 'pointer'; if (pendingValue !== null) { commit(pendingValue); pendingValue = null; } };
          window.addEventListener('mouseup', end);
          window.addEventListener('touchend', end);
        }
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // TEXT / INPUT_TEXT POPUP
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _renderTextPopupPortal(entity) {
      const name = this._getPopupName(entity);
      const domain = (entity.entity_id || '').split('.')[0];
      const currentText = entity.state === 'unknown' || entity.state === 'unavailable' ? '' : (entity.state || '');
      const minLen = entity.attributes?.min || 0;
      const maxLen = entity.attributes?.max || 255;
      const pattern = entity.attributes?.pattern || null;
      const mode = entity.attributes?.mode || 'text';
      const icon = this._getResolvedIcon(entity, 'mdi:form-textbox');
      const color = 'var(--primary-color, #00BCD4)';
      const showBottomBar = this._config.popup_hide_bottom_bar !== true;
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-popup-portal';
      portal.innerHTML = '';

      portal.innerHTML = `
        <style>
          .hki-popup-portal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; ${this._getPopupPortalStyle()} display: flex; align-items: center; justify-content: center; z-index: 9999; }
          .hki-popup-container { ${this._getPopupCardStyle()}; border-radius: ${popupBorderRadius}px; width: ${popupWidth}; height: ${popupHeight}; box-shadow: 0 8px 32px rgba(0,0,0,0.4); display: flex; flex-direction: column; overflow: hidden; user-select: none; }
          .hki-popup-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; background: rgba(255,255,255,0.03); border-bottom: 1px solid var(--divider-color, rgba(255,255,255,0.05)); flex-shrink: 0; }
          .hki-popup-title { display: flex; align-items: center; gap: 12px; flex: 1; min-width: 0; }
          .hki-popup-title ha-icon { --mdc-icon-size: 24px; }
          .hki-popup-title img { width:28px;height:28px;border-radius:50%;object-fit:cover;flex-shrink:0; }
          .hki-popup-title-text { display: flex; flex-direction: column; gap: 2px; font-size: 16px; font-weight: 500; min-width: 0; }
          .hki-popup-state { font-size: 12px; opacity: 0.6; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
          .hki-popup-header-controls { display: flex; gap: 8px; align-items: center; }
          .header-btn { width: 40px; height: 40px; border-radius: 50%; background: var(--divider-color, rgba(255,255,255,0.05)); border: none; color: var(--primary-text-color); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.2s; }
          .header-btn:hover { background: rgba(255,255,255,0.1); transform: scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size: 20px; }
          .hki-popup-content { flex: 1; padding: 24px; overflow-y: auto; display: flex; flex-direction: column; gap: 16px; align-items: stretch; min-height: 0; }
          .text-field-wrap { display: flex; flex-direction: column; gap: 8px; }
          .text-input { width: 100%; padding: 14px 16px; border-radius: 12px; border: 2px solid var(--divider-color, rgba(255,255,255,0.15)); background: rgba(255,255,255,0.06); color: var(--primary-text-color); font-size: 16px; box-sizing: border-box; outline: none; transition: border-color 0.2s; }
          .text-input:focus { border-color: var(--primary-color, #00BCD4); }
          .text-input-hint { font-size: 11px; opacity: 0.5; }
          .text-submit-btn { padding: 14px; border-radius: 12px; border: none; background: var(--primary-color, #00BCD4); color: white; font-size: 15px; font-weight: 600; cursor: pointer; transition: opacity 0.2s; }
          .text-submit-btn:hover { opacity: 0.85; }
          .text-current { font-size: 13px; opacity: 0.6; padding: 8px 12px; background: rgba(255,255,255,0.04); border-radius: 8px; }
          .timeline-container { width: 100%; }
          .timeline-item { display: flex; gap: 12px; position: relative; }
          .timeline-visual { display: flex; flex-direction: column; align-items: center; width: 20px; flex-shrink: 0; }
          .timeline-dot { width: 10px; height: 10px; border-radius: 50%; background: #00BCD4; z-index: 2; border: 2px solid var(--card-background-color, #1c1c1c); }
          .timeline-line { width: 2px; flex-grow: 1; background: var(--divider-color, rgba(255,255,255,0.1)); margin-top: -2px; margin-bottom: -4px; }
          .timeline-item:last-child .timeline-line { display: none; }
          .timeline-content { flex: 1; padding-bottom: 14px; font-size: 13px; }
          .timeline-ago { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; }
          .timeline-trigger { font-size: 10px; opacity: 0.5; display: block; margin-top: 2px; font-style: italic; }
          .history-loading { width: 100%; text-align: center; padding: 20px; opacity: 0.6; }
          .hki-popup-nav { display: flex; justify-content: space-evenly; padding: 12px; background: rgba(255,255,255,0.03); border-top: 1px solid var(--divider-color, rgba(255,255,255,0.05)); flex-shrink: 0; min-height: 74px; box-sizing: border-box; ${showBottomBar ? '' : 'display: none !important;'} }
        </style>
        <div class="hki-popup-container">
          <div class="hki-popup-header">
            <div class="hki-popup-title">
              ${this._getPopupHeaderIconHtml(entity, icon, this._getPopupIconColor(color))}
              <div class="hki-popup-title-text">
                ${name}
                <span class="hki-popup-state">${this._getPopupHeaderState(currentText || '(empty)')}${this._formatLastTriggered(entity) ? ' - ' + this._formatLastTriggered(entity) : ''}</span>
              </div>
            </div>
            <div class="hki-popup-header-controls">
              <button class="header-btn" id="txtHistoryBtn" title="History"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>
              <button class="header-btn" id="closeBtn" title="Close"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>
          <div class="hki-popup-content" id="textContent">
            ${this._activeView === 'history'
              ? '<div id="historyContainer" class="timeline-container"><div class="history-loading">Loadingâ€¦</div></div>'
              : `<div class="text-field-wrap">
                  <div class="text-current">Current: <strong>${currentText || '(empty)'}</strong></div>
                  <input class="text-input" id="textInput" type="${mode === 'password' ? 'password' : 'text'}"
                    value="${currentText.replace(/"/g, '&quot;')}"
                    minlength="${minLen}" maxlength="${maxLen}"
                    ${pattern ? `pattern="${pattern}"` : ''} placeholder="Enter textâ€¦">
                  <div class="text-input-hint">Max ${maxLen} characters${minLen > 0 ? ', min ' + minLen : ''}</div>
                  <button class="text-submit-btn" id="textSubmitBtn">Set Value</button>
                </div>`}
          </div>
          <div class="hki-popup-nav"></div>
        </div>
      `;

      const container = portal.querySelector('.hki-popup-container');
      if (container) container.addEventListener('click', (e) => e.stopPropagation());
      let isBackgroundClick = false;
      portal.addEventListener('mousedown', (e) => { isBackgroundClick = (e.target === portal); });
      portal.addEventListener('touchstart', (e) => { isBackgroundClick = (e.target === portal); }, { passive: true });
      portal.addEventListener('click', (e) => { if (isBackgroundClick && e.target === portal) this._closePopup(); isBackgroundClick = false; });

      if (!this._popupPortal) { document.body.appendChild(portal); this._applyOpenAnimation(portal); }
      this._popupPortal = portal;

      portal.querySelector('#closeBtn')?.addEventListener('click', () => this._closePopup());

      // Bottom bar entity buttons
      if (this._config.popup_hide_bottom_bar !== true) {
        const _bbNav = portal.querySelector('.hki-popup-nav');
        if (_bbNav) this._renderBottomBarEntityButtons(_bbNav);
      }
      portal.querySelector('#txtHistoryBtn')?.addEventListener('click', () => {
        this._activeView = this._activeView === 'history' ? 'main' : 'history';
        this._renderTextPopupPortal(this._getEntity());
        if (this._activeView === 'history') setTimeout(() => this._loadHistory(), 100);
      });

      const submitFn = () => {
        const input = portal.querySelector('#textInput');
        if (!input) return;
        const val = input.value;
        const svc = domain === 'input_text' ? 'input_text' : 'text';
        this.hass.callService(svc, 'set_value', { entity_id: this._config.entity, value: val });
        setTimeout(() => this._renderTextPopupPortal(this._getEntity()), 400);
      };

      portal.querySelector('#textSubmitBtn')?.addEventListener('click', submitFn);
      portal.querySelector('#textInput')?.addEventListener('keydown', (e) => { if (e.key === 'Enter') submitFn(); });

      if (this._activeView === 'history') setTimeout(() => this._loadHistory(), 100);
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // SHARED: Render entity buttons in popup bottom bar
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _renderBottomBarEntityButtons(navEl) {
      if (!navEl) return;
      const entities = this._config.popup_bottom_bar_entities;
      if (!Array.isArray(entities) || entities.length === 0) return;
      const align = this._config.popup_bottom_bar_align || 'spread';
      const justifyMap = { spread: 'space-around', start: 'flex-start', center: 'center', end: 'flex-end' };
      navEl.style.display = 'flex';
      navEl.style.alignItems = 'center';
      navEl.style.justifyContent = justifyMap[align] || 'space-around';
      navEl.style.padding = '8px 12px';
      navEl.style.gap = '4px';
      navEl.style.flexWrap = 'nowrap';
      navEl.innerHTML = '';
      entities.slice(0, 8).forEach(cfg => {
        if (!cfg || !cfg.entity) return;
        const stateObj = this.hass.states[cfg.entity];
        if (!stateObj) return;
        const domain = cfg.entity.split('.')[0];
        const state = stateObj.state;
        const isOn = state === 'on' || state === 'home' || state === 'open';
        const friendlyName = cfg.name || stateObj.attributes?.friendly_name || cfg.entity;
        const unit = stateObj.attributes?.unit_of_measurement || '';
        const icon = cfg.icon || stateObj.attributes?.icon || this._getDomainIcon(domain);
        const isSensor = ['sensor','number','input_number','input_text','text','select','input_select'].includes(domain);
        let iconColor = isSensor ? 'var(--primary-text-color)' : (isOn ? 'var(--primary-color,#03a9f4)' : 'rgba(255,255,255,0.35)');
        const displayVal = isSensor ? (state + (unit ? 'Â ' + unit : '')) : '';
        const label = String(friendlyName).length > 9 ? String(friendlyName).slice(0,8)+'â€¦' : friendlyName;
        const btn = document.createElement('button');
        btn.style.cssText = 'display:flex;flex-direction:column;align-items:center;justify-content:center;gap:2px;padding:4px 8px;min-width:48px;max-width:72px;background:transparent;border:none;cursor:pointer;color:var(--primary-text-color);border-radius:10px;transition:background 0.15s;flex-shrink:1;';
        btn.innerHTML = `<ha-icon icon="${icon}" style="--mdc-icon-size:22px;color:${iconColor}"></ha-icon>${displayVal ? `<span style="font-size:9px;opacity:0.7;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:68px">${displayVal}</span>` : ''}<span style="font-size:9px;opacity:0.55;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;max-width:68px">${label}</span>`;
        btn.addEventListener('mouseenter', () => { btn.style.background = 'rgba(255,255,255,0.08)'; });
        btn.addEventListener('mouseleave', () => { btn.style.background = 'transparent'; });
        btn.addEventListener('click', (e) => { e.stopPropagation(); const action = cfg.tap_action; if (!action || !action.action || action.action === 'none') return; this._executeBottomBarAction(action, cfg.entity); });
        navEl.appendChild(btn);
      });
    }

    _executeBottomBarAction(action, entityId) {
      const act = action.action;
      if (act === 'toggle') {
        const d = entityId.split('.')[0];
        const svc = d === 'input_boolean' ? 'input_boolean' : (d === 'light' ? 'light' : (d === 'switch' ? 'switch' : 'homeassistant'));
        this.hass.callService(svc, 'toggle', { entity_id: entityId });
      } else if (act === 'more-info') {
        const ev = new Event('hass-more-info', { bubbles: true, composed: true });
        ev.detail = { entityId };
        this.dispatchEvent(ev);
      } else if (act === 'navigate') {
        if (action.navigation_path) window.history.pushState(null, '', action.navigation_path);
      } else if (act === 'perform-action' || act === 'call-service') {
        const serviceStr = action.service || action.perform_action || '';
        const [d, s] = serviceStr.split('.');
        if (d && s) this.hass.callService(d, s, { entity_id: entityId, ...(action.service_data || action.data || {}) });
        if (this._config?.popup_close_on_action === true && this._popupOpen) {
          setTimeout(() => this._closePopup(), 0);
        }
      } else if (act === 'url') {
        if (action.url_path) window.open(action.url_path, '_blank');
      } else if (act === 'fire-dom-event') {
        const detail = { ...action };
        const rawEventData = typeof action.event_data === 'string' ? action.event_data.trim() : '';
        if (rawEventData) {
          try {
            const parsed = window.jsyaml?.load ? window.jsyaml.load(rawEventData) : JSON.parse(rawEventData);
            if (parsed !== undefined) detail.data = parsed;
          } catch (_) {
            detail.data = rawEventData;
          }
        }
        this.dispatchEvent(new CustomEvent('ll-custom', { bubbles: true, composed: true, detail }));
      }
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // PERSON POPUP â€” full-size HA map + configurable bottom bar
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    _renderPersonPopupPortal(entity) {
      const name = this._getPopupName(entity);
      const entityId = entity.entity_id;
      const state = entity.state;
      const icon = this._getResolvedIcon(entity, 'mdi:account');
      const isHome = state === 'home';
      const color = isHome ? 'var(--primary-color,#4CAF50)' : '#607D8B';
      const geocodedEntityId = this._config.person_geocoded_entity;
      const geocodedState = geocodedEntityId && this.hass.states[geocodedEntityId] ? this.hass.states[geocodedEntityId].state : null;
      const locationLabel = geocodedState || state;  // used only for the map pin label
      const lastSeen = this._formatLastTriggered(entity);
      const showBottomBar = this._config.popup_hide_bottom_bar !== true;
      const hasBottomBarEntities = Array.isArray(this._config.popup_bottom_bar_entities) && this._config.popup_bottom_bar_entities.length > 0;
      const popupBorderRadius = this._config.popup_border_radius ?? 16;
      const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();

      const portal = this._popupPortal || document.createElement('div');
      portal.className = 'hki-popup-portal';
      portal.innerHTML = '';
      portal.innerHTML = `
        <style>
          .hki-popup-portal { position:fixed;top:0;left:0;width:100%;height:100%; ${this._getPopupPortalStyle()} display:flex;align-items:center;justify-content:center;z-index:9999; }
          .hki-popup-container { ${this._getPopupCardStyle()};border-radius:${popupBorderRadius}px;width:${popupWidth};height:${popupHeight};box-shadow:0 8px 32px rgba(0,0,0,0.4);display:flex;flex-direction:column;overflow:hidden;user-select:none; }
          .hki-popup-header { display:flex;justify-content:space-between;align-items:center;padding:16px 20px;background:rgba(255,255,255,0.03);border-bottom:1px solid var(--divider-color,rgba(255,255,255,0.05));flex-shrink:0; }
          .hki-popup-title { display:flex;align-items:center;gap:12px;flex:1;min-width:0; }
          .hki-popup-title ha-icon { --mdc-icon-size:24px; }
          .hki-popup-title-text { display:flex;flex-direction:column;gap:2px;font-size:16px;font-weight:500;min-width:0; }
          .hki-popup-state { font-size:12px;opacity:0.6;white-space:nowrap;overflow:hidden;text-overflow:ellipsis; }
          .hki-popup-header-controls { display:flex;gap:8px;align-items:center; }
          .header-btn { width:40px;height:40px;border-radius:50%;background:var(--divider-color,rgba(255,255,255,0.05));border:none;color:var(--primary-text-color);cursor:pointer;display:flex;align-items:center;justify-content:center;transition:all 0.2s; }
          .header-btn:hover { background:rgba(255,255,255,0.1);transform:scale(1.05); }
          .header-btn ha-icon { --mdc-icon-size:20px; }
          .hki-popup-content { flex:1;overflow:hidden;display:flex;flex-direction:column;min-height:0;padding:16px; }
          .person-map-card { background:rgba(255,255,255,0.05);border-radius:18px;box-shadow:0 6px 18px rgba(0,0,0,0.25);flex:1;overflow:hidden;position:relative; }
          #personMapContainer { width:100%;height:100%;display:block;position:relative;overflow:hidden; }
          #personMapContainer > ha-map { display:block;width:100%;height:100%;border-radius:0; }
          #personMapContainer > hui-map-card,
          #personMapContainer > hui-map-card ha-card { display:block;width:100%;height:100%;border-radius:0;box-shadow:none;background:transparent; }
          .person-map-label { position:absolute;bottom:12px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.65);backdrop-filter:blur(6px);border-radius:20px;padding:6px 14px;font-size:13px;font-weight:500;color:white;white-space:nowrap;pointer-events:none;z-index:10;display:flex;align-items:center;gap:8px; }
          .person-map-dot { width:8px;height:8px;border-radius:50%;background:${color};flex-shrink:0; }
          .history-loading { width:100%;text-align:center;padding:20px;opacity:0.6; }
          .timeline-container { padding:16px;overflow-y:auto;height:100%;box-sizing:border-box; }
          .timeline-item { display:flex;gap:12px;position:relative; }
          .timeline-visual { display:flex;flex-direction:column;align-items:center;width:20px;flex-shrink:0; }
          .timeline-dot { width:10px;height:10px;border-radius:50%;background:var(--primary-color);z-index:2;border:2px solid var(--card-background-color,#1c1c1c); }
          .timeline-line { width:2px;flex-grow:1;background:var(--divider-color,rgba(255,255,255,0.1));margin-top:-2px;margin-bottom:-4px; }
          .timeline-item:last-child .timeline-line { display:none; }
          .timeline-content { flex:1;padding-bottom:14px;font-size:13px; }
          .timeline-ago { font-size:10px;opacity:0.5;display:block;margin-top:2px; }
          .timeline-trigger { font-size:10px;opacity:0.5;display:block;margin-top:2px;font-style:italic; }
          .hki-popup-nav { display:flex;align-items:center;padding:8px 12px;background:rgba(255,255,255,0.03);border-top:1px solid var(--divider-color,rgba(255,255,255,0.05));flex-shrink:0;min-height:74px;box-sizing:border-box; }
        </style>
        <div class="hki-popup-container">
          <div class="hki-popup-header">
            <div class="hki-popup-title">
              ${this._getPopupHeaderIconHtml(entity, icon, this._getPopupIconColor(color))}
              <div class="hki-popup-title-text">
                ${name}
                <span class="hki-popup-state">${this._getPopupHeaderState(state.charAt(0).toUpperCase() + state.slice(1))}${lastSeen ? ' â€” ' + lastSeen : ''}</span>
              </div>
            </div>
            <div class="hki-popup-header-controls">
              <button class="header-btn" id="personHistoryBtn" title="History"><ha-icon icon="mdi:chart-box-outline"></ha-icon></button>
              <button class="header-btn" id="closeBtn" title="Close"><ha-icon icon="mdi:close"></ha-icon></button>
            </div>
          </div>
          <div class="hki-popup-content" id="personContent">
            ${this._activeView === 'history'
              ? '<div class="timeline-container"><div id="historyContainer"><div class="history-loading">Loadingâ€¦</div></div></div>'
              : '<div class="person-map-card"><div id="personMapContainer"></div></div>'}
          </div>
          <div class="hki-popup-nav" id="personNav"></div>
        </div>
      `;

      const container = portal.querySelector('.hki-popup-container');
      if (container) container.addEventListener('click', (e) => e.stopPropagation());
      let isBackgroundClick = false;
      portal.addEventListener('mousedown', (e) => { isBackgroundClick = (e.target === portal); });
      portal.addEventListener('touchstart', (e) => { isBackgroundClick = (e.target === portal); }, { passive: true });
      portal.addEventListener('click', (e) => { if (isBackgroundClick && e.target === portal) this._closePopup(); isBackgroundClick = false; });

      if (!this._popupPortal) { document.body.appendChild(portal); this._applyOpenAnimation(portal); }
      this._popupPortal = portal;

      portal.querySelector('#closeBtn')?.addEventListener('click', () => this._closePopup());
      portal.querySelector('#personHistoryBtn')?.addEventListener('click', () => {
        this._activeView = this._activeView === 'history' ? 'main' : 'history';
        this._renderPersonPopupPortal(this._getEntity());
        if (this._activeView === 'history') setTimeout(() => this._loadHistory(), 100);
      });

      if (showBottomBar && hasBottomBarEntities) {
        const nav = portal.querySelector('#personNav');
        if (nav) this._renderBottomBarEntityButtons(nav);
      }

      if (this._activeView === 'history') {
        setTimeout(() => this._loadHistory(), 100);
      } else {
        setTimeout(() => this._mountPersonMap(portal, entityId, locationLabel, color), 80);
      }
    }

    _mountPersonMap(portal, entityId, locationLabel, color) {
      const container = portal.querySelector('#personMapContainer');
      const cardWrapper = portal.querySelector('.person-map-card');
      if (!container) return;

      // Try ha-map directly first (no card chrome, no "home" state label)
      const tryHaMap = () => {
        const mapEl = document.createElement('ha-map');
        mapEl.hass = this.hass;
        mapEl.entities = [{ entity_id: entityId }];
        mapEl.zoom = 14;
        mapEl.style.cssText = 'display:block;width:100%;height:100%;border-radius:0;';
        container.innerHTML = '';
        container.appendChild(mapEl);

        // Pierce ha-map shadow root to suppress leaflet zone/tooltip labels
        const hideLabels = () => {
          const sr = mapEl.shadowRoot;
          if (sr && !sr.querySelector('#hki-map-style')) {
            const s = document.createElement('style');
            s.id = 'hki-map-style';
            s.textContent = '.leaflet-tooltip,.leaflet-label,.entity-label{display:none!important}';
            sr.appendChild(s);
          }
          // Trigger leaflet invalidateSize so it fills the container
          const leafletMap = sr?.querySelector('.leaflet-container')?._leaflet_id
            ? null : sr?.querySelector('.leaflet-container');
          if (leafletMap) {
            window.dispatchEvent(new Event('resize'));
          }
        };
        setTimeout(hideLabels, 200);
        setTimeout(hideLabels, 800);
        // Also fire a window resize to prod leaflet into filling its container
        setTimeout(() => window.dispatchEvent(new Event('resize')), 100);
        setTimeout(() => window.dispatchEvent(new Event('resize')), 500);

        // Location pill overlay on the card wrapper
        const label = document.createElement('div');
        label.className = 'person-map-label';
        label.innerHTML = '<div class="person-map-dot"></div><span>' + locationLabel + '</span>';
        (cardWrapper || container).appendChild(label);
      };

      // Fallback: full map card but aggressively stripped
      const tryCardMap = (helpers) => {
        try {
          const mapCard = helpers.createCardElement({
            type: 'map',
            entities: [{ entity: entityId }],
            hours_to_show: 0,
            default_zoom: 14,
            aspect_ratio: null,
          });
          mapCard.hass = this.hass;
          mapCard.style.cssText = 'display:block;width:100%;height:100%;border-radius:0;';
          container.innerHTML = '';
          container.appendChild(mapCard);

          // Inject aggressive override style into the map card's shadow root
          const stripCardChrome = () => {
            const card = mapCard.shadowRoot;
            if (card) {
              const s = document.createElement('style');
              s.textContent = `
                ha-card { box-shadow:none!important;border-radius:0!important;background:transparent!important;height:100%!important; }
                .card-content,.card-header { padding:0!important;margin:0!important; }
              `;
              card.appendChild(s);
            }
            // Also try ha-card's own shadow root
            const haCard = mapCard.shadowRoot?.querySelector('ha-card');
            if (haCard) {
              haCard.style.cssText = 'height:100%;border-radius:0;box-shadow:none;background:transparent;';
              const hs = haCard.shadowRoot;
              if (hs) {
                const s2 = document.createElement('style');
                s2.textContent = '.card-content{padding:0!important;margin:0!important;}';
                hs.appendChild(s2);
              }
            }
            // Hide any text labels inside (the "home" zone label)
            mapCard.shadowRoot?.querySelectorAll('.leaflet-tooltip, .entity-label, .zone-label')
              .forEach(el => { el.style.display = 'none'; });
          };
          setTimeout(stripCardChrome, 150);
          setTimeout(stripCardChrome, 600);

          const label = document.createElement('div');
          label.className = 'person-map-label';
          label.innerHTML = '<div class="person-map-dot"></div><span>' + locationLabel + '</span>';
          (cardWrapper || container).appendChild(label);
        } catch (e) {
          container.innerHTML = '<div class="history-loading">Map unavailable</div>';
        }
      };

      // ha-map is preferred â€” check if it's a known custom element
      if (customElements.get('ha-map')) {
        tryHaMap();
      } else if (window.loadCardHelpers) {
        window.loadCardHelpers()
          .then((helpers) => {
            // Prefer ha-map once helpers have loaded (they register HA elements)
            if (customElements.get('ha-map')) {
              tryHaMap();
            } else {
              tryCardMap(helpers);
            }
          })
          .catch(() => { container.innerHTML = '<div class="history-loading">Map unavailable</div>'; });
      } else {
        container.innerHTML = '<div class="history-loading">Map unavailable</div>';
      }
    }

    _renderIndividualView() {
      const entity = this._getEntity();
      if (!entity || !entity.attributes.entity_id || !Array.isArray(entity.attributes.entity_id)) {
        return '<div style="padding: 20px; text-align: center; opacity: 0.6;">No individual lights found</div>';
      }

      let html = '<div class="individual-container" data-view-type="individual">';

      const defaultSection = this._config.popup_default_section; // 'brightness', 'color', 'temperature', 'last', or undefined
      
      const pickDefaultMode = (child) => {
        const scm = child?.attributes?.supported_color_modes || [];
        const hasTemp = scm.includes('color_temp');
        const hasColor = scm.some(m => ['hs','rgb','xy','rgbw','rgbww'].includes(m));
        
        // If default_section is configured and not 'last', use that setting
        if (defaultSection && defaultSection !== 'last') {
          if (defaultSection === 'temperature' && hasTemp) return 'temp';
          if (defaultSection === 'color' && hasColor) return 'color';
          return 'brightness';
        }
        
        // Otherwise use the smart default (temp > color > brightness)
        return hasTemp ? 'temp' : (hasColor ? 'color' : 'brightness');
      };

      entity.attributes.entity_id.forEach(entityId => {
        const childEntity = this.hass.states[entityId];
        if (!childEntity) return;

        const name = childEntity.attributes.friendly_name || entityId;
        const isOn = childEntity.state === 'on';
        const brightnessPct = childEntity.attributes.brightness ? Math.round((childEntity.attributes.brightness / 255) * 100) : 0;

        const scm = childEntity.attributes.supported_color_modes || [];
        const supportsTemp = scm.includes('color_temp');
        const supportsColor = scm.some(m => ['hs','rgb','xy','rgbw','rgbww'].includes(m));
        const supportsBrightness = scm.some(m => ['brightness', 'color_temp', 'hs', 'rgb', 'xy', 'rgbw', 'rgbww'].includes(m));
        
        // If light doesn't support brightness/color/temp, show as switch
        if (!supportsBrightness && !supportsTemp && !supportsColor) {
          html += `
            <div class="individual-item switch-style">
              <button class="individual-icon" data-entity="${entityId}" data-action="toggle" title="Toggle">
                <ha-icon icon="${isOn ? 'mdi:lightbulb-on' : 'mdi:lightbulb-off'}"></ha-icon>
              </button>
              <div class="individual-info">
                <div class="individual-name">${name}</div>
                <div class="individual-state">${isOn ? 'On' : 'Off'}</div>
              </div>
              <div class="individual-switch-container" data-entity="${entityId}">
                <div class="individual-switch ${isOn ? 'on' : 'off'}">
                  <div class="individual-switch-thumb"></div>
                </div>
              </div>
            </div>
          `;
          return;
        }

        if (!this._groupMemberModes) this._groupMemberModes = {};
        
        // If default_section is configured (not 'last'), always use that on first view
        // Otherwise, remember the last mode used for this light
        if (defaultSection && defaultSection !== 'last') {
          this._groupMemberModes[entityId] = pickDefaultMode(childEntity);
        } else if (!this._groupMemberModes[entityId]) {
          this._groupMemberModes[entityId] = pickDefaultMode(childEntity);
        }

        // Cycle order: brightness -> temp -> color -> brightness, skipping unsupported
        const mode = this._groupMemberModes[entityId];
        const nextMode = (() => {
          const order = ['brightness','temp','color'];
          let i = order.indexOf(mode);
          for (let step=0; step<3; step++) {
            i = (i+1) % order.length;
            const m = order[i];
            if (m==='temp' && !supportsTemp) continue;
            if (m==='color' && !supportsColor) continue;
            return m;
          }
          return 'brightness';
        })();

        const icon = mode === 'temp' ? 'mdi:thermometer' : (mode === 'color' ? 'mdi:palette' : 'mdi:lightbulb');

        // Slider value based on mode
        let pct = brightnessPct;
        let sliderKind = 'brightness';
        let gradient = '';
        if (mode === 'temp') {
          sliderKind = 'temp';
          const minM = childEntity.attributes.min_mireds || 153;
          const maxM = childEntity.attributes.max_mireds || 500;
          const ct = typeof childEntity.attributes.color_temp === 'number' ? childEntity.attributes.color_temp : minM;
          pct = Math.round(((ct - minM) / (maxM - minM)) * 100);
          gradient = 'background: linear-gradient(to right, #8ec5ff, #e8f0ff, #fff2c6, #ffd1a1);';
        } else if (mode === 'color') {
          sliderKind = 'color';
          const h = Array.isArray(childEntity.attributes.hs_color) ? childEntity.attributes.hs_color[0] : 0;
          pct = Math.round((h / 360) * 100);
          gradient = 'background: linear-gradient(to right, rgb(255,0,0), rgb(255,255,0), rgb(0,255,0), rgb(0,255,255), rgb(0,0,255), rgb(255,0,255), rgb(255,0,0));';
        }

        const memberColor = this._getCurrentColorFromState(childEntity);
        // For brightness mode, use the member's actual color if available, otherwise fall back to the classic gold.
        const brightnessFill = memberColor ? `${memberColor}` : 'rgba(255, 215, 0, 0.55)';

        html += `
          <div class="individual-item">
            <button class="individual-icon individual-mode-btn" data-entity="${entityId}" data-next="${nextMode}" title="Change mode">
              <ha-icon icon="${icon}"></ha-icon>
            </button>
            <div class="individual-info">
              <div class="individual-name">${name}</div>
              <div class="individual-state">${isOn ? brightnessPct + '%' : 'Off'}</div>
            </div>
            <div class="individual-slider" data-entity="${entityId}" data-mode="${sliderKind}" style="${gradient}">
              <div class="individual-slider-fill" style="width: ${pct}%; ${sliderKind==='brightness' ? `background: ${brightnessFill};` : ''}"></div>
              <div class="individual-slider-thumb" style="left: ${pct}%;"></div>
            </div>
          </div>
        `;
      });

      html += '</div>';

      // Save group favorite button (same placement as other save buttons)
      if (this._config.popup_show_favorites !== false) {
        html += `
          <button class="save-favorite-fab" id="saveGroupFavoriteBtn" title="Save group favorite">
            <ha-icon icon="mdi:star-plus"></ha-icon>
          </button>
        `;
      }

      return html;
    }


    _renderEffectsView(effectList, currentEffect) {
      let html = '<div class="effects-list-container" data-view-type="effects">';
      
      if (!effectList || effectList.length === 0) {
        html += '<div style="padding: 40px 20px; text-align: center; opacity: 0.6; font-size: 14px;">No effects available for this device</div>';
      } else {
        html += '<div class="effects-list expanded">';
        html += `<div class="effect-item ${currentEffect === 'None' || !currentEffect ? 'active' : ''}" data-effect="None">No Effect</div>`;
        effectList.forEach(effect => {
          html += `<div class="effect-item ${effect === currentEffect ? 'active' : ''}" data-effect="${effect}">${effect}</div>`;
        });
        html += '</div>';
      }
      
      html += '</div>';
      return html;
    }

    _setInitialColorIndicator() {
      const colorWheel = this._popupPortal ? this._popupPortal.querySelector('#colorWheel') : null;
      const indicator = this._popupPortal ? this._popupPortal.querySelector('#colorIndicator') : null;
      
      if (colorWheel && indicator) {
        const rect = colorWheel.getBoundingClientRect();
        
        if (rect.width === 0 || rect.height === 0) {
          setTimeout(() => this._setInitialColorIndicator(), 50);
          return;
        }
        
        const r = rect.width / 2;
        const hue = this._hue || 0;
        const saturation = Math.min(100, Math.max(0, this._saturation || 0));
        
        const theta = (hue - 90) * (Math.PI / 180);
        const dist = (saturation / 100) * r;
        
        const x = r + (dist * Math.cos(theta));
        const y = r + (dist * Math.sin(theta));
        
        indicator.style.left = x + 'px';
        indicator.style.top = y + 'px';
        indicator.style.background = 'hsl(' + hue + ', ' + saturation + '%, 50%)';
      }
    }

    _setupPopupHandlers(portal) {
      if (this._getDomain() === 'climate') {
          this._setupClimateHandlers(portal);
          return; // Skip light handlers
      }
      const closeBtn = portal.querySelector('#closeBtn');
      if (closeBtn) closeBtn.addEventListener('click', () => this._closePopup());

      const individualLightsBtn = portal.querySelector('#individualLightsBtn');
      if (individualLightsBtn) {
        individualLightsBtn.addEventListener('click', () => {
          portal.querySelectorAll('.hki-light-popup-tab').forEach(t => t.classList.remove('active'));
          
          const content = portal.querySelector('.hki-light-popup-content');
          if (content) {
            const currentView = content.querySelector('[data-view-type]')?.dataset.viewType;
            if (currentView === 'individual') {
              this._renderPopupPortal();
            } else {
              content.innerHTML = this._renderIndividualView();
              this._setupContentHandlers(portal);
            }
          }
        });
      }

      const historyBtn = portal.querySelector('#historyBtn');
      if (historyBtn) {
        historyBtn.addEventListener('click', () => {
          portal.querySelectorAll('.hki-light-popup-tab').forEach(t => t.classList.remove('active'));
          
          const content = portal.querySelector('.hki-light-popup-content');
          if (content) {
            const currentView = content.querySelector('[data-view-type]')?.dataset.viewType;
            if (currentView === 'history') {
              this._renderPopupPortal();
            } else {
              content.innerHTML = `<div class="timeline-container" data-view-type="history" id="historyContainer">
                <div class="history-loading">Loading Timeline...</div>
              </div>`;
              setTimeout(() => this._loadHistory(), 100);
            }
          }
        });
      }

      const scenesBtn = portal.querySelector('#scenesBtn');
      if (scenesBtn) {
        scenesBtn.addEventListener('click', () => {
          portal.querySelectorAll('.hki-light-popup-tab').forEach(t => t.classList.remove('active'));
          scenesBtn.classList.add('active');
          this._activeView = 'favorites';
          
          const content = portal.querySelector('.hki-light-popup-content');
          if (content) {
            content.classList.add('view-favorites');
            content.innerHTML = this._renderFavoritesView();
            this._setupContentHandlers(portal);
          }
        });
      }

      const effectsBtn = portal.querySelector('#effectsBtn');
      if (effectsBtn) {
        effectsBtn.addEventListener('click', () => {
          portal.querySelectorAll('.hki-light-popup-tab').forEach(t => t.classList.remove('active'));
          effectsBtn.classList.add('active');
          this._activeView = 'effects';
          
          const entity = this._getEntity();
          const effectList = entity && entity.attributes.effect_list ? entity.attributes.effect_list : [];
          const currentEffect = entity && entity.attributes.effect ? entity.attributes.effect : 'None';
          const content = portal.querySelector('.hki-light-popup-content');
          if (content) {
            content.innerHTML = this._renderEffectsView(effectList, currentEffect);
            this._setupContentHandlers(portal);
          }
        });
      }

      // Bottom navigation
      const powerBtn = portal.querySelector('#powerBtn');
      if (powerBtn) {
        powerBtn.addEventListener('click', () => {
          this.hass.callService('light', 'toggle', { entity_id: this._config.entity });
        });
      }

      const brightnessBtn = portal.querySelector('#brightnessBtn');
      if (brightnessBtn) {
        brightnessBtn.addEventListener('click', () => {
          portal.querySelectorAll('.nav-btn').forEach(t => t.classList.remove('active'));
          this._activeView = 'brightness';
          this._renderPopupPortal();
        });
      }

      const temperatureBtn = portal.querySelector('#temperatureBtn');
      if (temperatureBtn) {
        temperatureBtn.addEventListener('click', () => {
          portal.querySelectorAll('.nav-btn').forEach(t => t.classList.remove('active'));
          this._activeView = 'temperature';
          this._syncState();
          this._renderPopupPortal();
        });
      }

      const colorBtn = portal.querySelector('#colorBtn');
      if (colorBtn) {
        colorBtn.addEventListener('click', () => {
          portal.querySelectorAll('.nav-btn').forEach(t => t.classList.remove('active'));
          this._activeView = 'color';
          this._syncState();
          this._renderPopupPortal();
        });
      }
    }

    _setupClimateHandlers(portal) {
        // 1. Sliders
        portal.querySelectorAll('.vertical-slider-track').forEach(track => {
            const type = track.dataset.type; // 'single', 'low', 'high'
            const update = (e) => {
                 const rect = track.getBoundingClientRect();
                 const y = Math.max(0, Math.min(1, 1 - (e.clientY - rect.top) / rect.height));
                 let val = this._tempMin + (y * (this._tempMax - this._tempMin));
                 val = Math.round(val / this._step) * this._step;
                 val = Math.round(val * 10) / 10;
                 
                 // UI Update logic (height %, text content) goes here
                 // Same as the climate code provided previously
                 
                 return val;
            };
            // Add mousedown/touchstart listeners similar to light slider...
        });
    
        // 2. Nav Buttons
        const entity = this._getEntity();
        (entity.attributes.hvac_modes || []).forEach(m => {
            const btn = portal.querySelector(`#mode-${m}`);
            if(btn) btn.addEventListener('click', () => {
                 // Optimistic UI: highlight immediately
                 this._optimisticHvacMode = m;
                 portal.querySelectorAll('button[id^="mode-"]').forEach(b => {
                   b.classList.remove('active');
                   b.style.color = '';
                 });
                 btn.classList.add('active');
                 if (HVAC_COLORS && HVAC_COLORS[m]) btn.style.color = HVAC_COLORS[m];

                 this.hass.callService('climate', 'set_hvac_mode', {
                     entity_id: this._config.entity, hvac_mode: m
                 });
                 // Re-render shortly to keep UI consistent with other elements
                 setTimeout(() => this._renderPopupPortal(), 200);
            });
        });
    }

    _setupContentHandlers(portal) {
      // Brightness slider
      const brightnessTrack = portal.querySelector('#brightnessTrack');
      if (brightnessTrack) {
        const self = this;
        const updateBrightness = (e) => {
          self._isDragging = true;
          const rect = brightnessTrack.getBoundingClientRect();
          const y = Math.max(0, Math.min(1, 1 - (e.clientY - rect.top) / rect.height));
          const brightness = Math.round(y * 100);
          self._brightness = brightness;
          
          const fill = brightnessTrack.querySelector('.vertical-slider-fill');
          const thumb = brightnessTrack.querySelector('.vertical-slider-thumb');
          const valueDisplay = portal.querySelector('.value-display');
          
          if (fill) {
            fill.style.height = brightness + '%';
            if (self._config.dynamic_bar_color) {
              fill.style.background = self._getCurrentColor();
            }
          }
          // Clamp thumb position so it stays visible at 0% and 100%
          const thumbPos = brightness <= 0 ? '0px' : brightness >= 100 ? 'calc(100% - 6px)' : 'calc(' + brightness + '% - 6px)';
          if (thumb) thumb.style.bottom = thumbPos;
          if (valueDisplay) valueDisplay.innerHTML = brightness + '<span>%</span>';
        };

        const finishBrightness = () => {
          document.removeEventListener('mousemove', updateBrightness);
          document.removeEventListener('mouseup', finishBrightness);
          document.removeEventListener('touchmove', handleTouch);
          document.removeEventListener('touchend', finishBrightness);
          
          self._isDragging = false;
          if (self._brightness > 0) {
            self.hass.callService('light', 'turn_on', { entity_id: self._config.entity, brightness_pct: self._brightness });
          } else {
            self.hass.callService('light', 'turn_off', { entity_id: self._config.entity });
          }
        };

        const handleTouch = (e) => { e.preventDefault(); updateBrightness(e.touches[0]); };

        brightnessTrack.addEventListener('mousedown', (e) => {
          updateBrightness(e);
          document.addEventListener('mousemove', updateBrightness);
          document.addEventListener('mouseup', finishBrightness);
        });
        brightnessTrack.addEventListener('touchstart', (e) => {
          handleTouch(e);
          document.addEventListener('touchmove', handleTouch, { passive: false });
          document.addEventListener('touchend', finishBrightness);
        });
      }

      // Temperature slider
      const tempTrackVertical = portal.querySelector('#tempTrackVertical');
      if (tempTrackVertical) {
        const self = this;
        const updateTemp = (e) => {
          self._isDragging = true;
          const rect = tempTrackVertical.getBoundingClientRect();
          const y = Math.max(0, Math.min(1, 1 - (e.clientY - rect.top) / rect.height));
          const range = self._tempMax - self._tempMin;
          const mireds = Math.round(self._tempMax - (y * range));
          self._currentTemp = mireds;
          const kelvin = Math.round(1000000 / mireds);
          
          const fill = tempTrackVertical.querySelector('.vertical-slider-fill');
          const thumb = tempTrackVertical.querySelector('.vertical-slider-thumb');
          const valueDisplay = portal.querySelector('.value-display');
          
          const tempPct = 100 - (((mireds - self._tempMin) / range) * 100);
          if (fill) fill.style.height = tempPct + '%';
          // Clamp thumb position so it stays visible at 0% and 100%
          const thumbPos = tempPct <= 0 ? '0px' : tempPct >= 100 ? 'calc(100% - 6px)' : 'calc(' + tempPct + '% - 6px)';
          if (thumb) thumb.style.bottom = thumbPos;
          if (valueDisplay) valueDisplay.textContent = self._getTempName(kelvin);
        };

        const finishTemp = () => {
          document.removeEventListener('mousemove', updateTemp);
          document.removeEventListener('mouseup', finishTemp);
          document.removeEventListener('touchmove', handleTouchTemp);
          document.removeEventListener('touchend', finishTemp);
          
          self._isDragging = false;
          self.hass.callService('light', 'turn_on', { entity_id: self._config.entity, color_temp: self._currentTemp });
        };

        const handleTouchTemp = (e) => { e.preventDefault(); updateTemp(e.touches[0]); };

        tempTrackVertical.addEventListener('mousedown', (e) => {
          updateTemp(e);
          document.addEventListener('mousemove', updateTemp);
          document.addEventListener('mouseup', finishTemp);
        });
        tempTrackVertical.addEventListener('touchstart', (e) => {
          handleTouchTemp(e);
          document.addEventListener('touchmove', handleTouchTemp, { passive: false });
          document.addEventListener('touchend', finishTemp);
        });
      }

      // Color wheel
      const colorWheel = portal.querySelector('#colorWheel');
      if (colorWheel) {
        const self = this;
        const updateColor = (e) => {
          self._isDragging = true;
          const rect = colorWheel.getBoundingClientRect();
          const centerX = rect.width / 2;
          const centerY = rect.height / 2;
          
          const clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
          const clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
          
          const x = clientX - rect.left - centerX;
          const y = clientY - rect.top - centerY;
          
          let angle = Math.atan2(y, x) * (180 / Math.PI) + 90;
          if (angle < 0) angle += 360;
          const distance = Math.min(1, Math.sqrt(x * x + y * y) / (rect.width / 2));
          
          self._hue = angle;
          self._saturation = distance * 100;
          
          const indicator = portal.querySelector('#colorIndicator');
          const colorNameEl = portal.querySelector('.value-display');
          if (indicator) {
            const r = distance * (rect.width / 2);
            const theta = (angle - 90) * Math.PI / 180;
            const indicatorX = centerX + r * Math.cos(theta);
            const indicatorY = centerY + r * Math.sin(theta);
            
            indicator.style.left = indicatorX + 'px';
            indicator.style.top = indicatorY + 'px';
            indicator.style.background = 'hsl(' + self._hue + ', ' + self._saturation + '%, 50%)';
            indicator.style.transition = 'none';
          }
          if (colorNameEl) {
            colorNameEl.textContent = self._getColorName(self._hue, self._saturation);
          }
        };

        const finishColor = () => {
          document.removeEventListener('mousemove', updateColor);
          document.removeEventListener('mouseup', finishColor);
          document.removeEventListener('touchmove', handleTouchColor);
          document.removeEventListener('touchend', finishColor);
          self._isDragging = false;
          self.hass.callService('light', 'turn_on', { entity_id: self._config.entity, hs_color: [self._hue, self._saturation] });
          const indicator = portal.querySelector('#colorIndicator');
          if (indicator) indicator.style.transition = 'top 0.3s, left 0.3s';
        };
        
        const handleTouchColor = (e) => { e.preventDefault(); updateColor(e); };

        colorWheel.addEventListener('mousedown', (e) => {
          updateColor(e);
          document.addEventListener('mousemove', updateColor);
          document.addEventListener('mouseup', finishColor);
        });
        
        colorWheel.addEventListener('touchstart', (e) => {
          handleTouchColor(e);
          document.addEventListener('touchmove', handleTouchColor, { passive: false });
          document.addEventListener('touchend', finishColor);
        });
      }

      // Preset buttons
      const presetBtns = portal.querySelectorAll('.preset-btn');
      const self = this;
      presetBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation(); 
          if (self._favoritesEditMode) return;
          const idx = parseInt(btn.dataset.favIndex);
          if (Number.isNaN(idx)) return;
          self._ensureLightFavorites();
          const fav = Array.isArray(self._lightFavorites) ? self._lightFavorites[idx] : null;
          if (!fav) return;
          self._applyFavorite(fav);
        });
      });

      // Favorites edit toggle
      const favEditBtn = portal.querySelector('#favoritesEditBtn');
      if (favEditBtn) {
        favEditBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this._favoritesEditMode = !this._favoritesEditMode;
          const content = portal.querySelector('.hki-light-popup-content');
          if (content) {
            content.classList.add('view-favorites');
            content.innerHTML = this._renderFavoritesView();
            this._setupContentHandlers(portal);
          }
        });
      }

      // Favorites delete badges
      const delBadges = portal.querySelectorAll('.fav-delete-badge');
      delBadges.forEach(b => {
        b.addEventListener('click', (e) => {
          e.stopPropagation();
          const idx = parseInt(b.dataset.favDel);
          if (Number.isNaN(idx)) return;
          this._ensureLightFavorites();
          if (Array.isArray(this._lightFavorites)) {
            this._lightFavorites.splice(idx, 1);
            this._saveLightFavorites();
          }
          const content = portal.querySelector('.hki-light-popup-content');
          if (content) {
            content.classList.add('view-favorites');
            content.innerHTML = this._renderFavoritesView();
            this._setupContentHandlers(portal);
          }
        });
      });

      // Save favorite button (color wheel / color temp)
      const saveFavBtn = portal.querySelector('#saveFavoriteBtn');
      if (saveFavBtn) {
        saveFavBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          await this._addCurrentLightToFavorites();
          
          // Switch to favorites tab and show the updated list
          this._activeView = 'favorites';
          const content = portal.querySelector('.hki-light-popup-content');
          const scenesBtn = portal.querySelector('#scenesBtn');
          
          if (content) {
            content.classList.add('view-favorites');
            content.innerHTML = this._renderFavoritesView();
            this._setupContentHandlers(portal);
          }
          
          // Update tab active states
          if (scenesBtn) {
            portal.querySelectorAll('.hki-light-popup-tab').forEach(t => t.classList.remove('active'));
            scenesBtn.classList.add('active');
          }
        });
      }

      // Group member mode buttons
      const modeBtns = portal.querySelectorAll('.individual-mode-btn');
      modeBtns.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const eid = btn.dataset.entity;
          const next = btn.dataset.next || 'brightness';
          if (!this._groupMemberModes) this._groupMemberModes = {};
          this._groupMemberModes[eid] = next;
          // Re-render only the individual view
          const content = portal.querySelector('.hki-light-popup-content');
          if (content) {
            content.innerHTML = this._renderIndividualView();
            this._setupContentHandlers(portal);
          }
        });
      });

      // Save group favorite button
      const saveGroupBtn = portal.querySelector('#saveGroupFavoriteBtn');
      if (saveGroupBtn) {
        saveGroupBtn.addEventListener('click', async (e) => {
          e.stopPropagation();
          await this._addGroupSnapshotToFavorites({ alwaysPromptMeta: true });
          const content = portal.querySelector('.hki-light-popup-content');
          if (content) {
            content.classList.add('view-favorites');
            content.innerHTML = this._renderFavoritesView();
            this._setupContentHandlers(portal);
          }
        });
      }

      // Individual sliders
      const individualSliders = portal.querySelectorAll('.individual-slider');
      individualSliders.forEach(slider => {
        const entityId = slider.dataset.entity;
        const mode = slider.dataset.mode || 'brightness';

        const calcPct = (clientX) => {
          const rect = slider.getBoundingClientRect();
          const x = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
          return Math.round(x * 100);
        };

        const applyVisual = (pct) => {
          const fill = slider.querySelector('.individual-slider-fill');
          const thumb = slider.querySelector('.individual-slider-thumb');
          if (fill) fill.style.width = pct + '%';
          if (thumb) thumb.style.left = pct + '%';
        };

        const finish = async (clientX) => {
          const pct = calcPct(clientX);
          applyVisual(pct);

          const st = this.hass.states[entityId];
          if (!st) return;
          const a = st.attributes || {};

          if (mode === 'temp') {
            const minM = a.min_mireds || 153;
            const maxM = a.max_mireds || 500;
            const ct = Math.round(minM + ((maxM - minM) * (pct / 100)));
            await this.hass.callService('light', 'turn_on', { entity_id: entityId, color_temp: ct });
          } else if (mode === 'color') {
            const hue = Math.round((pct / 100) * 360);
            await this.hass.callService('light', 'turn_on', { entity_id: entityId, hs_color: [hue, 100] });
          } else {
            if (pct > 0) {
              await this.hass.callService('light', 'turn_on', { entity_id: entityId, brightness_pct: pct });
            } else {
              await this.hass.callService('light', 'turn_off', { entity_id: entityId });
            }
          }
        };

        let isDragging = false;
        const onMove = (e) => {
          if (!isDragging) return;
          const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
          const pct = calcPct(clientX);
          applyVisual(pct);
        };
        const onUp = async (e) => {
          if (!isDragging) return;
          isDragging = false;
          document.removeEventListener('mousemove', onMove);
          document.removeEventListener('mouseup', onUp);
          document.removeEventListener('touchmove', onMove);
          document.removeEventListener('touchend', onUp);
          const clientX = (e.changedTouches && e.changedTouches[0]) ? e.changedTouches[0].clientX : e.clientX;
          await finish(clientX);
        };

        const onDown = (e) => {
          isDragging = true;
          const clientX = (e.touches && e.touches[0]) ? e.touches[0].clientX : e.clientX;
          const pct = calcPct(clientX);
          applyVisual(pct);
          document.addEventListener('mousemove', onMove);
          document.addEventListener('mouseup', onUp);
          document.addEventListener('touchmove', onMove, { passive: true });
          document.addEventListener('touchend', onUp);
        };

        slider.addEventListener('mousedown', onDown);
        slider.addEventListener('touchstart', onDown, { passive: true });
      });

      // Individual switch containers (for on/off only lights)
      const individualSwitches = portal.querySelectorAll('.individual-switch-container');
      individualSwitches.forEach(switchContainer => {
        const entityId = switchContainer.dataset.entity;
        switchContainer.addEventListener('click', async () => {
          await this.hass.callService('light', 'toggle', { entity_id: entityId });
        });
      });
      
      // Individual icon buttons (both for mode switching and toggle)
      const individualIcons = portal.querySelectorAll('.individual-icon');
      individualIcons.forEach(icon => {
        const entityId = icon.dataset.entity;
        const action = icon.dataset.action;
        
        if (action === 'toggle') {
          // For switch-style items, icon toggles the light
          icon.addEventListener('click', async () => {
            await this.hass.callService('light', 'toggle', { entity_id: entityId });
          });
        } else {
          // For slider items, icon cycles the mode
          icon.addEventListener('click', () => {
            const nextMode = icon.dataset.next;
            if (this._groupMemberModes) {
              this._groupMemberModes[entityId] = nextMode;
            }
            this._renderPopupPortal();
          });
        }
      });

      // Effects toggle and items
      const effectsTrigger = portal.querySelector('#effectsTrigger');
      if (effectsTrigger) {
        effectsTrigger.addEventListener('click', () => {
          this._expandedEffects = !this._expandedEffects;
          const effectsList = portal.querySelector('.effects-list');
          const arrow = portal.querySelector('.effects-trigger-arrow');
          if (effectsList) {
            effectsList.classList.toggle('expanded');
          }
          if (arrow) {
            arrow.classList.toggle('expanded');
          }
        });
      }

      const effectItems = portal.querySelectorAll('.effect-item');
      effectItems.forEach(item => {
        item.addEventListener('click', () => {
          const effect = item.dataset.effect;
          if (effect === 'None') {
            self.hass.callService('light', 'turn_on', { entity_id: self._config.entity, effect: 'none' });
          } else {
            self.hass.callService('light', 'turn_on', { entity_id: self._config.entity, effect: effect });
          }
        });
      });
    }

    async _loadHistory() {
      const container = this._popupPortal.querySelector('#historyContainer');
      if (!container) return;

      const entityId = this._config.entity;
      const endTime = new Date();
      const startTime = new Date(endTime.getTime() - 24 * 60 * 60 * 1000);
      
      try {
        // Fetch main entity logbook
        const logbook = await this.hass.callApi('GET', `logbook/${startTime.toISOString()}?entity=${entityId}&end_time=${endTime.toISOString()}`);
        
        // For locks, also fetch contact sensor history if configured
        let contactLogbook = [];
        const domain = this._getDomain();
        if (domain === 'lock' && this._config.lock_contact_sensor_entity) {
          try {
            contactLogbook = await this.hass.callApi('GET', `logbook/${startTime.toISOString()}?entity=${this._config.lock_contact_sensor_entity}&end_time=${endTime.toISOString()}`);
          } catch (e) {
            console.warn('Could not fetch contact sensor history', e);
          }
        }
        
        if ((!logbook || logbook.length === 0) && (!contactLogbook || contactLogbook.length === 0)) {
          container.innerHTML = '<div class="history-loading">No history available</div>';
          return;
        }

        const stateChanges = logbook
          .filter(entry => {
            // alarm_control_panel entries (Alarmo) often have message instead of state
            if (domain === 'alarm_control_panel') {
              const hasState = !!entry.state && entry.state !== 'unknown';
              const hasMsg = !!entry.message && String(entry.message).trim() !== '';
              return hasState || hasMsg
            }
            if (!entry.state) return false;
            if (domain === 'climate') return entry.state !== 'unknown';
            if (domain === 'cover') return entry.state !== 'unknown';
            if (domain === 'lock') return entry.state !== 'unknown';
            if (domain === 'humidifier') return entry.state !== 'unknown';
            if (domain === 'fan') return entry.state !== 'unknown';
            if (domain === 'person') return !!entry.state;
            if (domain === 'binary_sensor' || domain === 'device_tracker' || domain === 'event') return !!entry.state;
            if (domain === 'sensor') return !!entry.state;
            if (domain === 'select' || domain === 'input_select') return !!entry.state;
            if (domain === 'number' || domain === 'input_number') return !!entry.state;
            if (domain === 'text' || domain === 'input_text') return !!entry.state;
            return (entry.state === 'on' || entry.state === 'off' || entry.state === 'unavailable');
          });
        
        // Add contact sensor state changes with a special flag
        const contactSensorLabel = this._config.lock_contact_sensor_label || "Door";
        contactLogbook
          .filter(entry => {
            const state = String(entry.state || '').toLowerCase();
            return state === 'on' || state === 'off' || state === 'open' || state === 'closed';
          })
          .forEach(entry => {
            stateChanges.push({
              ...entry,
              isContactSensor: true,
              contactLabel: contactSensorLabel
            });
          });
        
        // Sort all events by time, most recent first
        const sortedChanges = stateChanges
          .sort((a, b) => new Date(b.when) - new Date(a.when))
          .slice(0, 15);
        
        let htmlContent = '';
        
        sortedChanges.forEach((entry, index) => {
          const date = new Date(entry.when);
          const timeStr = this._formatHistoryTime(date);
          const ago = this._getTimeAgo(date);
          
          let stateText = 'Changed';
          
          // Handle contact sensor events
          if (entry.isContactSensor) {
            const state = String(entry.state || '').toLowerCase();
            if (state === 'on' || state === 'open') {
              stateText = `${entry.contactLabel} Opened`;
            } else if (state === 'off' || state === 'closed') {
              stateText = `${entry.contactLabel} Closed`;
            }
          } else if (domain === 'alarm_control_panel') {
            // Alarmo often logs message; prefer that, else state
            const raw = entry.message ?? entry.state ?? 'changed';
            const norm = String(raw)
              .replace(/_/g, ' ')
              .replace(/\s+/g, ' ')
              .trim();
            stateText = this._titleCase(norm);
          } else if (domain === 'sensor' || domain === 'number' || domain === 'input_number' || domain === 'text' || domain === 'input_text') {
            const unit = this.hass.states[entityId]?.attributes?.unit_of_measurement || '';
            stateText = unit ? `${entry.state} ${unit}` : (entry.state || 'Changed');
          } else if (domain === 'select' || domain === 'input_select') {
            stateText = entry.state || 'Changed';
          } else if (domain === 'person') {
            stateText = entry.state || 'Changed';
          } else if (domain === 'binary_sensor' || domain === 'device_tracker' || domain === 'event') {
            stateText = this._getLocalizedState(entry.state, domain) || entry.state || 'Changed';
          } else if (entry.state === 'on') {
            stateText = this.hass.localize('ui.card.button.turn_on') || 'Turned On';
          } else if (entry.state === 'off') {
            stateText = this.hass.localize('ui.card.button.turn_off') || 'Turned Off';
          } else if (entry.state === 'unavailable') {
            stateText = this._getLocalizedState('unavailable', domain);
          } else if (entry.state) {
            stateText = this._getLocalizedState(entry.state, domain);
          }

          
          // --- FIX: USER RESOLUTION VIA PERSON ENTITIES ---
          let trigger = 'System';
          
          if (entry.context_user_id) {
             // 1. Try to find a "person" entity that matches this user_id
             const person = Object.values(this.hass.states).find(state => 
                state.entity_id.startsWith('person.') && 
                state.attributes.user_id === entry.context_user_id
             );
             
             if (person && person.attributes.friendly_name) {
                trigger = person.attributes.friendly_name;
             } 
             // 2. Fallback: Check if it matches the currently logged-in user
             else if (this.hass.user && this.hass.user.id === entry.context_user_id) {
                trigger = this.hass.user.name;
             } 
             else {
                trigger = 'User'; // ID exists but couldn't resolve name
             }
          } else {
             // If no user ID, check if the entry name differs from the entity name
             // (This often catches automations or scenes depending on how they log)
             const entityName = this.hass.states[entityId]?.attributes?.friendly_name;
             if (entry.name && entry.name !== entityName && entry.name !== entityId) {
                trigger = entry.name;
             }
          }
          // ------------------------------------------------
          
          // Determine dot color
          let dotColor = '#2196F3';
          
          if (entry.isContactSensor) {
            // Contact sensor: red for open, yellow/amber for closed
            const state = String(entry.state || '').toLowerCase();
            dotColor = (state === 'on' || state === 'open') ? '#F44336' : '#FFC107';
          } else if (domain === 'alarm_control_panel') {
            const raw = (entry.state ? String(entry.state) : (entry.message ? String(entry.message) : '')).toLowerCase();
            if (raw.includes('disarm')) dotColor = '#4CAF50';
            else if (raw.includes('trigger')) dotColor = '#E53935';
            else if (raw.includes('armed') || raw.includes('arm')) dotColor = '#FF9800';
            else dotColor = '#2196F3';
          } else if (domain === 'lock') {
            const state = entry.state ? String(entry.state).toLowerCase() : '';
            if (state === 'locked') dotColor = '#4CAF50';
            else if (state === 'unlocked') dotColor = '#FFC107';
            else if (state === 'jammed') dotColor = '#F44336';
            else dotColor = '#2196F3';
          } else if (domain === 'climate') {
            dotColor = (HVAC_COLORS && HVAC_COLORS[entry.state]) || (entry.state === 'off' ? '#444' : '#FFD700');
          } else if (domain === 'cover') {
            dotColor = entry.state === 'closed' ? '#444' : '#2196F3';
          } else if (domain === 'binary_sensor' || domain === 'device_tracker' || domain === 'event') {
            dotColor = (entry.state === 'on' || entry.state === 'home' || entry.state === 'detected') ? '#4CAF50' : '#546E7A';
          } else if (domain === 'person') {
            dotColor = entry.state === 'home' ? '#4CAF50' : '#607D8B';
          } else if (domain === 'sensor') {
            dotColor = '#2196F3';
          } else if (domain === 'select' || domain === 'input_select') {
            dotColor = '#9C27B0';
          } else if (domain === 'number' || domain === 'input_number') {
            dotColor = '#FF9800';
          } else if (domain === 'text' || domain === 'input_text') {
            dotColor = '#00BCD4';
          } else if (domain === 'automation') {
            dotColor = entry.state === 'on' ? '#4CAF50' : '#546E7A';
          } else {
            dotColor = entry.state === 'on' ? '#FFD700' : (entry.state === 'off' ? '#444' : '#E53935');
          }
          
          htmlContent += `
            <div class="timeline-item">
              <div class="timeline-visual">
                <div class="timeline-dot" style="background: ${dotColor}"></div>
                <div class="timeline-line"></div>
              </div>
              <div class="timeline-content">
                <strong>${stateText}</strong>
                <span class="timeline-ago">${ago}</span>
                <span class="timeline-trigger">${trigger}</span>
              </div>
            </div>
          `;
        });
        container.innerHTML = htmlContent;
      } catch (err) {
        console.error("Error fetching history", err);
        container.innerHTML = '<div class="history-loading">Error loading history</div>';
      }
    }

    _titleCase(str) {
      return String(str)
        .toLowerCase()
        .replace(/\b\w/g, c => c.toUpperCase());
    }

    _getTimeAgo(date) {
      const now = new Date();
      const diff = now - date;
      const seconds = Math.floor(diff / 1000);
      const minutes = Math.floor(seconds / 60);
      const hours = Math.floor(minutes / 60);
      const days = Math.floor(hours / 24);
      
      if (days > 0) return days === 1 ? '1 day ago' : `${days} days ago`;
      if (hours > 0) return hours === 1 ? '1 hour ago' : `${hours} hours ago`;
      if (minutes > 0) return minutes === 1 ? '1 minute ago' : `${minutes} minutes ago`;
      return 'Just now';
    }

    _formatLastTriggered(entity) {
      if (!entity || !entity.last_changed) {
        return '';
      }
      const lastChanged = new Date(entity.last_changed);
      if (isNaN(lastChanged.getTime())) {
        return '';
      }
      return this._getTimeAgo(lastChanged);
    }

    
    _getClimateBadgeTemperature(entity) {
      // Optional override entity for the small temperature bubble.
      const overrideId = this._config.climate_current_temperature_entity;
      if (overrideId && this.hass && this.hass.states && this.hass.states[overrideId]) {
        const st = this.hass.states[overrideId].state;
        const num = Number(st);
        if (!Number.isNaN(num)) return num;
        // If it's not numeric (e.g. 'unknown'), fall through to default.
      }
      const v = entity?.attributes?.current_temperature;
      return (v === undefined || v === null) ? null : v;
    }


    _getTempUnit(entity) {
      const unit = entity?.attributes?.temperature_unit
        || this.hass?.config?.unit_system?.temperature
        || 'Â°C';
      // HA typically returns "Â°C"/"Â°F" already; if not, normalize.
      if (unit === 'C' || unit === 'c') return 'Â°C';
      if (unit === 'F' || unit === 'f') return 'Â°F';
      return unit;
    }

    _renderClimateCornerBadge(entity, isOn, iconColor, badgeBorder, badgeBg, getTransform) {
      if (this._getDomain() !== 'climate') return '';
      if (this._config.show_temp_badge === false) return '';
      const tempVal = this._getClimateBadgeTemperature(entity);
      if (tempVal === null || tempVal === undefined || tempVal === '' || Number.isNaN(Number(tempVal))) return '';

      const unit = 'Â°';

      // Temperature badge specific config (falls back to icon badge config)
      const size = this._config.temp_badge_size ?? this._config.badge_size ?? 40;
      const fontSize = this._config.size_temp_badge ?? this._config.size_badge;

      const textColor = this._config.temp_badge_text_color ?? 'white';

      const border = (() => {
        const w = this._config.temp_badge_border_width ?? this._config.badge_border_width;
        const st = this._config.temp_badge_border_style ?? this._config.badge_border_style ?? 'none';
        const c = this._config.temp_badge_border_color ?? this._config.badge_border_color ?? 'transparent';
        const _toUnit = (v) => (v === undefined || v === null || v === '') ? '0px' : (String(v).match(/[a-z%]+$/) ? String(v) : `${v}px`);
        return `${_toUnit(w)} ${st} ${c}`;
      })();

      const borderRadius = (() => {
        const r = this._config.temp_badge_border_radius ?? this._config.badge_border_radius;
        if (r === undefined || r === null || r === '') return '999px';
        return (String(r).match(/[a-z%]+$/) ? String(r) : `${r}px`);
      })();

      const boxShadow = this._config.temp_badge_box_shadow ?? this._config.badge_box_shadow ?? '';

      const bubbleColor = isOn ? iconColor : '#888';

      const x = (this._config.temp_badge_offset_x ?? this._config.badge_offset_x) || 0;
      const y = (this._config.temp_badge_offset_y ?? this._config.badge_offset_y) || 0;

      const fontFamily = (this._config.temp_badge_font_family === 'custom')
        ? this._config.temp_badge_font_custom
        : (this._config.temp_badge_font_family || this._config.badge_font_family || 'system-ui');

      const fontWeight = this._config.temp_badge_font_weight || this._config.badge_font_weight || '500';

      return html`
        <div class="badge climate-corner-badge" style="
          width: var(--hki-temp-badge-size, ${size}px); height: var(--hki-temp-badge-size, ${size}px);
          background: ${bubbleColor};
          border: ${border};
          border-radius: ${borderRadius};
          box-shadow: ${boxShadow};
          color: ${textColor};
          font-size: ${fontSize !== undefined && fontSize !== null && fontSize !== '' ? `${fontSize}px` : 'calc(var(--hki-temp-badge-size, 40px) * 0.35)'};
          font-family: ${fontFamily};
          font-weight: ${fontWeight};
          transform: translate(${x}px, ${y}px);
        ">
          ${tempVal}${unit}
        </div>
      `;
    }

    
    _renderBadge(entity, isOn, iconColor, badgeBorder, badgeBg, badgeCount, getTransform) {
      // Icon badge can be disabled independently of other elements
      if (this._config.show_icon_badge === false) return '';

      // Light group count badge
      if (badgeCount > 0) {
        // Scale badge with icon size (while preserving existing badge size overrides)
        // Use the same responsive icon sizing as the tile icon itself:
        const stageMin = Math.min(this._stageW || 0, this._stageH || 0);
        const maxIconSize = this._config.size_icon || 24;
        const iconScale = (() => { const max = Number(maxIconSize) || 24; return Math.max(0.08, Math.min(0.35, 0.15 * (max / 24))); })();
        const responsiveIcon = stageMin ? Math.round(stageMin * iconScale) : maxIconSize;
        const iconSize = Math.max(16, Math.min(maxIconSize, responsiveIcon));

        // If badge_size isn't configured, derive a sensible diameter from icon size
        const badgeDiameter = (this._config.badge_size !== undefined && this._config.badge_size !== null && this._config.badge_size !== '')
          ? Number(this._config.badge_size)
          : Math.max(16, Math.round(iconSize * 0.6));

        // Font size: keep existing size_badge override, otherwise scale with badge diameter
        const badgeFontSize = (this._config.size_badge !== undefined && this._config.size_badge !== null && this._config.size_badge !== '')
          ? Number(this._config.size_badge)
          : Math.max(9, Math.round(badgeDiameter * 0.55));

        return html`
          <div class="badge" style="
            font-size: ${badgeFontSize}px;
            background: ${badgeBg};
            border: ${badgeBorder};
            transform: ${getTransform(this._config.badge_offset_x, this._config.badge_offset_y)};
            min-width: ${badgeDiameter}px;
            height: ${badgeDiameter}px;
            line-height: ${badgeDiameter}px;
          ">
            ${badgeCount}
          </div>
        `;
      }

      return '';
    }



    /* --- TILE RENDER LOGIC --- */

    render() {
      const layoutRaw = this._config.card_layout || 'square';
      let layout = layoutRaw;

      // Supported layouts
      if (!['square','badge','hki_tile','google_default'].includes(layout)) layout = 'square';
      // Google Default renders like square, but has its own default config + editor baselines
      if (layout === 'google_default') layout = 'square';

      const entity = this._getEntity();
      const hasEntity = !!entity;
      const isOn = hasEntity ? this._isOn() : false;
      const isUnavailable = hasEntity ? (String(entity.state || '').toLowerCase() === 'unavailable') : false;
      const isOnEffective = isUnavailable ? false : isOn;

      // Icon (template-capable). If empty, fall back to HA entity icon.
      const iconRendered = this.renderTemplate('icon', this._config.icon || '');
      const iconToUse = (iconRendered !== undefined && iconRendered !== null && String(iconRendered).trim() !== '')
        ? String(iconRendered).trim()
        : undefined;

      // -- Typography Helper --
      const getFont = (family, weight, size) => {
          let f = family || 'inherit';
          if (f === 'system') f = 'inherit';
          else if (f === 'custom') f = this._config[`${family}_custom`] || 'inherit';
          
          let w = weight || 'normal';
          return `font-family: ${f}; font-weight: ${w}; font-size: ${size || 12}px;`;
      };

      // -- Unit Helper (Fix for "border: 2 solid" bug) --
      const _toUnit = (v) => (!v ? '0px' : (isNaN(v) ? v : `${v}px`));

      // -- Layout & Shape --
      // (layout is defined at the start of render)
      
      // Apply layout-specific defaults (without writing to YAML)
      let gridRows = this._config.grid_rows;
      let gridCols = this._config.grid_columns;
      let elementGrid = this._config.element_grid;
      let borderRadius = this._config.border_radius;
      if (layout === 'hki_tile') {
        if (borderRadius === undefined) borderRadius = 12;
      }

      if (layout === 'square') {
        // Fixed square layout (button-card grid-template-areas equivalent):
        // "i i"
        // "area area" (whitespace)
        // "n n"
        // "s s"
        // "l l" (info_display)
        // Layout settings are intentionally removed for now.
        gridRows = 5;
        gridCols = 2;
        if (borderRadius === undefined) borderRadius = 12;
        elementGrid = [
          'icon','icon',
          'empty','empty',
          'name','name',
          'state','state',
          'info','info'
        ];
      }

      // -- Colors --
      const haDefaultBg = 'var(--ha-card-background, var(--card-background-color))';
      
      // Auto color used by style fields that are set to "auto"
      const currentAutoColor = this._getCurrentColor?.() || null;
      const defaultAutoColor = currentAutoColor || 'var(--state-icon-color)';
      const resolveAutoColor = (value, fallback = '') => {
        if (value === undefined || value === null) return fallback;
        const str = String(value).trim();
        if (!str) return fallback;
        if (str.toLowerCase() === 'auto') return defaultAutoColor;
        return value;
      };
      const resolveAutoShadow = (value, fallback = '') => {
        if (value === undefined || value === null || value === '') return fallback;
        const str = String(value).trim().toLowerCase();
        if (str === 'auto') return `0 8px 24px ${defaultAutoColor}`;
        return value;
      };

      // HKI Default on-state auto-theme: white card + black text when entity is active
      // Only applies to HKI Default layout (square / undefined), only when the user
      // has not explicitly set a value for the affected property.
      const isHkiDefault = !this._config.card_layout || this._config.card_layout === 'square' || this._config.card_layout === 'hki_tile' || this._config.card_layout === 'badge';
      const _hkiOnActive = isHkiDefault && isOnEffective;
      
      // Card color with template support
      let bgColor = (_hkiOnActive && !this._config.card_color) ? 'white' : haDefaultBg;
      if (this._config.card_color) {
        const rendered = this.renderTemplate('cardColor', this._config.card_color);
        if (rendered === 'auto') {
          bgColor = defaultAutoColor;
        } else if (rendered) {
          bgColor = rendered;
        }
      }
      
      // Card opacity with template support
      // Defaults: 1.0 when on, 0.7 when off, 0.5 when unavailable
      let cardOpacity = isUnavailable ? 0.5 : (isOnEffective ? 1.0 : 0.7);
      if (this._config.card_opacity !== undefined) {
        const rendered = this.renderTemplate('cardOpacity', String(this._config.card_opacity));
        const parsed = parseFloat(rendered);
        if (!isNaN(parsed)) {
          cardOpacity = isUnavailable ? Math.min(parsed, 0.5) : parsed;
        }
      }
      
      // Box shadow with template support
      let boxShadow = '';
      if (this._config.box_shadow) {
        const rendered = this.renderTemplate('boxShadow', this._config.box_shadow);
        if (rendered === 'default') {
          boxShadow = ''; // unset -> theme default
        } else if (rendered === 'none') {
          boxShadow = 'none';
        } else if (rendered) {
          boxShadow = resolveAutoShadow(rendered, '');
        }
      }

      // Individual Element Colors with template support
      const nameColor = this._config.name_color
        ? resolveAutoColor(this.renderTemplate('nameColor', this._config.name_color), _hkiOnActive ? '#000000' : 'inherit')
        : (_hkiOnActive ? '#000000' : 'inherit');
      const stateColor = isUnavailable ? 'var(--error-color, red)' 
        : (this._config.state_color ? resolveAutoColor(this.renderTemplate('stateColor', this._config.state_color), _hkiOnActive ? '#000000' : 'inherit') : (_hkiOnActive ? '#000000' : 'inherit'));
      const labelColor = this._config.label_color
        ? resolveAutoColor(this.renderTemplate('labelColor', this._config.label_color), _hkiOnActive ? '#000000' : 'inherit')
        : (_hkiOnActive ? '#000000' : 'inherit');

      // Info display / brightness colors (template support; defaults follow theme)
      const brightnessColorBase = this._config.brightness_color
        ? resolveAutoColor(this.renderTemplate('brightnessColor', this._config.brightness_color), '')
        : '';
      const _infoDspDefault = _hkiOnActive ? '#000000' : 'inherit';
      const brightnessColorOn = this._config.brightness_color_on
        ? resolveAutoColor(this.renderTemplate('brightnessColorOn', this._config.brightness_color_on), brightnessColorBase || _infoDspDefault)
        : (brightnessColorBase || _infoDspDefault);
      const brightnessColorOff = this._config.brightness_color_off
        ? resolveAutoColor(this.renderTemplate('brightnessColorOff', this._config.brightness_color_off), brightnessColorBase || _infoDspDefault)
        : (brightnessColorBase || _infoDspDefault);

      // Icon color logic with template support and auto modes
      const domain = this._getDomain();
      let iconColor;
      // When no explicit icon_color is set, follow Home Assistant defaults:
      // - unavailable: --state-icon-unavailable-color
      // - climate: color based on hvac_action / hvac_mode
      // - light on: actual bulb color
      // - on: #ffc107, off: --state-icon-color
      if (isUnavailable) {
        iconColor = 'var(--state-icon-unavailable-color)';
      } else if (domain === 'climate' && !this._config.icon_color) {
        iconColor = this._getClimateColor(entity);
      } else if (domain === 'light' && isOn && !this._config.icon_color) {
        // For lights: use actual color
        iconColor = this._getCurrentColor() || '#ffc107';
      } else {
        // For everything else: yellow when on, grey when off
        iconColor = isOn ? '#ffc107' : 'var(--state-icon-color)';
      }
      
      if (this._config.icon_color) {
        const rendered = this.renderTemplate('iconColor', this._config.icon_color);
        
        if (rendered === 'auto') {
          // Auto mode: smart color based on domain and state
          if (domain === 'climate') {
            iconColor = this._getClimateColor(entity);
          } else if (domain === 'lock') {
            const state = entity?.state;
            if (state === 'locked') iconColor = '#4CAF50';
            else if (state === 'unlocked') iconColor = '#FFC107';
            else if (state === 'jammed') iconColor = '#F44336';
            else iconColor = 'var(--primary-color)';
          } else if (domain === 'alarm_control_panel') {
            const state = entity?.state;
            if (state === 'disarmed') iconColor = '#4CAF50';
            else if (state === 'armed_home' || state === 'armed_away' || state === 'armed_night' || 
                     state === 'armed_vacation' || state === 'armed_custom_bypass') iconColor = '#FF9800';
            else if (state === 'triggered' || state === 'pending') iconColor = '#F44336';
            else iconColor = 'var(--primary-color)';
          } else if (domain === 'light' && isOn) {
            // For lights in on state with auto, use current light color
            iconColor = this._getCurrentColor() || 'var(--primary-color)';
          }
        } else if (rendered) {
          // Use the rendered template value directly
          iconColor = rendered;
        }
      }


      // -- Borders with template support --
      // Card Border
      const borderWidth = this._config.border_width ? this.renderTemplate('borderWidth', String(this._config.border_width)) : '0';
      const borderStyle = this._config.border_style ? this.renderTemplate('borderStyle', this._config.border_style) : 'none';
      const borderColor = this._config.border_color ? resolveAutoColor(this.renderTemplate('borderColor', this._config.border_color), 'transparent') : 'transparent';
      const cardBorder = `${_toUnit(borderWidth)} ${borderStyle} ${borderColor}`;
      
      // Icon Circle Styling with template support
      const iconCircleBorderWidth = this._config.icon_circle_border_width ? this.renderTemplate('iconCircleBorderWidth', String(this._config.icon_circle_border_width)) : '0';
      const iconCircleBorderStyle = this._config.icon_circle_border_style ? this.renderTemplate('iconCircleBorderStyle', this._config.icon_circle_border_style) : 'none';
      const iconCircleBorderColor = this._config.icon_circle_border_color ? resolveAutoColor(this.renderTemplate('iconCircleBorderColor', this._config.icon_circle_border_color), 'transparent') : 'transparent';
      const iconCircleBorder = `${_toUnit(iconCircleBorderWidth)} ${iconCircleBorderStyle} ${iconCircleBorderColor}`;
      const iconCircleBg = this._config.icon_circle_bg 
        ? this.renderTemplate('iconCircleBg', this._config.icon_circle_bg) 
        : 'rgba(0,0,0,0.05)';

      // Badge Styling with template support
      const badgeBorderWidth = this._config.badge_border_width ? this.renderTemplate('badgeBorderWidth', String(this._config.badge_border_width)) : '0';
      const badgeBorderStyle = this._config.badge_border_style ? this.renderTemplate('badgeBorderStyle', this._config.badge_border_style) : 'none';
      const badgeBorderColor = this._config.badge_border_color ? resolveAutoColor(this.renderTemplate('badgeBorderColor', this._config.badge_border_color), 'transparent') : 'transparent';
      const badgeBorder = `${_toUnit(badgeBorderWidth)} ${badgeBorderStyle} ${badgeBorderColor}`;
      const badgeBg = this._config.badge_bg ? resolveAutoColor(this.renderTemplate('badgeBg', this._config.badge_bg), 'var(--primary-color)') : 'var(--primary-color)';

      // -- Offsets --
      const getTransform = (x, y) => `translate(${x || 0}px, ${y || 0}px)`;

      // -- Data --
      // For templates: show rendered value or empty string (cache retrieves instantly on subsequent loads)
      // Never show raw template syntax or default values while loading
      const nameText = this._isTemplate(this._config.name)
        ? (this._renderedName || '')
        : (this._config.name || entity?.attributes?.friendly_name || '');
      
      let stateText = this._isTemplate(this._config.state_label)
        ? (this._renderedState || '')
        : this._config.state_label;
      
      if (!stateText) {
          if (entity) {
            const domain = this._getDomain();
            // Use localized state strings
            stateText = this._getLocalizedState(entity.state, domain);
          } else {
            stateText = '';
          }
      }
      const labelText = this._isTemplate(this._config.label)
        ? (this._renderedLabel || '')
        : (this._config.label || '');
      const infoText = this._isTemplate(this._config.info_display)
        ? (this._renderedInfo || '')
        : (this._config.info_display || '');
      const brightnessColor = this._config.brightness_color
        ? resolveAutoColor(this.renderTemplate('brightnessColor', this._config.brightness_color), 'inherit')
        : 'inherit';
            
      const isGroup = !!(entity?.attributes?.entity_id && Array.isArray(entity.attributes.entity_id));
      const badgeCount = isGroup
        ? (entity?.attributes?.entity_id || []).filter((id) => this.hass?.states?.[id]?.state === 'on').length
        : 0;
      
      // Animations should only run when the entity is effectively ON.
      // (Disabled for OFF and for UNAVAILABLE, which is treated as OFF elsewhere.)
      // Icon animation with template support - defaults to "on" state if plain animation name
      let animClass = '';
      if (this._config.icon_animation) {
        const rendered = this.renderTemplate('iconAnimation', this._config.icon_animation);
        if (rendered && rendered !== 'none') {
          // If it's a plain animation name (no template syntax in original config)
          if (!this._isTemplate(this._config.icon_animation)) {
            // Default to showing animation only when entity is on
            animClass = isOnEffective ? `animate-${rendered}` : '';
          } else {
            // Template explicitly controls when to show animation
            animClass = `animate-${rendered}`;
          }
        }
        // rendered === 'none' â†’ no animation (also suppresses the fan default below)
      } else if (domain === 'fan' && isOnEffective) {
        // Fan: spin by default when on (override with icon_animation: none to disable)
        animClass = 'animate-spin';
      }

      // Custom Font Logic for specific fields
      const nameFont = this._config.name_font_family === 'custom' ? this._config.name_font_custom : this._config.name_font_family;
      const stateFont = this._config.state_font_family === 'custom' ? this._config.state_font_custom : this._config.state_font_family;
      const labelFont = this._config.label_font_family === 'custom' ? this._config.label_font_custom : this._config.label_font_family;

      // New Brightness Font Logic
      const brightnessFont = this._config.brightness_font_family === 'custom' ? this._config.brightness_font_custom : this._config.brightness_font_family;

      // Shared ha-card inline styles (used by most layouts). Tile layout should use this too.
      const __hkiCardStyle = `
            background: ${isUnavailable ? "transparent" : bgColor};
            opacity: ${isUnavailable ? 1 : cardOpacity};
            --hki-unavailable-bg: ${bgColor};
            --hki-unavailable-opacity: ${cardOpacity};
            border-radius: ${borderRadius}px !important;
            box-shadow: ${boxShadow || 'none'} !important;
            border: ${cardBorder} !important;
            ${iconColor ? `            --icon-color: ${iconColor} !important;\n` : ''}            --hki-card-min: ${Math.min(this._stageW || 0, this._stageH || 0)}px;
            --hki-icon-size: clamp(16px, calc(var(--hki-card-min) * ${(() => { const max = Number(this._config.size_icon) || 24; const scale = Math.max(0.08, Math.min(0.35, 0.15 * (max / 24))); return scale.toFixed(4); })()}), ${Number(this._config.size_icon) || 24}px);
            --hki-temp-badge-scale: ${(() => { const iconMax = (this._config.size_icon || 24); const circleMax = iconMax + 16; const tempMax = (this._config.temp_badge_size ?? circleMax); return (tempMax / circleMax).toFixed(4); })()};
            --hki-temp-badge-size: calc(var(--hki-icon-circle-size) * var(--hki-temp-badge-scale));
            --hki-icon-circle-size: calc(var(--hki-icon-size) + 16px);
      `;

      

      const iconAlign = this._config.icon_align || 'left';
      const iconJustify = iconAlign === 'center' ? 'center' : iconAlign === 'right' ? 'flex-end' : 'flex-start';
      const renderInfoDisplay = () => {
                  if (this._config.show_info_display === false) return '';
                  
                  let bottomValue = '';
                  
                  // For templates: only show rendered value, never raw template
                  if (this._isTemplate(this._config.info_display)) {
                    bottomValue = this._renderedInfo || '';
                  } else if (this._config.info_display) {
                    bottomValue = this._config.info_display;
                  }
                  
                  // If no override, calculate default value
                  if (!bottomValue) {
                    if (this._getDomain() === 'light') {
                      bottomValue = `${this._getBrightness()}%`;
                    } else if (this._getDomain() === 'climate') {
                      const attrs = entity.attributes || {};
                      if (attrs.target_temp_low !== undefined && attrs.target_temp_low !== null) {
                        const unit = 'Â°';
                        bottomValue = `${attrs.target_temp_low}-${attrs.target_temp_high}${unit}`;
                      } else if (attrs.temperature !== undefined && attrs.temperature !== null) {
                        const unit = 'Â°';
                        bottomValue = `${attrs.temperature}${unit}`;
                      }
                    }
                  }
                  
                  if (!bottomValue) return '';
                  const brightnessColor = isOn ? brightnessColorOn : brightnessColorOff;
                  return html`
                    <div class="brightness-tag info-tag" style="
                        ${getFont(brightnessFont, this._config.brightness_font_weight, this._config.size_brightness || 12)}
                        color: ${brightnessColor};
                        text-align: ${this._config.brightness_text_align || 'left'};
                        transform: ${getTransform(this._config.brightness_offset_x, this._config.brightness_offset_y)};
                    ">
                        ${bottomValue}
                    </div>
                  `;
              };
      const elements = {
                icon: () => html`
                  <div class="tile-header" style="justify-content: ${iconJustify};">
                    ${(this._config.show_icon !== false) ? html`
                    <div 
                        class="icon-circle"
                        style="
                            width: var(--hki-icon-circle-size); 
                            height: var(--hki-icon-circle-size);
                            background: ${this._config.show_icon_circle !== false ? iconCircleBg : 'transparent'};
                            border: ${this._config.show_icon_circle !== false ? iconCircleBorder : 'none'};
                            transform: ${getTransform(this._config.icon_offset_x, this._config.icon_offset_y)};
                        "
                        @click=${(e) => { e.stopPropagation(); this._handleDelayClick(this._config.icon_tap_action || this._config.tap_action || this._defaultTapActionConfig(), this._config.icon_double_tap_action || this._config.double_tap_action || { action: this._defaultInfoActionType() }); }}
                          
                        @mousedown=${(e) => { e.stopPropagation(); this._startHold(e, this._config.icon_hold_action); }}
                        @mouseup=${(e) => { e.stopPropagation(); this._clearHold(); }}
                        @mouseleave=${(e) => { this._clearHold(); }}
                        @touchstart=${(e) => { e.stopPropagation(); this._startHold(e, this._config.icon_hold_action); }}
                        @touchend=${(e) => { e.stopPropagation(); this._clearHold(); }}
                        @touchcancel=${(e) => { this._clearHold(); }}
                    >
                        ${this._config.use_entity_picture ? (() => {
                          const entityPicture = this._config.entity_picture_override || entity?.attributes?.entity_picture;
                          return entityPicture ? html`
                            <img 
                              src="${entityPicture}"
                              class="${animClass}"
                              style="width: var(--hki-icon-size); height: var(--hki-icon-size); border-radius: 50%; object-fit: cover;"
                            />
                          ` : html`
                            <ha-state-icon
                              .hass=${this.hass}
                              .stateObj=${entity}
                              .icon=${iconToUse}
                              class="${animClass}"
                              style="--mdc-icon-size: var(--hki-icon-size); color: ${iconColor}; transition: color 0.3s;"
                            ></ha-state-icon>
                          `;
                        })() : iconToUse ? html`
                          <ha-icon 
                            .icon=${iconToUse}
                            class="${animClass}"
                            style="--mdc-icon-size: var(--hki-icon-size); color: ${iconColor};"
                          ></ha-icon>
                        ` : html`
                          <ha-state-icon
                            .hass=${this.hass}
                            .stateObj=${entity}
                            class="${animClass}"
                            style="--mdc-icon-size: var(--hki-icon-size); color: ${iconColor}; transition: color 0.3s;"
                          ></ha-state-icon>
                        `}
                        ${this._renderBadge(entity, isOn, iconColor, badgeBorder, badgeBg, badgeCount, getTransform)}
                    </div>
                    ` : ''}
                  </div>
                `,
                name: () => (this._config.show_name !== false) ? html`
                  <div class="name" style="
                      ${getFont(nameFont, this._config.name_font_weight, this._config.size_name || 14)}
                      color: ${nameColor};
                      text-align: ${this._config.name_text_align || 'left'};
                      transform: ${getTransform(this._config.name_offset_x, this._config.name_offset_y)};
                  ">
                      ${nameText}
                  </div>
                ` : '',
                label: () => (this._config.show_label && labelText) ? html`
                  <div class="label" style="
                      ${getFont(labelFont, this._config.label_font_weight, this._config.size_label || 11)}
                      color: ${labelColor};
                      text-align: ${this._config.label_text_align || 'left'};
                      transform: ${getTransform(this._config.label_offset_x, this._config.label_offset_y)};
                  ">
                      ${labelText}
                  </div>
                ` : '',
                state: () => (this._config.show_state !== false) ? html`
                  <div class="state" style="
                      ${getFont(stateFont, this._config.state_font_weight, this._config.size_state || 12)}
                      color: ${stateColor};
                      text-align: ${this._config.state_text_align || 'left'};
                      transform: ${getTransform(this._config.state_offset_x, this._config.state_offset_y)};
                  ">
                      ${stateText}
                  </div>
                ` : '',
              info_display: renderInfoDisplay,
              info: renderInfoDisplay,
              temp_badge: () => {
                  // Only render for climate entities
                  if (this._getDomain() !== 'climate') return '';
                  return this._renderClimateCornerBadge(entity, isOn, iconColor, badgeBorder, badgeBg, getTransform);
                }
              };


      // HKI Tile layout: wide pill, icon circle left, stacked text.
      if (layout === 'hki_tile') {
        const showIcon = this._config.show_icon !== false;
        const showName = this._config.show_name !== false;
        const showState = this._config.show_state !== false;
        const showCircle = this._config.show_icon_circle !== false;
        const showLabel = false;
        const showInfo = this._config.show_brightness !== false; // Enable info display for tile layout
        
        // Icon color logic for tile (same as main layout)
        let tileIconColor;
        if (isUnavailable) {
          tileIconColor = 'var(--state-icon-unavailable-color)';
        } else if (domain === 'climate' && !this._config.icon_color) {
          tileIconColor = this._getClimateColor(entity);
        } else if (domain === 'light' && isOn && !this._config.icon_color) {
          // For lights: use actual color
          tileIconColor = this._getCurrentColor() || '#ffc107';
        } else {
          // For everything else: yellow when on, grey when off
          tileIconColor = isOn ? '#ffc107' : 'var(--state-icon-color)';
        }
        
        if (this._config.icon_color) {
          const rendered = this.renderTemplate('iconColor', this._config.icon_color);
          if (rendered === 'auto') {
            if (domain === 'climate') {
              tileIconColor = this._getClimateColor(entity);
            } else if (domain === 'light' && isOn) {
              tileIconColor = this._getCurrentColor() || 'var(--primary-color)';
            }
          } else if (rendered) {
            tileIconColor = rendered;
          }
        }
        
        const __iconOverride = (this.renderTemplate('icon', this._config.icon || '') || '').toString().trim();
        const icon = (__iconOverride)
          ? __iconOverride
          : ((entity && entity.attributes && entity.attributes.icon) || 'mdi:help-circle');

        const tileNameText = nameText;
        const tileStateText = stateText;

        const tileLabelText = (this._config.label !== undefined && this._config.label !== null && this._config.label !== '')
          ? labelText
          : labelText;
        
        // Get info display content
        let tileInfoEl = "";
        if (showInfo) {
          // Get the info value from template or config or domain defaults
          if (this._isTemplate(this._config.info_display)) {
            tileInfoEl = this._renderedInfo || '';
          } else if (this._config.info_display) {
            tileInfoEl = this._config.info_display;
          } else if (domain === 'light') {
            tileInfoEl = `${this._getBrightness()}%`;
          } else if (domain === 'climate') {
            const attrs = entity.attributes || {};
            if (attrs.target_temp_low !== undefined && attrs.target_temp_low !== null) {
              tileInfoEl = `${attrs.target_temp_low}-${attrs.target_temp_high}Â°`;
            } else if (attrs.temperature !== undefined && attrs.temperature !== null) {
              tileInfoEl = `${attrs.temperature}Â°`;
            }
          } else if (domain === 'media_player') {
            const volume = this._getSliderValue();
            tileInfoEl = `${volume}%`;
          } else if (domain === 'fan') {
            const speed = this._getSliderValue();
            tileInfoEl = `${speed}%`;
          }
        }

        const tileAnimClass = (this._config.enable_icon_animation === true && isOnEffective)
          ? 'hki-icon-anim'
          : (domain === 'fan' && isOnEffective ? 'animate-spin' : '');
        const __hkiTileHeightCfg = Number(this._config.tile_height);
        const __hkiTileHeightRaw = (Number.isFinite(__hkiTileHeightCfg) && __hkiTileHeightCfg > 0)
          ? Math.round(__hkiTileHeightCfg)
          : 60; // default tile height (do not write to YAML)
        const __hkiTileHeight = Math.max(40, __hkiTileHeightRaw); // minimum 40px
        const __hkiTileStyle = `${__hkiCardStyle} height: ${__hkiTileHeight}px !important; min-height: ${__hkiTileHeight}px !important;`;

        // Tile brightness/volume slider configuration
        const showBrightnessSlider = this._config.show_tile_slider === true && isOnEffective && (
          domain === 'light' ||
          domain === 'media_player' ||
          domain === 'fan' ||
          domain === 'cover'
        );
        const sliderTrackColor = this._config.tile_slider_track_color || 'rgba(255, 255, 255, 0.2)';
        const sliderFillColor = this._config.tile_slider_fill_color || 'rgba(255, 255, 255, 0.8)';
        const currentSliderValue = this._getSliderValue();


        return html`
          <ha-card 
            class="hki-tile ${isOnEffective ? 'on' : 'off'} layout-hki-tile ${isUnavailable ? 'is-unavailable' : ''}"
            style="${__hkiTileStyle}"
            @click=${(e) => { 
              // Don't handle if slider is active (let slider handle it)
              if (showBrightnessSlider) return;
              e.stopPropagation(); 
              this._handleDelayClick(this._config.tap_action || this._defaultTapActionConfig(), this._config.double_tap_action || { action: this._defaultInfoActionType() }); 
            }}
            @mousedown=${(e) => {
              // Don't handle if slider is active
              if (showBrightnessSlider) return;
              e.stopPropagation(); 
              this._startHold(e, this._config.hold_action); 
            }}
            @mouseup=${(e) => { e.stopPropagation(); this._clearHold(); }}
            @mouseleave=${(e) => { this._clearHold(); }}
            @touchstart=${(e) => {
              // Don't handle if slider is active
              if (showBrightnessSlider) return;
              e.stopPropagation(); 
              this._startHold(e, this._config.hold_action); 
            }}
            @touchend=${(e) => { e.stopPropagation(); this._clearHold(); }}
          >
            <div class="hki-tile layout-hki-tile">
              ${showIcon ? html`
                <div class="icon-circle hki-icon-circle" style="
                  width: var(--hki-icon-circle-size);
                  height: var(--hki-icon-circle-size);
                  background: ${showCircle ? iconCircleBg : 'transparent'};
                  border: ${showCircle ? iconCircleBorder : 'none'};
                  transform: translate(calc(${Number(this._config.icon_offset_x||0)}px + ${Number(this._config.icon_circle_offset_x||0)}px), calc(${Number(this._config.icon_offset_y||0)}px + ${Number(this._config.icon_circle_offset_y||0)}px));
                  cursor: pointer;
                  z-index: 10;
                  position: relative;
                "
                @click=${(e) => { 
                  e.stopPropagation();
                  // When slider is enabled, the card itself ignores taps; so the icon handles them.
                  const ta = (this._config.icon_tap_action || this._config.tap_action || this._defaultTapActionConfig());
                  const dta = (this._config.icon_double_tap_action || this._config.double_tap_action || { action: this._defaultInfoActionType() });
                  this._handleDelayClick(ta, dta);
                }}
                @mousedown=${(e) => { 
                  e.stopPropagation(); 
                  const ha = (this._config.icon_hold_action || this._config.hold_action);
                  this._startHold(e, ha); 
                }}
                @mouseup=${(e) => { e.stopPropagation(); this._clearHold(); }}
                @mouseleave=${(e) => { this._clearHold(); }}
                @touchstart=${(e) => { 
                  e.stopPropagation(); 
                  const ha = (this._config.icon_hold_action || this._config.hold_action);
                  this._startHold(e, ha); 
                }}
                @touchend=${(e) => { e.stopPropagation(); this._clearHold(); }}
                @touchcancel=${(e) => { this._clearHold(); }}
                >
                  ${this._config.entity_picture ? html`
                    <img src="${this._getEntityPicture(entity)}" class="${tileAnimClass}" style="width:var(--hki-icon-size);height:var(--hki-icon-size);border-radius:50%; " />
                  ` : (icon && this._config.icon) ? html`
                    <ha-icon .icon=${icon} class="${tileAnimClass}" style="--mdc-icon-size: var(--hki-icon-size); color: ${tileIconColor}; transition: color 0.3s;"></ha-icon>
                  ` : html`
                    <ha-state-icon .hass=${this.hass} .stateObj=${entity} class="${tileAnimClass}" style="--mdc-icon-size: var(--hki-icon-size); color: ${tileIconColor}; transition: color 0.3s;"></ha-state-icon>
                  `}

                  ${this._renderBadge(entity, isOnEffective, tileIconColor, badgeBorder, badgeBg, badgeCount, (x, y) => `translate(${x || 0}px, ${y || 0}px)`)}
                  </div>
              ` : ''}

              <div class="hki-tile-text">
                ${showName ? html`<div class="name" style="${getFont(nameFont, this._config.name_font_weight, this._config.size_name || 13)} color:${nameColor}; transform:${getTransform(this._config.name_offset_x, this._config.name_offset_y)};">${tileNameText}</div>` : ''}
                ${showLabel ? html`<div class="label" style="${getFont(labelFont, this._config.label_font_weight, (this._config.size_label ?? -2))} color:${labelColor}; transform:${getTransform(this._config.label_offset_x, this._config.label_offset_y)};">${tileLabelText}</div>` : ''}
                ${showState ? html`<div class="state" style="${getFont(stateFont, this._config.state_font_weight, this._config.size_state || 12)} color:${stateColor}; transform:${getTransform(this._config.state_offset_x, this._config.state_offset_y)};">${tileStateText}</div>` : ''}
              </div>
              ${showInfo && tileInfoEl ? html`
                <div class="tile-info-corner" style="
                  ${getFont(brightnessFont, this._config.brightness_font_weight, this._config.size_brightness || 12)}
                  color: ${isOnEffective ? brightnessColorOn : brightnessColorOff};
                  transform:${getTransform(this._config.brightness_offset_x, this._config.brightness_offset_y)};
                ">${tileInfoEl}</div>
              ` : ''}
            </div>
            ${showBrightnessSlider ? html`
                <div 
                  class="hki-brightness-slider-container"
                  style="
                    --slider-track-color: ${sliderTrackColor};
                    --slider-fill-color: ${sliderFillColor};
                    --slider-progress: ${currentSliderValue}%;
                  "
                >
                  <div class="hki-brightness-slider-visual"></div>
                </div>
                <input 
                  type="range" 
                  min="0" 
                  max="100" 
                  .value=${currentSliderValue}
                  class="hki-brightness-slider-input"
                  style="
                    --slider-track-color: ${sliderTrackColor};
                    --slider-fill-color: ${sliderFillColor};
                    --slider-progress: ${currentSliderValue}%;
                  "
                  @click=${(e) => this._tileSliderClick(e)}
                  @pointerdown=${(e) => this._tileSliderPointerDown(e)}
                  @pointermove=${(e) => this._tileSliderPointerMove(e)}
                  @pointerup=${(e) => this._tileSliderPointerUp(e)}
                  @pointercancel=${(e) => this._tileSliderPointerUp(e)}
                  @input=${(e) => this._tileSliderInput(e, domain)}
                  @change=${(e) => this._tileSliderChange(e, domain)}
                  />
                </div>
              ` : ''}
          </ha-card>
        `;
      }

      // HA badge mimic mode: compact, fixed-size, no grid.
      if (layout === 'badge') {
        // Mimic Home Assistant badges: fixed-size icon circle and optional pill for name/state.
        const showIcon = this._config.show_icon !== false;
        const showName = this._config.show_name === true;
        const showState = this._config.show_state === true;

        // Use the already computed display strings (and allow explicit overrides via config)
        const badgeNameText = nameText;

        const badgeStateText = stateText;

        // Fixed HA-like badge sizes
        const badgeCircleSize = 35;
        const iconSize = Math.min(Math.max(Number(this._config.size_icon || 18), 10), 28);

        // Pill is shown only when name/state selected
        const showPill = (showName || showState);

        // Reuse existing HKI styling logic for card-level overrides (background/border/shadow/opacity/radius)
        const badgeBg = bgColor;
        const badgeBorder = (() => {
          // HA-like default outline for badges is slightly thinner than 1px.
          // Only apply this default when the user didn't explicitly configure a border.
          const bw = this._config.border_width;
          const bs = this._config.border_style;
          const bc = this._config.border_color;
          const userSetBorder = !((bw === undefined || bw === null || bw === '') && (bs === undefined || bs === null || bs === '') && (bc === undefined || bc === null || bc === ''));
          if (!userSetBorder) return `0.5px solid var(--divider-color)`;
          // If user did set a border but used an unqualified "1", allow "0.5" in badge mode by setting border_width to 0.5.
          if ((bw === 1 || bw === '1' || bw === '1px') && (bs === undefined || bs === null || bs === '')) {
            return `0.5px solid ${bc || 'var(--divider-color)'}`;
          }
          return cardBorder;
        })();
        const iconRendered = this.renderTemplate('icon', this._config.icon || '');
        const iconToUse = (iconRendered !== undefined && iconRendered !== null && String(iconRendered).trim() !== '') ? String(iconRendered).trim() : undefined;

        const badgeShadow = boxShadow;
        const badgeOpacity = cardOpacity;

        const badgeRadius = (this._config.border_radius !== undefined && this._config.border_radius !== null)
          ? borderRadius
          : 999;

        // Icon circle style (can be disabled independently)
        const showCircle = this._config.show_icon_circle !== false;

        // Default to the existing icon circle styling (so HKI overrides behave the same as other layouts)
        const circleBg = showCircle ? iconCircleBg : 'transparent';
        const circleBorder = showCircle ? iconCircleBorder : 'none';

        // Icon color logic for badge (same as main layout)
        let badgeIconColor;
        if (isUnavailable) {
          badgeIconColor = 'var(--state-icon-unavailable-color)';
        } else if (domain === 'climate' && !this._config.icon_color) {
          badgeIconColor = this._getClimateColor(entity);
        } else if (domain === 'light' && isOn && !this._config.icon_color) {
          // For lights: use actual color
          badgeIconColor = this._getCurrentColor() || '#ffc107';
        } else {
          // For everything else: yellow when on, grey when off
          badgeIconColor = isOn ? '#ffc107' : 'var(--state-icon-color)';
        }
        
        if (this._config.icon_color) {
          const rendered = this.renderTemplate('iconColor', this._config.icon_color);
          if (rendered === 'auto') {
            if (domain === 'climate') {
              badgeIconColor = this._getClimateColor(entity);
            } else if (domain === 'light' && isOn) {
              badgeIconColor = this._getCurrentColor() || 'var(--primary-color)';
            }
          } else if (rendered) {
            badgeIconColor = rendered;
          }
        }

        // Render icon using the same HKI logic as other layouts (entity picture, overrides, animations, colors)
        const renderBadgeIcon = () => {
          if (!showIcon) return '';

          if (this._config.use_entity_picture) {
            const entityPicture = this._config.entity_picture_override || entity?.attributes?.entity_picture;
            if (entityPicture) {
              return html`
                <img
                  src="${entityPicture}"
                  class="${animClass}"
                  style="width:${iconSize}px;height:${iconSize}px;border-radius:50%;object-fit:cover;display:block;"
                />
              `;
            }
          }

          if (iconToUse) {
            return html`
              <ha-icon
                .icon=${iconToUse}
                class="${animClass}"
                style="--mdc-icon-size:${iconSize}px;color:${badgeIconColor};transition:color 0.3s;display:block;"
              ></ha-icon>
            `;
          }

          return html`
            <ha-state-icon
              .hass=${this.hass}
              .stateObj=${entity}
              class="${animClass}"
              style="--mdc-icon-size:${iconSize}px;color:${badgeIconColor};transition:color 0.3s;display:block;"
            ></ha-state-icon>
          `;
        };

        // Apply HKI visual overrides:
        // - Icon-only: circle gets background/border/shadow/radius/opacity
        // - Pill: wrapper gets background/border/shadow/radius/opacity (circle uses icon-circle settings)
        const wrapStyle = showPill
          ? (isUnavailable
              ? `background:transparent;border:${badgeBorder};box-shadow:${badgeShadow};--hki-badge-bg:${badgeBg};--hki-badge-opacity:${badgeOpacity};--hki-badge-pill-height:${badgeCircleSize}px;height:${badgeCircleSize}px;border-radius:calc(${badgeCircleSize}px/2);`
              : `background:${badgeBg};border:${badgeBorder};box-shadow:${badgeShadow};opacity:${badgeOpacity};--hki-badge-pill-height:${badgeCircleSize}px;height:${badgeCircleSize}px;border-radius:calc(${badgeCircleSize}px/2);`)
          : '';

        return html`
          <ha-card
            class="hki-ha-badge ${isOnEffective ? 'on' : 'off'}"
            style="
              background: transparent;box-shadow: none !important;border: none !important;
              padding: 0 !important;
              margin: 0 !important;
              ${iconColor ? `            --icon-color: ${iconColor} !important;\n` : ''}            "

            @click=${() => this._handleDelayClick(this._config.tap_action || this._defaultTapActionConfig(), this._config.double_tap_action || { action: this._defaultInfoActionType() })}
              
            @mousedown=${(e) => this._startHold(e, this._config.hold_action || { action: this._defaultInfoActionType() })}
            @mouseup=${() => this._clearHold()}
            @mouseleave=${() => this._clearHold()}
            @touchstart=${(e) => this._startHold(e, this._config.hold_action || { action: this._defaultInfoActionType() })}
            @touchend=${() => this._clearHold()}
            @touchcancel=${() => this._clearHold()}
          >
            <div
              class="hki-ha-badge__wrap ${showPill ? 'pill' : 'icon-only'} ${isUnavailable ? 'is-unavailable' : ''}"
              style="${wrapStyle}"
            >
              ${showIcon ? html`
                <div
                  class="hki-ha-badge__circle ${isUnavailable ? 'is-unavailable' : ''}"
                  style="
                    width:${badgeCircleSize}px;
                    height:${badgeCircleSize}px;
                    transform: translate(calc(${Number(this._config.icon_offset_x||0)}px + ${Number(this._config.icon_circle_offset_x||0)}px), calc(${Number(this._config.icon_offset_y||0)}px + ${Number(this._config.icon_circle_offset_y||0)}px));
                    ${showPill ? `background:${circleBg};border:${circleBorder};border-radius:999px;` : `background:${badgeBg || 'var(--card-background-color)'};border:${badgeBorder || '0.5px solid var(--divider-color)'};border-radius:${badgeRadius}px;box-shadow:${badgeShadow};opacity:${badgeOpacity};`}
                  "
                >
                  <div class="hki-ha-badge__iconwrap">
                    ${renderBadgeIcon()}
                  </div>
                </div>
              ` : ''}

              ${showPill ? html`
                <div class="hki-ha-badge__text">
                  ${showName ? html`
                    <div class="hki-ha-badge__name" style="
                      ${getFont(nameFont, this._config.name_font_weight, this._config.size_name || 12)}
                      color:${nameColor};
                      text-align:${this._config.name_text_align || 'left'};
                      transform:${getTransform(this._config.name_offset_x, this._config.name_offset_y)};
                    ">${badgeNameText}</div>
                  ` : ''}
                  ${showState ? html`
                    <div class="hki-ha-badge__state" style="
                      ${getFont(stateFont, this._config.state_font_weight, this._config.size_state || 12)}
                      color:${stateColor};
                      text-align:${this._config.state_text_align || 'left'};
                      transform:${getTransform(this._config.state_offset_x, this._config.state_offset_y)};
                    ">${badgeStateText}</div>
                  ` : ''}
                </div>
              ` : ''}
            </div>
          </ha-card>
        `;
      }


      return html`
        <ha-card 
          class="hki-tile ${isOnEffective ? 'on' : 'off'} layout-${layout}  ${isUnavailable ? "is-unavailable" : ""}"
          style="
            background: ${isUnavailable ? "transparent" : bgColor};
            opacity: ${isUnavailable ? 1 : cardOpacity};
            --hki-unavailable-bg: ${bgColor};
            --hki-unavailable-opacity: ${cardOpacity};
            border-radius: ${borderRadius}px !important;
            box-shadow: ${boxShadow || 'none'} !important;
            border: ${cardBorder} !important;
            ${iconColor ? `            --icon-color: ${iconColor} !important;\n` : ''}            --hki-card-min: ${Math.min(this._stageW || 0, this._stageH || 0)}px;
            --hki-icon-size: clamp(16px, calc(var(--hki-card-min) * ${(() => { const max = Number(this._config.size_icon) || 24; const scale = Math.max(0.08, Math.min(0.35, 0.15 * (max / 24))); return scale.toFixed(4); })()}), ${Number(this._config.size_icon) || 24}px);
            --hki-temp-badge-scale: ${(() => { const iconMax = (this._config.size_icon || 24); const circleMax = iconMax + 16; const tempMax = (this._config.temp_badge_size ?? circleMax); return (tempMax / circleMax).toFixed(4); })()};
            --hki-temp-badge-size: calc(var(--hki-icon-circle-size) * var(--hki-temp-badge-scale));
            --hki-icon-circle-size: calc(var(--hki-icon-size) + 16px);
            
          "
          @click=${() => this._handleDelayClick(this._config.tap_action || this._defaultTapActionConfig(), this._config.double_tap_action || { action: this._defaultInfoActionType() })}
            
          @mousedown=${(e) => this._startHold(e, this._config.hold_action || { action: this._defaultInfoActionType() })}
          @mouseup=${() => this._clearHold()}
          @mouseleave=${() => this._clearHold()}
          @touchstart=${(e) => this._startHold(e, this._config.hold_action || { action: this._defaultInfoActionType() })}
          @touchend=${() => this._clearHold()}
          @touchcancel=${() => this._clearHold()}
        >
            ${(() => {
              // Define all renderable elements
              
              // Fixed square layout: button-card like grid
              if (layout === 'square') {
                const _name = (this._config.show_name !== false) ? elements.name?.() : '';
                const _label = (this._config.show_label && labelText) ? elements.label?.() : '';
                const _state = (this._config.show_state !== false) ? elements.state?.() : '';
                const _info  = (this._config.show_info_display !== false) ? elements.info?.() : '';
                const _temp  = (this._config.show_temp_badge !== false) ? elements.temp_badge?.() : '';

                return html`
                  <div class="hki-square-grid">
                    <div class="sq-icon">${elements.icon?.()}</div>
                    ${_temp ? html`<div class="sq-temp-badge">${_temp}</div>` : ''}
                    <div class="sq-area"></div>
                    <div class="sq-name">${_name}</div>
                    <div class="sq-label">${_label}</div>
                    <div class="sq-state-row">
                      <div class="sq-state">${_state}</div>
                      <div class="sq-info">${_info}</div>
                    </div>
                  </div>
                `;
              }

              // Check if we have grid layout config, otherwise use default
              return elementGrid
                ? (() => {
                // Button-card-like approach:
                // We treat the tile as a positioning stage and place each element absolutely,
                // anchored to the tile box (percent-based), so elements don't drift when the
                // tile is resized inside parent grid cards (e.g. type: grid, square: true).
                const grid = elementGrid;

                // === Canvas Layout (WYSIWYG) ===
                // If enabled, we ignore the painted grid for rendering and instead place a few logical
                // elements by percent-based boxes relative to the card. This behaves consistently inside
                // HA grid cards (square: true) and during resizing.
                const _useCanvas = (layout !== 'square') && (this._config.use_canvas_layout !== false);
                if (_useCanvas) {
                  const _defaultCanvas = {
                    icon: { x: 6, y: 6, w: 28, h: 28, ax: 'start', ay: 'start' },
                    text: { x: 6, y: 64, w: 70, h: 30, ax: 'start', ay: 'end' },
                    info: { x: 70, y: 64, w: 24, h: 30, ax: 'end', ay: 'end' }
                  };
                  const _canvas = (this._config.canvas_layout && typeof this._config.canvas_layout === 'object')
                    ? this._config.canvas_layout
                    : _defaultCanvas;

                  // Build a text stack so line spacing stays stable during resize (button-card-like).
                  const _nameHtml = elements.name?.();
                  const _stateHtml = elements.state?.();
                  const _labelHtml = elements.label?.();
                  const _gap = Number.isFinite(this._config.text_line_gap_px) ? Number(this._config.text_line_gap_px) : 2;
                  const _textStack = (_nameHtml || _stateHtml || _labelHtml) ? html`
                    <div class="hki-text-stack" style="display:flex;flex-direction:column;gap:${_gap}px;align-items:flex-start;">
                      ${_nameHtml || ''}
                      ${_stateHtml || ''}
                      ${_labelHtml || ''}
                    </div>
                  ` : '';

                  const _placed = [];
                  const _place = (key, content, fallbackBox, innerJustify, innerAlign) => {
                    if (!content) return;
                    const b = (_canvas && _canvas[key]) ? _canvas[key] : fallbackBox;
                    if (!b) return;
                    const x = Math.max(0, Math.min(100, Number(b.x ?? fallbackBox.x)));
                    const y = Math.max(0, Math.min(100, Number(b.y ?? fallbackBox.y)));
                    const w = Math.max(1, Math.min(100, Number(b.w ?? fallbackBox.w)));
                    const h = Math.max(1, Math.min(100, Number(b.h ?? fallbackBox.h)));

                    _placed.push(html`
                      <div class="stage-item stage-${key}" style="
                        left:${x}%;
                        top:${y}%;
                        width:${w}%;
                        height:${h}%;
                        display:flex;
                        justify-content:${innerJustify};
                        align-items:${innerAlign};
                        box-sizing:border-box;
                        padding:0;
                      ">
                        <div class="stage-inner" style="width:100%;height:100%;display:flex;justify-content:${innerJustify};align-items:${innerAlign};max-width:100%;max-height:100%;">
                          ${content}
                        </div>
                      </div>
                    `);
                  };

                  // Place icon, text stack, and info (brightness). Other elements remain controlled by existing toggles.
                  _place('icon', elements.icon?.(), _defaultCanvas.icon, 'flex-start', 'flex-start');
                  _place('text', _textStack, _defaultCanvas.text, 'flex-start', 'flex-end');
                  _place('info', elements.info?.(), _defaultCanvas.info, 'flex-end', 'flex-end');
                  // Climate corner badge if present (top-right by default, small box)
                  _place('temp_badge', elements.temp_badge?.(), { x: 76, y: 6, w: 18, h: 18 }, 'flex-end', 'flex-start');

                  return html`<div class="layout-stage-container">${_placed}</div>`;
                }


                // Percent inset from the stage edges/cell edges for start/end alignment.
                // Kept intentionally simple (no UI complexity required).
                const inset = Number.isFinite(this._config.grid_inset_percent)
                  ? Number(this._config.grid_inset_percent)
                  : 7;

                const placed = [];

                // Build a bounding box per element type so selecting multiple cells creates a single spanning area
                // (instead of duplicating the element).
                const boundsByCell = {};
                for (let i = 0; i < grid.length; i++) {
                  const cell = grid[i];
                  if (!cell || cell === 'empty') continue;
                  const r = Math.floor(i / gridCols) + 1;
                  const c = (i % gridCols) + 1;
                  if (!boundsByCell[cell]) {
                    boundsByCell[cell] = { minR: r, maxR: r, minC: c, maxC: c };
                  } else {
                    boundsByCell[cell].minR = Math.min(boundsByCell[cell].minR, r);
                    boundsByCell[cell].maxR = Math.max(boundsByCell[cell].maxR, r);
                    boundsByCell[cell].minC = Math.min(boundsByCell[cell].minC, c);
                    boundsByCell[cell].maxC = Math.max(boundsByCell[cell].maxC, c);
                  }
                }

                
                
                // Merge text elements into a single stack when they are laid out as a typical tile text block.
                // This keeps the spacing between lines stable when the card resizes (e.g. inside HA grid cards),
                // while still letting users position the text visually by choosing the text cells.
                if (boundsByCell.name && (boundsByCell.state || boundsByCell.label)) {
                  const _n = boundsByCell.name;
                  const _s = boundsByCell.state;
                  const _l = boundsByCell.label;

                  // Prefer merging when state/label are below (or overlapping) the name and share columns.
                  const _rowsOk = (_s ? (_s.minR >= _n.minR) : true) && (_l ? (_l.minR >= _n.minR) : true);

                  const _overlap = (a, b) => Math.max(a.minC, b.minC) <= Math.min(a.maxC, b.maxC);

                  const _colsOk =
                    (_s ? _overlap(_n, _s) : true) &&
                    (_l ? _overlap(_n, _l) : true);

                  if (_rowsOk && _colsOk) {
                    const _minR = Math.min(_n.minR, _s ? _s.minR : _n.minR, _l ? _l.minR : _n.minR);
                    const _maxR = Math.max(_n.maxR, _s ? _s.maxR : _n.maxR, _l ? _l.maxR : _n.maxR);
                    const _minC = Math.min(_n.minC, _s ? _s.minC : _n.minC, _l ? _l.minC : _n.minC);
                    const _maxC = Math.max(_n.maxC, _s ? _s.maxC : _n.maxC, _l ? _l.maxC : _n.maxC);

                    boundsByCell.textstack = { minR: _minR, maxR: _maxR, minC: _minC, maxC: _maxC };

                    // Replace individual name/state/label renders with a single stacked block.
                    const _nameHtml = elements.name?.();
                    const _stateHtml = elements.state?.();
                    const _labelHtml = elements.label?.();

                    elements.textstack = () => html`
                      <div class="hki-text-stack" style="display:flex;flex-direction:column;gap:${Number.isFinite(this._config.text_line_gap_px) ? Number(this._config.text_line_gap_px) : 2}px;align-items:flex-start;">
                        ${_nameHtml || ''}
                        ${_stateHtml || ''}
                        ${_labelHtml || ''}
                      </div>
                    `;

                    delete boundsByCell.name;
                    delete boundsByCell.state;
                    delete boundsByCell.label;
                  }
                }

                // Compute stage dimensions for pixel-accurate placement.
                // Use the measured ha-card size (ResizeObserver) to avoid clipping/misalignment when ha-card has overflow hidden.
                const _stageW = this._stageW || 0;
                const _stageH = this._stageH || 0;

                // Row sizing:
                // Keep the visual grid intuitive: each row/column represents an equal slice of the card.
                // This ensures the visual editor grid is a true "where it will go" preview.
                const _rowHeights = [];

                for (const cell of Object.keys(boundsByCell)) {
                  const elementHtml = elements[cell]?.();
                  if (!elementHtml) continue;

                  const b = boundsByCell[cell];

                                    // Cell bounds for the stage.
                  // Use pixel-based rows when we can measure the card, so text rows behave like min-content rows.
                  let leftVal, topVal, widthVal, heightVal;
                  if (_stageW > 0 && _stageH > 0) {
                    const _colW = _stageW / gridCols;
                    leftVal = `${(b.minC - 1) * _colW}px`;
                    widthVal = `${(b.maxC - b.minC + 1) * _colW}px`;

                    if (_rowHeights.length) {
                      let _topPx = 0;
                      for (let rr = 1; rr < b.minR; rr++) _topPx += (_rowHeights[rr] || 0);
                      let _hPx = 0;
                      for (let rr = b.minR; rr <= b.maxR; rr++) _hPx += (_rowHeights[rr] || 0);
                      topVal = `${_topPx}px`;
                      heightVal = `${_hPx}px`;
                    } else {
                      const _rowH = _stageH / gridRows;
                      topVal = `${(b.minR - 1) * _rowH}px`;
                      heightVal = `${(b.maxR - b.minR + 1) * _rowH}px`;
                    }
                  } else {
                    // Fallback to percentage placement if size is not yet measurable.
                    leftVal = `${((b.minC - 1) / gridCols) * 100}%`;
                    topVal = `${((b.minR - 1) / gridRows) * 100}%`;
                    widthVal = `${((b.maxC - b.minC + 1) / gridCols) * 100}%`;
                    heightVal = `${((b.maxR - b.minR + 1) / gridRows) * 100}%`;
                  }

                  // Align within the spanned area.
                  // Goal: make the visual editor grid a true preview of where content lands.
                  const _edgeJustify = (b.minC === 1) ? 'flex-start' : ((b.maxC === gridCols) ? 'flex-end' : 'center');
                  const _edgeAlign = (b.minR === 1) ? 'flex-start' : ((b.maxR === gridRows) ? 'flex-end' : 'center');

                  const _isText = (cell === 'name' || cell === 'state' || cell === 'label' || cell === 'info' || cell === 'textstack');

                  // Horizontal alignment
                  let _slotJustify = _edgeJustify;
                  if (cell === 'info') {
                    _slotJustify = 'flex-end';
                  } else if (_isText) {
                    _slotJustify = (b.minC === 1) ? 'flex-start' : ((b.maxC === gridCols) ? 'flex-end' : 'flex-start');
                  }

                  // Vertical alignment
                  let _slotAlign = _edgeAlign;
                  if (cell === 'name' || cell === 'textstack') {
                    _slotAlign = 'flex-end';
                  } else if (cell === 'state' || cell === 'label' || cell === 'info') {
                    _slotAlign = 'flex-start';
                  }

                  // Padding inside each slot. Keep this stable so element offsets don't "drift" when the card resizes.
                  // Users can control outer spacing via border/padding settings; slot padding should remain predictable.
                  const _padCfg = Number.isFinite(this._config.grid_cell_padding_px)
                    ? Number(this._config.grid_cell_padding_px)
                    : 6;

                  // Adaptive padding: keep small cells usable (e.g. 5x5 grids) so content doesn't get clipped.
                  // Cap padding to a fraction of a single cell size when we know the stage dimensions.
                  let _padPx = _padCfg;
                  if (_stageW > 0 && _stageH > 0) {
                    const _cellW = _stageW / gridCols;
                    const _cellH = _stageH / gridRows;
                    const _cap = Math.max(2, Math.floor(Math.min(_cellW, _cellH) * 0.12));
                    _padPx = Math.max(2, Math.min(_padCfg, _cap));
                  }

                  // Info should flush to the right edge of its slot.
                  const _isInfo = cell === 'info';

                  const _innerStyle = _isInfo
                    ? `width:100%; height:100%; display:flex; justify-content:flex-end; align-items:${_slotAlign}; max-width:100%; max-height:100%;`
                    : 'max-width:100%; max-height:100%;';

                  placed.push(html`
                    <div class="stage-item stage-${cell}" style="
                      left: ${leftVal};
                      top: ${topVal};
                      width: ${widthVal};
                      height: ${heightVal};
                      display: flex;
                      justify-content: ${_slotJustify};
                      align-items: ${_slotAlign};
                      box-sizing: border-box;
                      padding: ${_padPx}px;
                    ">
                      <div class="stage-inner" style="${_innerStyle}">
                        ${elementHtml}
                      </div>
                    </div>
                  `);
                }

                return html`
                  <div class="layout-stage-container">
                    ${placed}
                  </div>
                `;
                })()
                : (() => {
                const order = (this._config.element_order || ['icon', 'name', 'label', 'state']).filter(el => el !== 'info');
                
                // Render elements in configured order with proper structure
                // Text elements need to be wrapped in tile-content-wrapper, but icon should be standalone
                const renderedElements = [];
                let textElements = [];
                
                order.forEach(el => {
                  if (el === 'icon') {
                    // If we have accumulated text elements, wrap them
                    if (textElements.length > 0) {
                      renderedElements.push(html`<div class="tile-content-wrapper">${textElements}</div>`);
                      textElements = [];
                    }
                    // Add icon directly
                    renderedElements.push(elements.icon?.());
                  } else {
                    // Accumulate text elements
                    const elementHtml = elements[el]?.();
                    if (elementHtml) {
                      textElements.push(elementHtml);
                    }
                  }
                });
                
                // Wrap any remaining text elements
                if (textElements.length > 0) {
                  renderedElements.push(html`<div class="tile-content-wrapper">${textElements}</div>`);
                }

                return html`${renderedElements}`;
                })();
            })()}
        </ha-card>
      `;
    }

    static get styles() {
      return css`
        :host { display: block; }
        
        ha-card { 
            transition: all 0.3s ease; 
            overflow: hidden; 
            padding: 12px; 
            box-sizing: border-box; 
            cursor: pointer; 
            position: relative;
            display: flex; 
            flex-direction: column; 
            -webkit-touch-callout: none;
            justify-content: space-between;
            isolation: isolate; 
            z-index: 0;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* --- LAYOUTS --- */
        
        /* Rectangular: Default flex column behavior */
        
        /* Square: Force aspect ratio */
        .hki-tile.layout-square { 
            aspect-ratio: 1 / 1; 
            height: auto;
        }

        /* Tile: Row Layout (Icon Left, Text Right) */
        .hki-tile.layout-tile {
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;
            gap: 16px;
            min-height: 72px; /* Standard HA Tile height */
        }
        .hki-tile.layout-tile .tile-header {
            width: auto;
            flex-shrink: 0;
        }
        .hki-tile.layout-tile .tile-content-wrapper {
            flex: 1;
            align-items: flex-start;
            text-align: left;
            justify-content: center;
        }
        .hki-tile.layout-tile .brightness-tag, .info-tag {
            position: static;
            transform: none;
            margin-left: 0;
        }

        /* Badge: Compact Horizontal Layout (Like HA Badge) */
        .hki-ha-badge {
          cursor: pointer;
        }

        ha-card.hki-tile { height: 100%; min-height: 0; position: relative; }
        .hki-tile.is-unavailable::before {
          content: "";
          position: absolute;
          inset: 0;
          background: var(--hki-unavailable-bg, transparent);
          opacity: var(--hki-unavailable-opacity, 0.5);
          border-radius: inherit;
          pointer-events: none;
          z-index: 0;
        }
        .hki-tile.is-unavailable > * {
          position: relative;
          z-index: 1;
        }
        /* Fixed square layout (button-card grid-template-areas) */
        .hki-square-grid {
          position: relative;
          display: grid;
          grid-template-areas:
            "i i"
            "area area"
            "n n"
            "l l"
            "s s";
          /* Intentionally matches custom:button-card behavior:
             only one explicit column size -> remaining column becomes auto */
          grid-template-columns: 1fr 1fr;
          grid-template-rows: 1fr 1fr min-content min-content min-content;
          width: 100%;
          height: 100%;
          min-height: 0;
          box-sizing: border-box;
          padding: 0;
          align-items: stretch;
          justify-items: stretch;
        }

        /* Icon is positioned like button-card (top/left in %) so it scales with the card,
           while text stays stable via fixed paddings. */
        .hki-square-grid .sq-icon {
          grid-area: i;
          position: absolute;
          top: 7%;
          left: 7%;
          display: inline-flex;
          align-items: flex-start;
          justify-content: flex-start;
          z-index: 1;
          pointer-events: none; /* click handled by card; keep icon purely visual */
        }
        .hki-square-grid .sq-icon * { pointer-events: none; }

        .hki-square-grid .sq-temp-badge {
          position: absolute;
          top: 7%;
          right: 7%;
          z-index: 2;
          pointer-events: none;
        }
        .hki-square-grid .sq-temp-badge         .hki-square-grid .sq-area { grid-area: area; }

        .hki-square-grid .sq-name {
          grid-area: n;
          justify-self: start;
          align-self: end;
          padding: 0 10px;
          min-width: 0;
        
          text-align: left;
          /* Keep name on one line, but don't clip it out when offsets push it */
          white-space: nowrap;
          overflow-wrap: normal !important;
          word-break: keep-all;
          overflow: visible;
          text-overflow: clip;
        }

        /* The actual name text is rendered inside a nested .name element.
           Force the nested element to inherit the single-line behavior so it
           never wraps when the card is resized. */
        .hki-square-grid .sq-name .name {
          white-space: nowrap !important;
          overflow: visible;
          text-overflow: clip;
          display: block;
          min-width: 0;
          overflow-wrap: normal !important;
          word-break: keep-all;
        }


        .hki-square-grid .sq-label {
          grid-area: l;
          justify-self: start;
          align-self: start;
          padding: 0 10px;
          min-width: 0;
          text-align: left;
          overflow: visible;
          white-space: normal;
          text-overflow: clip;
        }


        .hki-square-grid .sq-state-row {
          grid-area: s;

          /* Full-width row with stable padding; keep state (left) + info (right) locked together */
          justify-self: stretch;
          align-self: start;
          width: 100%;
          min-width: 0;

          display: flex;
          flex-direction: row;
          justify-content: flex-start; /* info is pushed via margin-left:auto */
          align-items: baseline;
          gap: 10px;

          padding: 0 10px;
          box-sizing: border-box;

          overflow: visible;
        }


        .hki-square-grid .sq-state {
          flex: 1 1 auto;
          min-width: 0;

          /* Text should not be clipped; allow overflow */
          overflow: visible;
          text-overflow: unset;
          white-space: normal;

          text-align: left;
        }

        /* Ensure legacy shared classes don't re-enable ellipsis inside square layout */
        .hki-square-grid .name,
        .hki-square-grid .state,
        .hki-square-grid .label {
          white-space: normal !important;
          overflow: visible !important;
          text-overflow: unset !important;
        }


        .hki-square-grid .sq-info {
          flex: 0 0 auto;
          margin-left: auto;

          text-align: right;
          white-space: nowrap;
          min-width: 0;

          overflow: visible;
        }



        /* Square fixed layout: info display must participate in the state row (no absolute positioning) */
        .hki-square-grid .brightness-tag,
        .hki-square-grid .info-tag {
          position: static !important;
          top: auto !important;
          right: auto !important;
          bottom: auto !important;
          left: auto !important;
          margin: 0 !important;
          width: auto !important;
          max-width: none !important;
          overflow: visible !important;
          text-overflow: unset !important;
          white-space: nowrap !important;
          display: inline-flex;
          align-items: baseline;
        }
        .hki-ha-badge__wrap {
          display: inline-flex;
          align-items: center;
          gap: 6px;
          padding: 0;
        }

        .hki-ha-badge__wrap.pill {
          /* Prevent pill background bleeding around the icon circle */
          overflow: hidden;
          gap: 0;
          height: var(--hki-badge-pill-height, auto);
          border-radius: calc(var(--hki-badge-pill-height, 0px) / 2);
        }
        .hki-ha-badge__wrap.pill .hki-ha-badge__text {
          margin-left: 2px;
          margin-right: 2px;
        }


        .hki-ha-badge__wrap.is-unavailable,
        .hki-ha-badge__circle.is-unavailable {
          position: relative;
        }
        .hki-ha-badge__wrap.is-unavailable::before,
        .hki-ha-badge__circle.is-unavailable::before {
          content: "";
          position: absolute;
          inset: 0;
          background: var(--hki-badge-bg, transparent);
          opacity: var(--hki-badge-opacity, 0.5);
          border-radius: inherit;
          pointer-events: none;
          z-index: 0;
        }
        .hki-ha-badge__wrap.is-unavailable > *,
        .hki-ha-badge__circle.is-unavailable > * {
          position: relative;
          z-index: 1;
        }
        .hki-ha-badge__circle {
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          flex: 0 0 auto;
          margin: 0;
          box-sizing: border-box;
        }
        .hki-ha-badge__text {
          display: flex;
          flex-direction: column;
          line-height: 1.0;
          padding-right: 2px;
        }
        .hki-ha-badge__name {
          font-size: 12px;
          font-weight: 500;
        }
        .hki-ha-badge__state {
          font-size: 11px;
          opacity: 0.8;
        }
        .hki-tile.layout-badge {
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;

            /* More compact like HA badges */
            gap: 6px;
            min-height: 35px;
            height: auto;
            padding: 6px 8px;

            /* Do not stretch full-width in headers */
            width: fit-content;
            max-width: 100%;
            flex: 0 0 auto;

            border-radius: 999px;
            overflow: hidden;
        }

        .hki-tile.layout-badge .tile-header {
            width: auto;
            flex-shrink: 0;
        }
        .hki-tile.layout-badge .icon-circle {
            width: var(--hki-icon-circle-size) !important;
            height: var(--hki-icon-circle-size) !important;
            padding: 0;
        }


        /* HKI Tile layout: wide pill */
        .hki-tile.layout-hki-tile {
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;
            gap: 12px;
            padding: 12px 16px;
            border-radius: 999px;
            min-height: 72px;
            width: 100%;
            box-sizing: border-box;
            position: relative; /* For stacking context */
            pointer-events: auto; /* allow whole tile to be clickable */
        }
        
        /* Re-enable pointer events on interactive elements */
        .hki-tile.layout-hki-tile .hki-icon-circle {
            pointer-events: auto;
            flex: 0 0 auto;
        }
        
        .hki-tile.layout-hki-tile .hki-tile-text {
            pointer-events: auto;
        }
        
        /* Info display positioned in top-right corner */
        .hki-tile.layout-hki-tile .tile-info-corner {
            position: absolute;
            top: 8px;
            right: 12px;
            pointer-events: none; /* Don't block slider */
            z-index: 1; /* Above content (but keep card stacking sane) */
            font-weight: 500;
            opacity: 0.9;
        }
        
        /* Allow slider to fill full width on tile layout */
        ha-card.layout-hki-tile {
            position: relative; /* anchor slider overlay stacking */
            overflow: hidden; /* Keep overflow hidden to clip slider to card shape */
        }
        .hki-tile.layout-hki-tile .hki-tile-text {
            display: flex;
            flex-direction: column;
            justify-content: center;
            min-width: 0;
        }

        .hki-tile.layout-hki-tile .tile-info{
            margin-left: 0;
            flex: 0 0 auto;
            align-self: flex-start;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .hki-tile.layout-hki-tile .label{
            line-height: 1.1;
        }
        .hki-tile.layout-hki-tile .name,
        .hki-tile.layout-hki-tile .state {
            white-space: normal;
            overflow: visible;
            text-overflow: clip;
            line-height: 1.1;
        }

        /* Brightness Slider Overlay */
        .hki-brightness-slider-container {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            padding: 0;
            overflow: hidden;
            border-radius: inherit;
            pointer-events: none; /* purely visual; hitbox is the input */
            z-index: 1; /* above card background */
        }

        /* Visual fill overlay (full-card) */
        .hki-brightness-slider-visual {
            position: absolute;
            inset: 0;
            border-radius: inherit;
            pointer-events: none;
            background: linear-gradient(
                to right,
                var(--slider-fill-color, rgba(255, 255, 255, 0.8)) 0%,
                var(--slider-fill-color, rgba(255, 255, 255, 0.8)) var(--slider-progress, 50%),
                var(--slider-track-color, rgba(255, 255, 255, 0.2)) var(--slider-progress, 50%),
                var(--slider-track-color, rgba(255, 255, 255, 0.2)) 100%
            );
        }

        /* Invisible interaction layer (bottom strip) */
        .hki-brightness-slider-input {
            -webkit-appearance: none;
            appearance: none;
            position: absolute;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 28px; /* interaction area */
            background: transparent;
            outline: none;
            margin: 0;
            padding: 0;
            cursor: pointer;
            pointer-events: auto; /* this is what makes it draggable */
        
            z-index: 2;
            touch-action: none;
        }

        /* Keep the native track/thumb invisible */
        .hki-brightness-slider-input::-webkit-slider-runnable-track {
            width: 100%;
            height: 100%;
            background: transparent;
        }

        .hki-brightness-slider-input::-moz-range-track {
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
        }

        .hki-brightness-slider-input::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 0;
            height: 0;
            background: transparent;
        }

        .hki-brightness-slider-input::-moz-range-thumb {
            width: 0;
            height: 0;
            background: transparent;
            border: none;
        }

        /* Ensure HKI Tile slider fill never washes out the icon/circle/badges */
        .hki-tile.layout-hki-tile .tile-header,
        .hki-tile.layout-hki-tile .icon-circle,
        .hki-tile.layout-hki-tile .hki-tile-text {
            position: relative;
            z-index: 3;
        }
        /* Keep info display in the corner and above the slider fill */
        .hki-tile.layout-hki-tile .tile-info-corner {
            position: absolute;
            z-index: 4;
        }
        /* Badges must remain absolutely positioned (don't let them shift the icon) */
        .hki-tile.layout-hki-tile .badge,
        .hki-tile.layout-hki-tile .climate-corner-badge {
            position: absolute;
            z-index: 4;
        }

        /* Match HKI default badge placement (tile needs a small nudge) */
        .hki-tile.layout-hki-tile .icon-circle .badge {
            top: -5px !important;
            right: -5px !important;
        }
        /* Badge Circular: Fully round badge with icon only */
        .hki-tile.layout-badge.badge-circle {
            aspect-ratio: 1 / 1;
            width: auto;
            min-width: 40px;
            min-height: 40px;
            padding: 8px;
            justify-content: center;
        }
        .hki-tile.layout-badge.badge-circle .name,
        .hki-tile.layout-badge.badge-circle .state,
        .hki-tile.layout-badge.badge-circle .label,
        .hki-tile.layout-badge.badge-circle .brightness-tag,
        .hki-tile.layout-badge.badge-circle .info-tag {
            display: none;
        }
        
        /* Circle: Fully Round Button with Centered Content */
        .hki-tile.layout-circle {
            aspect-ratio: 1 / 1;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            min-height: 100px;
        }
        .hki-tile.layout-circle .tile-content-wrapper {
            align-items: center;
            text-align: center;
        }
        .hki-tile.layout-circle .icon-circle {
            margin: 0;
        }
        /* Hide badge counter when card is used in header badges section */
        :host([role="button"]) ha-card::after,
        :host(:not([role])) ha-card::after {
            content: none !important;
            display: none !important;
        }
        .hki-tile.layout-badge .icon-circle ha-icon,
        .hki-tile.layout-badge .icon-circle ha-state-icon {
            --mdc-icon-size: var(--hki-icon-size) !important;
        }
        .hki-tile.layout-badge .tile-content-wrapper {
            flex: 1;
            align-items: flex-start;
            justify-content: center;
            gap: 2px;
        }
        .hki-tile.layout-badge .name {
            font-size: 14px;
            line-height: 1.2;
        }
        .hki-tile.layout-badge .state {
            font-size: 12px;
            line-height: 1.2;
        }
        .hki-tile.layout-badge .label {
            display: none; /* Hide label in badge mode */
        }
        .hki-tile.layout-badge .brightness-tag,
        .hki-tile.layout-badge .info-tag {
            position: static;
            transform: none;
            font-size: 12px;
            margin-left: auto;
        }
        .hki-tile.layout-badge:not(.badge-circle) .badge,
        .hki-tile.layout-badge .climate-corner-badge {
            display: none; /* Hide badges in badge layout (except circular badges) */
        }

        /* --- ELEMENTS --- */

        .tile-header { display: flex; justify-content: space-between; align-items: flex-start; width: 100%; z-index: 1; }
        
        .icon-circle {
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            position: relative;
            transition: transform 0.2s;
            cursor: pointer;
            box-sizing: border-box;
        }
        .icon-circle:active { transform: scale(0.9); }

        .badge {
            position: absolute; top: -2px; right: -2px;
            color: white; border-radius: 50%;
            min-width: 16px; padding: 0 3px; height: 16px;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold;
            z-index: 2;
            box-sizing: border-box;
            pointer-events: none;
            flex-shrink: 0;
        }
        .badge.climate-corner-badge {
            /* Align with the icon row (same vertical level as the icon) */
            top: 7%;
            right: 7%;
        }

        .brightness-tag { 
            position: absolute; 
            bottom: 12px; 
            right: 12px; 
            font-weight: 500; 
            opacity: 0.9;
            z-index: 2;
        }
        
        /* When brightness-tag is in tile-content-wrapper, use normal flow positioning */
        .tile-content-wrapper .brightness-tag,
        .tile-content-wrapper .info-tag {
            position: static;
            bottom: auto;
            right: auto;
            width: 100%;
        }
        
        /* When badge or info is in grid, remove absolute positioning */
        .grid-cell .climate-corner-badge,
        .grid-cell .brightness-tag,
        .grid-cell .info-tag {
            position: static !important;
            top: auto !important;
            right: auto !important;
            bottom: auto !important;
            left: auto !important;
            width: auto;
            margin: 0;
        }
        
        .tile-content-wrapper { display: flex; flex-direction: column; gap: 2px; z-index: 1; width: 100%; }
        
        /* Grid layout container (single grid so elements stay anchored on resize) */
        

        /* Stage-based placement (button-card-like): absolute elements anchored to the tile box */
        .layout-stage-container {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 0;
        }
        .stage-item {
            position: absolute;
            box-sizing: border-box;
            /* Keep icons/text from being clipped; text overflow is handled on text nodes */
            overflow: visible;
        }
        /* Text nodes: allow wrapping or truncation via existing HKI settings; default to no overflow bleed */
        .stage-item .name,
        .stage-item .state,
        .stage-item .label,
        .stage-item .info-tag {
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .layout-grid-container {
            display: grid;
            gap: 12px;
            align-items: stretch;
            justify-items: stretch;
            width: 100%;
            height: 100%;
            align-content: stretch;
            min-height: 0;
        }


        /* Absolute positioning grid mode (grid_position_mode: "absolute") */
        .layout-abs-container {
            position: relative;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }
        .layout-abs-container .abs-cell {
            position: absolute;
            display: flex;
            box-sizing: border-box;
            pointer-events: none;
        }
        .layout-abs-container .abs-cell > * {
            pointer-events: auto;
        }


        /* Grid layout rows - 3 column grid */
        .layout-grid-row {
            display: grid;
            gap: 12px;
            align-items: center;
            width: 100%;
        }
        
        /* Grid cell styling */
        .grid-cell {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        
        /* Center non-text elements in grid cells */
        .grid-cell:has(.badge),
        .grid-cell:has(.climate-corner-badge),
        .grid-cell:has(.tile-header) {
            align-items: center;
        }
        
        /* Text elements in grid cells take full width */
        .grid-cell .name,
        .grid-cell .state,
        .grid-cell .label,
        .grid-cell .brightness-tag,
        .grid-cell .info-tag {
            width: 100%;
        }
        .name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .state { opacity: 0.8; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .label { opacity: 0.7; font-style: italic; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }

        /* Animations */
        @keyframes spin { 100% { transform: rotate(360deg); } }
        @keyframes pulse { 50% { opacity: 0.5; transform: scale(0.9); } }
        @keyframes bounce { 0%, 20%, 50%, 80%, 100% {transform: translateY(0);} 40% {transform: translateY(-6px);} 60% {transform: translateY(-3px);} }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-4px); } 20%, 40%, 60%, 80% { transform: translateX(4px); } }
        @keyframes swing { 20% { transform: rotate(15deg); } 40% { transform: rotate(-10deg); } 60% { transform: rotate(5deg); } 80% { transform: rotate(-5deg); } 100% { transform: rotate(0deg); } }
        @keyframes tada { 0%, 100% { transform: scale(1) rotate(0); } 10%, 20% { transform: scale(0.9) rotate(-3deg); } 30%, 50%, 70%, 90% { transform: scale(1.1) rotate(3deg); } 40%, 60%, 80% { transform: scale(1.1) rotate(-3deg); } }
        @keyframes wobble { 0%, 100% { transform: translateX(0%); } 15% { transform: translateX(-6px) rotate(-5deg); } 30% { transform: translateX(5px) rotate(3deg); } 45% { transform: translateX(-5px) rotate(-3deg); } 60% { transform: translateX(4px) rotate(2deg); } 75% { transform: translateX(-3px) rotate(-1deg); } }
        @keyframes flip { 0% { transform: perspective(400px) rotateY(0); } 40% { transform: perspective(400px) rotateY(-180deg); } 100% { transform: perspective(400px) rotateY(-360deg); } }
        
        .animate-spin { animation: spin 2s linear infinite; }
        .animate-pulse { animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite; }
        .animate-bounce { animation: bounce 2s infinite; }
        .animate-shake { animation: shake 0.8s cubic-bezier(0.36, 0.07, 0.19, 0.97) infinite; }
        .animate-swing { animation: swing 1s ease-in-out infinite; }
        .animate-tada { animation: tada 1.5s ease-in-out infinite; }
        .animate-wobble { animation: wobble 1s ease-in-out infinite; }
        .animate-flip { animation: flip 2s ease-in-out infinite; }
      
        /* HA Badge mimic layout */
        .hki-ha-badge__wrap {
          display: inline-flex;
          align-items: center;
          gap: 8px;
          height: 40px;
          line-height: 1;
        }

        .hki-ha-badge__wrap.pill {
          height: 36px;
          /* Make the icon circle flush with the pill edge (closer to HA default). */
          padding: 0 10px 0 0;
          box-sizing: border-box;
        }

        .hki-ha-badge__wrap.icon-only {
          height: 36px;
          padding: 0;
          box-sizing: border-box;
        }

        .hki-ha-badge__circle {
          width: 36px;
          height: 36px;
          border-radius: 999px;
          display: inline-flex;
          align-items: center;
          justify-content: center;
          flex: 0 0 auto;
          box-sizing: border-box;
        }

        .hki-ha-badge__iconwrap {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          width: 100%;
          height: 100%;
          line-height: 0;
        }

        .hki-ha-badge__icon {
          display: block;
        }

        .hki-ha-badge__text {
          display: flex;
          flex-direction: column;
          justify-content: center;
          gap: 1px;
          padding-right: 2px;
          white-space: nowrap;
        }

        .hki-ha-badge__name {
          font-size: 12px;
          font-weight: 600;
          line-height: 1.1;
        }

        .hki-ha-badge__state {
          font-size: 12px;
          opacity: 0.85;
          line-height: 1.1;
        }


      mwc-button.reset-defaults {
        --mdc-theme-primary: var(--primary-color);
        --mdc-theme-on-primary: var(--text-primary-color, #fff);

        /* Filled button (covers different mwc versions) */
        --mdc-button-raised-button-color: var(--primary-color);
        --mdc-button-raised-ink-color: var(--text-primary-color, #fff);
        --mdc-button-unelevated-fill-color: var(--primary-color);
        --mdc-button-unelevated-ink-color: var(--text-primary-color, #fff);
        --mdc-protected-button-container-color: var(--primary-color);
        --mdc-protected-button-label-text-color: var(--text-primary-color, #fff);

        /* Ripple */
        --mdc-ripple-color: rgba(255,255,255,0.6);

        min-height: 34px;
      }

      `;
    }
  }

  /* --- ENHANCED VISUAL EDITOR WITH ACCORDIONS --- */

  class HkiButtonCardEditor extends LitElement {

    // Baseline defaults for offset editors (UI shows values relative to these).
    static OFFSET_DEFAULTS = {
      name_offset_x: -10,
      state_offset_x: -10,
      label_offset_x: -10,
      icon_offset_x: -10,
      brightness_offset_x: 10,
      temp_badge_offset_x: 10,
      brightness_offset_y: 10,
      temp_badge_offset_y: -10,
      icon_offset_y: -4,
      label_offset_y: 11,
      state_offset_y: 10,
      name_offset_y: 17,
    };
    static TILE_OFFSET_DEFAULTS = {
      name_offset_x: 44,
      name_offset_y: -18,
      state_offset_x: 44,
      state_offset_y: -15,
      label_offset_x: 0,
      label_offset_y: 0,
      icon_offset_x: -17,
      icon_offset_y: 13,
      icon_badge_offset_x: 0,
      icon_badge_offset_y: 0,
      brightness_offset_x: 21,
      brightness_offset_y: 43,
      temp_badge_offset_x: 0,
      temp_badge_offset_y: 0,
    }
    static GOOGLE_OFFSET_DEFAULTS = {
      name_offset_x: 0,
      name_offset_y: -6,
      state_offset_x: 0,
      state_offset_y: -8,
      label_offset_x: 0,
      label_offset_y: -6,
      icon_offset_x: -10,
      icon_offset_y: -1,
      icon_badge_offset_x: 0,
      icon_badge_offset_y: 0,
      brightness_offset_x: 0,
      brightness_offset_y: 0,
      temp_badge_offset_x: 0,
      temp_badge_offset_y: 0,
    };

    _getOffsetUiValue(field) {
      const __layout = (this._config?.card_layout || 'square');
      // Badge uses raw offsets (baseline 0). Tile uses its own baseline.
      if (__layout === 'badge') return (this._config?.[field] ?? 0);
      const dict = (__layout === 'hki_tile') ? HkiButtonCardEditor.TILE_OFFSET_DEFAULTS : ((__layout === 'google_default') ? HkiButtonCardEditor.GOOGLE_OFFSET_DEFAULTS : HkiButtonCardEditor.OFFSET_DEFAULTS);
      const base = dict[field];
      if (base === undefined) return (this._config?.[field] ?? 0);
      const actual = (this._config?.[field] ?? base);
      return Number.isFinite(actual) ? (actual - base) : 0;
    }

    _applyOffsetUiValue(field, uiValue) {
      const __layout = (this._config?.card_layout || 'square');
      // Badge uses raw offsets (baseline 0). Tile uses its own baseline.
      if (__layout === 'badge') {
        const actual = Number(uiValue);
        return Number.isFinite(actual) ? actual : 0;
      }
      const dict = (__layout === 'hki_tile') ? HkiButtonCardEditor.TILE_OFFSET_DEFAULTS : ((__layout === 'google_default') ? HkiButtonCardEditor.GOOGLE_OFFSET_DEFAULTS : HkiButtonCardEditor.OFFSET_DEFAULTS);
      const base = dict[field];
      if (base === undefined) return uiValue;
      const n = Number(uiValue);
      return (Number.isFinite(n) ? (base + n) : base);
    }

    static get properties() { return { hass: {}, lovelace: {}, _config: { state: true }, _closedDetails: { state: true } }; }
    
    constructor() {
      super();
      this._paDomainCache = {};

      this._closedDetails = {
        // keep the first (non-accordion) block open automatically
    
        // accordions: collapsed by default
        climate: true,
        humidifier: true,
        lock: true,
        layout_order: true,
        typography: true,
        visibility: true,
        card_styling: true,
        icon_settings: true,
    
        popup: true,
        popup_card: false,    // open by default
        popup_default_view: true,
        sensor_opts: true,
        person_opts: true,
        popup_bottom_bar: true,
        popup_anim: true,
        popup_container: true,
        popup_blur: true,
        popup_features: true,
        popup_content: true,
        popup_highlight: true,
        popup_buttons: true,
    
        actions: true,
        action_tap: true,
        action_double_tap: true,
        action_hold: true,
        action_icon_tap: true,
        action_icon_hold: true,
        action_icon_double_tap: true,
    
        offsets: true,
      };
    }


    
    _cardObjToYaml(obj, indent = 0) {
      if (obj == null) return '';
      const pad = '  '.repeat(indent);
      if (typeof obj === 'boolean' || typeof obj === 'number') return String(obj);
      if (typeof obj === 'string') {
        const s = obj;

        // Multiline strings -> YAML block scalar (preserves formatting/templates)
        if (s.includes('\n')) {
          const indentStr = '  '.repeat(indent + 1);
          const lines = s.split('\n').map(line => `${indentStr}${line}`).join('\n');
          return `|-\n${lines}`;
        }

        // Only quote when truly needed - NOT just because string contains ':'
        // mdi:power, custom:card, scene.entity are all valid unquoted YAML values
        if (s === '' || ['true','false','null','yes','no','on','off'].includes(s.toLowerCase()) ||
            (!isNaN(Number(s)) && s.trim() !== '') ||
            /^[\{\[\*&!|>'"@`]/.test(s) || / #/.test(s) || /^\s|\s$/.test(s)) {
          return `"${s.replace(/\\/g,'\\\\').replace(/"/g,'\\\"')}"`;
        }
        return s;
      }

      if (Array.isArray(obj)) {
        return obj.map(item => {
          if (item && typeof item === 'object') {
            // Render object entries; first entry goes inline with "- ", rest align to same column
            const entries = Object.entries(item);
            if (entries.length === 0) return `${pad}-`;
            const [firstKey, firstVal] = entries[0];
            const firstValStr = (firstVal && typeof firstVal === 'object')
              ? `\n${this._cardObjToYaml(firstVal, indent + 2)}`
              : ` ${this._cardObjToYaml(firstVal, indent + 1)}`;
            const rest = entries.slice(1).map(([k, v]) => {
              const valStr = (v && typeof v === 'object')
                ? `\n${this._cardObjToYaml(v, indent + 2)}`
                : ` ${this._cardObjToYaml(v, indent + 1)}`;
              return `${'  '.repeat(indent + 1)}${k}:${valStr}`;
            });
            return [`${pad}- ${firstKey}:${firstValStr}`, ...rest].join('\n');
          }
          return `${pad}- ${this._cardObjToYaml(item, indent)}`;
        }).join('\n');
      }
      if (typeof obj === 'object') {
        return Object.entries(obj).map(([k, v]) => {
          if (v && typeof v === 'object') {
            return `${pad}${k}:\n${this._cardObjToYaml(v, indent + 1)}`;
          }
          const rendered = this._cardObjToYaml(v, indent);
          return `${pad}${k}: ${rendered}`;
        }).join('\n');
      }
      return String(obj);
    }

    _yamlStrToObj(str) {
      if (!str || !str.trim()) return null;
      try {
        const lines = str.split('\n');
        const [obj] = this._parseYamlBlock(lines, 0, 0);
        return (obj && typeof obj === 'object') ? obj : null;
      } catch(e) { return null; }
    }

    _parseYamlValue(raw) {
      const s = raw.trim();
      if (s === 'true' || s === 'yes') return true;
      if (s === 'false' || s === 'no') return false;
      if (s === 'null' || s === '~' || s === '') return null;
      if ((s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'")))
        return s.slice(1,-1).replace(/\\"/g,'"').replace(/\\\\/g,'\\');
      const n = Number(s);
      if (!isNaN(n) && s !== '') return n;
      return s;
    }

    _parseYamlBlockScalar(lines, startIdx, parentIndent, style) {
      // Minimal YAML block scalar support for "|" (literal) and ">" (folded)
      // Returns [stringValue, nextIdx]
      let idx = startIdx;

      // Find indentation level of the scalar content (first non-empty line)
      let contentIndent = null;
      while (idx < lines.length) {
        const line = lines[idx];
        if (line.trimEnd() === '') { idx++; continue; }
        const indent = line.length - line.trimStart().length;
        if (indent <= parentIndent) {
          // no content (or scalar ended immediately)
          return ['', idx];
        }
        contentIndent = indent;
        break;
      }
      if (contentIndent === null) return ['', idx];

      const outLines = [];
      while (idx < lines.length) {
        const line = lines[idx];
        const trimmedEnd = line.trimEnd();
        if (trimmedEnd === '') {
          outLines.push('');
          idx++;
          continue;
        }
        const indent = line.length - line.trimStart().length;
        if (indent <= parentIndent) break; // scalar ended
        // Strip the content indentation (or as much as available)
        outLines.push(line.slice(Math.min(contentIndent, line.length)));
        idx++;
      }

      if (style === '>') {
        // Fold: turn single newlines into spaces, keep paragraph breaks
        const paragraphs = [];
        let current = [];
        for (const l of outLines) {
          if (l === '') {
            if (current.length) {
              paragraphs.push(current.join(' ').trimEnd());
              current = [];
            }
            // keep empty line as paragraph separator
            paragraphs.push('');
          } else {
            current.push(l.trimEnd());
          }
        }
        if (current.length) paragraphs.push(current.join(' ').trimEnd());

        // Rebuild, preserving blank lines
        let folded = '';
        for (let p = 0; p < paragraphs.length; p++) {
          const part = paragraphs[p];
          if (part === '') {
            // avoid trailing extra blank lines
            if (!folded.endsWith('\n') && folded !== '') folded += '\n';
            folded += '\n';
          } else {
            if (folded !== '' && !folded.endsWith('\n\n')) folded += '\n';
            folded += part;
          }
        }
        return [folded.replace(/\n\n\n+/g, '\n\n'), idx];
      }

      // Literal
      return [outLines.join('\n'), idx];
    }


    _parseYamlBlock(lines, startIdx, baseIndent) {
      // Returns [result, nextIdx]
      // Detect if this block is an array or object by looking at first non-empty line
      let idx = startIdx;
      let result = null;

      while (idx < lines.length) {
        const line = lines[idx];
        const trimmed = line.trimEnd();
        if (trimmed === '' || trimmed.trimStart().startsWith('#')) { idx++; continue; }
        const indent = trimmed.length - trimmed.trimStart().length;
        if (indent < baseIndent) break; // dedented â€” end of block

        const content = trimmed.trimStart();

        if (content.startsWith('- ') || content === '-') {
          // Array
          if (!Array.isArray(result)) result = [];
          const itemContent = content.startsWith('- ') ? content.slice(2).trimStart() : '';

          if (itemContent === '') {
            // Next lines form the item
            idx++;
            const [val, nextIdx] = this._parseYamlBlock(lines, idx, indent + 2);
            result.push(val);
            idx = nextIdx;
          } else if (itemContent.includes(': ') || itemContent.endsWith(':')) {
            // Inline object start: "- key: value" or "- key:"
            const obj = {};
            const colonIdx = itemContent.indexOf(': ');
            const colonEnd = itemContent.endsWith(':');
            const key = colonEnd ? itemContent.slice(0, -1) : itemContent.slice(0, colonIdx);
            const valStr = colonEnd ? '' : itemContent.slice(colonIdx + 2);
            idx++;
            if (valStr === '' || colonEnd) {
              const [val, nextIdx] = this._parseYamlBlock(lines, idx, indent + 2);
              obj[key] = val;
              idx = nextIdx;
            } else {
              if (valStr === '|' || valStr.startsWith('|') || valStr === '>' || valStr.startsWith('>')) {
                const style = valStr.trim().startsWith('>') ? '>' : '|';
                const [val, ni] = this._parseYamlBlockScalar(lines, idx, indent, style);
                obj[key] = val;
                idx = ni;
              } else {
                obj[key] = this._parseYamlValue(valStr);
              }
            }
            // Continue reading sibling keys at indent+2
            while (idx < lines.length) {
              const sibLine = lines[idx].trimEnd();
              if (sibLine === '' || sibLine.trimStart().startsWith('#')) { idx++; continue; }
              const sibIndent = sibLine.length - sibLine.trimStart().length;
              if (sibIndent !== indent + 2) break;
              const sibContent = sibLine.trimStart();
              if (sibContent.startsWith('- ') || sibContent === '-') break; // next array item
              const ci = sibContent.indexOf(': ');
              const ce = sibContent.endsWith(':');
              if (ci === -1 && !ce) break;
              const sk = ce ? sibContent.slice(0,-1) : sibContent.slice(0, ci);
              const sv = ce ? '' : sibContent.slice(ci + 2);
              idx++;
              if (sv === '' || ce) {
                const [val, nextIdx] = this._parseYamlBlock(lines, idx, sibIndent + 2);
                obj[sk] = val;
                idx = nextIdx;
              } else {
                if (sv === '|' || sv.startsWith('|') || sv === '>' || sv.startsWith('>')) {
                const style = sv.trim().startsWith('>') ? '>' : '|';
                const [val, ni] = this._parseYamlBlockScalar(lines, idx, sibIndent, style);
                obj[sk] = val;
                idx = ni;
              } else {
                obj[sk] = this._parseYamlValue(sv);
              }
              }
            }
            result.push(obj);
          } else {
            result.push(this._parseYamlValue(itemContent));
            idx++;
          }
        } else if (content.includes(': ') || content.endsWith(':')) {
          // Object
          if (!result || Array.isArray(result)) result = {};
          const ci = content.indexOf(': ');
          const ce = content.endsWith(':');
          const key = ce ? content.slice(0,-1) : content.slice(0, ci);
          const valStr = ce ? '' : content.slice(ci + 2);
          idx++;
          if (valStr === '' || ce) {
            // Check if next line is more indented (nested block) or same (empty value)
            let nextIdx2 = idx;
            while (nextIdx2 < lines.length && lines[nextIdx2].trim() === '') nextIdx2++;
            const nextLine = lines[nextIdx2];
            if (nextLine !== undefined) {
              const nextIndent = nextLine.length - nextLine.trimStart().length;
              if (nextIndent > indent) {
                const [val, ni] = this._parseYamlBlock(lines, idx, nextIndent);
                result[key] = val;
                idx = ni;
              } else {
                result[key] = null;
              }
            } else {
              result[key] = null;
            }
          } else {
            if (valStr === '|' || valStr.startsWith('|') || valStr === '>' || valStr.startsWith('>')) {
              const style = valStr.trim().startsWith('>') ? '>' : '|';
              const [val, ni] = this._parseYamlBlockScalar(lines, idx, indent, style);
              result[key] = val;
              idx = ni;
            } else {
              result[key] = this._parseYamlValue(valStr);
            }
          }
        } else {
          idx++;
        }
      }
      return [result, idx];
    }

    _defaultFontWeight(prefix) {
      if (prefix === "name") return "bold";
      if (prefix === "state") return "bold";
      if (prefix === "brightness") return "bold";
      return "normal";
    }


    setConfig(config) {
      const flat = HkiButtonCard._migrateFlatConfig(config) || {};
      this._config = flat;
      // If the user is not actively editing the YAML, drop the draft so the editor shows the
      // serialized value from config again. While focused, keep the draft to avoid cursor jumps.
      if (!this._customPopupYamlFocused) {
        this._customPopupYamlDraft = null;
      }
      // NOTE: Do NOT fire config-changed here. Doing so causes an infinite crash loop when this
      // editor is embedded inside hui-card-element-editor (e.g. as a slot card in hki-header-card):
      // setConfig -> config-changed -> parent saves -> HA calls setConfig again -> repeat.
      // Migration/normalization is already handled by _fireChanged on every real user-driven change.
    }

    disconnectedCallback() {
      super.disconnectedCallback?.();
      // hui-card-element-editor saves on every change, so no flush needed on disconnect.
    }
    
    shouldUpdate(changedProps) {
      // Always update if hass changed
      if (changedProps.has('hass')) {
        return true;
      }
      
      // Always update if _closedDetails changed (accordion state)
      if (changedProps.has('_closedDetails')) {
        return true;
      }
      
      // If _config didn't change, check other properties
      if (!changedProps.has('_config')) {
        return true;
      }
      
      // If _config changed, do a deep comparison to see if it's meaningful
      const oldConfig = changedProps.get('_config');
      const newConfig = this._config;
      
      // Simple comparison - if they're the same reference, no update needed
      if (oldConfig === newConfig) {
        return false;
      }
      
      // Deep comparison - stringify and compare
      // This prevents re-renders from object reference changes when content is identical
      try {
        return JSON.stringify(oldConfig) !== JSON.stringify(newConfig);
      } catch (e) {
        // If stringify fails, assume we need to update
        return true;
      }
    }
    
    render() {
      if (!this.hass || !this._config) return html``;
      this._ensureCardEditorLoaded();
      
      const fonts = ["system", "Roboto", "Open Sans", "Lato", "Montserrat", "Oswald", "Raleway", "custom"];
      // Weights as Names
      const weights = ["lighter", "normal", "bold", "bolder"];
      const shapes = ["square", "google_default", "hki_tile", "badge"];
      const isBadgeLayout = (this._config.card_layout === 'badge');

      const isGoogleLayout = (this._config.card_layout === 'google_default');

      const borderStyleOptions = HKI_EDITOR_OPTIONS.borderStyles;
      const popupDefaultViewOptions = HKI_EDITOR_OPTIONS.popupDefaultViewOptions;
      const popupDefaultSectionOptionsTagged = HKI_EDITOR_OPTIONS.popupDefaultSectionOptionsTagged;
      const popupBottomBarAlignOptionsDetailed = HKI_EDITOR_OPTIONS.popupBottomBarAlignOptionsDetailed;

      const selectedEntity = this.hass.states[this._config.entity];
      const _edDomain = selectedEntity?.entity_id?.split('.')[0];
      const isClimate = _edDomain === 'climate';
      const isLock = _edDomain === 'lock';
      const isHumidifier = _edDomain === 'humidifier';
      const isSensor = _edDomain === 'sensor';
      const isBinarySensor = ['binary_sensor', 'device_tracker', 'event'].includes(_edDomain);
      const isSelect = ['select', 'input_select'].includes(_edDomain);
      const isNumber = ['number', 'input_number'].includes(_edDomain);
      const isText = ['text', 'input_text'].includes(_edDomain);
      const isAutomation = _edDomain === 'automation';
      const isPerson = _edDomain === 'person';

      // Custom Actions Dropdown List (Replaces Native Selector)
      const actionsList = HKI_EDITOR_OPTIONS.buttonActionOptions;

      const renderHeader = (title, key) => html`
        <div class="accordion-header" @click=${(e) => this._toggleHeader(e, key)}>
           <span>${title}</span>
           <ha-icon icon="${this._closedDetails[key] ? 'mdi:plus' : 'mdi:minus'}"></ha-icon>
        </div>
      `;

      // Helper to generate Font Inputs for a specific element (Name, State, Label)
      const renderFontSection = (prefix, label) => html`
        <div class="sub-section">
            <strong>${label} Typography</strong>
            <div class="side-by-side">
                <ha-select 
                  label="Family" 
                  .value=${this._config[`${prefix}_font_family`] || "system"} 
                  @selected=${(ev) => this._dropdownChanged(ev, `${prefix}_font_family`)} 
                  @closed=${(e) => e.stopPropagation()}
                  @click=${(e) => e.stopPropagation()}
                >
                    ${fonts.map(f => html`<mwc-list-item .value=${f}>${f}</mwc-list-item>`)}
                </ha-select>
                <ha-select 
                  label="Weight" 
                  .value=${(this._config[`${prefix}_font_weight`] ?? this._defaultFontWeight(prefix))} 
                  @selected=${(ev) => this._dropdownChanged(ev, `${prefix}_font_weight`)} 
                  @closed=${(e) => e.stopPropagation()}
                  @click=${(e) => e.stopPropagation()}
                >
                    ${weights.map(w => html`<mwc-list-item .value=${w}>${w.charAt(0).toUpperCase() + w.slice(1)}</mwc-list-item>`)}
                </ha-select>
            </div>
            ${this._config[`${prefix}_font_family`] === 'custom' ? html`
                <ha-textfield .label=${"Custom Font Name"} .value=${this._config[`${prefix}_font_custom`] || ""} @input=${(ev) => this._textChanged(ev, `${prefix}_font_custom`)}></ha-textfield>
            ` : ''}
            <ha-textfield label="Size (px)" type="number" .value=${this._config[`size_${prefix}`] || ""} @input=${(ev) => this._textChanged(ev, `size_${prefix}`)}></ha-textfield>
            <div class="tpl-field">
                <div class="tpl-title">Color (supports templates)</div>
                <ha-code-editor
                  .hass=${this.hass}
                  mode="yaml"
                  autocomplete-entities
                  autocomplete-icons
                  .autocompleteEntities=${true}
                  .autocompleteIcons=${true}
                  .label=${"Color"}
                  .value=${this._config[`${prefix}_color`] || ""}
                  @value-changed=${(ev) => {
                    ev.stopPropagation();
                    const value = ev.detail?.value;
                    const key = `${prefix}_color`;
                    if (value !== this._config[key]) {
                      this._fireChanged({ ...this._config, [key]: value || undefined });
                    }
                  }}
                  @click=${(e) => e.stopPropagation()}
                ></ha-code-editor>
            </div>
        </div>
      `;
      
      // Helper for Action Dropdowns with conditional fields
      const renderActionDropdown = (label, configKey) => {
          const currentAction = (this._config[configKey] && this._config[configKey].action) ? this._config[configKey].action : "none";
          const actionConfig = this._config[configKey] || {};
          
          return html`
            <div class="action-config-section">
              <strong>${label}</strong>
              <ha-select 
                label="Action Type" 
                .value=${currentAction} 
                @selected=${(ev) => this._actionChanged(ev, configKey)} 
                @closed=${(e) => e.stopPropagation()} 
                @click=${(e) => e.stopPropagation()}
              >
                  ${actionsList.map(a => html`<mwc-list-item .value=${a.value}>${a.label}</mwc-list-item>`)}
              </ha-select>
              
              ${currentAction === 'navigate' ? html`
                ${customElements.get("ha-navigation-picker") ? html`
                  <ha-navigation-picker
                    .hass=${this.hass}
                    .label=${"Navigation Path"}
                    .value=${actionConfig.navigation_path || ""}
                    @value-changed=${(ev) => this._actionFieldChanged(ev, configKey, 'navigation_path')}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-navigation-picker>
                ` : customElements.get("ha-selector") ? html`
                  <ha-selector
                    .hass=${this.hass}
                    .label=${"Navigation Path"}
                    .selector=${{ navigation: {} }}
                    .value=${actionConfig.navigation_path || ""}
                    @value-changed=${(ev) => this._actionFieldChanged(ev, configKey, 'navigation_path')}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-selector>
                ` : html`
                  <ha-textfield
                    label="Navigation Path"
                    .value=${actionConfig.navigation_path || ""}
                    @input=${(ev) => this._actionFieldChanged(ev, configKey, 'navigation_path')}
                    placeholder="/lovelace/0"
                  ></ha-textfield>
                `}
              ` : ''}


              ${currentAction === 'url' ? html`
                <ha-textfield 
                  label="URL Path" 
                  .value=${actionConfig.url_path || ""} 
                  @input=${(ev) => this._actionFieldChanged(ev, configKey, 'url_path')}
                  placeholder="https://example.com"
                ></ha-textfield>
              ` : ''}
              
              ${currentAction === "perform-action" ? html`
                <div class="perform-action-config">
                  ${customElements.get("ha-service-picker") ? html`
                    <ha-service-picker
                      .hass=${this.hass}
                      .label=${"Action (service)"}
                      .value=${actionConfig.perform_action || ""}
                      @value-changed=${(ev) => {
                        ev.stopPropagation();
                        const v = ev.detail?.value ?? ev.target?.value ?? "";
                        if (v !== actionConfig.perform_action) {
                          const updated = { ...actionConfig, action: "perform-action", perform_action: String(v || "") };
                          this._fireChanged({ ...this._config, [configKey]: updated });
                        }
                      }}
                      @click=${(e) => e.stopPropagation()}
                    ></ha-service-picker>
                  ` : html`
                    ${(() => {
                      const key = String(configKey || '');
                      const full = String(actionConfig.perform_action || "");
                      const derivedDomain = full.includes('.') ? full.split('.')[0] : '';
                      const cachedDomain = (this._paDomainCache && this._paDomainCache[key]) ? this._paDomainCache[key] : '';
                      const domain = cachedDomain || derivedDomain;
                      const derivedService = (full.includes('.') && derivedDomain === domain) ? (full.split('.')[1] || '') : '';
                      const domains = Object.keys(this.hass?.services || {}).sort();
                      const services = (domain && this.hass?.services?.[domain]) ? Object.keys(this.hass.services[domain]).sort() : [];
                      return html`
                        <div class="side-by-side">
                          <ha-select
                            label="Domain"
                            .value=${domain || ""}
                            @selected=${(e) => {
                              e.stopPropagation();
                              const nextDomain = e.target.value || '';
                              this._paDomainCache[key] = nextDomain;
                              const updated = { ...actionConfig, action: "perform-action", perform_action: "" };
                              this._fireChanged({ ...this._config, [configKey]: updated });
                              this.requestUpdate();
                            }}
                            @closed=${(e) => e.stopPropagation()}
                            @click=${(e) => e.stopPropagation()}
                          >
                            <mwc-list-item value=""></mwc-list-item>
                            ${domains.map((d) => html`<mwc-list-item .value=${d}>${d}</mwc-list-item>`)}
                          </ha-select>

                          <ha-select
                            label="Service"
                            .value=${derivedService || ""}
                            .disabled=${!domain}
                            @selected=${(e) => {
                              e.stopPropagation();
                              const service = e.target.value || '';
                              const d = (this._paDomainCache[key] || domain || '');
                              const next = (d && service) ? `${d}.${service}` : "";
                              const updated = { ...actionConfig, action: "perform-action", perform_action: next };
                              this._fireChanged({ ...this._config, [configKey]: updated });
                            }}
                            @closed=${(e) => e.stopPropagation()}
                            @click=${(e) => e.stopPropagation()}
                          >
                            <mwc-list-item value=""></mwc-list-item>
                            ${services.map((s) => html`<mwc-list-item .value=${s}>${s}</mwc-list-item>`)}
                          </ha-select>
                        </div>
                      `;
                    })()}
                  `}


                  ${actionConfig.perform_action ? html`
                    <ha-selector
                      .hass=${this.hass}
                      .selector=${{ target: {} }}
                      .label=${"Target (optional)"}
                      .value=${actionConfig.target || null}
                      @value-changed=${(ev) => {
                        ev.stopPropagation();
                        const target = ev.detail?.value;
                        // Only update if target actually changed
                        const currentTarget = actionConfig.target;
                        if (JSON.stringify(currentTarget) !== JSON.stringify(target)) {
                          const updated = { ...actionConfig };
                          if (target && Object.keys(target).length > 0) {
                            updated.target = target;
                          } else {
                            delete updated.target;
                          }
                          this._fireChanged({ ...this._config, [configKey]: updated });
                        }
                      }}
                      @click=${(e) => e.stopPropagation()}
                    ></ha-selector>

                    <ha-yaml-editor
                      .hass=${this.hass}
                      .label=${"Service Data (optional, YAML)"}
                      .value=${actionConfig.data || null}
                      @value-changed=${(ev) => {
                        ev.stopPropagation();
                        const data = ev.detail?.value;
                        // Only update if data actually changed
                        const currentData = actionConfig.data;
                        if (JSON.stringify(currentData) !== JSON.stringify(data)) {
                          const updated = { ...actionConfig };
                          if (data && typeof data === 'object' && Object.keys(data).length > 0) {
                            updated.data = data;
                          } else {
                            delete updated.data;
                          }
                          this._fireChanged({ ...this._config, [configKey]: updated });
                        }
                      }}
                      @click=${(e) => e.stopPropagation()}
                    ></ha-yaml-editor>
                  ` : ''}
                </div>
              ` : ""}

              ${currentAction === "fire-dom-event" ? html`
                <ha-textfield
                  label="Event Name (optional)"
                  .value=${actionConfig.event_name || ""}
                  @input=${(ev) => this._actionFieldChanged(ev, configKey, "event_name")}
                  placeholder="browser_mod"
                ></ha-textfield>
                <div class="tpl-field">
                  <div class="tpl-title">Event Data (YAML/JSON text)</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    .value=${actionConfig.event_data || ""}
                    mode="yaml"
                    @value-changed=${(ev) => this._actionFieldChanged(ev, configKey, "event_data")}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
              ` : ""}
              
              ${currentAction === 'more-info' ? html`
                <ha-selector 
                  .hass=${this.hass} 
                  .selector=${{ entity: {} }} 
                  .value=${actionConfig.entity || ""} 
                  .label=${"Entity (optional)"} 
                  @value-changed=${(ev) => this._actionFieldSelectorChanged(ev, configKey, 'entity')}
                ></ha-selector>
              ` : ''}
            </div>
          `;
      };

      return html`
        <div class="card-config">
          <div class="disclaimer">
            <ha-alert alert-type="info" title="Documentation">
              Please read the <a href="https://jimz011.github.io/hki-elements/" target="_blank" rel="noopener noreferrer">documentation</a>
              first to set up this card. <br><br>
              This card may contain bugs. Use at your own risk!
            </ha-alert>
          </div>
          <div class="accordion-group">
            ${renderHeader("Card Layout", "layout_type")}
            <div class="accordion-content ${this._closedDetails['layout_type'] ? 'hidden' : ''}">
                <ha-select 
                  label="Card Layout" 
                  .value=${this._config.card_layout || "square"} 
                  @selected=${(ev) => {
                    ev.stopPropagation();
                    const newLayout = ev.target.value;
                    const oldLayout = this._config.card_layout;
                    
                    // Create new config with layout changed
                    const newConfig = { ...this._config, card_layout: newLayout };
                    
                    // When switching layouts, clear conflicting properties
                    if (oldLayout !== newLayout) {
                      // Clear layout-specific customizations to apply new defaults
                      if (newLayout === 'circle') {
                        // Force circle to be round even if user had custom border_radius
                        delete newConfig.grid_rows;
                        delete newConfig.grid_columns;
                        delete newConfig.element_grid;
                        delete newConfig.border_radius;
                      } else if (newLayout === 'badge' && this._config.badge_circle) {
                        // Force badge circle to be round
                        delete newConfig.border_radius;
                      } else {
                        // For other layouts, clear grid and border_radius if they were set by previous layouts
                        // Only clear if they match layout-specific defaults
                        if (this._config.grid_rows === 3 && this._config.grid_columns === 3) {
                          // These look like circle defaults
                          delete newConfig.grid_rows;
                          delete newConfig.grid_columns;
                          delete newConfig.element_grid;
                        }
                        if (this._config.border_radius === 100 || this._config.border_radius === 50) {
                          // These look like circle/badge-circle defaults
                          delete newConfig.border_radius;
                        }
                      }
                    }
                    
                    this._fireChanged(newConfig);
                  }} 
                  @closed=${(e) => e.stopPropagation()}
                  @click=${(e) => e.stopPropagation()}
                >
                    ${shapes.map(a => html`<mwc-list-item .value=${a}>${a === "square" ? "HKI Default" : (a === "google_default" ? "Google Default" : (a === "hki_tile" ? "HKI Tile" : "Badge"))}</mwc-list-item>`) }
                </ha-select>
                <div class="layout-actions">
                  <button type="button" class="hki-reset-btn" @click=${(ev) => { ev.stopPropagation(); this._resetToDefaults(ev); }}>
                    <ha-icon icon="mdi:restore"></ha-icon>
                    <span>Reset to defaults</span>
                  </button>
                </div>

                
                
                
                ${this._config.card_layout === 'badge' ? html`
                  <p style="font-size: 13px; opacity: 0.7; margin: 8px 0;">
                    Badge layout mimics Home Assistant badges. Only icon, name and state are available here.
                  </p>
                  <div class="side-by-side" style="gap: 16px; flex-wrap: wrap;">
                    <ha-formfield .label=${"Show Icon"}>
                      <ha-switch .checked=${this._config.show_icon !== false} @change=${(ev) => { ev.stopPropagation(); this._switchChanged(ev, "show_icon"); }}></ha-switch>
                    </ha-formfield>
                    <ha-formfield .label=${"Show Name"}>
                      <ha-switch .checked=${this._config.show_name !== false} @change=${(ev) => { ev.stopPropagation(); this._switchChanged(ev, "show_name"); }}></ha-switch>
                    </ha-formfield>
                    <ha-formfield .label=${"Show State"}>
                      <ha-switch .checked=${this._config.show_state !== false} @change=${(ev) => { ev.stopPropagation(); this._switchChanged(ev, "show_state"); }}></ha-switch>
                    </ha-formfield>
                  </div>
                ` : ''}
            </div>
          </div>

          <div class="accordion-group ">
            ${renderHeader("Entity", "general")}
            <div class="accordion-content ${this._closedDetails['general'] ? 'hidden' : ''}">
                <div class="side-by-side" style="grid-template-columns: 1fr auto; align-items:center;">
                  <ha-selector
                    .hass=${this.hass}
                    .selector=${{ entity: {} }}
                    .value=${this._config.entity || ""}
                    .label=${"Entity"}
                    .required=${false}
                    @value-changed=${(ev) => this._selectorChanged(ev, "entity")}
                  ></ha-selector>
                  <button class="hki-editor-clear" title="Clear Entity" @click=${(e) => { e.stopPropagation(); this._fireChanged({ ...this._config, entity: "" }); }}>
                    <ha-icon icon="mdi:close"></ha-icon>
                  </button>
                </div>
                
                <div class="separator"></div>
                <strong>Appearance</strong>
                <ha-formfield .label=${"Use Entity Picture"}><ha-switch .checked=${this._config.use_entity_picture === true} @change=${(ev) => this._switchChanged(ev, "use_entity_picture")}></ha-switch></ha-formfield>
                
                ${this._config.use_entity_picture ? html`
                  <ha-textfield .label=${"Entity Picture Override (optional)"} .value=${this._config.entity_picture_override || ""} @input=${(ev) => this._textChanged(ev, "entity_picture_override")}></ha-textfield>
                ` : html`
                  <div class="tpl-field">
                    <div class="tpl-title">Icon</div>
                    <div class="tpl-desc">Enter a single icon (e.g., <code>mdi:lightbulb</code>) or a Jinja template that resolves to one icon.</div>
                    <ha-code-editor
                      .hass=${this.hass}
                      mode="yaml"
                      autocomplete-entities
                      autocomplete-icons
                      .autocompleteEntities=${true}
                      .autocompleteIcons=${true}
                      .label=${"Icon (mdi:* or Jinja)"}
                      .value=${this._config.icon || ""}
                      @value-changed=${(ev) => {
                        ev.stopPropagation();
                        const value = ev.detail?.value;
                        if (value !== this._config.icon) {
                          this._fireChanged({ ...this._config, icon: value || undefined });
                        }
                      }}
                      @click=${(e) => e.stopPropagation()}
                    ></ha-code-editor>
                  </div>
                `}
                
                <div class="separator"></div>
                <strong>Text Overrides (Jinja)</strong>
                <p style="font-size: 11px; opacity: 0.7; margin-top: 0;">
                  These fields support Jinja templates (e.g., <code>{{ states('sensor.temperature') }}Â°C</code>).
                  Available variables: <code>config</code>, <code>user</code>.
                </p>

                <div class="tpl-field">
                  <div class="tpl-title">Name (top line)</div>
                  <div class="tpl-desc">Overrides the primary name text shown on the tile.</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Name template"}
                    .value=${this._config.name || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.name) {
                        this._fireChanged({ ...this._config, name: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>

                <div class="tpl-field">
                  <div class="tpl-title">State (bottom-right / state line)</div>
                  <div class="tpl-desc">Overrides the state text (normally the entity state, like On/Off/23Â°C).</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"State template"}
                    .value=${this._config.state_label || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.state_label) {
                        this._fireChanged({ ...this._config, state_label: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
                ${isBadgeLayout ? '' : html`

                ${this._config.card_layout === 'hki_tile' ? '' : html`
                <div class="tpl-field">
                  <div class="tpl-title">Label (subtitle)</div>
                  <div class="tpl-desc">Overrides the smaller subtitle/label text (if enabled).</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Label template"}
                    .value=${this._config.label || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.label) {
                        this._fireChanged({ ...this._config, label: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
                `}
                ${(isBadgeLayout || isGoogleLayout) ? '' : html`

                <div class="tpl-field">
                  <div class="tpl-title">Info (the optional â€œinfoâ€ row)</div>
                  <div class="tpl-desc">Overrides the info line when the card layout includes an info element.</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Info template"}
                    .value=${this._config.info_display || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.info_display) {
                        this._fireChanged({ ...this._config, info_display: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
                `}
                `}

          </div>

          ${isClimate ? html`
          <div class="accordion-group ">
            ${renderHeader("Climate Settings", "climate")}
            <div class="accordion-content ${this._closedDetails['climate'] ? 'hidden' : ''}">
                <div class="side-by-side" style="align-items:center;">
                  <ha-selector 
                    .hass=${this.hass} 
                    .selector=${{ entity: {} }} 
                    .value=${this._config.climate_current_temperature_entity || ""} 
                    .label=${"Current Temp Entity (optional)"} 
                    @value-changed=${(ev) => this._selectorChanged(ev, "climate_current_temperature_entity")}
                  ></ha-selector>
                  <button class="hki-editor-clear" title="Clear" @click=${(e) => { e.stopPropagation(); this._fireChanged({ ...this._config, climate_current_temperature_entity: "" }); }}>
                    <ha-icon icon="mdi:close"></ha-icon>
                  </button>
                </div>

                <ha-textfield label="Temp Friendly Name (optional)" .value=${this._config.climate_temperature_name || ""} @input=${(ev) => this._textChanged(ev, "climate_temperature_name")}></ha-textfield>

                <div class="side-by-side" style="align-items:center;">
                  <ha-selector 
                    .hass=${this.hass} 
                    .selector=${{ entity: {} }} 
                    .value=${this._config.climate_humidity_entity || ""} 
                    .label=${"Humidity Entity (optional)"} 
                    @value-changed=${(ev) => this._selectorChanged(ev, "climate_humidity_entity")}
                  ></ha-selector>
                  <button class="hki-editor-clear" title="Clear" @click=${(e) => { e.stopPropagation(); this._fireChanged({ ...this._config, climate_humidity_entity: "" }); }}>
                    <ha-icon icon="mdi:close"></ha-icon>
                  </button>
                </div>

                <ha-textfield label="Humidity Friendly Name (optional)" .value=${this._config.climate_humidity_name || ""} @input=${(ev) => this._textChanged(ev, "climate_humidity_name")}></ha-textfield>

                <div class="side-by-side" style="align-items:center;">
                  <ha-selector 
                    .hass=${this.hass} 
                    .selector=${{ entity: {} }} 
                    .value=${this._config.climate_pressure_entity || ""} 
                    .label=${"Pressure Entity (optional)"} 
                    @value-changed=${(ev) => this._selectorChanged(ev, "climate_pressure_entity")}
                  ></ha-selector>
                  <button class="hki-editor-clear" title="Clear" @click=${(e) => { e.stopPropagation(); this._fireChanged({ ...this._config, climate_pressure_entity: "" }); }}>
                    <ha-icon icon="mdi:close"></ha-icon>
                  </button>
                </div>

                <ha-textfield label="Pressure Friendly Name (optional)" .value=${this._config.climate_pressure_name || ""} @input=${(ev) => this._textChanged(ev, "climate_pressure_name")}></ha-textfield>
                
                <div class="separator"></div>
                <strong>Popup Slider Settings</strong>
                <ha-textfield label="Temperature Step Size" type="number" step="0.1" .value=${this._config.climate_temp_step ?? 0.5} @input=${(ev) => this._textChanged(ev, "climate_temp_step")} placeholder="0.5"></ha-textfield>
                <ha-formfield .label=${"Use Circular Slider"}><ha-switch .checked=${this._config.climate_use_circular_slider === true} @change=${(ev) => this._switchChanged(ev, "climate_use_circular_slider")}></ha-switch></ha-formfield>
                <ha-formfield .label=${"Show +/- Buttons"}><ha-switch .checked=${this._config.climate_show_plus_minus === true} @change=${(ev) => this._switchChanged(ev, "climate_show_plus_minus")}></ha-switch></ha-formfield>
                <ha-formfield .label=${"Show Gradient"}><ha-switch .checked=${this._config.climate_show_gradient !== false} @change=${(ev) => this._switchChanged(ev, "climate_show_gradient")}></ha-switch></ha-formfield>
                <ha-formfield .label=${"Show Min/Max Target Range (if supported)"}><ha-switch .checked=${this._config.climate_show_target_range !== false} @change=${(ev) => this._switchChanged(ev, "climate_show_target_range")}></ha-switch></ha-formfield>
                
                <div class="separator"></div>
                <ha-formfield .label=${"Show Temperature Badge"}>
                  <ha-switch .checked=${this._config.show_temp_badge !== false} @change=${(ev) => this._switchChanged(ev, "show_temp_badge")}></ha-switch>
                </ha-formfield>
                <strong>Temperature Badge Styling</strong>
                <div class="side-by-side">
                  <ha-textfield label="Size (px)" type="number" .value=${this._config.temp_badge_size ?? 40} @input=${(ev) => this._textChanged(ev, "temp_badge_size")}></ha-textfield>
                  <ha-textfield label="Font Size (px)" type="number" .value=${this._config.size_temp_badge ?? 9} @input=${(ev) => this._textChanged(ev, "size_temp_badge")}></ha-textfield>
                </div>
                <div class="side-by-side">
                  <ha-select 
                    label="Font Family" 
                    .value=${this._config.temp_badge_font_family || "system"} 
                    @selected=${(ev) => this._dropdownChanged(ev, "temp_badge_font_family")}
                    @closed=${(e) => e.stopPropagation()}
                    @click=${(e) => e.stopPropagation()}
                  >
                    ${fonts.map(f => html`<mwc-list-item .value=${f}>${f}</mwc-list-item>`)}
                  </ha-select>
                  <ha-select 
                    label="Font Weight" 
                    .value=${this._config.temp_badge_font_weight || "normal"} 
                    @selected=${(ev) => this._dropdownChanged(ev, "temp_badge_font_weight")}
                    @closed=${(e) => e.stopPropagation()}
                    @click=${(e) => e.stopPropagation()}
                  >
                    ${weights.map(w => html`<mwc-list-item .value=${w}>${w.charAt(0).toUpperCase() + w.slice(1)}</mwc-list-item>`)}
                  </ha-select>
                </div>
                ${this._config.temp_badge_font_family === 'custom' ? html`
                  <ha-textfield label="Custom Font Name" .value=${this._config.temp_badge_font_custom || ""} @input=${(ev) => this._textChanged(ev, "temp_badge_font_custom")}></ha-textfield>
                ` : ''}
                <div class="side-by-side">
                  <ha-textfield label="Border Radius" .value=${this._config.temp_badge_border_radius ?? ""} @input=${(ev) => this._textChanged(ev, "temp_badge_border_radius")}></ha-textfield>
                  <ha-textfield label="Box Shadow" .value=${this._config.temp_badge_box_shadow || ""} @input=${(ev) => this._textChanged(ev, "temp_badge_box_shadow")}></ha-textfield>
                </div>
                <div class="side-by-side">
                  <ha-textfield label="Text Color" .value=${this._config.temp_badge_text_color || ""} @input=${(ev) => this._textChanged(ev, "temp_badge_text_color")}></ha-textfield>
                  <ha-textfield label="Border Color" .value=${this._config.temp_badge_border_color || ""} @input=${(ev) => this._textChanged(ev, "temp_badge_border_color")}></ha-textfield>
                </div>
                <div class="side-by-side">
                  <ha-select 
                    label="Border Style" 
                    .value=${this._config.temp_badge_border_style || "none"} 
                    @selected=${(ev) => this._dropdownChanged(ev, "temp_badge_border_style")}
                    @closed=${(e) => e.stopPropagation()}
                    @click=${(e) => e.stopPropagation()}
                  >
                    ${borderStyleOptions.map((o) => html`<mwc-list-item .value=${o.value}>${o.label}</mwc-list-item>`)}
                  </ha-select>
                  <ha-textfield label="Border Width" .value=${this._config.temp_badge_border_width || ""} @input=${(ev) => this._textChanged(ev, "temp_badge_border_width")}></ha-textfield>
                </div>
            </div>
          </div>
          ` : ''}

          ${isHumidifier ? html`
          <div class="accordion-group ">
            ${renderHeader("Humidifier Settings", "humidifier")}
            <div class="accordion-content ${this._closedDetails['humidifier'] ? 'hidden' : ''}">
                <strong>Fan Speed Entity</strong>
                <p style="font-size:13px;opacity:0.7;margin:8px 0;">
                  Connect a <code>select</code> or <code>fan</code> entity to control fan speed directly inside the humidifier popup.
                </p>
                <div class="side-by-side" style="align-items:center;">
                  <ha-selector 
                    .hass=${this.hass} 
                    .selector=${{ entity: { domain: ['select', 'fan'] } }} 
                    .value=${this._config.humidifier_fan_entity || ""} 
                    .label=${"Fan Speed Entity (optional)"} 
                    @value-changed=${(ev) => this._selectorChanged(ev, "humidifier_fan_entity")}
                  ></ha-selector>
                  <button class="hki-editor-clear" title="Clear" @click=${(e) => { e.stopPropagation(); this._fireChanged({ ...this._config, humidifier_fan_entity: "" }); }}>
                    <ha-icon icon="mdi:close"></ha-icon>
                  </button>
                </div>

                <div class="separator"></div>
                <strong>Popup Slider Settings</strong>
                <ha-textfield label="Humidity Step Size" type="number" step="1" .value=${this._config.humidifier_humidity_step ?? 1} @input=${(ev) => this._textChanged(ev, "humidifier_humidity_step")} placeholder="1"></ha-textfield>
                <ha-formfield .label=${"Use Circular Slider"}><ha-switch .checked=${this._config.humidifier_use_circular_slider === true} @change=${(ev) => this._switchChanged(ev, "humidifier_use_circular_slider")}></ha-switch></ha-formfield>
                <ha-formfield .label=${"Show +/- Buttons"}><ha-switch .checked=${this._config.humidifier_show_plus_minus === true} @change=${(ev) => this._switchChanged(ev, "humidifier_show_plus_minus")}></ha-switch></ha-formfield>
                <ha-formfield .label=${"Show Gradient"}><ha-switch .checked=${this._config.humidifier_show_gradient !== false} @change=${(ev) => this._switchChanged(ev, "humidifier_show_gradient")}></ha-switch></ha-formfield>
            </div>
          </div>
          ` : ''}

          ${isPerson ? html`
          <div class="accordion-group ">
            ${renderHeader("Person Popup Options", "person_opts")}
            <div class="accordion-content ${this._closedDetails['person_opts'] ? 'hidden' : ''}">
              <p style="font-size: 11px; opacity: 0.7; margin: 0 0 8px 0;">Applies when action is "More Info (HKI)" on a person entity.</p>
              <p style="font-size: 10px; opacity: 0.6; margin: 0 0 8px 0; font-style: italic;">Link a geocoded address sensor to show the real street address on the map pin. The popup header always shows the person's state (home / away / zone).</p>
              <ha-entity-picker
                .hass=${this.hass}
                .value=${this._config.person_geocoded_entity || ""}
                .label=${"Geocoded Address Entity (optional)"}
                @value-changed=${(ev) => this._fireChanged({ ...this._config, person_geocoded_entity: ev.detail.value || undefined })}
                allow-custom-entity
              ></ha-entity-picker>
            </div>
          </div>
          ` : ''}

          ${isSensor ? html`
          <div class="accordion-group ">
            ${renderHeader("Sensor Graph Options", "sensor_opts")}
            <div class="accordion-content ${this._closedDetails['sensor_opts'] ? 'hidden' : ''}">
              <p style="font-size: 11px; opacity: 0.7; margin: 0 0 8px 0;">Applies when domain popup is Sensor and action is "More Info (HKI)".</p>
              <ha-formfield .label=${"Use gradient coloring (temperature-style)"}>
                <ha-select label="Graph Style" .value=${this._config.sensor_graph_style || 'line'}
                  @selected=${(ev) => this._dropdownChanged(ev, 'sensor_graph_style')}
                  @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                  <mwc-list-item value="line">Line Graph</mwc-list-item>
                  <mwc-list-item value="bar">Bar Chart</mwc-list-item>
                </ha-select>
                <ha-switch .checked=${this._config.sensor_graph_gradient !== false} @change=${(ev) => this._switchChanged(ev, "sensor_graph_gradient")}></ha-switch>
              </ha-formfield>
              <ha-textfield label="Fixed line color (overrides gradient)" .value=${this._config.sensor_graph_color || ""} @input=${(ev) => this._textChanged(ev, "sensor_graph_color")} placeholder="e.g. #2196F3 or var(--primary-color)"></ha-textfield>
              <ha-textfield label="Line width (px)" type="number" .value=${this._config.sensor_line_width ?? 3} @input=${(ev) => this._textChanged(ev, "sensor_line_width")}></ha-textfield>
              <ha-select label="Graph time range"
                .value=${String(this._config.sensor_hours ?? 24)}
                @selected=${(ev) => this._dropdownChanged(ev, 'sensor_hours')}
                @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                <mwc-list-item value="12">12 hours</mwc-list-item>
                <mwc-list-item value="24">24 hours</mwc-list-item>
                <mwc-list-item value="48">48 hours</mwc-list-item>
                <mwc-list-item value="72">72 hours</mwc-list-item>
              </ha-select>
            </div>
          </div>
          ` : ''}

                    ${isLock ? html`
          <div class="accordion-group ">
            ${renderHeader("Lock Settings", "lock")}
            <div class="accordion-content ${this._closedDetails['lock'] ? 'hidden' : ''}">
                <strong>Contact Sensor (Door/Window)</strong>
                <p style="font-size: 13px; opacity: 0.7; margin: 8px 0;">
                  Add a contact sensor (door or window) to display when it's open. The lock icon will turn red and show your custom label when the sensor is open/on.
                </p>
                
                <div class="side-by-side" style="align-items:center;">
                  <ha-selector 
                    .hass=${this.hass} 
                    .selector=${{ entity: { domain: ['binary_sensor', 'sensor'] } }} 
                    .value=${this._config.lock_contact_sensor_entity || ""} 
                    .label=${"Contact Sensor Entity (optional)"} 
                    @value-changed=${(ev) => this._selectorChanged(ev, "lock_contact_sensor_entity")}
                  ></ha-selector>
                  <button class="hki-editor-clear" title="Clear" @click=${(e) => { e.stopPropagation(); this._fireChanged({ ...this._config, lock_contact_sensor_entity: "" }); }}>
                    <ha-icon icon="mdi:close"></ha-icon>
                  </button>
                </div>

                <ha-textfield 
                  label="Open State Label (e.g., 'Door Open')" 
                  .value=${this._config.lock_contact_sensor_label || "Door Open"} 
                  @input=${(ev) => this._textChanged(ev, "lock_contact_sensor_label")}
                  placeholder="Door Open"
                ></ha-textfield>
            </div>
          </div>
          ` : ''}

          
          <div class="accordion-group ">
            ${renderHeader("Visibility", "visibility")}
            <div class="accordion-content ${this._closedDetails['visibility'] ? 'hidden' : ''}">
              <p style="font-size: 13px; opacity: 0.7; margin: 8px 0;">
                Toggle which elements are shown. (Badge layout also has its own quick toggles in Card Layout.)
              </p>
              <div class="side-by-side" style="gap: 16px; flex-wrap: wrap;">
                <ha-formfield .label=${"Show Icon"}>
                  <ha-switch .checked=${this._config.show_icon !== false} @change=${(ev) => { ev.stopPropagation(); this._switchChanged(ev, "show_icon"); }}></ha-switch>
                </ha-formfield>
                <ha-formfield .label=${"Show Name"}>
                  <ha-switch .checked=${this._config.show_name !== false} @change=${(ev) => { ev.stopPropagation(); this._switchChanged(ev, "show_name"); }}></ha-switch>
                </ha-formfield>
                <ha-formfield .label=${"Show State"}>
                  <ha-switch .checked=${this._config.show_state !== false} @change=${(ev) => { ev.stopPropagation(); this._switchChanged(ev, "show_state"); }}></ha-switch>
                </ha-formfield>
                ${((this._config.card_layout || 'square') === 'square' || isGoogleLayout) ? html`
                <ha-formfield .label=${"Show Label"}>
                  <ha-switch .checked=${this._config.show_label !== false} @change=${(ev) => { ev.stopPropagation(); this._switchChanged(ev, "show_label"); }}></ha-switch>
                </ha-formfield>
                ` : ''} 
                ${((this._config.card_layout || 'square') === 'square' || this._config.card_layout === 'hki_tile') ? html`
                <ha-formfield .label=${"Show Info Display"}>
                  <ha-switch .checked=${this._config.show_info_display !== false} @change=${(ev) => { ev.stopPropagation(); this._switchChanged(ev, "show_info_display"); }}></ha-switch>
                </ha-formfield>
                ` : ''} 
                </div>
            </div>
          </div>

          <div class="accordion-group ">
             ${renderHeader("Card Styling", "card_styling")}
             <div class="accordion-content ${this._closedDetails['card_styling'] ? 'hidden' : ''}">
                <strong>Colors</strong>
                <div class="tpl-field">
                  <div class="tpl-title">Card Background</div>
                  <div class="tpl-desc">Supports templates and plain values</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Card Background"}
                    .value=${this._config.card_color || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.card_color) {
                        this._fireChanged({ ...this._config, card_color: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
                <div class="tpl-field">
                  <div class="tpl-title">Card Opacity</div>
                  <div class="tpl-desc">Supports templates and plain values</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Card Opacity"}
                    .value=${this._config.card_opacity || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.card_opacity) {
                        this._fireChanged({ ...this._config, card_opacity: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>

                <div class="separator"></div>
                <strong>Card Border</strong>
                <div class="tpl-field">
                  <div class="tpl-title">Border Style</div>
                  <div class="tpl-desc">Supports templates. Values: none, solid, dashed, dotted, double, groove, ridge, inset, outset</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Border Style"}
                    .value=${this._config.border_style || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.border_style) {
                        this._fireChanged({ ...this._config, border_style: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
                <div class="tpl-field">
                  <div class="tpl-title">Border Width</div>
                  <div class="tpl-desc">Supports templates. Auto adds 'px' if number only.</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Border Width"}
                    .value=${this._config.border_width || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.border_width) {
                        this._fireChanged({ ...this._config, border_width: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
                <div class="tpl-field">
                  <div class="tpl-title">Border Color</div>
                  <div class="tpl-desc">Supports templates and plain values</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Border Color"}
                    .value=${this._config.border_color || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.border_color) {
                        this._fireChanged({ ...this._config, border_color: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div><div class="tpl-field">
                  <div class="tpl-title">Border Radius</div>
                  <div class="tpl-desc">Supports templates and plain values</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Border Radius"}
                    .value=${this._config.border_radius || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.border_radius) {
                        this._fireChanged({ ...this._config, border_radius: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
                ${this._config.card_layout === "hki_tile" ? html`
                  <div class="side-by-side">
                    <ha-textfield
                      label="Tile Height (px)"
                      type="number"
                      min="40"
                      step="1"
                      placeholder="60"
                      .value=${this._config.tile_height ?? ""}
                      @input=${(ev) => this._textChanged(ev, "tile_height")}
                    ></ha-textfield>
                    <div></div>
                  </div>
                  <ha-formfield label="Show Slider (brightness/volume)">
                    <ha-switch
                      .checked=${this._config.show_tile_slider === true}
                      @change=${(ev) => this._switchChanged(ev, "show_tile_slider")}
                    ></ha-switch>
                  </ha-formfield>
                  ${this._config.show_tile_slider === true ? html`
                    <div class="side-by-side">
                      <ha-textfield
                        label="Track Color (unfilled)"
                        placeholder="rgba(255, 255, 255, 0.2)"
                        .value=${this._config.tile_slider_track_color ?? ""}
                        @input=${(ev) => this._textChanged(ev, "tile_slider_track_color")}
                      ></ha-textfield>
                      <ha-textfield
                        label="Fill Color (filled)"
                        placeholder="rgba(255, 255, 255, 0.8)"
                        .value=${this._config.tile_slider_fill_color ?? ""}
                        @input=${(ev) => this._textChanged(ev, "tile_slider_fill_color")}
                      ></ha-textfield>
                    </div>
                  ` : ''}
                ` : ''}
                <div class="tpl-field">
                  <div class="tpl-title">Box Shadow</div>
                  <div class="tpl-desc">Supports templates and plain values</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Box Shadow"}
                    .value=${this._config.box_shadow || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.box_shadow) {
                        this._fireChanged({ ...this._config, box_shadow: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
             </div>
          </div>

          <div class="accordion-group ">
             ${renderHeader("Icon Styling", "icon_settings")}
             <div class="accordion-content ${this._closedDetails['icon_settings'] ? 'hidden' : ''}">

                <strong>Icon Styling</strong>
                <ha-formfield .label=${"Show Icon"}>
                  <ha-switch .checked=${this._config.show_icon !== false} @change=${(ev) => { ev.stopPropagation(); this._switchChanged(ev, "show_icon"); }}></ha-switch>
                </ha-formfield>
                <ha-textfield label="Size (px)" type="number" .value=${this._config.size_icon || 24} @input=${(ev) => this._textChanged(ev, "size_icon")}></ha-textfield>
                <div class="tpl-field">
                  <div class="tpl-title">Icon Color</div>
                  <div class="tpl-desc">Supports templates and plain values</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Icon Color"}
                    .value=${this._config.icon_color || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.icon_color) {
                        this._fireChanged({ ...this._config, icon_color: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>

                ${isGoogleLayout ? '' : html`
                <div class="separator"></div>
                <strong>Icon Circle</strong>
                <ha-formfield .label=${"Show Icon Circle"}>
                  <ha-switch .checked=${this._config.show_icon_circle !== false} @change=${(ev) => this._switchChanged(ev, "show_icon_circle")}></ha-switch>
                </ha-formfield>
                <div class="tpl-field">
                  <div class="tpl-title">Icon Circle Background</div>
                  <div class="tpl-desc">Supports templates and plain values</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Icon Circle Background"}
                    .value=${this._config.icon_circle_bg || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.icon_circle_bg) {
                        this._fireChanged({ ...this._config, icon_circle_bg: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
                <div class="tpl-field">
                  <div class="tpl-title">Icon Circle Border Style</div>
                  <div class="tpl-desc">Supports templates. Values: none, solid, dashed, dotted</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Icon Circle Border Style"}
                    .value=${this._config.icon_circle_border_style || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.icon_circle_border_style) {
                        this._fireChanged({ ...this._config, icon_circle_border_style: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
                <div class="tpl-field">
                  <div class="tpl-title">Icon Circle Border Width</div>
                  <div class="tpl-desc">Supports templates. Auto adds 'px' if number only.</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Icon Circle Border Width"}
                    .value=${this._config.icon_circle_border_width || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.icon_circle_border_width) {
                        this._fireChanged({ ...this._config, icon_circle_border_width: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
                <div class="tpl-field">
                  <div class="tpl-title">Icon Circle Border Color</div>
                  <div class="tpl-desc">Supports templates and plain values</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Icon Circle Border Color"}
                    .value=${this._config.icon_circle_border_color || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.icon_circle_border_color) {
                        this._fireChanged({ ...this._config, icon_circle_border_color: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>

                
                `}
                ${isGoogleLayout ? '' : html`
                <div class="separator"></div>
                <strong>Icon Badge</strong>
                <ha-formfield .label=${"Show Icon Badge"}>
                  <ha-switch .checked=${this._config.show_icon_badge !== false} @change=${(ev) => this._switchChanged(ev, "show_icon_badge")}></ha-switch>
                </ha-formfield>
                <div class="tpl-field">
                  <div class="tpl-title">Badge Background</div>
                  <div class="tpl-desc">Supports templates and plain values</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Badge Background"}
                    .value=${this._config.badge_bg || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.badge_bg) {
                        this._fireChanged({ ...this._config, badge_bg: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
                <div class="tpl-field">
                  <div class="tpl-title">Badge Border Style</div>
                  <div class="tpl-desc">Supports templates. Values: none, solid, dashed, dotted</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Badge Border Style"}
                    .value=${this._config.badge_border_style || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.badge_border_style) {
                        this._fireChanged({ ...this._config, badge_border_style: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div><div class="tpl-field">
                  <div class="tpl-title">Badge Border Width</div>
                  <div class="tpl-desc">Supports templates. Auto adds 'px' if number only.</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Badge Border Width"}
                    .value=${this._config.badge_border_width || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.badge_border_width) {
                        this._fireChanged({ ...this._config, badge_border_width: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div><div class="tpl-field">
                  <div class="tpl-title">Badge Border Color</div>
                  <div class="tpl-desc">Supports templates and plain values</div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Badge Border Color"}
                    .value=${this._config.badge_border_color || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.badge_border_color) {
                        this._fireChanged({ ...this._config, badge_border_color: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
                
                <div class="separator"></div>
                
                `}
                <strong>Icon Animation</strong>
                <div class="tpl-field">
                  <div class="tpl-title">Animation</div>
                  <div class="tpl-desc">
                    Supports templates and plain values. Available: <code>spin</code>, <code>pulse</code>, <code>bounce</code>, <code>shake</code>, <code>swing</code>, <code>tada</code>, <code>wobble</code>, <code>flip</code><br>
                    <strong>Note:</strong> Plain animation names (e.g., <code>pulse</code>) automatically apply only when entity is ON. Use templates for custom control.
                  </div>
                  <ha-code-editor
                    .hass=${this.hass}
                    mode="yaml"
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Animation"}
                    .value=${this._config.icon_animation || ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const value = ev.detail?.value;
                      if (value !== this._config.icon_animation) {
                        this._fireChanged({ ...this._config, icon_animation: value || undefined });
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                </div>
             </div>
          </div>

          <div class="accordion-group ">
            ${renderHeader("Typography", "typography")}
             <div class="accordion-content ${this._closedDetails['typography'] ? 'hidden' : ''}">
                ${renderFontSection("name", "Name")}
                <div class="separator"></div>
                ${renderFontSection("state", "State")}
                <div class="separator"></div>
                ${renderFontSection("label", "Label")}
                <div class="separator"></div>
                ${renderFontSection("brightness", "Info Display")}
             </div>
          </div>

          <div class="accordion-group ">
            ${renderHeader("HKI Popup Options", "popup")}
             <div class="accordion-content ${this._closedDetails['popup'] ? 'hidden' : ''}">
                <p style="font-size: 12px; opacity: 0.7; margin: 8px 0; padding: 8px; background: var(--secondary-background-color); border-radius: 6px; border-left: 3px solid var(--primary-color);">
                  <strong>Note:</strong> These settings only work when an action is set to <code>more-info (HKI)</code>.
                </p>

                ${(() => {
                  const isCustomPopup = this._config.custom_popup?.enabled === true || this._config.custom_popup_enabled === true;
                  const domain = selectedEntity?.entity_id?.split('.')[0];
                  const hasChildren = selectedEntity?.attributes?.entity_id && Array.isArray(selectedEntity.attributes.entity_id);
                  const isLightGroup = domain === 'light' && hasChildren;
                  const entityTypeName = domain === 'light' ? 'Lights' : (domain === 'cover' ? 'Covers' : (domain === 'switch' ? 'Switches' : 'Entities'));

                  const showLightOptions = domain === 'light';
                  const showClimateOptions = isClimate;
                  const showAlarmOptions = domain === 'alarm_control_panel';
                  const showCoverOptions = domain === 'cover';
                  const hasDomainFeatures = true;

                  return html`
                    <div class="sub-accordion">
                      ${renderHeader("Popup Card", "popup_card")}
                      <div class="sub-accordion-content ${this._closedDetails['popup_card'] ? 'hidden' : ''}">
                        <p style="font-size: 11px; opacity: 0.7; margin: 0 0 6px 0;">Enable to embed any custom card instead of the auto domain popup.</p>
                        <ha-formfield .label=${"Enable Custom Popup"}><ha-switch .checked=${isCustomPopup} @change=${(ev) => this._switchChanged(ev, "custom_popup_enabled")}></ha-switch></ha-formfield>
                        ${isCustomPopup ? html`
                          <p style="font-size: 10px; opacity: 0.6; margin: 6px 0 4px 0; font-style: italic;">This card will be embedded in the popup. Defaults to a vertical-stack â€” click the card type to change it.</p>
                          <div class="card-config">
                            ${customElements.get('hui-card-element-editor')
                              ? html`<hui-card-element-editor
                                .hass=${this.hass}
                                .lovelace=${this._getLovelace()}
                                .value=${this._config.custom_popup_card ?? this._config.custom_popup?.card ?? { type: "vertical-stack", cards: [] }}
                                @config-changed=${(ev) => {
                                  ev.stopPropagation();
                                  const newCard = ev.detail?.config;
                                  if (!newCard) return;
                                  const existing = this._config?.custom_popup_card ?? this._config?.custom_popup?.card;
                                  if (JSON.stringify(newCard) !== JSON.stringify(existing)) {
                                    this._fireChanged({ ...this._config, custom_popup_card: newCard });
                                  }
                                }}
                              ></hui-card-element-editor>`
                              : customElements.get('hui-card-picker')
                                ? html`
                                  <hui-card-picker
                                    .hass=${this.hass}
                                    .lovelace=${this._getLovelace()}
                                    .value=${this._config.custom_popup_card ?? this._config.custom_popup?.card ?? { type: "vertical-stack", cards: [] }}
                                    @config-changed=${(ev) => {
                                      ev.stopPropagation();
                                      const picked = ev.detail?.config;
                                      if (!picked) return;
                                      const existing = this._config?.custom_popup_card ?? this._config?.custom_popup?.card;
                                      if (JSON.stringify(picked) !== JSON.stringify(existing)) {
                                        this._fireChanged({ ...this._config, custom_popup_card: picked });
                                      }
                                    }}
                                  ></hui-card-picker>
                                  <ha-yaml-editor
                                    .hass=${this.hass}
                                    .label=${"Popup Card (YAML)"}
                                    .value=${this._config.custom_popup_card ?? this._config.custom_popup?.card ?? { type: "vertical-stack", cards: [] }}
                                    @value-changed=${(ev) => {
                                      ev.stopPropagation();
                                      const newCard = ev.detail?.value;
                                      if (!newCard) return;
                                      const existing = this._config?.custom_popup_card ?? this._config?.custom_popup?.card;
                                      if (JSON.stringify(newCard) !== JSON.stringify(existing)) {
                                        this._fireChanged({ ...this._config, custom_popup_card: newCard });
                                      }
                                    }}
                                    @click=${(e) => e.stopPropagation()}
                                  ></ha-yaml-editor>
                                `
                                : (() => { this._ensureCardEditorLoaded(); return html`<div class="hki-editor-loading">Loading card pickerâ€¦</div>`; })()}
                          </div>
                        ` : ''}
                      </div>
                    </div>

                    <div class="sub-accordion">
                      ${renderHeader("Animation", "popup_anim")}
                      <div class="sub-accordion-content ${this._closedDetails['popup_anim'] ? 'hidden' : ''}">
                        <div class="side-by-side">
                          <ha-select label="Open Animation" .value=${this._config.popup_open_animation || 'scale'}
                            @selected=${(ev) => this._dropdownChanged(ev, 'popup_open_animation')}
                            @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                            ${HKI_POPUP_EDITOR_OPTIONS.animations.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                          </ha-select>
                          <ha-select label="Close Animation" .value=${this._config.popup_close_animation || 'scale'}
                            @selected=${(ev) => this._dropdownChanged(ev, 'popup_close_animation')}
                            @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                            ${HKI_POPUP_EDITOR_OPTIONS.animations.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                          </ha-select>
                        </div>
                        <ha-textfield label="Animation Duration (ms)" type="number" .value=${this._config.popup_animation_duration ?? 300} @input=${(ev) => this._textChanged(ev, 'popup_animation_duration')}></ha-textfield>
                      </div>
                    </div>

                    <div class="sub-accordion">
                      ${renderHeader("Container & Size", "popup_container")}
                      <div class="sub-accordion-content ${this._closedDetails['popup_container'] ? 'hidden' : ''}">
                        <ha-textfield label="Border Radius (px)" type="number" .value=${this._config.popup_border_radius ?? 16} @input=${(ev) => this._textChanged(ev, "popup_border_radius")}></ha-textfield>
                        <div class="side-by-side">
                          <ha-select label="Width" .value=${this._config.popup_width || 'auto'}
                            @selected=${(ev) => this._dropdownChanged(ev, "popup_width")}
                            @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                            ${HKI_POPUP_EDITOR_OPTIONS.width.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                          </ha-select>
                          ${this._config.popup_width === 'custom' ? html`
                            <ha-textfield label="Custom Width (px)" type="number" .value=${this._config.popup_width_custom ?? 400} @input=${(ev) => this._textChanged(ev, "popup_width_custom")}></ha-textfield>
                          ` : html`<div></div>`}
                        </div>
                        <div class="side-by-side">
                          <ha-select label="Height" .value=${this._config.popup_height || 'auto'}
                            @selected=${(ev) => this._dropdownChanged(ev, "popup_height")}
                            @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                            ${HKI_POPUP_EDITOR_OPTIONS.height.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                          </ha-select>
                          ${this._config.popup_height === 'custom' ? html`
                            <ha-textfield label="Custom Height (px)" type="number" .value=${this._config.popup_height_custom ?? 600} @input=${(ev) => this._textChanged(ev, "popup_height_custom")}></ha-textfield>
                          ` : html`<div></div>`}
                        </div>
                      </div>
                    </div>

                    <div class="sub-accordion">
                      ${renderHeader("Blur & Glass Effect", "popup_blur")}
                      <div class="sub-accordion-content ${this._closedDetails['popup_blur'] ? 'hidden' : ''}">
                        <p style="font-size: 11px; opacity: 0.7; margin: 0 0 4px 0;">Background (portal)</p>
                        <ha-formfield .label=${"Enable Background Blur"}><ha-switch .checked=${this._config.popup_blur_enabled !== false} @change=${(ev) => this._switchChanged(ev, "popup_blur_enabled")}></ha-switch></ha-formfield>
                        <ha-textfield label="Blur Amount (px)" type="number" .value=${this._config.popup_blur_amount ?? 10} @input=${(ev) => this._textChanged(ev, "popup_blur_amount")} .disabled=${this._config.popup_blur_enabled === false}></ha-textfield>
                        <p style="font-size: 11px; opacity: 0.7; margin: 8px 0 4px 0;">Card glass effect</p>
                        <p style="font-size: 10px; opacity: 0.6; margin: 0 0 6px 0; font-style: italic;">Creates a frosted glass effect on the popup card.</p>
                        <ha-formfield .label=${"Enable Card Blur"}><ha-switch .checked=${this._config.popup_card_blur_enabled !== false} @change=${(ev) => this._switchChanged(ev, "popup_card_blur_enabled")}></ha-switch></ha-formfield>
                        <div class="side-by-side">
                          <ha-textfield label="Card Blur (px)" type="number" .value=${this._config.popup_card_blur_amount ?? 40} @input=${(ev) => this._textChanged(ev, "popup_card_blur_amount")} .disabled=${this._config.popup_card_blur_enabled === false}></ha-textfield>
                          <ha-textfield label="Card Opacity" type="number" step="0.1" min="0" max="1" .value=${this._config.popup_card_opacity ?? 0.4} @input=${(ev) => this._textChanged(ev, "popup_card_opacity")}></ha-textfield>
                        </div>
                      </div>
                    </div>

                    <div class="sub-accordion">
                      ${renderHeader("Bottom Bar Entities", "popup_bottom_bar")}
                      <div class="sub-accordion-content ${this._closedDetails['popup_bottom_bar'] ? 'hidden' : ''}">
                        <p style="font-size: 11px; opacity: 0.7; margin: 0 0 6px 0;">Add up to 8 icon buttons to the bottom bar. Works on all popups.</p>
                        <ha-select label="Button Alignment"
                          .value=${this._config.popup_bottom_bar_align || 'spread'}
                          @selected=${(ev) => this._dropdownChanged(ev, 'popup_bottom_bar_align')}
                          @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                          ${popupBottomBarAlignOptionsDetailed.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                        </ha-select>
                        ${(() => {
                          const currentSlots = this._config._bb_slots ?? Math.max(1, (this._config.popup_bottom_bar_entities || []).filter(Boolean).length || 1);
                          const slots = Math.max(1, Math.min(8, currentSlots));
                          return html`
                            <div style="display:flex;align-items:center;gap:8px;margin:10px 0 4px 0;">
                              <span style="font-size:12px;opacity:0.7;flex:1;">Slots: ${slots}</span>
                              <button style="width:28px;height:28px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);background:rgba(255,255,255,0.06);color:var(--primary-text-color);cursor:pointer;font-size:16px;display:flex;align-items:center;justify-content:center;"
                                @click=${(e) => { e.stopPropagation(); this._fireChanged({ ...this._config, _bb_slots: Math.max(1, slots - 1) }); }}>âˆ’</button>
                              <button style="width:28px;height:28px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);background:rgba(255,255,255,0.06);color:var(--primary-text-color);cursor:pointer;font-size:16px;display:flex;align-items:center;justify-content:center;"
                                @click=${(e) => { e.stopPropagation(); this._fireChanged({ ...this._config, _bb_slots: Math.min(8, slots + 1) }); }}>+</button>
                            </div>
                            ${Array.from({ length: slots }, (_, i) => {
                          const ents = this._config.popup_bottom_bar_entities || [];
                          const entry = ents[i] || {};
                          const tapAction = entry.tap_action || { action: 'more-info' };
                          const currentAction = tapAction.action || 'more-info';
                          const bbKey = `bb_${i}`;

                          const setEntry = (patch) => {
                            const src = this._config.popup_bottom_bar_entities || [];
                            const arr = Array.from({ length: Math.max(src.length, i + 1) }, (_, j) => src[j] || null);
                            arr[i] = { ...(arr[i] || {}), ...patch };
                            while (arr.length > 0 && !arr[arr.length - 1]?.entity) arr.pop();
                            this._fireChanged({ ...this._config, popup_bottom_bar_entities: arr.length ? arr : undefined });
                          };
                          const moveEntry = (toIndex) => {
                            const src = this._config.popup_bottom_bar_entities || [];
                            if (toIndex < 0 || toIndex >= slots || toIndex === i) return;
                            const arr = Array.from({ length: Math.max(src.length, slots) }, (_, j) => src[j] || null);
                            [arr[toIndex], arr[i]] = [arr[i], arr[toIndex]];
                            while (arr.length > 0 && !arr[arr.length - 1]?.entity) arr.pop();
                            this._fireChanged({ ...this._config, popup_bottom_bar_entities: arr.length ? arr : undefined });
                          };
                          const setTapAction = (actionPatch) => setEntry({ tap_action: { ...tapAction, ...actionPatch } });

                          return html`
                            <div style="margin-top:10px;padding:10px;background:rgba(255,255,255,0.04);border-radius:10px;">
                              <div style="display:flex;justify-content:space-between;align-items:center;">
                                <p style="font-size:11px;opacity:0.7;margin:0 0 6px 0;font-weight:600;">Button ${i+1}</p>
                                <div style="display:flex;align-items:center;gap:2px;">
                                  <mwc-icon-button ?disabled=${i === 0} @click=${() => moveEntry(i - 1)}><ha-icon icon="mdi:chevron-up"></ha-icon></mwc-icon-button>
                                  <mwc-icon-button ?disabled=${i === slots - 1} @click=${() => moveEntry(i + 1)}><ha-icon icon="mdi:chevron-down"></ha-icon></mwc-icon-button>
                                </div>
                              </div>
                              <ha-entity-picker .hass=${this.hass} .value=${entry.entity||""} .label=${"Entity"}
                                @value-changed=${(ev) => setEntry({ entity: ev.detail.value || undefined })}
                                allow-custom-entity></ha-entity-picker>
                              ${entry.entity ? html`
                                <ha-textfield label="Name (optional)" .value=${entry.name||""} placeholder="Custom name"
                                  @input=${(ev) => setEntry({ name: ev.target.value || undefined })} style="margin-top:6px;"></ha-textfield>
                                <ha-textfield label="Custom Icon (optional)" .value=${entry.icon||""} placeholder="mdi:account"
                                  @input=${(ev) => setEntry({ icon: ev.target.value || undefined })} style="margin-top:6px;"></ha-textfield>

                                <ha-select label="Tap Action" .value=${currentAction}
                                  @selected=${(ev) => { ev.stopPropagation(); const v = ev.detail?.value || ev.target?.value; if (v && v !== currentAction) setTapAction({ action: v }); }}
                                  @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()} style="margin-top:6px;">
                                  ${actionsList.map(a => html`<mwc-list-item .value=${a.value}>${a.label}</mwc-list-item>`)}
                                </ha-select>

                                ${currentAction === 'navigate' ? html`
                                  ${customElements.get("ha-navigation-picker") ? html`
                                    <ha-navigation-picker .hass=${this.hass} label="Navigation Path"
                                      .value=${tapAction.navigation_path||""}
                                      @value-changed=${(ev) => { ev.stopPropagation(); setTapAction({ navigation_path: ev.detail?.value || "" }); }}
                                      @click=${(e) => e.stopPropagation()} style="margin-top:6px;"></ha-navigation-picker>
                                  ` : html`
                                    <ha-textfield label="Navigation Path" .value=${tapAction.navigation_path||""} placeholder="/lovelace/0"
                                      @input=${(ev) => setTapAction({ navigation_path: ev.target.value })} style="margin-top:6px;"></ha-textfield>
                                  `}
                                ` : ''}

                                ${currentAction === 'url' ? html`
                                  <ha-textfield label="URL" .value=${tapAction.url_path||""} placeholder="https://..."
                                    @input=${(ev) => setTapAction({ url_path: ev.target.value })} style="margin-top:6px;"></ha-textfield>
                                ` : ''}

                                ${currentAction === 'perform-action' ? html`
                                  ${customElements.get("ha-service-picker") ? html`
                                    <ha-service-picker .hass=${this.hass} label="Action (service)"
                                      .value=${tapAction.perform_action||""}
                                      @value-changed=${(ev) => { ev.stopPropagation(); const v = ev.detail?.value ?? ev.target?.value ?? ""; if (v !== tapAction.perform_action) setTapAction({ perform_action: String(v || "") }); }}
                                      @click=${(e) => e.stopPropagation()} style="margin-top:6px;"></ha-service-picker>
                                  ` : html`
                                    ${(() => {
                                      const full = String(tapAction.perform_action || "");
                                      this._paDomainCache = this._paDomainCache || {};
                                      const cachedDomain = this._paDomainCache[bbKey] || "";
                                      const derivedDomain = full.includes('.') ? full.split('.')[0] : '';
                                      const domain = cachedDomain || derivedDomain;
                                      const derivedService = (full.includes('.') && derivedDomain === domain) ? (full.split('.')[1] || '') : '';
                                      const domains = Object.keys(this.hass?.services || {}).sort();
                                      const services = domain && this.hass?.services?.[domain] ? Object.keys(this.hass.services[domain]).sort() : [];
                                      return html`
                                        <div class="side-by-side" style="margin-top:6px;">
                                          <ha-select label="Domain" .value=${domain||""}
                                            @selected=${(e) => { e.stopPropagation(); this._paDomainCache[bbKey] = e.target.value || ''; setTapAction({ perform_action: "" }); this.requestUpdate(); }}
                                            @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                                            <mwc-list-item value=""></mwc-list-item>
                                            ${domains.map(d => html`<mwc-list-item .value=${d}>${d}</mwc-list-item>`)}
                                          </ha-select>
                                          <ha-select label="Service" .value=${derivedService||""} .disabled=${!domain}
                                            @selected=${(e) => { e.stopPropagation(); const svc = e.target.value || ''; const d = this._paDomainCache[bbKey] || domain || ''; setTapAction({ perform_action: d && svc ? `${d}.${svc}` : "" }); }}
                                            @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                                            <mwc-list-item value=""></mwc-list-item>
                                            ${services.map(s => html`<mwc-list-item .value=${s}>${s}</mwc-list-item>`)}
                                          </ha-select>
                                        </div>`;
                                    })()}
                                  `}
                                  ${tapAction.perform_action ? html`
                                    <ha-selector .hass=${this.hass} .selector=${{ target: {} }} label="Target (optional)"
                                      .value=${tapAction.target || null}
                                      @value-changed=${(ev) => { ev.stopPropagation(); const t = ev.detail?.value; const upd = { ...tapAction }; if (t && Object.keys(t).length) upd.target = t; else delete upd.target; setEntry({ tap_action: upd }); }}
                                      @click=${(e) => e.stopPropagation()} style="margin-top:6px;"></ha-selector>
                                    <ha-yaml-editor .hass=${this.hass} label="Service Data (optional, YAML)"
                                      .value=${tapAction.data || null}
                                      @value-changed=${(ev) => { ev.stopPropagation(); const d = ev.detail?.value; const upd = { ...tapAction }; if (d && typeof d === 'object' && Object.keys(d).length) upd.data = d; else delete upd.data; setEntry({ tap_action: upd }); }}
                                      @click=${(e) => e.stopPropagation()} style="margin-top:6px;"></ha-yaml-editor>
                                  ` : ''}
                                ` : ''}
                                ${currentAction === 'fire-dom-event' ? html`
                                  <ha-textfield label="Event Name (optional)" .value=${tapAction.event_name||""}
                                    @input=${(ev) => setTapAction({ event_name: ev.target.value || "" })} style="margin-top:6px;"></ha-textfield>
                                  <ha-code-editor .hass=${this.hass} mode="yaml" .value=${tapAction.event_data||""}
                                    @value-changed=${(ev) => { ev.stopPropagation(); setTapAction({ event_data: ev.detail?.value || "" }); }}
                                    @click=${(e) => e.stopPropagation()} style="margin-top:6px;"></ha-code-editor>
                                ` : ''}
                              ` : ''}
                            </div>`;
                            })}
                          `;
                        })()
                        }
                      </div>
                    </div>

                    ${!isCustomPopup ? html`
                      ${hasChildren ? html`
                        <div class="sub-accordion">
                          ${renderHeader("Default View (Groups)", "popup_default_view")}
                          <div class="sub-accordion-content ${this._closedDetails['popup_default_view'] ? 'hidden' : ''}">
                            <p style="font-size: 10px; opacity: 0.6; margin: 0 0 8px 0; font-style: italic;">Choose which view${isLightGroup ? ' and section' : ''} to show when opening the popup.</p>
                            <div class="side-by-side">
                              <ha-select label="Default View" .value=${this._config.popup_default_view || 'main'}
                                @selected=${(ev) => this._dropdownChanged(ev, "popup_default_view")}
                                @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                                ${popupDefaultViewOptions.map((o) => html`<mwc-list-item value="${o.value}">${o.value === "individual" ? `Individual ${entityTypeName}` : o.label}</mwc-list-item>`)}
                              </ha-select>
                              ${isLightGroup ? html`
                                <ha-select label="Default Section" .value=${this._config.popup_default_section || 'last'}
                                  @selected=${(ev) => this._dropdownChanged(ev, "popup_default_section")}
                                  @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                                  ${popupDefaultSectionOptionsTagged.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                                </ha-select>
                              ` : html`<div></div>`}
                            </div>
                          </div>
                        </div>
                      ` : ''}

                      ${hasDomainFeatures ? html`
                        <div class="sub-accordion">
                          ${renderHeader("Features", "popup_features")}
                          <div class="sub-accordion-content ${this._closedDetails['popup_features'] ? 'hidden' : ''}">
                            <div class="checkbox-grid">
                              ${showLightOptions ? html`
                                <ha-formfield .label=${"Show Favorites"}><ha-switch .checked=${this._config.popup_show_favorites !== false} @change=${(ev) => this._switchChanged(ev, "popup_show_favorites")}></ha-switch></ha-formfield>
                                <ha-formfield .label=${"Show Effects"}><ha-switch .checked=${this._config.popup_show_effects !== false} @change=${(ev) => this._switchChanged(ev, "popup_show_effects")}></ha-switch></ha-formfield>
                              ` : ''}
                              ${showClimateOptions ? html`
                                <ha-formfield .label=${"Show Presets"}><ha-switch .checked=${this._config.popup_show_presets !== false} @change=${(ev) => this._switchChanged(ev, "popup_show_presets")}></ha-switch></ha-formfield>
                              ` : ''}
                              ${showCoverOptions ? html`
                                <ha-formfield .label=${"Show Favorites"}><ha-switch .checked=${this._config.popup_show_favorites !== false} @change=${(ev) => this._switchChanged(ev, "popup_show_favorites")}></ha-switch></ha-formfield>
                              ` : ''}
                              <ha-formfield .label=${"Hide Bottom Bar"}><ha-switch .checked=${this._config.popup_hide_bottom_bar === true} @change=${(ev) => this._switchChanged(ev, "popup_hide_bottom_bar")}></ha-switch></ha-formfield>
                              <ha-formfield .label=${"Hide Top Bar"}><ha-switch .checked=${this._config.popup_hide_top_bar === true} @change=${(ev) => this._switchChanged(ev, "popup_hide_top_bar")}></ha-switch></ha-formfield>
                              ${this._config.popup_hide_top_bar === true ? html`
                                <ha-formfield .label=${"Show Close Button"}><ha-switch .checked=${this._config.popup_show_close_button !== false} @change=${(ev) => this._switchChanged(ev, "popup_show_close_button")}></ha-switch></ha-formfield>
                              ` : ''}
                              <ha-formfield .label=${"Close Popup After Action"}><ha-switch .checked=${this._config.popup_close_on_action === true} @change=${(ev) => this._switchChanged(ev, "popup_close_on_action")}></ha-switch></ha-formfield>
                            </div>
                          </div>
                        </div>
                      ` : ''}

                      <div class="sub-accordion">
                        ${renderHeader("Content Display", "popup_content")}
                        <div class="sub-accordion-content ${this._closedDetails['popup_content'] ? 'hidden' : ''}">
                          <ha-textfield label="Slider Border Radius (px)" type="number" .value=${this._config.popup_slider_radius ?? 12} @input=${(ev) => this._textChanged(ev, "popup_slider_radius")}></ha-textfield>
                          <ha-formfield .label=${"Hide Text Under Buttons"}><ha-switch .checked=${this._config.popup_hide_button_text === true} @change=${(ev) => this._switchChanged(ev, "popup_hide_button_text")}></ha-switch></ha-formfield>
                          <p style="font-size: 11px; opacity: 0.7; margin: 8px 0 4px 0;">Value Display (Temperature/Brightness)</p>
                          <div class="side-by-side">
                            <ha-textfield label="Font Size (px)" type="number" .value=${this._config.popup_value_font_size ?? 36} @input=${(ev) => this._textChanged(ev, "popup_value_font_size")}></ha-textfield>
                            <ha-textfield label="Font Weight" type="number" .value=${this._config.popup_value_font_weight ?? 300} @input=${(ev) => this._textChanged(ev, "popup_value_font_weight")}></ha-textfield>
                          </div>
                          <p style="font-size: 11px; opacity: 0.7; margin: 8px 0 4px 0;">Label Display (Color/Mode Names)</p>
                          <div class="side-by-side">
                            <ha-textfield label="Font Size (px)" type="number" .value=${this._config.popup_label_font_size ?? 16} @input=${(ev) => this._textChanged(ev, "popup_label_font_size")}></ha-textfield>
                            <ha-textfield label="Font Weight" type="number" .value=${this._config.popup_label_font_weight ?? 400} @input=${(ev) => this._textChanged(ev, "popup_label_font_weight")}></ha-textfield>
                          </div>
                          <p style="font-size: 11px; opacity: 0.7; margin: 8px 0 4px 0;">History/Logbook Time Format</p>
                          <ha-select label="Time Format" .value=${this._config.popup_time_format || 'auto'}
                            @selected=${(ev) => this._dropdownChanged(ev, "popup_time_format")}
                            @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                            ${HKI_POPUP_EDITOR_OPTIONS.timeFormats.map((o) => html`<mwc-list-item value="${o.value}">${o.label}</mwc-list-item>`)}
                          </ha-select>
                        </div>
                      </div>

                      <div class="sub-accordion">
                        ${renderHeader("Active Button Styling", "popup_highlight")}
                        <div class="sub-accordion-content ${this._closedDetails['popup_highlight'] ? 'hidden' : ''}">
                          <p style="font-size: 11px; opacity: 0.7; margin: 0 0 6px 0;">Customize selected/highlighted buttons</p>
                          <div class="side-by-side">
                            <ha-textfield label="Color" .value=${this._config.popup_highlight_color || ""} @input=${(ev) => this._textChanged(ev, "popup_highlight_color")} placeholder="var(--primary-color)"></ha-textfield>
                            <ha-textfield label="Text Color" .value=${this._config.popup_highlight_text_color || ""} @input=${(ev) => this._textChanged(ev, "popup_highlight_text_color")} placeholder="white"></ha-textfield>
                          </div>
                          <div class="side-by-side">
                            <ha-textfield label="Border Radius (px)" type="number" .value=${this._config.popup_highlight_radius ?? ""} @input=${(ev) => this._textChanged(ev, "popup_highlight_radius")} placeholder="8"></ha-textfield>
                            <ha-textfield label="Opacity" type="number" step="0.1" min="0" max="1" .value=${this._config.popup_highlight_opacity ?? ""} @input=${(ev) => this._textChanged(ev, "popup_highlight_opacity")} placeholder="1"></ha-textfield>
                          </div>
                          <div class="side-by-side">
                            <ha-select label="Border Style" .value=${this._config.popup_highlight_border_style || "none"}
                              @selected=${(ev) => this._dropdownChanged(ev, "popup_highlight_border_style")}
                              @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                              ${borderStyleOptions.map((o) => html`<mwc-list-item .value=${o.value}>${o.label}</mwc-list-item>`)}
                            </ha-select>
                            <ha-textfield label="Border Width (px)" .value=${this._config.popup_highlight_border_width || ""} @input=${(ev) => this._textChanged(ev, "popup_highlight_border_width")} placeholder="0"></ha-textfield>
                          </div>
                          <ha-textfield label="Border Color" .value=${this._config.popup_highlight_border_color || ""} @input=${(ev) => this._textChanged(ev, "popup_highlight_border_color")}></ha-textfield>
                          <ha-textfield label="Box Shadow" .value=${this._config.popup_highlight_box_shadow || ""} @input=${(ev) => this._textChanged(ev, "popup_highlight_box_shadow")} placeholder="0 2px 8px rgba(0,0,0,0.2)"></ha-textfield>
                        </div>
                      </div>

                      <div class="sub-accordion">
                        ${renderHeader("Inactive Button Styling", "popup_buttons")}
                        <div class="sub-accordion-content ${this._closedDetails['popup_buttons'] ? 'hidden' : ''}">
                          <p style="font-size: 11px; opacity: 0.7; margin: 0 0 6px 0;">Customize unselected buttons</p>
                          <div class="side-by-side">
                            <ha-textfield label="Background" .value=${this._config.popup_button_bg || ""} @input=${(ev) => this._textChanged(ev, "popup_button_bg")} placeholder="transparent"></ha-textfield>
                            <ha-textfield label="Text Color" .value=${this._config.popup_button_text_color || ""} @input=${(ev) => this._textChanged(ev, "popup_button_text_color")} placeholder="inherit"></ha-textfield>
                          </div>
                          <div class="side-by-side">
                            <ha-textfield label="Border Radius (px)" type="number" .value=${this._config.popup_button_radius ?? ""} @input=${(ev) => this._textChanged(ev, "popup_button_radius")} placeholder="8"></ha-textfield>
                            <ha-textfield label="Opacity" type="number" step="0.1" min="0" max="1" .value=${this._config.popup_button_opacity ?? ""} @input=${(ev) => this._textChanged(ev, "popup_button_opacity")} placeholder="1"></ha-textfield>
                          </div>
                          <div class="side-by-side">
                            <ha-select label="Border Style" .value=${this._config.popup_button_border_style || "none"}
                              @selected=${(ev) => this._dropdownChanged(ev, "popup_button_border_style")}
                              @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                              ${borderStyleOptions.map((o) => html`<mwc-list-item .value=${o.value}>${o.label}</mwc-list-item>`)}
                            </ha-select>
                            <ha-textfield label="Border Width (px)" .value=${this._config.popup_button_border_width || ""} @input=${(ev) => this._textChanged(ev, "popup_button_border_width")} placeholder="0"></ha-textfield>
                          </div>
                          <ha-textfield label="Border Color" .value=${this._config.popup_button_border_color || ""} @input=${(ev) => this._textChanged(ev, "popup_button_border_color")}></ha-textfield>
                        </div>
                      </div>
                    ` : ''}
                  `;
                })()}
             </div>
          </div>

          <div class="accordion-group ">
            ${renderHeader("Actions", "actions")}
             <div class="accordion-content ${this._closedDetails['actions'] ? 'hidden' : ''}">
                ${this._config.show_tile_slider === true ? html`
                  <div style="padding: 12px; background: rgba(255,193,7,0.1); border-radius: 8px; margin: 8px 0;">
                    <strong style="color: var(--primary-text-color);">â„¹ï¸ Card Actions Disabled</strong>
                    <div style="font-size: 12px; color: var(--primary-text-color); opacity: 0.7; margin-top: 4px;">
                      When tile slider is enabled, card tap/hold/double-tap actions are disabled. Use icon actions below instead.
                    </div>
                  </div>
                ` : html`
                  <div class="sub-accordion">
                    ${renderHeader("Tap Action", "action_tap")}
                    <div class="sub-accordion-content ${this._closedDetails['action_tap'] ? 'hidden' : ''}">
                      ${renderActionDropdown("Tap Action", "tap_action")}
                    </div>
                  </div>
                  
                  <div class="sub-accordion">
                    ${renderHeader("Double Tap Action", "action_double_tap")}
                    <div class="sub-accordion-content ${this._closedDetails['action_double_tap'] ? 'hidden' : ''}">
                      ${renderActionDropdown("Double Tap Action", "double_tap_action")}
                    </div>
                  </div>
                  
                  <div class="sub-accordion">
                    ${renderHeader("Hold Action", "action_hold")}
                    <div class="sub-accordion-content ${this._closedDetails['action_hold'] ? 'hidden' : ''}">
                      ${renderActionDropdown("Hold Action", "hold_action")}
                    </div>
                  </div>
                `}
                
                <div class="sub-accordion">
                  ${renderHeader("Icon Tap Action", "action_icon_tap")}
                  <div class="sub-accordion-content ${this._closedDetails['action_icon_tap'] ? 'hidden' : ''}">
                    ${renderActionDropdown("Icon Tap Action", "icon_tap_action")}
                  </div>
                </div>
                
                <div class="sub-accordion">
                  ${renderHeader("Icon Hold Action", "action_icon_hold")}
                  <div class="sub-accordion-content ${this._closedDetails['action_icon_hold'] ? 'hidden' : ''}">
                    ${renderActionDropdown("Icon Hold Action", "icon_hold_action")}
                  </div>
                </div>
                
                <div class="sub-accordion">
                  ${renderHeader("Icon Double Tap Action", "action_icon_double_tap")}
                  <div class="sub-accordion-content ${this._closedDetails['action_icon_double_tap'] ? 'hidden' : ''}">
                    ${renderActionDropdown("Icon Double Tap Action", "icon_double_tap_action")}
                  </div>
                </div>
             </div>
          </div>

          <div class="accordion-group ">
            ${renderHeader("Offsets", "offsets")}
             <div class="accordion-content ${this._closedDetails['offsets'] ? 'hidden' : ''}">
                <p style="font-size: 11px; opacity: 0.7; margin-top: 0;">Adjust X/Y position in pixels.</p>
                <div class="side-by-side">
                    <ha-textfield label="Name X" type="number" .value=${this._getOffsetUiValue("name_offset_x")} @input=${(ev) => this._textChanged(ev, "name_offset_x")}></ha-textfield>
                    <ha-textfield label="Name Y" type="number" .value=${this._getOffsetUiValue("name_offset_y")} @input=${(ev) => this._textChanged(ev, "name_offset_y")}></ha-textfield>
                </div>
                <div class="side-by-side">
                    <ha-textfield label="State X" type="number" .value=${this._getOffsetUiValue("state_offset_x")} @input=${(ev) => this._textChanged(ev, "state_offset_x")}></ha-textfield>
                    <ha-textfield label="State Y" type="number" .value=${this._getOffsetUiValue("state_offset_y")} @input=${(ev) => this._textChanged(ev, "state_offset_y")}></ha-textfield>
                </div>
                ${((this._config.card_layout || 'square') === 'square' || isGoogleLayout) ? html`
                <div class="side-by-side">
                    <ha-textfield label="Label X" type="number" .value=${this._getOffsetUiValue("label_offset_x")} @input=${(ev) => this._textChanged(ev, "label_offset_x")}></ha-textfield>
                    <ha-textfield label="Label Y" type="number" .value=${this._getOffsetUiValue("label_offset_y")} @input=${(ev) => this._textChanged(ev, "label_offset_y")}></ha-textfield>
                </div>
                ` : ''} 

                <div class="side-by-side">
                    <ha-textfield label="Icon X" type="number" .value=${this._getOffsetUiValue("icon_offset_x")} @input=${(ev) => this._textChanged(ev, "icon_offset_x")}></ha-textfield>
                    <ha-textfield label="Icon Y" type="number" .value=${this._getOffsetUiValue("icon_offset_y")} @input=${(ev) => this._textChanged(ev, "icon_offset_y")}></ha-textfield>
                </div>
                ${!isGoogleLayout ? html`
                <div class="side-by-side">
                    <ha-textfield label="Icon Badge X" type="number" .value=${this._config.badge_offset_x || 0} @input=${(ev) => this._textChanged(ev, "badge_offset_x")}></ha-textfield>
                    <ha-textfield label="Icon Badge Y" type="number" .value=${this._config.badge_offset_y || 0} @input=${(ev) => this._textChanged(ev, "badge_offset_y")}></ha-textfield>
                </div>
                ` : ''}
                ${((this._config.card_layout || 'square') === 'square' || this._config.card_layout === 'hki_tile') ? html`
                <div class="side-by-side">
                    <ha-textfield label="Info X" type="number" .value=${this._getOffsetUiValue("brightness_offset_x")} @input=${(ev) => this._textChanged(ev, "brightness_offset_x")}></ha-textfield>
                    <ha-textfield label="Info Y" type="number" .value=${this._getOffsetUiValue("brightness_offset_y")} @input=${(ev) => this._textChanged(ev, "brightness_offset_y")}></ha-textfield>
                </div>
                ` : ''} 
                ${isClimate ? html`
                <div class="side-by-side">
                    <ha-textfield label="Temp Badge X" type="number" .value=${this._getOffsetUiValue("temp_badge_offset_x")} @input=${(ev) => this._textChanged(ev, "temp_badge_offset_x")}></ha-textfield>
                    <ha-textfield label="Temp Badge Y" type="number" .value=${this._getOffsetUiValue("temp_badge_offset_y")} @input=${(ev) => this._textChanged(ev, "temp_badge_offset_y")}></ha-textfield>
                </div>
                ` : ''}
             </div>
          </div>

        </div>
      `;
    }
    
    _toggleHeader(e, key) {
        // Check if the click target is an interactive element or inside one
        const target = e.target;
        const header = e.currentTarget;
        
        // Don't toggle if clicking on interactive elements like selectors, dropdowns, buttons, inputs
        const interactiveSelectors = [
            'ha-selector',
            'ha-select', 
            'mwc-list-item',
            'ha-textfield',
            'input',
            'button',
            'ha-switch',
            'ha-icon-button',
            'mwc-button',
            'ha-target-picker',
            'ha-entity-picker',
            'ha-service-picker',
            '.hki-editor-clear'
        ];
        
        // Check if target or any parent (up to header) matches interactive selectors
        let element = target;
        while (element && element !== header) {
            if (interactiveSelectors.some(selector => element.matches?.(selector))) {
                return; // Don't toggle
            }
            element = element.parentElement;
        }
        
        // Safe to toggle - click was on header itself or non-interactive child (like span/ha-icon)
        this._toggle(key);
    }

    _toggle(key) {
        this._closedDetails = { ...this._closedDetails, [key]: !this._closedDetails[key] };
    }
    
    // For HA Selectors (Entity, Icon)
    _selectorChanged(ev, field) { 
        ev.stopPropagation(); 
        const value = ev.detail.value;
        // If the user changes the main entity, prefer the entity's default icon.
        // Only keep a custom icon if the user explicitly set one (i.e. not the old default lightbulb fallback).
        if (field === 'entity') {
          const next = { ...this._config, [field]: value };
          if (!next.icon || next.icon === 'mdi:lightbulb') {
            next.icon = '';
          }
          this._fireChanged(next);
          return;
        }
        this._fireChanged({ ...this._config, [field]: value }); 
    }

    _toHaActionSelectorValue(actionConfig) {
      // Convert your lovelace-style config -> HA automation action list
      if (!actionConfig?.perform_action) return [];
    
      return [{
        service: actionConfig.perform_action,
        target: actionConfig.target,
        data: actionConfig.data,
      }];
    }
    
    _fromHaActionSelectorValue(ev, configKey) {
      ev.stopPropagation();
    
      const list = ev.detail?.value;
      const currentConfig = this._config[configKey] || {};
    
      // Ignore events without detail or value
      if (!ev.detail || ev.detail.value === undefined) {
        return;
      }
    
      // cleared
      if (!Array.isArray(list) || list.length === 0) {
        // Only fire if we actually had a value before
        if (currentConfig.perform_action) {
          this._fireChanged({ ...this._config, [configKey]: { action: "perform-action" } });
        }
        return;
      }
    
      const a = list[0] || {};
    
      // HA's action selector often uses `action:` for service calls
      const act = a.action || a.service || "";
      
      // Ignore incomplete actions (no service specified)
      if (!act) {
        return;
      }
    
      const updated = {
        action: "perform-action",
        perform_action: act,
      };
    
      if (a.target && Object.keys(a.target).length) updated.target = a.target;
      if (a.data && Object.keys(a.data).length) updated.data = a.data;
    
      // Only fire change if the value actually changed
      const hasChanged = 
        currentConfig.perform_action !== updated.perform_action ||
        JSON.stringify(currentConfig.target || {}) !== JSON.stringify(updated.target || {}) ||
        JSON.stringify(currentConfig.data || {}) !== JSON.stringify(updated.data || {});
      
      if (hasChanged) {
        this._fireChanged({ ...this._config, [configKey]: updated });
      }
    }

    
    // For Dropdowns (ha-select)
    _dropdownChanged(ev, field) {
        ev.stopPropagation();
        const value = ev.target.value;
        this._fireChanged({ ...this._config, [field]: value });
    }

    // For Action Dropdowns - merges 'action' string back into an object

    _actionChanged(ev, field) {
        ev.stopPropagation();
        const actionValue = ev.target.value;

        // IMPORTANT:
        // Keep `{ action: "none" }` in the config instead of deleting the field.
        // Otherwise the card falls back to its default action (e.g. HKI more-info),
        // which makes "None" still do something.
        if (actionValue === "none") {
          this._fireChanged({ ...this._config, [field]: { action: "none" } });
          return;
        }

        // Clean slate: only keep the new action type, remove old properties
        // This prevents navigation_path staying when switching from navigate to url, etc.
        const newActionConfig = { action: actionValue };
        this._fireChanged({ ...this._config, [field]: newActionConfig });
    }

    _actionFieldChanged(ev, actionKey, fieldName, isJSON = false) {
      ev.stopPropagation();
    
      let value = ev.detail?.value ?? ev.target?.value;  // âœ… supports ha-selector + text/select
    
      if (isJSON && value) {
        try { value = JSON.parse(value); } catch (e) { return; }
      }
    
      const currentActionConfig = this._config[actionKey] || {};
      const newActionConfig = { ...currentActionConfig, [fieldName]: value };
      this._fireChanged({ ...this._config, [actionKey]: newActionConfig });
    }


    _actionFieldYamlChanged(ev, actionKey, fieldName) {
        ev.stopPropagation();
        const value = ev.detail.value;
        const currentActionConfig = this._config[actionKey] || {};
        const newActionConfig = { ...currentActionConfig, [fieldName]: value };
        this._fireChanged({ ...this._config, [actionKey]: newActionConfig });
    }

    _actionFieldSelectorChanged(ev, actionKey, fieldName) {
      ev.stopPropagation();
      const value = ev.detail?.value;
    
      const currentActionConfig = this._config[actionKey] || {};
      const newActionConfig = { ...currentActionConfig };
    
      // Only special-case "target"
      if (fieldName === "target") {
        const t = value || {};
    
        const isEmptyVal = (v) => {
          if (v === undefined || v === null) return true;
          if (Array.isArray(v)) return v.length === 0;
          if (typeof v === "string") return v.trim() === "";
          return false;
        };
    
        const empty =
          isEmptyVal(t.entity_id) &&
          isEmptyVal(t.device_id) &&
          isEmptyVal(t.area_id) &&
          isEmptyVal(t.floor_id) &&
          isEmptyVal(t.label_id);
    
        if (empty) {
          delete newActionConfig.target;   // âœ… THIS is what makes â€œlast oneâ€ removable
        } else {
          newActionConfig.target = t;
        }
      } else {
        newActionConfig[fieldName] = value;
      }
    
      this._fireChanged({ ...this._config, [actionKey]: newActionConfig });
    }

    // For Textfields (ha-textfield)
    _textChanged(ev, field) { 
        ev.stopPropagation(); 
        let value = ev.target.value; 
        const isOffset = HkiButtonCardEditor.OFFSET_DEFAULTS[field] !== undefined ||
                         HkiButtonCardEditor.TILE_OFFSET_DEFAULTS[field] !== undefined ||
                         HkiButtonCardEditor.GOOGLE_OFFSET_DEFAULTS[field] !== undefined;
        if (ev.target.type === "number") {
          const parsed = parseFloat(value);
          if (isNaN(parsed)) {
            // Empty number field: reset offset to baseline (0 in UI = default), or delete non-offset key
            if (isOffset) {
              value = this._applyOffsetUiValue(field, 0);
            } else {
              const next = { ...this._config };
              delete next[field];
              this._fireChanged(next);
              return;
            }
          } else {
            value = parsed;
            if (isOffset) value = this._applyOffsetUiValue(field, value);
          }
        } else {
          // Text field: empty string â†’ remove key
          if (value === '' && !isOffset) {
            const next = { ...this._config };
            delete next[field];
            this._fireChanged(next);
            return;
          }
          if (isOffset) value = this._applyOffsetUiValue(field, value);
        }
        this._fireChanged({ ...this._config, [field]: value }); 
    }

    // For Switches (ha-switch)
    _getLovelace() {
      // HA sets this.lovelace on the editor element. Fall back to DOM lookup if not set.
      if (this.lovelace) return this.lovelace;
      try {
        const root = document.querySelector('home-assistant')?.shadowRoot
          ?.querySelector('ha-panel-lovelace')?.shadowRoot
          ?.querySelector('hui-root');
        const huiRoot = root || document.querySelector('hui-root');
        const lv = huiRoot?.lovelace || huiRoot?.__lovelace || huiRoot?._lovelace;
        if (lv) return lv;
        // Borrow lovelace from any already-rendered hui-card-element-editor on the page
        const existingEditor = document.querySelector('hui-card-element-editor');
        if (existingEditor?.lovelace) return existingEditor.lovelace;
        return null;
      } catch (_) { return null; }
    }

    _ensureCardEditorLoaded() {
      // Proactively load the built-in Lovelace card editor. HA lazy-loads this,
      // which can cause the card picker to be missing unless it was opened elsewhere first.
      //
      // APPROACH: Call getConfigElement() on already-registered HA cards. This is the
      // same trick used by simple-swipe-card and triggers HA's own lazy-loader to
      // register hui-card-picker and hui-card-element-editor as a side effect.
      // This is far more reliable than trying to import() hardcoded/hashed JS paths.
      if (customElements.get('hui-card-element-editor') || customElements.get('hui-card-picker')) return;

      if (this._waitingForCardEditor) return;
      this._waitingForCardEditor = true;

      const triggers = [
        () => customElements.get('hui-entities-card')?.getConfigElement?.(),
        () => customElements.get('hui-conditional-card')?.getConfigElement?.(),
        () => customElements.get('hui-vertical-stack-card')?.getConfigElement?.(),
        () => customElements.get('hui-horizontal-stack-card')?.getConfigElement?.(),
        () => customElements.get('hui-glance-card')?.getConfigElement?.(),
        () => customElements.get('hui-picture-elements-card')?.getConfigElement?.(),
        () => customElements.get('hui-button-card')?.getConfigElement?.(),
      ];

      const tryTriggers = async () => {
        for (const trigger of triggers) {
          try {
            await trigger();
            if (customElements.get('hui-card-element-editor') || customElements.get('hui-card-picker')) break;
          } catch (_) {}
        }
        // Regardless of whether any trigger succeeded, wait for the element to be defined.
        Promise.race([
          customElements.whenDefined('hui-card-element-editor'),
          customElements.whenDefined('hui-card-picker'),
          new Promise((res) => setTimeout(res, 3000)),
        ]).then(() => {
          this._waitingForCardEditor = false;
          this.requestUpdate();
        });
      };

      tryTriggers();
    }

    _switchChanged(ev, field) { 
        ev.stopPropagation(); 
        this._fireChanged({ ...this._config, [field]: ev.target.checked }); 
    }
    

    // Reset all optional settings back to internal defaults (keeps entity + layout)
    _resetToDefaults(ev) {
        if (ev) {
          ev.stopPropagation();
          ev.preventDefault?.();
        }
        // Reset only layout geometry controls (sizes + offsets) back to internal defaults.
        // We deliberately keep content/visibility/styling keys (name/state/label/icon settings etc.).
        const next = { ...this._config };
        const keysToClear = [
          "size_icon",
          "size_name",
          "size_state",
          "size_label",
          "size_brightness",
          "temp_badge_size",
          "name_offset_x",
          "name_offset_y",
          "state_offset_x",
          "state_offset_y",
          "label_offset_x",
          "label_offset_y",
          "icon_offset_x",
          "icon_offset_y",
          "brightness_offset_x",
          "brightness_offset_y",
          "temp_badge_offset_x",
          "temp_badge_offset_y",
          "icon_circle_offset_x",
          "icon_circle_offset_y",
          "icon_badge_offset_x",
          "icon_badge_offset_y"
        ];
        for (const k of keysToClear) {
          if (k in next) delete next[k];
        }
        // Keep mandatory fields
        next.type = next.type || "custom:hki-button-card";
        this._fireChanged(next);
    }

    _fireChanged(newConfig) {
        // Clean up empty values that shouldn't be in YAML
        const cleaned = { ...newConfig };
        
        // Remove empty icon
        if (cleaned.icon === '') {
          delete cleaned.icon;
        }
        
        // Remove any empty-string optional fields (but keep 'entity' which may be intentionally blank)
        const KEEP_EMPTY = new Set(['entity', 'type']);
        for (const [k, v] of Object.entries(cleaned)) {
          if (typeof v === 'string' && v === '' && !KEEP_EMPTY.has(k)) {
            delete cleaned[k];
          }
        }
        
        // Remove empty or default icon_double_tap_action
        if (cleaned.icon_double_tap_action && 
            (!cleaned.icon_double_tap_action.action || cleaned.icon_double_tap_action.action === 'none')) {
          delete cleaned.icon_double_tap_action;
        }

        // Convert flat internal format â†’ nested YAML format for user-facing output
        const output = HkiButtonCard._serializeToNested(cleaned);
        
        this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: output }, bubbles: true, composed: true }));
    }
    
    static get styles() { 
        return css`
            .card-config { 
                display: flex; 
                flex-direction: column; 
                gap: 12px; 
                padding: 8px; 
            }
            
            /* ALLOW OVERFLOW FOR DROPDOWNS */
            .accordion-group { 
                background: var(--secondary-background-color);
                border-radius: 4px;
                margin-bottom: 8px;
                overflow: visible;
                border: 1px solid var(--divider-color);
            }
            
            .accordion-header { 
                padding: 12px;
                cursor: pointer;
                font-weight: 600;
                background: var(--primary-background-color);
                border-bottom: 1px solid var(--divider-color);
                display: flex;
                align-items: center;
                justify-content: space-between;
            }

            .accordion-header ha-icon {
                font-weight: bold;
                font-size: 1.2em;
            }
            
            .accordion-content { 
                padding: 12px;
                display: flex;
                flex-direction: column;
                gap: 12px;
                overflow: visible; 
            }
            
            .accordion-content.hidden { display: none; }
            .accordion-group.hidden { display: none; }
            
            .sub-accordion {
                background: var(--secondary-background-color);
                border-radius: 4px;
                margin-bottom: 8px;
                overflow: visible;
                border: 1px solid var(--divider-color);
            }
            
            .sub-accordion .accordion-header {
                padding: 12px;
                font-size: 14px;
                font-weight: 600;
                background: var(--primary-background-color);
                border-bottom: 1px solid var(--divider-color);
            }
            
            .sub-accordion-content {
                padding: 12px;
                display: flex;
                flex-direction: column;
                gap: 12px;
                overflow: visible;
            }
            
            .sub-accordion-content.hidden { display: none; }
            
            .side-by-side { 
                display: grid; 
                grid-template-columns: 1fr 1fr; 
                gap: 12px; 
                margin-bottom: 8px; 
            }

            /* Text override template helpers */
            .tpl-field {
                margin-top: 10px;
            }
            .tpl-title {
                font-weight: 600;
                margin-bottom: 4px;
            }
            .tpl-desc {
                font-size: 11px;
                opacity: 0.7;
                margin-bottom: 6px;
            }
            ha-code-editor {
                width: 100%;
            }
            
            .sub-section { 
                border: 1px solid var(--divider-color); 
                padding: 10px; 
                border-radius: 6px; 
                margin-bottom: 8px; 
            }
            
            .separator { 
                height: 1px; 
                background: var(--divider-color); 
                margin: 12px 0; 
            }
            
            .action-config-section {
                display: flex;
                flex-direction: column;
                gap: 8px;
            }
            
            .action-config-section strong {
                font-size: 13px;
                opacity: 0.7;
                margin-bottom: 4px;
            }
            
            .perform-action-config {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }
            
            .perform-action-config ha-selector,
            .perform-action-config ha-textfield,
            .perform-action-config ha-yaml-editor {
                width: 100%;
            }
            
            
            .hki-editor-clear{
                width: 40px;
                height: 40px;
                border-radius: 50%;
                border: 1px solid var(--divider-color);
                background: var(--card-background-color);
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                padding: 0;
            }
            .hki-editor-clear ha-icon{
                --mdc-icon-size: 20px;
            }
            .hki-editor-clear:hover{
                background: var(--secondary-background-color);
            }
            .checkbox-grid { 
                display: grid; 
                grid-template-columns: 1fr 1fr; 
                gap: 8px; 
            }
            
            .grid-layout-editor {
                display: flex;
                flex-direction: column;
                gap: 16px;
                margin: 12px 0;
            }
            
            .element-palette {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }
            
            .palette-element {
                flex: 1;
                min-width: 80px;
                padding: 8px 12px;
                background: var(--card-background-color);
                border: 2px solid var(--divider-color);
                border-radius: 6px;
                cursor: pointer;
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 4px;
                position: relative;
                transition: all 0.2s;
            }
            
            .palette-element:hover {
                border-color: var(--primary-color);
                transform: translateY(-2px);
            }
            
            .palette-element.selected {
                border-color: var(--primary-color);
                background: var(--primary-color);
                color: white;
            }
            
            .palette-element ha-icon {
                --mdc-icon-size: 20px;
            }
            
            .palette-element span {
                font-size: 11px;
                font-weight: 500;
            }
            
            .element-count {
                position: absolute;
                top: 4px;
                right: 4px;
                background: var(--primary-color);
                color: white;
                border-radius: 50%;
                width: 18px;
                height: 18px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 10px;
                font-weight: bold;
            }
            
            .palette-element.selected .element-count {
                background: white;
                color: var(--primary-color);
            }
            
            .layout-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
                padding: 12px;
                background: var(--secondary-background-color);
                border-radius: 8px;
                border: 2px solid var(--divider-color);
            }
            
            .grid-cell {
                aspect-ratio: 1;
                background: var(--card-background-color);
                border: 2px dashed var(--divider-color);
                border-radius: 6px;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                gap: 4px;
                cursor: pointer;
                transition: all 0.2s;
                min-height: 60px;
            }
            
            .grid-cell:hover {
                border-color: var(--primary-color);
                transform: scale(1.05);
            }
            
            .grid-cell.filled {
                border-style: solid;
                background: var(--primary-color);
                color: white;
            }
            
            .grid-cell.filled ha-icon {
                --mdc-icon-size: 24px;
            }
            
            .grid-cell.filled span {
                font-size: 10px;
                font-weight: 500;
            }
            
            .grid-cell.selectable {
                animation: pulse 1s infinite;
            }
            
            @keyframes pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.6; }
            }
            
            .grid-cell .empty-indicator {
                font-size: 24px;
                opacity: 0.3;
                font-weight: 300;
            }
            
            .reset-order-btn {
                width: 100%;
                padding: 10px;
                background: var(--secondary-background-color);
                border: 1px solid var(--divider-color);
                border-radius: 6px;
                cursor: pointer;
                font-weight: 500;
                margin-top: 8px;
            }
            
            .reset-order-btn:hover {
                background: var(--primary-color);
                color: white;
            }
            
            ha-textfield, ha-selector, ha-select, ha-yaml-editor { 
                width: 100%; 
                display: block; 
                margin-bottom: 8px; 
            }
            ha-formfield { 
                display: flex; 
                align-items: center; 
                height: 40px; 
            }
        
            .layout-actions{
                margin-top: 8px;
                display: flex;
                justify-content: flex-end;
            }
            
            .hki-reset-btn{
                display: inline-flex;
                align-items: center;
                gap: 8px;
                padding: 8px 12px;
                border-radius: 8px;
                border: 1px solid var(--primary-color);
                background: var(--primary-color);
                color: var(--text-primary-color, #fff);
                cursor: pointer;
                font-size: 13px;
                font-weight: 600;
                line-height: 1;
                transition: background 120ms ease, border-color 120ms ease, transform 60ms ease;
            }
            .hki-reset-btn:hover{
                background: rgba(255,255,255,0.14);
                border-color: rgba(255,255,255,0.35);
            }
            .hki-reset-btn:active{
                transform: translateY(1px);
                background: rgba(255,255,255,0.18);
            }
            .hki-reset-btn ha-icon{
                width: 18px;
                height: 18px;
            }
            mwc-button.reset-defaults{
                --mdc-theme-primary: var(--primary-color);
            }
        `; 
    }
  }

  // Guard against double-registration (can happen on reloads / caching)
  if (!customElements.get(CARD_TYPE)) {
    customElements.define(CARD_TYPE, HkiButtonCard);
  }
  if (!customElements.get(EDITOR_TAG)) {
    customElements.define(EDITOR_TAG, HkiButtonCardEditor);
  }
  
  window.customCards = window.customCards || [];
  window.customCards.push({ 
    type: CARD_TYPE, 
    name: "HKI Button Card", 
    description: "Customizable buttons with built-in popups.", 
    preview: true 
  });
})();

})();

// ============================================================
// hki-navigation-card
// ============================================================

(() => {
// HKI Navigation Card

const { LitElement, html, css } = window.HKI.getLit();
const CARD_TYPE = "hki-navigation-card";
const VERSION = "1.2.1"; // Fixed: Real-time template updates + unresponsive buttons after idle/navigation

const CARD_TAG = "hki-navigation-card";
const EDITOR_TAG = "hki-navigation-card-editor";

const INHERIT = "__inherit__";
const MIN_PILL_WIDTH = 85;
const applyGlobalDefaultsToConfig = window.HKI?.applyGlobalDefaultsToConfig || (({ config }) => config);
const getGlobalDefaultsFor = window.HKI?.getGlobalDefaultsFor || (() => ({}));
const isUnsetValue = window.HKI?.isUnsetValue || ((v) => v === undefined || v === null || (typeof v === "string" && v.trim() === ""));

// Static Constants
const BUTTON_TYPES = [
  { value: "icon", label: "Icon Only" },
  { value: "icon_label_below", label: "Icon + Label Below" },
  { value: "icon_label_left", label: "Icon + Label Left" },
  { value: "icon_label_right", label: "Icon + Label Right" },
  { value: "pill", label: "Pill Button (Icon + Label)" },
  { value: "pill_label", label: "Pill Button (Label Only)" },
];

const FONT_WEIGHTS = [
  { value: 300, label: "Light (300)" },
  { value: 400, label: "Regular (400)" },
  { value: 500, label: "Medium (500)" },
  { value: 600, label: "Semibold (600)" },
  { value: 700, label: "Bold (700)" },
  { value: 800, label: "Extra Bold (800)" },
];

const ACTIONS = [
  { value: "navigate", label: "Navigate" },
  { value: "url", label: "Open URL" },
  { value: "toggle", label: "Toggle entity" },
  { value: "more-info", label: "More info" },
  { value: "perform-action", label: "Perform action" },
  { value: "fire-dom-event", label: "Fire DOM Event" },
  { value: "back", label: "Back" },
  { value: "toggle-group", label: "Show/Hide Group" },
  { value: "none", label: "None" },
];

const GROUP_ACTIONS = [
  { value: "toggle", label: "Toggle" },
  { value: "show", label: "Show" },
  { value: "hide", label: "Hide" },
];

const GROUP_TARGETS = [
  { value: "horizontal", label: "Horizontal group" },
  { value: "vertical", label: "Vertical group" },
  { value: "both", label: "Both groups" },
];

const CONDITION_TYPES = [
  { value: "entity", label: "Entity state" },
  { value: "user", label: "User" },
  { value: "view", label: "View" },
  { value: "screen", label: "Screen size" },
];

const ENTITY_OPERATORS = [
  { value: "equals", label: "Equals" },
  { value: "not_equals", label: "Not equals" },
  { value: "above", label: "Above (numeric)" },
  { value: "below", label: "Below (numeric)" },
  { value: "includes", label: "Includes" },
  { value: "not_includes", label: "Not includes" },
  { value: "exists", label: "Entity exists" },
  { value: "not_exists", label: "Entity does not exist" },
];

const DEFAULT_LABEL_STYLE = {
  font_size: 12,
  font_weight: 600,
  letter_spacing: 0,
  text_transform: "none",
  color: "",
  background: "",
  background_opacity: 0.72,
  padding_x: 10,
  padding_y: 6,
  border_radius: 999,
  backdrop_blur: 8,
  max_width: 220,
};

// Utilities
const debounce = (func, wait) => {
  let timeout;
  return function (...args) {
    const later = () => {
      clearTimeout(timeout);
      func.apply(this, args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
};


// Action conflict mapping - when one action is set, these should be removed
const ACTION_CONFLICTS = {
  navigate: ['url', 'url_path', 'entity', 'service', 'data', 'target', 'mode', 'perform_action', 'new_tab'],
  url: ['navigation_path', 'entity', 'service', 'data', 'target', 'mode', 'perform_action'],
  toggle: ['navigation_path', 'url', 'url_path', 'service', 'data', 'target', 'mode', 'perform_action'],
  'more-info': ['navigation_path', 'url', 'url_path', 'service', 'data', 'target', 'mode', 'perform_action'],
  'perform-action': ['navigation_path', 'url', 'url_path', 'entity', 'mode', 'target'],
  'toggle-group': ['navigation_path', 'url', 'url_path', 'entity', 'service', 'data', 'perform_action'],
  'fire-dom-event': ['navigation_path', 'url', 'url_path', 'entity', 'service', 'data', 'target', 'mode', 'perform_action'],
  back: ['navigation_path', 'url', 'url_path', 'entity', 'service', 'data', 'target', 'mode', 'perform_action'],
  none: ['navigation_path', 'url', 'url_path', 'entity', 'service', 'data', 'target', 'mode', 'perform_action'],
};

// Helper to cleanup conflicting action properties
function cleanupActionConflicts(actionObj) {
  if (!actionObj || !actionObj.action) return actionObj;
  
  const conflicts = ACTION_CONFLICTS[actionObj.action];
  if (!conflicts) return actionObj;
  
  const cleaned = { ...actionObj };
  conflicts.forEach(key => {
    if (key in cleaned) {
      delete cleaned[key];
    }
  });
  
  return cleaned;
}

// Helper to remove default values from config (for minimal YAML)
function removeDefaults(obj, defaults) {
  if (!obj || !defaults) return obj;
  
  // Critical properties that should always be preserved for config structure and Home Assistant compatibility
  const criticalProps = ['type', 'base', 'horizontal', 'vertical', 'grid_options', 'visibility'];
  
  const cleaned = {};
  for (const key in obj) {
    const value = obj[key];
    const defaultValue = defaults[key];
    
    // Always preserve critical structural properties
    if (criticalProps.includes(key)) {
      cleaned[key] = value;
      continue;
    }
    
    // Skip if value matches default exactly
    if (JSON.stringify(value) === JSON.stringify(defaultValue)) {
      continue;
    }
    
    // Recursively clean nested objects
    if (value && typeof value === 'object' && !Array.isArray(value) && 
        defaultValue && typeof defaultValue === 'object' && !Array.isArray(defaultValue)) {
      const cleanedNested = removeDefaults(value, defaultValue);
      if (Object.keys(cleanedNested).length > 0) {
        cleaned[key] = cleanedNested;
      }
    } else {
      cleaned[key] = value;
    }
  }
  
  return cleaned;
}

// Helper to migrate old flat config to new nested structure
function migrateConfig(config) {
  if (!config) return config;
  
  const migrated = { ...config };
  let needsMigration = false;
  
  // Check if old flat structure exists
  const oldBottomBarKeys = ['bottom_bar_enabled', 'bottom_bar_full_width', 'bottom_bar_height', 
    'bottom_bar_color', 'bottom_bar_opacity', 'bottom_bar_border_radius', 'bottom_bar_bottom_offset',
    'bottom_bar_box_shadow', 'bottom_bar_margin_left', 'bottom_bar_margin_right', 
    'bottom_bar_border_width', 'bottom_bar_border_style', 'bottom_bar_border_color'];
  
  const hasOldBottomBar = oldBottomBarKeys.some(key => migrated[key] !== undefined);
  
  // Migrate bottom bar to nested structure
  if (hasOldBottomBar && !migrated.bottom_bar_settings) {
    needsMigration = true;
    migrated.bottom_bar_settings = {};
    
    if (migrated.bottom_bar_enabled !== undefined) {
      migrated.bottom_bar_settings.enabled = migrated.bottom_bar_enabled;
      delete migrated.bottom_bar_enabled;
    }
    if (migrated.bottom_bar_full_width !== undefined) {
      migrated.bottom_bar_settings.full_width = migrated.bottom_bar_full_width;
      delete migrated.bottom_bar_full_width;
    }
    if (migrated.bottom_bar_height !== undefined) {
      migrated.bottom_bar_settings.height = migrated.bottom_bar_height;
      delete migrated.bottom_bar_height;
    }
    if (migrated.bottom_bar_bottom_offset !== undefined) {
      migrated.bottom_bar_settings.bottom_offset = migrated.bottom_bar_bottom_offset;
      delete migrated.bottom_bar_bottom_offset;
    }
    if (migrated.bottom_bar_margin_left !== undefined) {
      migrated.bottom_bar_settings.margin_left = migrated.bottom_bar_margin_left;
      delete migrated.bottom_bar_margin_left;
    }
    if (migrated.bottom_bar_margin_right !== undefined) {
      migrated.bottom_bar_settings.margin_right = migrated.bottom_bar_margin_right;
      delete migrated.bottom_bar_margin_right;
    }
    
    // Migrate bottom bar style properties
    if (!migrated.bottom_bar_settings.style) {
      migrated.bottom_bar_settings.style = {};
    }
    
    if (migrated.bottom_bar_color !== undefined) {
      migrated.bottom_bar_settings.style.background = migrated.bottom_bar_color;
      delete migrated.bottom_bar_color;
    }
    if (migrated.bottom_bar_opacity !== undefined) {
      migrated.bottom_bar_settings.style.opacity = migrated.bottom_bar_opacity;
      delete migrated.bottom_bar_opacity;
    }
    if (migrated.bottom_bar_border_radius !== undefined) {
      migrated.bottom_bar_settings.style.border_radius = migrated.bottom_bar_border_radius;
      delete migrated.bottom_bar_border_radius;
    }
    if (migrated.bottom_bar_box_shadow !== undefined) {
      migrated.bottom_bar_settings.style.box_shadow = migrated.bottom_bar_box_shadow;
      delete migrated.bottom_bar_box_shadow;
    }
    if (migrated.bottom_bar_border_width !== undefined) {
      migrated.bottom_bar_settings.style.border_width = migrated.bottom_bar_border_width;
      delete migrated.bottom_bar_border_width;
    }
    if (migrated.bottom_bar_border_style !== undefined) {
      migrated.bottom_bar_settings.style.border_style = migrated.bottom_bar_border_style;
      delete migrated.bottom_bar_border_style;
    }
    if (migrated.bottom_bar_border_color !== undefined) {
      migrated.bottom_bar_settings.style.border_color = migrated.bottom_bar_border_color;
      delete migrated.bottom_bar_border_color;
    }
  }
  
  // Migrate button default styles to nested structure
  const oldStyleKeys = ['default_background', 'default_button_opacity', 'default_icon_color',
    'default_border_radius', 'default_border_width', 'default_border_style', 'default_border_color',
    'button_box_shadow', 'button_box_shadow_hover'];
  
  const hasOldStyles = oldStyleKeys.some(key => migrated[key] !== undefined);
  
  if (hasOldStyles && !migrated.button_defaults) {
    needsMigration = true;
    migrated.button_defaults = { style: {} };
    
    if (migrated.default_background !== undefined) {
      migrated.button_defaults.style.background = migrated.default_background;
      delete migrated.default_background;
    }
    if (migrated.default_button_opacity !== undefined) {
      migrated.button_defaults.style.opacity = migrated.default_button_opacity;
      delete migrated.default_button_opacity;
    }
    if (migrated.default_icon_color !== undefined) {
      migrated.button_defaults.style.icon_color = migrated.default_icon_color;
      delete migrated.default_icon_color;
    }
    if (migrated.default_border_radius !== undefined) {
      migrated.button_defaults.style.border_radius = migrated.default_border_radius;
      delete migrated.default_border_radius;
    }
    if (migrated.default_border_width !== undefined) {
      migrated.button_defaults.style.border_width = migrated.default_border_width;
      delete migrated.default_border_width;
    }
    if (migrated.default_border_style !== undefined) {
      migrated.button_defaults.style.border_style = migrated.default_border_style;
      delete migrated.default_border_style;
    }
    if (migrated.default_border_color !== undefined) {
      migrated.button_defaults.style.border_color = migrated.default_border_color;
      delete migrated.default_border_color;
    }
    if (migrated.button_box_shadow !== undefined) {
      migrated.button_defaults.style.box_shadow = migrated.button_box_shadow;
      delete migrated.button_box_shadow;
    }
    if (migrated.button_box_shadow_hover !== undefined) {
      migrated.button_defaults.style.box_shadow_hover = migrated.button_box_shadow_hover;
      delete migrated.button_box_shadow_hover;
    }
  }
  
  // Migrate label_style if it exists at top level
  if (migrated.label_style && !migrated.button_defaults?.label) {
    needsMigration = true;
    if (!migrated.button_defaults) migrated.button_defaults = {};
    migrated.button_defaults.label = migrated.label_style;
    delete migrated.label_style;
  }
  
  return migrated;
}

// Helper to clean up and validate config
function cleanupAndValidateConfig(config) {
  if (!config) return config;
  
  const cleaned = deepClone(config);
  
  // Clean up button actions
  const cleanButtons = (buttons) => {
    if (!Array.isArray(buttons)) return buttons;
    return buttons.map(btn => {
      const cleanedBtn = { ...btn };
      
      // Clean up tap_action
      if (cleanedBtn.tap_action) {
        cleanedBtn.tap_action = cleanupActionConflicts(cleanedBtn.tap_action);
      }
      
      // Clean up hold_action
      if (cleanedBtn.hold_action) {
        cleanedBtn.hold_action = cleanupActionConflicts(cleanedBtn.hold_action);
      }
      
      // Clean up double_tap_action
      if (cleanedBtn.double_tap_action) {
        cleanedBtn.double_tap_action = cleanupActionConflicts(cleanedBtn.double_tap_action);
      }
      
      return cleanedBtn;
    });
  };
  
  // Clean base button
  if (cleaned.base?.button) {
    const btn = cleaned.base.button;
    if (btn.tap_action) btn.tap_action = cleanupActionConflicts(btn.tap_action);
    if (btn.hold_action) btn.hold_action = cleanupActionConflicts(btn.hold_action);
    if (btn.double_tap_action) btn.double_tap_action = cleanupActionConflicts(btn.double_tap_action);
  }
  
  // Clean horizontal buttons
  if (cleaned.horizontal?.buttons) {
    cleaned.horizontal.buttons = cleanButtons(cleaned.horizontal.buttons);
  }
  
  // Clean vertical buttons
  if (cleaned.vertical?.buttons) {
    cleaned.vertical.buttons = cleanButtons(cleaned.vertical.buttons);
  }
  
  return cleaned;
}


function _uid() {
  if (window.crypto?.randomUUID) return window.crypto.randomUUID();
  return `id_${Date.now()}_${(Math.random() * 1e9) >>> 0}`;
}

function safeString(v) {
  return (v === null || v === undefined) ? "" : String(v);
}

function deepClone(obj) {
  return obj ? JSON.parse(JSON.stringify(obj)) : obj;
}

// Simplified hash (djb2) + cache key for template result caching
function hashStr(s) {
  let h = 5381;
  for (let i = 0; i < s.length; i++) h = (h * 33) ^ s.charCodeAt(i);
  return (h >>> 0).toString(16);
}

function cacheKey(raw, vars) {
  return `hkiTpl:${hashStr(raw + (vars ? JSON.stringify(vars) : ""))}`;
}

function clampNum(v, fallback) {
  const n = Number(v);
  return Number.isFinite(n) ? n : fallback;
}

function clampInt(v, fallback, min = 0) {
  const n = Number(v);
  if (!Number.isFinite(n)) return fallback;
  return Math.max(min, Math.trunc(n));
}

function fireEvent(node, type, detail, options = {}) {
  node.dispatchEvent(
    new CustomEvent(type, {
      detail,
      bubbles: options.bubbles ?? true,
      composed: options.composed ?? true,
    })
  );
}

function _hasMeaningfulNumber(x) {
  if (x === undefined || x === null) return false;
  if (typeof x === "number") return Number.isFinite(x);
  if (typeof x === "string") {
    const t = x.trim();
    if (t === "") return false;
    const n = Number(t);
    return Number.isFinite(n);
  }
  return false;
}

function _toNumber(x) {
  if (typeof x === "number") return x;
  if (typeof x === "string") return Number(x.trim());
  return NaN;
}

function normalizeLabelStyle(style) {
  const s = style && typeof style === "object" ? style : {};
  return {
    font_size: clampNum(s.font_size, DEFAULT_LABEL_STYLE.font_size),
    font_weight: clampNum(s.font_weight, DEFAULT_LABEL_STYLE.font_weight),
    letter_spacing: clampNum(s.letter_spacing, DEFAULT_LABEL_STYLE.letter_spacing),
    text_transform: typeof s.text_transform === "string" ? s.text_transform : DEFAULT_LABEL_STYLE.text_transform,
    color: typeof s.color === "string" ? s.color : "",
    background: typeof s.background === "string" ? s.background : "",
    background_opacity: clampNum(s.background_opacity, DEFAULT_LABEL_STYLE.background_opacity),
    padding_x: clampNum(s.padding_x, DEFAULT_LABEL_STYLE.padding_x),
    padding_y: clampNum(s.padding_y, DEFAULT_LABEL_STYLE.padding_y),
    border_radius: clampNum(s.border_radius, DEFAULT_LABEL_STYLE.border_radius),
    backdrop_blur: clampNum(s.backdrop_blur, DEFAULT_LABEL_STYLE.backdrop_blur),
    max_width: clampNum(s.max_width, DEFAULT_LABEL_STYLE.max_width),
  };
}

function mergeLabelStyle(globalStyle, buttonStyle) {
  const g = normalizeLabelStyle(globalStyle);
  const b = buttonStyle && typeof buttonStyle === "object" ? buttonStyle : {};
  const pickStr = (key) => typeof b[key] === "string" && b[key].trim() !== "" ? b[key] : g[key];
  const pickNum = (key) => _hasMeaningfulNumber(b[key]) ? _toNumber(b[key]) : g[key];

  return {
    font_size: pickNum("font_size"),
    font_weight: pickNum("font_weight"),
    letter_spacing: pickNum("letter_spacing"),
    text_transform: pickStr("text_transform"),
    color: pickStr("color"),
    background: pickStr("background"),
    background_opacity: pickNum("background_opacity"),
    padding_x: pickNum("padding_x"),
    padding_y: pickNum("padding_y"),
    border_radius: pickNum("border_radius"),
    backdrop_blur: pickNum("backdrop_blur"),
    max_width: pickNum("max_width"),
  };
}

function normalizeButtonType(type, fallback) {
  if (BUTTON_TYPES.some((t) => t.value === type)) return type;
  return fallback;
}

/* -------------------- Minimal YAML parser -------------------- */
function _stripYamlComment(line) {
  let inS = false, inD = false;
  for (let i = 0; i < line.length; i++) {
    const ch = line[i];
    if (ch === "'" && !inD) inS = !inS;
    else if (ch === '"' && !inS) inD = !inD;
    else if (ch === "#" && !inS && !inD) return line.slice(0, i);
  }
  return line;
}

function _parseScalar(raw) {
  const s = raw.trim();
  if (s === "") return null;
  if ((s.startsWith("{") && s.endsWith("}")) || (s.startsWith("[") && s.endsWith("]"))) {
    try { return JSON.parse(s); } catch (_) {}
  }
  const lower = s.toLowerCase();
  if (lower === "null" || lower === "~") return null;
  if (lower === "true" || lower === "yes" || lower === "on") return true;
  if (lower === "false" || lower === "no" || lower === "off") return false;
  if (/^-?\d+(\.\d+)?$/.test(s)) {
    const n = Number(s);
    if (Number.isFinite(n)) return n;
  }
  if ((s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))) {
    return s.slice(1, -1);
  }
  return s;
}

function parseYamlLite(yamlStr) {
  const src = safeString(yamlStr);
  const lines = src.split("\n");
  const nextNonEmpty = new Array(lines.length).fill(-1);
  let next = -1;
  for (let i = lines.length - 1; i >= 0; i--) {
    const l = _stripYamlComment(lines[i]).trim();
    if (l !== "") next = i;
    nextNonEmpty[i] = next;
  }
  const root = {};
  const stack = [{ indent: -1, kind: "map", value: root }];
  const popToIndent = (indent) => {
    while (stack.length > 1 && stack[stack.length - 1].indent >= indent) stack.pop();
  };
  const ensureContainerForKey = (parent, key, kind) => {
    parent[key] = kind === "list" ? [] : {};
    return parent[key];
  };

  for (let i = 0; i < lines.length; i++) {
    let rawLine = _stripYamlComment(lines[i]);
    if (!rawLine.trim()) continue;
    const indent = rawLine.match(/^\s*/)[0].length;
    const line = rawLine.trim();
    popToIndent(indent);
    const top = stack[stack.length - 1];

    if (line.startsWith("-")) {
      if (top.kind !== "list") {
        if (stack.length === 1) stack[0] = { indent: -1, kind: "list", value: [] };
        else throw new Error("YAML: list item found where a mapping was expected.");
      }
      const list = stack[stack.length - 1].value;
      const itemRest = line.replace(/^-/, "").trim();
      if (itemRest === "") {
        const ni = nextNonEmpty[i];
        const nextLine = ni >= 0 ? _stripYamlComment(lines[ni]).trim() : "";
        const nextIndent = ni >= 0 ? _stripYamlComment(lines[ni]).match(/^\s*/)[0].length : -1;
        if (ni >= 0 && nextIndent > indent && nextLine.startsWith("-")) {
          const child = []; list.push(child); stack.push({ indent, kind: "list", value: child });
        } else if (ni >= 0 && nextIndent > indent) {
          const child = {}; list.push(child); stack.push({ indent, kind: "map", value: child });
        } else {
          list.push(null);
        }
        continue;
      }
      const colonIdx = itemRest.indexOf(":");
      if (colonIdx > -1) {
        const k = itemRest.slice(0, colonIdx).trim();
        const vRaw = itemRest.slice(colonIdx + 1).trim();
        if (vRaw === "") {
          const ni = nextNonEmpty[i];
          const nextLine = ni >= 0 ? _stripYamlComment(lines[ni]).trim() : "";
          const nextIndent = ni >= 0 ? _stripYamlComment(lines[ni]).match(/^\s*/)[0].length : -1;
          const child = {}; child[k] = (ni >= 0 && nextIndent > indent && nextLine.startsWith("-")) ? [] : {};
          list.push(child); stack.push({ indent, kind: "map", value: child });
          stack.push({ indent: indent + 2, kind: Array.isArray(child[k]) ? "list" : "map", value: child[k] });
        } else {
          const child = {}; child[k] = _parseScalar(vRaw); list.push(child);
        }
        continue;
      }
      list.push(_parseScalar(itemRest));
      continue;
    }
    const idx = line.indexOf(":");
    if (idx === -1) throw new Error(`YAML: expected "key: value" but got "${line}"`);
    const key = line.slice(0, idx).trim();
    let vRaw = line.slice(idx + 1).trim();
    if (stack[stack.length - 1].kind !== "map") throw new Error("YAML: mapping entry found where a list was expected.");
    const map = stack[stack.length - 1].value;
    if (vRaw === "") {
      const ni = nextNonEmpty[i];
      const nextLine = ni >= 0 ? _stripYamlComment(lines[ni]).trim() : "";
      const nextIndent = ni >= 0 ? _stripYamlComment(lines[ni]).match(/^\s*/)[0].length : -1;
      if (ni >= 0 && nextIndent > indent && nextLine.startsWith("-")) {
        const child = ensureContainerForKey(map, key, "list"); stack.push({ indent: indent + 2, kind: "list", value: child });
      } else if (ni >= 0 && nextIndent > indent) {
        const child = ensureContainerForKey(map, key, "map"); stack.push({ indent: indent + 2, kind: "map", value: child });
      } else {
        map[key] = null;
      }
    } else {
      map[key] = _parseScalar(vRaw);
    }
  }
  if (Array.isArray(stack[0].value)) return stack[0].value;
  return root;
}

/* -------------------------- Defaults -------------------------- */
const DEFAULT_BUTTON = () => ({
  id: _uid(),
  icon: "mdi:floor-plan",
  tooltip: "",
  label: "",
  entity: "",
  button_type: "",
  background: "",
  background_opacity: "",
  border_radius: "",
  border_style: "",
  border_width: "",
  border_color: "",
  icon_color: "",
  label_style: {},
  pill_width: "",
  conditions_mode: "all",
  conditions: [],
  tap_action: { action: "navigate", navigation_path: "/" },
  hold_action: { action: "none" },
  double_tap_action: { action: "none" },
});

const DEFAULTS = {
  type: `custom:${CARD_TYPE}`,
  position: "bottom-right",
  offset_x: 12,
  offset_y: 20,
  button_size: 50,
  gap: 12,
  vertical_gap: 12,
  z_index: 5,
  base: { button: DEFAULT_BUTTON() },
  horizontal: { enabled: true, columns: 6, buttons: [] },
  vertical: { enabled: false, rows: 6, buttons: [] },
  default_background: "",
  default_button_opacity: 1,
  default_border_radius: 999,
  default_border_style: "solid",
  default_border_width: 0,
  default_border_color: "",
  default_icon_color: "",
  button_box_shadow: "0 8px 24px rgba(0, 0, 0, 0.35)",
  button_box_shadow_hover: "0 10px 30px rgba(0, 0, 0, 0.42)",
  default_button_type: "icon",
  label_style: { ...DEFAULT_LABEL_STYLE },
  pill_width: 0,
  center_spread: false,
  offset_x_mobile: null,
  offset_x_tablet: null,
  offset_x_desktop: null,
  bottom_bar_enabled: false,
  bottom_bar_height: 85,
  bottom_bar_color: "rgb(var(--rgb-card-background-color, 0,0,0))",
  bottom_bar_opacity: 0.85,
  bottom_bar_full_width: false,
  bottom_bar_border_radius: 0,
  bottom_bar_box_shadow: "",
  bottom_bar_bottom_offset: 0,
  bottom_bar_margin_left: 0,
  bottom_bar_margin_right: 0,
  bottom_bar_border_width: 0,
  bottom_bar_border_style: "solid",
  bottom_bar_border_color: "",
  buttons: undefined,
  default_label_position: undefined,
  default_show_label: undefined,
  reserve_space: false,
};

function ensureButtonIdsInList(list) {
  const arr = Array.isArray(list) ? list : [];
  let changed = false;
  const next = arr.map((b) => {
    if (b && typeof b === "object" && !b.id) {
      changed = true;
      return { ...b, id: _uid() };
    }
    return b;
  });
  return [next, changed];
}

function ensureConditionIdsInList(list) {
  const arr = Array.isArray(list) ? list : [];
  let changed = false;
  const next = arr.map((b) => {
    if (!b || typeof b !== "object") return b;
    const conds = Array.isArray(b.conditions) ? b.conditions : [];
    let local = false;
    const nextConds = conds.map((c) => {
      if (!c || typeof c !== "object") return c;
      const cc = { ...c };
      if (!cc.id) {
        cc.id = _uid();
        local = true;
      }
      if (!cc.type) cc.type = "entity";
      return cc;
    });
    if (local) {
      changed = true;
      return { ...b, conditions: nextConds };
    }
    return b;
  });
  return [next, changed];
}

function inferButtonTypeFromLegacy(btn, configDefaultType) {
  if (btn?.button_type && BUTTON_TYPES.some((t) => t.value === btn.button_type)) return btn.button_type;
  const lp = btn?.label_position;
  if (lp === "inside") return "pill";
  if (lp === "below") return "icon_label_below";
  if (lp === "left") return "icon_label_left";
  if (lp === "right") return "icon_label_right";
  if (lp === "none") return "icon";
  if (btn?.show_label === true) return configDefaultType || "icon_label_below";
  if (btn?.show_label === false) return "icon";
  return configDefaultType || "icon";
}

function normalizeConfig(cfg) {
  // Auto-migrate old config to new nested structure
  cfg = migrateConfig(cfg);
  // Clean up and validate config
  cfg = cleanupAndValidateConfig(cfg);

  const sourceCfg = cfg || {};
  const raw = { ...DEFAULTS, ...sourceCfg };
  applyGlobalDefaultsToConfig({
    scope: "navigation",
    config: raw,
    sourceConfig: sourceCfg,
    fields: [
      "default_border_radius",
      "default_border_width",
      "default_border_style",
      "default_border_color",
      "button_box_shadow",
      "button_box_shadow_hover",
      "default_button_opacity",
      "default_background",
      "default_icon_color",
      "bottom_bar_border_radius",
      "bottom_bar_box_shadow",
      "bottom_bar_border_width",
      "bottom_bar_border_style",
      "bottom_bar_border_color",
    ],
  });
  const navGlobals = getGlobalDefaultsFor("navigation");
  if (!raw.label_style || typeof raw.label_style !== "object") raw.label_style = {};
  const sourceLabelStyle = (sourceCfg.label_style && typeof sourceCfg.label_style === "object") ? sourceCfg.label_style : {};
  if (isUnsetValue(sourceLabelStyle.font_size) && !isUnsetValue(navGlobals.label_font_size)) raw.label_style.font_size = Number(navGlobals.label_font_size);
  if (isUnsetValue(sourceLabelStyle.font_weight) && !isUnsetValue(navGlobals.label_font_weight)) raw.label_style.font_weight = Number(navGlobals.label_font_weight);
  if (isUnsetValue(sourceLabelStyle.letter_spacing) && !isUnsetValue(navGlobals.label_letter_spacing)) raw.label_style.letter_spacing = Number(navGlobals.label_letter_spacing);
  if (isUnsetValue(sourceLabelStyle.text_transform) && !isUnsetValue(navGlobals.label_text_transform)) raw.label_style.text_transform = navGlobals.label_text_transform;
  if (isUnsetValue(sourceLabelStyle.color) && !isUnsetValue(navGlobals.label_color)) raw.label_style.color = navGlobals.label_color;
  const base = { ...(raw.base || {}) };
  base.button = { ...DEFAULT_BUTTON(), ...(base.button || {}) };
  if (!base.button.id) base.button.id = _uid();
  delete base.button.conditions;
  delete base.button.conditions_mode;

  const horizontal = { ...DEFAULTS.horizontal, ...(raw.horizontal || {}) };
  const vertical = { ...DEFAULTS.vertical, ...(raw.vertical || {}) };
  const hasNewLists =
    (Array.isArray(horizontal.buttons) && horizontal.buttons.length > 0) ||
    (Array.isArray(vertical.buttons) && vertical.buttons.length > 0);

  if (!hasNewLists && Array.isArray(raw.buttons)) {
    const h = [], v = [];
    for (const b of raw.buttons) {
      if (b?.group === "vertical") v.push({ ...b });
      else h.push({ ...b });
    }
    horizontal.buttons = h;
    vertical.buttons = v;
  }

  const c = {
    ...raw,
    base,
    horizontal,
    vertical,
    label_style: normalizeLabelStyle(raw.label_style),
  };

  c.position = ["bottom-left", "bottom-center", "bottom-right"].includes(c.position) ? c.position : "bottom-right";
  c.offset_x = clampNum(c.offset_x, DEFAULTS.offset_x);
  c.offset_y = clampNum(c.offset_y, DEFAULTS.offset_y);
  c.button_size = Math.max(36, clampNum(c.button_size, DEFAULTS.button_size));
  c.gap = Math.max(0, clampNum(c.gap, DEFAULTS.gap));
  c.vertical_gap = Math.max(0, clampNum(c.vertical_gap, c.gap));
  c.z_index = clampNum(c.z_index, DEFAULTS.z_index);

  c.bottom_bar_enabled = !!raw.bottom_bar_enabled;
  c.bottom_bar_full_width = !!raw.bottom_bar_full_width;
  c.bottom_bar_height = Math.max(0, clampInt(raw.bottom_bar_height, DEFAULTS.bottom_bar_height, 0));
  c.bottom_bar_color = (typeof raw.bottom_bar_color === "string") ? raw.bottom_bar_color : DEFAULTS.bottom_bar_color;
  c.bottom_bar_opacity = Math.max(0, Math.min(1, clampNum(raw.bottom_bar_opacity, DEFAULTS.bottom_bar_opacity)));
  c.bottom_bar_border_radius = Math.max(0, clampNum(raw.bottom_bar_border_radius, DEFAULTS.bottom_bar_border_radius));
  c.bottom_bar_bottom_offset = clampNum(raw.bottom_bar_bottom_offset, DEFAULTS.bottom_bar_bottom_offset);
  c.bottom_bar_box_shadow = (typeof raw.bottom_bar_box_shadow === "string") ? raw.bottom_bar_box_shadow : DEFAULTS.bottom_bar_box_shadow;
  c.bottom_bar_margin_left = clampNum(raw.bottom_bar_margin_left, DEFAULTS.bottom_bar_margin_left);
  c.bottom_bar_margin_right = clampNum(raw.bottom_bar_margin_right, DEFAULTS.bottom_bar_margin_right);
  c.bottom_bar_border_width = Math.max(0, clampNum(raw.bottom_bar_border_width, DEFAULTS.bottom_bar_border_width));
  c.bottom_bar_border_style = (typeof raw.bottom_bar_border_style === "string") ? raw.bottom_bar_border_style : DEFAULTS.bottom_bar_border_style;
  c.bottom_bar_border_color = (typeof raw.bottom_bar_border_color === "string") ? raw.bottom_bar_border_color : DEFAULTS.bottom_bar_border_color;

  c.button_box_shadow = (typeof raw.button_box_shadow === "string") ? raw.button_box_shadow : DEFAULTS.button_box_shadow;
  c.button_box_shadow_hover = (typeof raw.button_box_shadow_hover === "string") ? raw.button_box_shadow_hover : DEFAULTS.button_box_shadow_hover;
  c.default_button_opacity = Math.max(0, Math.min(1, clampNum(c.default_button_opacity, DEFAULTS.default_button_opacity)));
  c.default_border_radius = Math.max(0, clampNum(raw.default_border_radius, DEFAULTS.default_border_radius));
  c.default_border_style = (typeof raw.default_border_style === "string") ? raw.default_border_style : DEFAULTS.default_border_style;
  c.default_border_width = Math.max(0, clampNum(raw.default_border_width, DEFAULTS.default_border_width));
  c.default_border_color = (typeof raw.default_border_color === "string") ? raw.default_border_color : DEFAULTS.default_border_color;

  c.horizontal.enabled = !!c.horizontal.enabled;
  c.horizontal.columns = Math.max(1, clampInt(c.horizontal.columns, DEFAULTS.horizontal.columns, 1));
  c.horizontal.buttons = Array.isArray(c.horizontal.buttons) ? c.horizontal.buttons : [];
  c.vertical.enabled = !!c.vertical.enabled;
  c.vertical.rows = Math.max(1, clampInt(c.vertical.rows, DEFAULTS.vertical.rows, 1));
  c.vertical.buttons = Array.isArray(c.vertical.buttons) ? c.vertical.buttons : [];

  c.default_button_type = normalizeButtonType(c.default_button_type, DEFAULTS.default_button_type);

  if (!cfg?.default_button_type && (cfg?.default_label_position || cfg?.default_show_label !== undefined)) {
    if (cfg?.default_show_label) {
      const lp = cfg.default_label_position;
      if (lp === "inside") c.default_button_type = "pill";
      else if (lp === "left") c.default_button_type = "icon_label_left";
      else if (lp === "right") c.default_button_type = "icon_label_right";
      else c.default_button_type = "icon_label_below";
    } else {
      c.default_button_type = "icon";
    }
  }

  c.pill_width = clampNum(c.pill_width, 0);
  if (c.pill_width > 0 && c.pill_width < MIN_PILL_WIDTH) c.pill_width = MIN_PILL_WIDTH;

  c.center_spread = !!c.center_spread;
  c.offset_x_mobile = (raw.offset_x_mobile !== undefined && raw.offset_x_mobile !== null && raw.offset_x_mobile !== "") ? Number(raw.offset_x_mobile) : null;
  c.offset_x_tablet = (raw.offset_x_tablet !== undefined && raw.offset_x_tablet !== null && raw.offset_x_tablet !== "") ? Number(raw.offset_x_tablet) : null;
  c.offset_x_desktop = (raw.offset_x_desktop !== undefined && raw.offset_x_desktop !== null && raw.offset_x_desktop !== "") ? Number(raw.offset_x_desktop) : null;

  c.reserve_space = !!raw.reserve_space;

  {
    const [hb] = ensureButtonIdsInList(c.horizontal.buttons);
    const [vb] = ensureButtonIdsInList(c.vertical.buttons);
    c.horizontal.buttons = hb;
    c.vertical.buttons = vb;
    const [hb2] = ensureConditionIdsInList(c.horizontal.buttons);
    const [vb2] = ensureConditionIdsInList(c.vertical.buttons);
    c.horizontal.buttons = hb2;
    c.vertical.buttons = vb2;
  }
  return c;
}

function clamp01(n) {
  const x = Number(n);
  if (!Number.isFinite(x)) return 1;
  return x < 0 ? 0 : (x > 1 ? 1 : x);
}

function applyBgOpacity(color, opacity01) {
  const o = clamp01(opacity01);
  if (o >= 1) return color;
  if (o <= 0) return "transparent";
  const pct = Math.round(o * 1000) / 10;
  return `color-mix(in srgb, ${color} ${pct}%, transparent)`;
}

/* -------------------------- Card -------------------------- */

class HkiNavigationCard extends LitElement {
  static get properties() {
    return {
      hass: {},
      _config: { state: true },
      _layout: { state: true },
    };
  }

  constructor() {
    super();
    this._rawConfigInput = null;
    this._groupOverride = { horizontal: null, vertical: null };
    this._tapState = { lastId: null, lastTime: 0, singleTimer: null };
    this._holdTimers = new Map();
    // Template rendering state per button id (label/tooltip)
    // Map<btnId, { raw: string, sig: string, seq: number, unsub: function|null, rendered: string }>
    this._tpl = new Map();
    this._layout = { ready: false, slots: {}, meta: {} };
    this._measureRaf = null;
    this._bottomBarMeasureRaf = null;
    this._bottomBarBounds = null;
    this._contentLeftMargin = 0;
    this._contentRightMargin = 0;
    this._contentEl = null;
    this._rightPanelWidth = 0;
    this._rightPanelEl = null;
    this._uiObservers = [];
    this._resizeObservers = [];

    // Optimize: Debounce resize and measurement to avoid heavy DOM thrashing
    this._debouncedRefreshAndMeasure = debounce(() => {
        this._refreshUiState();
        this._layout = { ready: false, slots: {}, meta: {} };
        this.requestUpdate();
        this._scheduleMeasure();
        this._scheduleMeasureBottomBar();
    }, 100);

    this._onResize = () => {
        this._debouncedRefreshAndMeasure();
    };
    
    // Fix unresponsive buttons after nav
    this._onLocationChange = () => {
        // Reset DOM references so we force finding the new view. 
        // Failing to do this causes measurement on the OLD (now detached) view.
        this._contentEl = null;
        this._rightPanelEl = null;

        // Force immediate re-render to ensure buttons are responsive
        this.requestUpdate();
        setTimeout(() => this._debouncedRefreshAndMeasure(), 50);
        setTimeout(() => this._debouncedRefreshAndMeasure(), 500);
    };
    
    // Fix unresponsive buttons after idle/sleep
    this._onVisibilityChange = () => {
      if (!document.hidden) {
        // Page became visible again - reconnect everything
        this._reconnectTemplates();
        this.requestUpdate();
        setTimeout(() => this._debouncedRefreshAndMeasure(), 100);
      }
    };
    
    // Fix unresponsive buttons when hass connection is restored
    this._onConnectionChange = () => {
      this._reconnectTemplates();
      this.requestUpdate();
    };
    this._onGlobalSettingsChanged = () => {
      if (!this._rawConfigInput) return;
      try { this.setConfig(this._rawConfigInput); } catch (_) {}
    };
  }

  connectedCallback() {
    super.connectedCallback();
    window.addEventListener("resize", this._onResize);
    window.addEventListener("location-changed", this._onLocationChange);
    document.addEventListener("visibilitychange", this._onVisibilityChange);
    window.addEventListener("connection-status", this._onConnectionChange);
    window.addEventListener("hki-global-settings-changed", this._onGlobalSettingsChanged);
    
    // Fix: Invalidate cached DOM references on reconnect to ensure we aren't holding onto stale views
    this._contentEl = null;
    this._rightPanelEl = null;
    this._bottomBarBounds = null;

    this._refreshUiState(true);
    // Force immediate measurement
    requestAnimationFrame(() => this._debouncedRefreshAndMeasure());
    
    // Safety measures for slow-loading views
    setTimeout(() => this._debouncedRefreshAndMeasure(), 250);
    setTimeout(() => this._debouncedRefreshAndMeasure(), 1000);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("resize", this._onResize);
    window.removeEventListener("location-changed", this._onLocationChange);
    document.removeEventListener("visibilitychange", this._onVisibilityChange);
    window.removeEventListener("connection-status", this._onConnectionChange);
    window.removeEventListener("hki-global-settings-changed", this._onGlobalSettingsChanged);
    this._disconnectObservers();
    if (this._measureRaf) cancelAnimationFrame(this._measureRaf);
    if (this._bottomBarMeasureRaf) cancelAnimationFrame(this._bottomBarMeasureRaf);

    // Unsubscribe all template subscriptions
    for (const st of this._tpl.values()) {
      if (st?.unsub) {
        try { st.unsub(); } catch (_) {}
      }
    }
    this._tpl.clear();
  }

  _disconnectObservers() {
    for (let i = 0; i < this._uiObservers.length; i++) this._uiObservers[i].disconnect();
    this._uiObservers = [];
    for (let i = 0; i < this._resizeObservers.length; i++) this._resizeObservers[i].disconnect();
    this._resizeObservers = [];
  }

  _reconnectTemplates() {
    // Force reconnect all template subscriptions after idle/visibility change
    if (!this._config) return;
    
    const reconnectButton = (btn) => {
      if (!btn || !btn.id) return;
      // Re-setup label template if it exists
      const labelRaw = btn.label || btn.tooltip || "";
      if (labelRaw) {
        this._setupBtnLabelTemplate(btn, labelRaw);
      }
    };
    
    // Reconnect base button
    if (this._config.base?.button) {
      reconnectButton(this._config.base.button);
    }
    
    // Reconnect horizontal buttons
    if (this._config.horizontal?.buttons) {
      for (const btn of this._config.horizontal.buttons) {
        reconnectButton(btn);
      }
    }
    
    // Reconnect vertical buttons
    if (this._config.vertical?.buttons) {
      for (const btn of this._config.vertical.buttons) {
        reconnectButton(btn);
      }
    }
  }

  updated(changedProps) {
    super.updated?.(changedProps);
    // If Hass was reconnected or we are just starting up, verify layout
    if (changedProps.has("hass")) {
      const oldHass = changedProps.get("hass");
      const newHass = this.hass;
      
      // Hass became available or connection was restored
      if ((!oldHass && newHass) || (oldHass && !newHass) || 
          (oldHass?.connection?.connected !== newHass?.connection?.connected)) {
        this._reconnectTemplates();
      }
      
      if (!this._layout.ready) {
        this._scheduleMeasure();
      }
    }
    this._refreshUiState(false, true);
    this._scheduleMeasure();
    this._scheduleMeasureBottomBar();
  }

  setConfig(config) {
    if (!config) throw new Error("Invalid configuration");
    this._rawConfigInput = config;
    this._config = normalizeConfig(config);
    this._layout = { ready: false, slots: {}, meta: {} };

    // Clear template state so templates re-render with new config
    for (const st of this._tpl.values()) {
      if (st?.unsub) {
        try { st.unsub(); } catch (_) {}
      }
    }
    this._tpl.clear();

    this._refreshUiState(true);
    this.requestUpdate();
    this._scheduleMeasure();
  }

  getCardSize() { return 0; }

  _scheduleMeasure() {
    if (!this._config || this._config.position === "bottom-center") return;
    if (this._measureRaf) cancelAnimationFrame(this._measureRaf);
    this._measureRaf = requestAnimationFrame(() => this._measureAndLayout());
  }

  _scheduleMeasureBottomBar() {
    const c = this._config;
    if (!c || !c.bottom_bar_enabled || c.bottom_bar_full_width) {
      if (this._bottomBarBounds) {
        this._bottomBarBounds = null;
        this.requestUpdate();
      }
      return;
    }
    if (this._bottomBarMeasureRaf) cancelAnimationFrame(this._bottomBarMeasureRaf);
    this._bottomBarMeasureRaf = requestAnimationFrame(() => this._measureBottomBarBounds());
  }

  _measureBottomBarBounds() {
    const c = this._config;
    if (!c || !c.bottom_bar_enabled || c.bottom_bar_full_width) return;
    if (c.position !== "bottom-center") return;

    const root = this.shadowRoot;
    if (!root) return;
    const vw = window.innerWidth || document.documentElement.clientWidth || 0;
    if (vw <= 0) return;

    const fabs = root.querySelectorAll(".fab-anchor .fab");
    if (!fabs.length) return;

    const rects = [];
    for (let i = 0; i < fabs.length; i++) {
        const r = fabs[i].getBoundingClientRect();
        if (r && r.width > 0 && r.height > 0) rects.push(r);
    }
    if (!rects.length) return;

    const maxBottom = Math.max(...rects.map((r) => r.bottom));
    const bottomRow = rects.filter((r) => r.bottom >= maxBottom - 2);
    if (!bottomRow.length) return;

    const centerX = vw / 2;
    const threshold = vw * 0.4;
    const mainCluster = bottomRow.filter(r => Math.abs(((r.left + r.right) / 2) - centerX) <= threshold);
    if (!mainCluster.length) return;

    const minLeft = Math.min(...mainCluster.map((r) => r.left));
    const maxRight = Math.max(...mainCluster.map((r) => r.right));

    const next = {
      left: Math.max(0, Math.round(minLeft)),
      right: Math.max(0, Math.round(vw - maxRight)),
    };
    const cur = this._bottomBarBounds;
    if (!cur || cur.left !== next.left || cur.right !== next.right) {
      this._bottomBarBounds = next;
      this.requestUpdate();
    }
  }

  _isEditMode() {
    try {
      const qs = new URLSearchParams(window.location.search || "");
      if (qs.get("edit") === "1") return true;
    } catch (_) {}
    if (document.body?.classList) {
        if (document.body.classList.contains("edit-mode") || document.body.classList.contains("edit")) return true;
    }
    return false;
  }

  _isInPreviewContext() {
    let node = this;
    while (node) {
      const root = node.getRootNode?.();
      if (!root || root === document) break;
      const host = root.host;
      if (!host) break;
      const tag = (host.tagName || "").toLowerCase();
      if (tag === "hui-card-preview" || tag === "hui-dialog-edit-card" || tag === "ha-dialog" || tag === "ha-dialog-scroller") {
        return true;
      }
      node = host;
    }
    return false;
  }

  // Optimized Deep Query: Passes results array ref instead of concat
  _queryDeep(selector, root = document, maxDepth = 12, results = [], visited = new Set()) {
    const walk = (node, depth) => {
      if (!node || depth > maxDepth || visited.has(node)) return;
      visited.add(node);
      try {
        if (node.querySelectorAll) {
          const found = node.querySelectorAll(selector);
          for (let i = 0; i < found.length; i++) results.push(found[i]);
        }
      } catch (_) {}
      const sr = node.shadowRoot;
      if (sr) walk(sr, depth + 1);
      const children = node instanceof ShadowRoot ? node.host?.children : node.children;
      if (children && children.length) {
        for (let i = 0; i < children.length; i++) walk(children[i], depth + 1);
      }
    };
    walk(root, 0);
    return results;
  }

  _findVisibleBest(elements, predicate = null) {
    let best = null;
    let bestScore = 0;
    for (let i = 0; i < elements.length; i++) {
      const el = elements[i];
      try {
        const rect = el.getBoundingClientRect();
        const style = window.getComputedStyle(el);
        if (style.display === "none" || style.visibility === "hidden") continue;
        if (rect.width <= 0 || rect.height <= 0) continue;
        if (predicate && !predicate(el, rect)) continue;
        const score = rect.width * rect.height;
        if (score > bestScore) {
          bestScore = score;
          best = el;
        }
      } catch (_) {}
    }
    return best;
  }

  _measureContentMargins() {
    const vw = window.innerWidth || document.documentElement.clientWidth || 0;
    const predicate = (_el, rect) => rect.width >= 200 && rect.height >= 200;
    
    // Check if we already have valid contentEl to avoid re-querying deep DOM
    let el = this._contentEl;
    if (!el || !el.isConnected) {
        const preferred = this._queryDeep("hui-sections-view, hui-view, hui-masonry-view");
        el = this._findVisibleBest(preferred, predicate);
        if (!el) {
            const fallback = this._queryDeep("ha-panel-lovelace");
            el = this._findVisibleBest(fallback, predicate);
        }
    }
    
    this._contentEl = el || null;
    if (!el || vw <= 0) {
      this._contentLeftMargin = 0;
      this._contentRightMargin = 0;
      return;
    }
    const rect = el.getBoundingClientRect();
    this._contentLeftMargin = Math.max(0, rect.left);
    this._contentRightMargin = Math.max(0, vw - rect.right);
  }

  _refreshUiState(forceRehook = false, softRehook = false) {
    const vw = window.innerWidth || document.documentElement.clientWidth || 0;
    
    // Check if we need to re-scan for right panel
    let rightEl = this._rightPanelEl;
    if (!rightEl || !rightEl.isConnected || forceRehook) {
        const rightCandidates = this._queryDeep("ha-drawer, mwc-drawer, app-drawer-layout");
        rightEl = this._findVisibleBest(rightCandidates, (_el, rect) => {
            if (vw <= 0) return false;
            const nearRight = rect.right >= vw - 2;
            const onRightHalf = rect.left >= vw * 0.55;
            const wideEnough = rect.width >= 120;
            return nearRight && onRightHalf && wideEnough;
        });
    }

    this._rightPanelEl = rightEl || null;
    this._rightPanelWidth = rightEl ? (rightEl.getBoundingClientRect().width || 0) : 0;
    this._measureContentMargins();

    if (forceRehook || softRehook) {
      this._disconnectObservers();
      const observeElAttrs = (el, attrs = []) => {
        if (!el) return;
        try {
          const mo = new MutationObserver(this._debouncedRefreshAndMeasure);
          mo.observe(el, { attributes: true, attributeFilter: attrs.length ? attrs : undefined });
          this._uiObservers.push(mo);
        } catch (_) {}
      };

      observeElAttrs(this._rightPanelEl, ["open", "opened", "style", "class"]);
      observeElAttrs(document.body, ["class", "style"]);
      observeElAttrs(this._contentEl, ["style", "class"]);

      if (window.ResizeObserver) {
        const hookResize = (el) => {
          if (!el) return;
          try {
            const ro = new ResizeObserver(this._debouncedRefreshAndMeasure);
            ro.observe(el);
            this._resizeObservers.push(ro);
          } catch (_) {}
        };
        hookResize(this._rightPanelEl);
        hookResize(this._contentEl);
      }
    }
  }

  _getButtonType(btn) {
    const c = this._config;
    const t = safeString(btn?.button_type);
    if (t && BUTTON_TYPES.some((x) => x.value === t)) return t;
    return inferButtonTypeFromLegacy(btn, c.default_button_type);
  }

  _isTemplateString(s) {
    if (typeof s !== "string") return false;
    return s.includes("{{") || s.includes("{%") || s.includes("{#");
  }

  _getUserVariable() {
    const u = this.hass?.user;
    return u?.name || u?.username || u?.id || "";
  }

  _buildTemplateVariables(btn) {
    // Keep parity with HKI Header Card and extend with version/button
    return {
      config: this._config ?? {},
      user: this._getUserVariable(),
      version: VERSION,
      button: btn ?? {},
    };
  }

  _unsubscribeBtnTemplate(btnId) {
    const st = this._tpl.get(btnId);
    if (st?.unsub) {
      try { st.unsub(); } catch (_) {}
    }
    if (st) st.unsub = null;
  }

  _applyCachedTemplate(sig) {
    try {
      const cached = sessionStorage.getItem(sig);
      if (cached != null && cached !== "") return String(cached);
    } catch (_) {}
    return null;
  }

  _storeTemplateCache(sig, value) {
    try { sessionStorage.setItem(sig, value); } catch (_) {}
  }

  async _renderTemplateOnce(btnId, seq, raw, vars, sig) {
    if (!this.hass?.callWS) return;
    try {
      const res = await this.hass.callWS({
        type: "render_template",
        template: raw,
        variables: vars,
        strict: false,
      });
      const st = this._tpl.get(btnId);
      if (!st || st.seq !== seq) return;
      const text = res?.result == null ? "" : String(res.result);
      if (st.rendered !== text) {
        st.rendered = text;
        this._storeTemplateCache(sig, text);
        this.requestUpdate();
      }
    } catch (err) {
      console.warn("[HKI Navigation Card] Template render failed:", err);
    }
  }

  async _subscribeTemplate(btnId, seq, raw, vars, sig) {
    if (!this.hass?.connection?.subscribeMessage) return;
    try {
      const unsub = await this.hass.connection.subscribeMessage(
        (msg) => {
          const st = this._tpl.get(btnId);
          if (!st || st.seq !== seq) return;
          if (msg?.error) {
            console.warn("[HKI Navigation Card] Template update error:", msg.error);
            return;
          }
          const text = msg?.result == null ? "" : String(msg.result);
          if (st.rendered !== text) {
            st.rendered = text;
            this._storeTemplateCache(sig, text);
            this.requestUpdate();
          }
        },
        { type: "render_template", template: raw, variables: vars, strict: false, report_errors: false }
      );

      const st = this._tpl.get(btnId);
      if (!st || st.seq !== seq) {
        unsub?.();
        return;
      }
      st.unsub = unsub;
    } catch (err) {
      console.warn("[HKI Navigation Card] Template subscription failed:", err);
      this._renderTemplateOnce(btnId, seq, raw, vars, sig);
    }
  }

  _setupBtnLabelTemplate(btn, raw) {
    const btnId = btn?.id || "no_id";
    if (!raw || typeof raw !== "string") {
      this._unsubscribeBtnTemplate(btnId);
      this._tpl.delete(btnId);
      return;
    }

    const isTpl = this._isTemplateString(raw);
    if (!isTpl) {
      // Fast-path: just keep plain text and still support {{ user }} / {{ version }} replacements
      this._unsubscribeBtnTemplate(btnId);
      const rendered = raw
        .replace(/\{\{\s*user\s*\}\}/g, this._getUserVariable() || "User")
        .replace(/\{\{\s*version\s*\}\}/g, VERSION);
      this._tpl.set(btnId, { raw, sig: "", seq: 0, unsub: null, rendered });
      return;
    }

    const vars = this._buildTemplateVariables(btn);
    const sig = cacheKey(raw, vars);
    const prev = this._tpl.get(btnId);
    const nextSeq = (prev?.seq ?? 0) + 1;

    // If nothing changed, keep existing subscription/rendered
    if (prev && prev.raw === raw && prev.sig === sig) return;

    this._unsubscribeBtnTemplate(btnId);

    const st = { raw, sig, seq: nextSeq, unsub: null, rendered: raw };
    this._tpl.set(btnId, st);

    // Apply session cache immediately if available
    const cached = this._applyCachedTemplate(sig);
    if (cached != null) st.rendered = cached;

    // Prefer subscription so rendered labels update with state changes
    if (this.hass?.connection?.subscribeMessage) {
      this._subscribeTemplate(btnId, nextSeq, raw, vars, sig);
    } else {
      // Fallback: one-off render
      this._renderTemplateOnce(btnId, nextSeq, raw, vars, sig);
    }
  }

  _getLabelText(btn) {
    let raw = btn?.label;
    if (raw == null || raw === "") raw = btn?.tooltip || "";

    // Safety: older editor versions may have stored label as an object
    if (raw && typeof raw !== "string") {
      if (typeof raw === "object") {
        if (typeof raw.value === "string") raw = raw.value;
        else if (typeof raw.text === "string") raw = raw.text;
        else raw = "";
      } else {
        raw = "";
      }
    }

    if (!raw) return "";

    this._setupBtnLabelTemplate(btn, raw);

    const st = this._tpl.get(btn?.id || "no_id");
    return st?.rendered ?? raw;
  }

  _getPillWidth(btn) {
    const per = btn?.pill_width;
    if (_hasMeaningfulNumber(per)) {
      const n = _toNumber(per);
      return n <= 0 ? 0 : Math.max(MIN_PILL_WIDTH, n);
    }
    const g = clampNum(this._config.pill_width, 0);
    return g > 0 ? Math.max(MIN_PILL_WIDTH, g) : 0;
  }

  _buttonOpacity(btn) {
    if (_hasMeaningfulNumber(btn?.background_opacity)) return clamp01(_toNumber(btn.background_opacity));
    return clamp01(this._config.default_button_opacity);
  }

  _buttonBg(btn) {
    const base = btn?.background || this._config.default_background || "var(--accent-color, var(--primary-color))";
    return applyBgOpacity(base, this._buttonOpacity(btn));
  }

  _buttonIconColor(btn) {
    return btn?.icon_color || this._config.default_icon_color || "var(--text-primary-color, var(--primary-text-color))";
  }

  _buttonBorderRadius(btn) {
    if (_hasMeaningfulNumber(btn?.border_radius)) return Math.max(0, _toNumber(btn.border_radius));
    return Math.max(0, clampNum(this._config.default_border_radius, DEFAULTS.default_border_radius));
  }

  _buttonBorderWidth(btn) {
    if (_hasMeaningfulNumber(btn?.border_width)) return Math.max(0, _toNumber(btn.border_width));
    return Math.max(0, clampNum(this._config.default_border_width, DEFAULTS.default_border_width));
  }

  _buttonBorderStyle(btn) {
    const per = safeString(btn?.border_style).trim();
    if (per) return per;
    const g = safeString(this._config.default_border_style).trim();
    return g || "solid";
  }

  _buttonBorderColor(btn) {
    const per = safeString(btn?.border_color).trim();
    if (per) return per;
    const g = safeString(this._config.default_border_color).trim();
    return g || "var(--divider-color)";
  }

  _labelBubbleStyle(btn) {
    const merged = mergeLabelStyle(this._config.label_style, btn?.label_style);
    const bg = merged.background && merged.background !== ""
        ? applyBgOpacity(merged.background, clamp01(merged.background_opacity))
        : `rgba(var(--rgb-card-background-color, 0, 0, 0), ${clamp01(merged.background_opacity)})`;
    const color = merged.color && merged.color !== "" ? merged.color : "var(--text-primary-color, var(--primary-text-color))";

    return `font-size:${merged.font_size}px;font-weight:${merged.font_weight};letter-spacing:${merged.letter_spacing}px;text-transform:${merged.text_transform};color:${color};background:${bg};padding:${merged.padding_y}px ${merged.padding_x}px;border-radius:${merged.border_radius}px;max-width:${merged.max_width}px;backdrop-filter:blur(${merged.backdrop_blur}px);-webkit-backdrop-filter:blur(${merged.backdrop_blur}px)`;
  }

  _pillTextStyle(btn) {
    const merged = mergeLabelStyle(this._config.label_style, btn?.label_style);
    const color = merged.color && merged.color !== "" ? merged.color : "currentColor";
    return `font-size:${merged.font_size}px;font-weight:${merged.font_weight};letter-spacing:${merged.letter_spacing}px;text-transform:${merged.text_transform};color:${color}`;
  }

  _evalCondition(cond) {
    const hass = this.hass;
    if (!hass) return true;
    if (!cond || typeof cond !== "object") return true;

    const type = cond.type || "entity";
    let result = true;

    if (type === "entity") {
      const entityId = cond.entity;
      if (!entityId) return true;
      const operator = cond.operator || "equals";
      const stateObj = hass.states?.[entityId];
      if (operator === "exists") result = !!stateObj;
      else if (operator === "not_exists") result = !stateObj;
      else {
        if (!stateObj) result = false;
        else {
          const actual = cond.attribute ? stateObj.attributes?.[cond.attribute] : stateObj.state;
          const actualStr = safeString(actual);
          const valueStr = safeString(cond.value);
          if (operator === "equals") result = actualStr === valueStr;
          else if (operator === "not_equals") result = actualStr !== valueStr;
          else if (operator === "above") {
            const a = Number(actual);
            const v = Number(cond.value);
            result = Number.isFinite(a) && Number.isFinite(v) ? a > v : false;
          } else if (operator === "below") {
            const a = Number(actual);
            const v = Number(cond.value);
            result = Number.isFinite(a) && Number.isFinite(v) ? a < v : false;
          } else if (operator === "includes") {
            if (Array.isArray(actual)) result = actual.map(safeString).includes(valueStr);
            else result = actualStr.includes(valueStr);
          } else if (operator === "not_includes") {
            if (Array.isArray(actual)) result = !actual.map(safeString).includes(valueStr);
            else result = !actualStr.includes(valueStr);
          }
        }
      }
    } else if (type === "user") {
      const userName = this.hass?.user?.name || "";
      const list = Array.isArray(cond.users) ? cond.users : [];
      result = list.length === 0 ? true : list.includes(userName);
    } else if (type === "view") {
      const path = window.location?.pathname || "";
      const list = Array.isArray(cond.views) ? cond.views : [];
      result = list.length === 0 ? true : list.some((v) => v === path || path.endsWith(v));
    } else if (type === "screen") {
      const mode = cond.mode || "mobile";
      const isMobile = window.matchMedia?.("(max-width: 800px)")?.matches ?? false;
      result = mode === "mobile" ? isMobile : !isMobile;
    }
    if (cond.invert) result = !result;
    return result;
  }

  _isButtonVisible(btn) {
    const conds = Array.isArray(btn?.conditions) ? btn.conditions : [];
    if (conds.length === 0) return true;
    const mode = btn.conditions_mode === "any" ? "any" : "all";
    const results = conds.map((c) => this._evalCondition(c));
    return mode === "any" ? results.some(Boolean) : results.every(Boolean);
  }

  _isGroupVisible(groupKey) {
    const c = this._config;
    if (c.position === "bottom-center" && groupKey === "vertical") return false;
    const baseEnabled = groupKey === "horizontal" ? !!c.horizontal.enabled : !!c.vertical.enabled;
    const override = this._groupOverride[groupKey];
    return override === null ? baseEnabled : !!override;
  }

  _wasTempOpened(groupKey) {
    const c = this._config;
    const baseEnabled = groupKey === "horizontal" ? !!c.horizontal.enabled : !!c.vertical.enabled;
    const override = this._groupOverride[groupKey];
    return baseEnabled === false && override === true;
  }

  _autoCloseTempMenus() {
    if (this._wasTempOpened("horizontal")) this._groupOverride.horizontal = null;
    if (this._wasTempOpened("vertical")) this._groupOverride.vertical = null;
    this.requestUpdate();
    this._scheduleMeasure();
  }

  _toggleGroup(target, mode) {
    const c = this._config;
    const applyOne = (key) => {
      if (c.position === "bottom-center" && key === "vertical") return;
      const baseEnabled = key === "horizontal" ? !!c.horizontal.enabled : !!c.vertical.enabled;
      const override = this._groupOverride[key];
      const current = override === null ? baseEnabled : !!override;
      let next = current;
      if (mode === "show") next = true;
      else if (mode === "hide") next = false;
      else next = !current;
      if (next === baseEnabled) this._groupOverride[key] = null;
      else this._groupOverride[key] = next;
    };
    if (target === "both") {
      applyOne("horizontal");
      applyOne("vertical");
    } else {
      applyOne(target);
    }
    this.requestUpdate();
    this._scheduleMeasure();
  }

  _computeOffsetX() {
    const c = this._config;
    const vw = window.innerWidth || document.documentElement.clientWidth || 0;
    if (vw < 768 && c.offset_x_mobile !== undefined && c.offset_x_mobile !== null) return c.offset_x_mobile;
    if (vw >= 768 && vw < 1024 && c.offset_x_tablet !== undefined && c.offset_x_tablet !== null) return c.offset_x_tablet;
    if (vw >= 1024 && c.offset_x_desktop !== undefined && c.offset_x_desktop !== null) return c.offset_x_desktop;
    return c.offset_x || 0;
  }

  _renderBottomBar() {
    const c = this._config;
    if (!c?.bottom_bar_enabled) return null;
    const height = Math.max(0, clampInt(c.bottom_bar_height, DEFAULTS.bottom_bar_height, 0));
    if (height <= 0) return null;

    const color = (typeof c.bottom_bar_color === "string" && c.bottom_bar_color.trim()) ? c.bottom_bar_color.trim() : DEFAULTS.bottom_bar_color;
    const opacity = Math.max(0, Math.min(1, clampNum(c.bottom_bar_opacity, DEFAULTS.bottom_bar_opacity)));
    const bottom = clampNum(c.bottom_bar_bottom_offset, DEFAULTS.bottom_bar_bottom_offset);
    const radius = Math.max(0, clampNum(c.bottom_bar_border_radius, DEFAULTS.bottom_bar_border_radius));
    const shadow = (typeof c.bottom_bar_box_shadow === "string" && c.bottom_bar_box_shadow.trim()) ? c.bottom_bar_box_shadow.trim() : "";
    const marginLeft = clampNum(c.bottom_bar_margin_left, DEFAULTS.bottom_bar_margin_left);
    const marginRight = clampNum(c.bottom_bar_margin_right, DEFAULTS.bottom_bar_margin_right);
    const borderWidth = Math.max(0, clampNum(c.bottom_bar_border_width, DEFAULTS.bottom_bar_border_width));
    const borderStyle = (typeof c.bottom_bar_border_style === "string" && c.bottom_bar_border_style.trim()) ? c.bottom_bar_border_style.trim() : DEFAULTS.bottom_bar_border_style;
    const borderColor = (typeof c.bottom_bar_border_color === "string" && c.bottom_bar_border_color.trim()) ? c.bottom_bar_border_color.trim() : "";

    const styleParts = [
      `height:${height}px`, `background:${color}`, `opacity:${opacity}`, `z-index:1`, `border-radius:${radius}px`, `bottom:${bottom}px`,
    ];
    if (shadow) styleParts.push(`box-shadow:${shadow}`);
    if (borderWidth > 0 && borderColor) styleParts.push(`border: ${borderWidth}px ${borderStyle} ${borderColor}`);

    const isFullWidth = c.bottom_bar_full_width || c.position !== "bottom-center";
    if (isFullWidth) {
      styleParts.push(`left:${marginLeft}px`, `right:${marginRight}px`);
    } else {
      this._scheduleMeasureBottomBar();
      if (this._bottomBarBounds) {
        const finalLeft = this._bottomBarBounds.left - marginLeft;
        const finalRight = this._bottomBarBounds.right - marginRight;
        styleParts.push(`left:${finalLeft}px`, `right:${finalRight}px`);
      } else {
        const offsetX = this._computeOffsetX();
        styleParts.push(`left:${offsetX - marginLeft}px`, `right:${offsetX - marginRight}px`);
      }
    }

    return html`<div class="bottom-bar" style="${styleParts.join(";")}"></div>`;
  }

  _measureAndLayout() {
    const c = this._config;
    if (!c || c.position === "bottom-center") return;
    const root = this.shadowRoot;
    if (!root) return;
    const slotEls = root.querySelectorAll(".abs-slot");
    if (!slotEls.length) return;

    const widthByKey = {};
    for (let i = 0; i < slotEls.length; i++) {
        const el = slotEls[i];
        const slotId = el.getAttribute("data-slot-id") || "";
        const fab = el.querySelector(".fab");
        const rect = fab ? fab.getBoundingClientRect() : null;
        widthByKey[slotId] = rect?.width ? Math.max(rect.width, 1) : c.button_size;
    }

    const plan = this._cornerSlotPlan();
    if (!plan) return;

    const gapX = c.gap;
    const gapY = c.vertical_gap;
    const stepY = c.button_size + gapY;
    const isRight = c.position === "bottom-right";
    const baseW = widthByKey[plan.baseKey] ?? c.button_size;
    const cols = Math.max(1, c.horizontal.columns);
    const hColW = new Array(cols).fill(c.button_size);

    for (let i = 0; i < plan.slots.length; i++) {
      const s = plan.slots[i];
      if (s.area !== "h") continue;
      const w = widthByKey[s.key] ?? c.button_size;
      const colIdx = s.col - 1;
      if (colIdx >= 0 && colIdx < cols) hColW[colIdx] = Math.max(hColW[colIdx], w);
    }
    const hSpan = baseW + (gapX * cols) + hColW.reduce((a, b) => a + b, 0);

    const vWrapCols = plan.vWrapCols || 0;
    const vWrapW = new Array(vWrapCols).fill(c.button_size);
    for (let i = 0; i < plan.slots.length; i++) {
      const s = plan.slots[i];
      if (s.area !== "v") continue;
      const w = widthByKey[s.key] ?? c.button_size;
      const wc = s.wrapCol;
      if (wc >= 0 && wc < vWrapCols) vWrapW[wc] = Math.max(vWrapW[wc], w);
    }

    const hPrefix = new Array(cols).fill(0);
    for (let i = 1; i < cols; i++) hPrefix[i] = hPrefix[i - 1] + hColW[i - 1] + gapX;

    const vPrefix = new Array(vWrapCols).fill(0);
    for (let i = 1; i < vWrapCols; i++) vPrefix[i] = vPrefix[i - 1] + vWrapW[i - 1] + gapX;

    const positions = {};
    positions[plan.baseKey] = isRight ? { x: -baseW, y: 0 } : { x: 0, y: 0 };

    for (let i = 0; i < plan.slots.length; i++) {
      const s = plan.slots[i];
      if (s.area !== "h") continue;
      const w = widthByKey[s.key] ?? c.button_size;
      const colIdx = s.col - 1;
      const y = -s.row * stepY;
      if (isRight) {
        const rightEdge = -(baseW + gapX + (hPrefix[colIdx] || 0));
        positions[s.key] = { x: rightEdge - w, y };
      } else {
        const leftEdge = baseW + gapX + (hPrefix[colIdx] || 0);
        positions[s.key] = { x: leftEdge, y };
      }
    }

    for (let i = 0; i < plan.slots.length; i++) {
      const s = plan.slots[i];
      if (s.area !== "v") continue;
      const w = widthByKey[s.key] ?? c.button_size;
      const y = -s.row * stepY;
      if (isRight) {
        if (s.wrapCol === 0) positions[s.key] = { x: -w, y };
        else {
          const rightEdge = -(hSpan + gapX + (vPrefix[s.wrapCol] || 0));
          positions[s.key] = { x: rightEdge - w, y };
        }
      } else {
        if (s.wrapCol === 0) positions[s.key] = { x: 0, y };
        else {
          const leftEdge = hSpan + gapX + (vPrefix[s.wrapCol] || 0);
          positions[s.key] = { x: leftEdge, y };
        }
      }
    }

    this._layout = { ready: true, slots: positions, meta: { baseW, hSpan, isRight } };
    this.requestUpdate();
  }

  _cornerSlotPlan() {
    const c = this._config;
    if (!c || c.position === "bottom-center") return null;

    const baseBtn = c.base?.button;
    const baseKey = baseBtn ? `base:${baseBtn.id}` : null;
    const horizontalVisible = this._isGroupVisible("horizontal");
    const verticalVisible = this._isGroupVisible("vertical");
    const hButtons = horizontalVisible ? (c.horizontal.buttons || []).filter((b) => this._isButtonVisible(b)) : [];
    const vButtons = verticalVisible ? (c.vertical.buttons || []).filter((b) => this._isButtonVisible(b)) : [];
    const slots = [];
    const cols = Math.max(1, c.horizontal.columns);
    const rows = Math.max(1, c.vertical.rows);

    for (let i = 0; i < hButtons.length; i++) {
      const row = Math.floor(i / cols);
      const col = 1 + (i % cols);
      const key = `h:${hButtons[i].id}`;
      slots.push({ area: "h", key, row, col });
    }
    let vWrapCols = 0;
    for (let j = 0; j < vButtons.length; j++) {
      const r = 1 + (j % rows);
      const wrapCol = Math.floor(j / rows);
      vWrapCols = Math.max(vWrapCols, wrapCol + 1);
      const key = `v:${vButtons[j].id}`;
      slots.push({ area: "v", key, row: r, wrapCol });
    }
    return { baseKey, slots, vWrapCols };
  }

  _handleAction(btn, which) {
    let hass = this.hass;
    // Fallback: If hass is missing (sometimes happens during view transitions), try to grab it from the main element
    if (!hass) {
        const main = document.querySelector("home-assistant");
        if (main && main.hass) hass = main.hass;
    }
    
    if (!hass) return;
    const action = (btn && btn[which]) || btn?.tap_action || { action: "none" };
    const type = action?.action || "none";
    if (type === "none") return;

    if (type === "toggle-group") {
      const target = action.target || "vertical";
      const mode = action.mode || "toggle";
      this._toggleGroup(target, mode);
      return;
    }
    if (type === "back") {
      history.back();
      setTimeout(() => fireEvent(window, "location-changed", {}), 0);
      this._autoCloseTempMenus();
      return;
    }
    if (type === "navigate") {
      const path = action.navigation_path || "/";
      history.pushState(null, "", path);
      fireEvent(window, "location-changed", {});
      this._autoCloseTempMenus();
      return;
    }
    if (type === "url") {
      const url = action.url_path;
      if (!url) return;
      window.open(url, action.new_tab === false ? "_self" : "_blank", "noreferrer");
      this._autoCloseTempMenus();
      return;
    }
    if (type === "toggle") {
      if (!btn?.entity) return;
      hass.callService("homeassistant", "toggle", { entity_id: btn.entity });
      this._autoCloseTempMenus();
      return;
    }
    if (type === "more-info") {
      if (!btn?.entity) return;
      fireEvent(this, "hass-more-info", { entityId: btn.entity });
      this._autoCloseTempMenus();
      return;
    }
    if (type === "perform-action") {
      if (!action.perform_action) return;
      const svc = action.perform_action;
      if (!svc.includes(".")) return;
      const [domain, service] = svc.split(".", 2);
      const serviceData = action.data || {};
      const target = action.target || {};
      hass.callService(domain, service, serviceData, target);
      this._autoCloseTempMenus();
      return;
    }
    if (type === "call-service") {
      // Legacy support for old call-service action
      const svc = action.service;
      if (!svc || !svc.includes(".")) return;
      const [domain, service] = svc.split(".", 2);
      let data = {};
      try {
        const raw = safeString(action.service_data || "");
        data = raw.trim() ? parseYamlLite(raw) : {};
      } catch (err) {
        console.warn("[HKI Navigation Card] Service data YAML parse failed:", err);
        data = {};
      }
      const targetEntity = safeString(action.target_entity || "").trim();
      if (targetEntity) data = { ...(data || {}), entity_id: targetEntity };
      hass.callService(domain, service, data || {});
      this._autoCloseTempMenus();
      return;
    }
    if (type === "fire-dom-event") {
      // Fire a custom DOM event with all properties except 'action'
      const eventDetail = {};
      Object.keys(action).forEach(key => {
        if (key !== 'action') {
          eventDetail[key] = action[key];
        }
      });
      const rawEventData = typeof action.event_data === "string" ? action.event_data.trim() : "";
      if (rawEventData) {
        try {
          const parsed = window.jsyaml?.load ? window.jsyaml.load(rawEventData) : JSON.parse(rawEventData);
          if (parsed !== undefined) eventDetail.data = parsed;
        } catch (_) {
          eventDetail.data = rawEventData;
        }
      }
      fireEvent(this, "ll-custom", eventDetail);
      this._autoCloseTempMenus();
      return;
    }
    this._autoCloseTempMenus();
  }

  _onPointerDown(e, btn) {
    e.stopPropagation();
    if (e.button === 2) return;
    const key = `${btn.id}:${e.pointerId}`;
    const t = setTimeout(() => {
      this._holdTimers.delete(key);
      this._handleAction(btn, "hold_action");
    }, 520);
    this._holdTimers.set(key, t);
  }

  _onPointerUp(e, btn) {
    e.stopPropagation();
    if (e.button === 2) return;
    const key = `${btn.id}:${e.pointerId}`;
    const holdTimer = this._holdTimers.get(key);
    if (holdTimer) {
      clearTimeout(holdTimer);
      this._holdTimers.delete(key);
    } else return;

    const now = Date.now();
    const dblWindow = 280;
    if (this._tapState.lastId === btn.id && (now - this._tapState.lastTime) < dblWindow) {
      if (this._tapState.singleTimer) clearTimeout(this._tapState.singleTimer);
      this._tapState = { lastId: null, lastTime: 0, singleTimer: null };
      this._handleAction(btn, "double_tap_action");
      return;
    }
    if (this._tapState.singleTimer) clearTimeout(this._tapState.singleTimer);
    this._tapState.lastId = btn.id;
    this._tapState.lastTime = now;
    this._tapState.singleTimer = setTimeout(() => {
      this._tapState = { lastId: null, lastTime: 0, singleTimer: null };
      this._handleAction(btn, "tap_action");
    }, dblWindow);
  }

  _onPointerCancel(e, btn) {
    const key = `${btn.id}:${e.pointerId}`;
    const holdTimer = this._holdTimers.get(key);
    if (holdTimer) clearTimeout(holdTimer);
    this._holdTimers.delete(key);
  }

  _onContextMenu(e, btn) {
    e.preventDefault();
    e.stopPropagation();
    this._handleAction(btn, "hold_action");
  }

  _isPillType(type) {
    return type === "pill" || type === "pill_label";
  }

  _renderButton(btn) {
    const type = this._getButtonType(btn);
    const labelText = this._getLabelText(btn);
    const hasLabel = !!labelText;
    const isPill = this._isPillType(type);
    const showIcon = type === "icon" || type === "icon_label_below" || type === "icon_label_left" || type === "icon_label_right" || type === "pill";
    const showBubbleBelow = type === "icon_label_below" && hasLabel;
    const showBubbleLeft = type === "icon_label_left" && hasLabel;
    const showBubbleRight = type === "icon_label_right" && hasLabel;
    const showPillText = isPill && hasLabel;
    const bg = this._buttonBg(btn);
    const iconColor = this._buttonIconColor(btn);
    const isBackTap = (btn?.tap_action?.action === "back");
    const icon = isBackTap ? "mdi:chevron-left" : (btn.icon && btn.icon.trim()) ? btn.icon : "mdi:circle";
    const pillWidth = isPill ? this._getPillWidth(btn) : 0;
    const pillFixed = isPill && pillWidth > 0;
    const radius = this._buttonBorderRadius(btn);
    const bw = this._buttonBorderWidth(btn);
    const bs = this._buttonBorderStyle(btn);
    const bc = this._buttonBorderColor(btn);
    const btnStyleParts = [`background:${bg}`, `color:${iconColor}`, `border-radius:${radius}px`];
    btnStyleParts.push(bw > 0 ? `border:${bw}px ${bs} ${bc}` : `border:none`);
    if (pillFixed) btnStyleParts.push(`width:${pillWidth}px`);
    if (typeof btn.box_shadow === "string" && btn.box_shadow.trim()) btnStyleParts.push(`--hki-button-shadow:${btn.box_shadow.trim()}`);
    if (typeof btn.box_shadow_hover === "string" && btn.box_shadow_hover.trim()) btnStyleParts.push(`--hki-button-shadow-hover:${btn.box_shadow_hover.trim()}`);
    const floatGap = 10;
    const floatSide = showBubbleLeft ? "left" : (showBubbleRight ? "right" : null);

    return html`
      <div class="item ${showBubbleBelow ? "item-v" : "item-float"}">
        <div class="float-wrap">
          <button
            class="fab ${isPill ? "fab-pill" : ""} ${pillFixed ? "pill-fixed" : ""}"
            title="${btn.tooltip || ""}"
            aria-label="${btn.tooltip || btn.label || icon || "button"}"
            style="${btnStyleParts.join(";")}"
            @pointerdown=${(e) => this._onPointerDown(e, btn)}
            @pointerup=${(e) => this._onPointerUp(e, btn)}
            @pointercancel=${(e) => this._onPointerCancel(e, btn)}
            @contextmenu=${(e) => this._onContextMenu(e, btn)}
          >
            ${showIcon ? html`<ha-icon class="fab-icon" .icon=${icon}></ha-icon>` : html``}
            ${showPillText ? html`<span class="pill-text" style="${this._pillTextStyle(btn)}">${labelText}</span>` : html``}
          </button>
          ${floatSide === "left" ? html`<div class="label label-float" style="${this._labelBubbleStyle(btn)}; right: calc(100% + ${floatGap}px); top: 50%; transform: translateY(-50%);">${labelText}</div>` : html``}
          ${floatSide === "right" ? html`<div class="label label-float" style="${this._labelBubbleStyle(btn)}; left: calc(100% + ${floatGap}px); top: 50%; transform: translateY(-50%);">${labelText}</div>` : html``}
        </div>
        ${showBubbleBelow ? html`<div class="label" style="${this._labelBubbleStyle(btn)}">${labelText}</div>` : html``}
      </div>
    `;
  }

  render() {
    if (!this._config) return html``;
    const c = this._config;
    const editMode = this._isEditMode();
    const inPreviewContext = this._isInPreviewContext();
    const showEditPlaceholder = editMode && !inPreviewContext;
    const offsetX = this._computeOffsetX();
    const offsetY = c.offset_y;

    let spacerHtml = html``;
    if (c.reserve_space) {
        let heightNeeded = 0;
        if (c.bottom_bar_enabled) {
            heightNeeded = (c.bottom_bar_height || DEFAULTS.bottom_bar_height) + (c.bottom_bar_bottom_offset || 0);
        } else {
            heightNeeded = c.button_size + offsetY + 10;
        }
        spacerHtml = html`<div class="hki-spacer" style="height: ${heightNeeded}px; width: 100%; clear: both;"></div>`;
    }

    const anchorStyle = (() => {
      if (c.position === "bottom-center") {
        if (c.center_spread) return `left:0px; right:0px; bottom:${offsetY}px;`;
        const lm = this._contentLeftMargin || 0;
        const rm = this._contentRightMargin || 0;
        const shift = (lm - rm) / 2;
        if (Math.abs(shift) > 0.5) return `left:calc(50% + ${shift}px); transform:translateX(-50%); bottom:${offsetY}px;`;
        return `left:50%; transform:translateX(-50%); bottom:${offsetY}px;`;
      }
      if (c.position === "bottom-left") {
        const lm = this._contentLeftMargin || 0;
        return `left:${offsetX + lm}px; bottom:${offsetY}px;`;
      }
      const rm = this._contentRightMargin || 0;
      return `right:${offsetX + rm}px; bottom:${offsetY}px;`;
    })();

    const shadowVars = [];
    if (typeof c.button_box_shadow === "string" && c.button_box_shadow.trim()) shadowVars.push(`--hki-button-shadow:${c.button_box_shadow.trim()}`);
    if (typeof c.button_box_shadow_hover === "string" && c.button_box_shadow_hover.trim()) shadowVars.push(`--hki-button-shadow-hover:${c.button_box_shadow_hover.trim()}`);
    const shadowVarStyle = shadowVars.length ? `; ${shadowVars.join(";")}` : "";
    const base = c.base?.button;

    const placeholder = showEditPlaceholder ? html`
          <ha-card class="edit-placeholder">
            <div class="edit-placeholder-inner">
              <ha-icon icon="mdi:gesture-tap-button"></ha-icon>
              <div class="edit-placeholder-text">
                <div class="t1">HKI Navigation Card</div>
                <div class="t2">Fixed-position buttons â€¢ This placeholder makes the card easy to select in edit mode</div>
              </div>
            </div>
          </ha-card>` : html``;

    if (c.position === "bottom-center") {
      const horizontalVisible = this._isGroupVisible("horizontal");
      const hButtons = horizontalVisible ? (c.horizontal.buttons || []).filter((b) => this._isButtonVisible(b)) : [];
      const all = [base, ...hButtons];
      const cols = Math.max(1, clampInt(c.horizontal.columns, DEFAULTS.horizontal.columns, 1));
      const rows = [];
      for (let i = 0; i < all.length; i += cols) rows.push(all.slice(i, i + cols));
      const justify = c.center_spread ? "space-between" : "center";
      const padLeft = c.center_spread ? `${(this._contentLeftMargin || 0) + offsetX}px` : "0px";
      const padRight = c.center_spread ? `${(this._contentRightMargin || 0) + offsetX}px` : "0px";

      return html`
        ${spacerHtml}
        ${placeholder}
        ${this._renderBottomBar()}
        <div class="fab-anchor" style="${anchorStyle} z-index:${c.z_index}; --hki-size:${c.button_size}px; --hki-gap:${c.gap}px${shadowVarStyle};">
          <div class="center-stack ${c.center_spread ? "spread" : ""}" style="padding:0 ${padRight} 0 ${padLeft}; gap:${c.vertical_gap}px;">
            ${rows.map((row) => html`<div class="center-row" style="justify-content:${justify};">${row.map((btn) => this._renderButton(btn))}</div>`)}
          </div>
        </div>
      `;
    }

    const horizontalVisible = this._isGroupVisible("horizontal");
    const verticalVisible = this._isGroupVisible("vertical");
    const hButtons = horizontalVisible ? (c.horizontal.buttons || []).filter((b) => this._isButtonVisible(b)) : [];
    const vButtons = verticalVisible ? (c.vertical.buttons || []).filter((b) => this._isButtonVisible(b)) : [];
    const slots = [{ key: `base:${base.id}`, btn: base }];
    for (let i = 0; i < hButtons.length; i++) slots.push({ key: `h:${hButtons[i].id}`, btn: hButtons[i] });
    for (let j = 0; j < vButtons.length; j++) slots.push({ key: `v:${vButtons[j].id}`, btn: vButtons[j] });

    return html`
      ${spacerHtml}
      ${placeholder}
      ${this._renderBottomBar()}
      <div class="fab-anchor" style="${anchorStyle} z-index:${c.z_index}; --hki-size:${c.button_size}px; --hki-gap:${c.gap}px${shadowVarStyle};">
        <div class="abs-grid">
          ${slots.map((s) => {
            const pos = this._layout?.slots?.[s.key];
            const tx = pos ? pos.x : 0;
            const ty = pos ? pos.y : 0;
            const style = pos ? `transform: translate(${tx}px, ${ty}px);` : `transform: translate(0px,0px);`;
            return html`<div class="abs-slot" data-slot-id="${s.key}" style="${style}">${this._renderButton(s.btn)}</div>`;
          })}
        </div>
      </div>
    `;
  }

  static get styles() {
    return css`
      :host { display: block; overflow: visible; }
      .edit-placeholder { border-radius: 14px; border: 2px dashed rgba(160, 160, 160, 0.35); background: rgba(0,0,0,0.02); }
      .edit-placeholder-inner { display:flex; align-items:center; gap:12px; padding:12px; }
      .edit-placeholder-text { min-width:0; }
      .t1 { font-weight:800; }
      .t2 { opacity:0.7; font-size:12px; }
      .fab-anchor { position: fixed; pointer-events: none; }
      .bottom-bar { position: fixed; bottom: 0; pointer-events: none; }
      .abs-grid, .abs-slot, .item, .label { pointer-events: none; }
      .abs-grid { position: relative; width: 0; height: 0; overflow: visible; }
      .abs-slot { position: absolute; left: 0; bottom: 0; will-change: transform; }
      .center-stack { pointer-events: none; display: flex; flex-direction: column-reverse; align-items: stretch; }
      .center-row { pointer-events: none; display: flex; align-items: center; gap: var(--hki-gap); width: fit-content; margin: 0 auto; }
      .center-stack.spread .center-row { width: 100%; margin: 0; }
      .item { display: flex; flex-direction: column; align-items: center; gap: 6px; }
      .item-float .float-wrap { pointer-events: none; position: relative; display: inline-flex; align-items: center; justify-content: center; }
      .item-v { display: flex; flex-direction: column; align-items: center; gap: 6px; }
      .fab {
        pointer-events: auto; width: var(--hki-size); height: var(--hki-size); border-radius: 999px; border: none; outline: none; cursor: pointer;
        display: inline-flex; align-items: center; justify-content: center; position: relative;
        box-shadow: var(--hki-button-shadow, 0 8px 24px rgba(0, 0, 0, 0.35));
        transition: transform 120ms ease, box-shadow 120ms ease, filter 120ms ease;
        filter: saturate(1.05); touch-action: manipulation; will-change: transform;
      }
      .fab:hover { transform: translateY(-1px); box-shadow: var(--hki-button-shadow-hover, 0 10px 30px rgba(0, 0, 0, 0.42)); }
      .fab:active { transform: translateY(0px) scale(0.98); }
      .fab-icon { --mdc-icon-size: calc(var(--hki-size) * 0.48); width: var(--mdc-icon-size); height: var(--mdc-icon-size); }
      .fab-pill { width: auto; min-width: max(var(--hki-size), ${MIN_PILL_WIDTH}px); padding: 0 calc(var(--hki-size) * 0.32); gap: calc(var(--hki-size) * 0.14); justify-content: center; border-radius: 999px; }
      .pill-fixed { padding: 0 calc(var(--hki-size) * 0.24); min-width: ${MIN_PILL_WIDTH}px; }
      .pill-text { line-height: 1; white-space: nowrap; overflow: visible; text-overflow: ellipsis; max-width: 260px; }
      .label { pointer-events: none; line-height: 1.1; border-radius: 999px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .label-float { position: absolute; }
    `;
  }
}

/* -------------------------- Editor -------------------------- */
class HkiNavigationCardEditor extends LitElement {
  static get properties() {
    return { hass: {}, _config: { state: true }, _expanded: { state: true }, _yamlErrors: { state: true } };
  }
  constructor() { super(); this._expanded = {}; this._yamlErrors = {}; this._paDomainCache = {}; }
  setConfig(config) { this._config = normalizeConfig(config); }
  get _c() { return this._config || normalizeConfig({}); }
  _cleanupConfig(config) {
    if (!config || typeof config !== 'object') return config;
    
    const clean = Array.isArray(config) ? [...config] : { ...config };
    
    Object.keys(clean).forEach(key => {
      const value = clean[key];
      
      // Remove empty strings
      if (value === "") {
        delete clean[key];
        return;
      }
      
      // Remove empty objects
      if (value && typeof value === 'object' && !Array.isArray(value) && Object.keys(value).length === 0) {
        delete clean[key];
        return;
      }
      
      // Remove empty arrays
      if (Array.isArray(value) && value.length === 0) {
        delete clean[key];
        return;
      }
      
      // Recursively clean nested objects and arrays
      if (value && typeof value === 'object') {
        clean[key] = this._cleanupConfig(value);
        // After cleaning, remove if it became empty
        if (typeof clean[key] === 'object' && !Array.isArray(clean[key]) && Object.keys(clean[key]).length === 0) {
          delete clean[key];
        } else if (Array.isArray(clean[key]) && clean[key].length === 0) {
          delete clean[key];
        }
      }
    });
    
    return clean;
  }
  
  _emit(cfg) { 
    const cleaned = this._cleanupConfig(cfg);
    this._config = cleaned; 
    
    // Remove defaults for minimal config
    const minimal = removeDefaults(cleaned, DEFAULTS);
    this._config = minimal;
    fireEvent(this, "config-changed", { config: minimal });
  }
  _applyGlobalAndClearOverrides(keyPath, mutateFn) {
    const cfg = deepClone(this._c);
    mutateFn(cfg);
    const clearOnBtn = (btn) => {
      const b = { ...btn };
      if (keyPath.startsWith("label_style.")) {
        const k = keyPath.split(".")[1];
        const ls = { ...(b.label_style || {}) };
        delete ls[k];
        b.label_style = ls;
        return b;
      }
      if (keyPath === "pill_width") { b.pill_width = ""; return b; }
      if (keyPath === "background") { b.background = ""; return b; }
      if (keyPath === "background_opacity") { b.background_opacity = ""; return b; }
      if (keyPath === "border_radius") { b.border_radius = ""; return b; }
      if (keyPath === "border_style") { b.border_style = ""; return b; }
      if (keyPath === "border_width") { b.border_width = ""; return b; }
      if (keyPath === "border_color") { b.border_color = ""; return b; }
      if (keyPath === "icon_color") { b.icon_color = ""; return b; }
      return b;
    };
    cfg.horizontal.buttons = (cfg.horizontal.buttons || []).map(clearOnBtn);
    cfg.vertical.buttons = (cfg.vertical.buttons || []).map(clearOnBtn);
    cfg.base.button = clearOnBtn(cfg.base.button);
    this._emit(cfg);
  }
  _setValue(key, value) { const cfg = deepClone(this._c); cfg[key] = value; this._emit(cfg); }
  _setBool(path, value) {
    const cfg = deepClone(this._c);
    const parts = path.split(".");
    let obj = cfg;
    for (let i = 0; i < parts.length - 1; i++) obj = obj[parts[i]];
    obj[parts[parts.length - 1]] = !!value;
    this._emit(cfg);
  }
  _setLabelStyleGlobal(key, value) { this._applyGlobalAndClearOverrides(`label_style.${key}`, (cfg) => { cfg.label_style = cfg.label_style || {}; cfg.label_style[key] = value; }); }
  _setDefaultBackground(value) { this._applyGlobalAndClearOverrides("background", (cfg) => { cfg.default_background = value; }); }
  _setDefaultIconColor(value) { this._applyGlobalAndClearOverrides("icon_color", (cfg) => { cfg.default_icon_color = value; }); }
  _setDefaultButtonOpacity(value) { this._applyGlobalAndClearOverrides("background_opacity", (cfg) => { cfg.default_button_opacity = Math.max(0, Math.min(1, Number(value))); }); }
  _setDefaultBorderRadius(value) { this._applyGlobalAndClearOverrides("border_radius", (cfg) => { cfg.default_border_radius = Math.max(0, Number(value)); }); }
  _setDefaultBorderStyle(value) { this._applyGlobalAndClearOverrides("border_style", (cfg) => { cfg.default_border_style = safeString(value).trim(); }); }
  _setDefaultBorderWidth(value) { this._applyGlobalAndClearOverrides("border_width", (cfg) => { cfg.default_border_width = Math.max(0, Number(value)); }); }
  _setDefaultBorderColor(value) { this._applyGlobalAndClearOverrides("border_color", (cfg) => { cfg.default_border_color = safeString(value); }); }
  _setGlobalPillWidth(value) { this._applyGlobalAndClearOverrides("pill_width", (cfg) => { const n = Number(value); cfg.pill_width = n <= 0 ? 0 : Math.max(MIN_PILL_WIDTH, n); }); }
  _listKey(group) { return group === "vertical" ? "vertical" : "horizontal"; }
  _getButtons(group) { const g = this._listKey(group); return (this._c[g]?.buttons || []); }
  _setButtons(group, nextButtons) { const cfg = deepClone(this._c); const g = this._listKey(group); cfg[g].buttons = nextButtons; this._emit(cfg); }
  _setButtonById(group, btnId, patch) {
    const buttons = [...this._getButtons(group)];
    const idx = buttons.findIndex((b) => b?.id === btnId);
    if (idx < 0) return;
    buttons[idx] = { ...(buttons[idx] || {}), ...patch };
    this._setButtons(group, buttons);
  }
  _removeButtonById(group, btnId) { const buttons = this._getButtons(group).filter((b) => b?.id !== btnId); delete this._expanded[`${group}:${btnId}`]; this._setButtons(group, buttons); }
  _moveButtonById(group, btnId, dir) {
    const buttons = [...this._getButtons(group)];
    const i = buttons.findIndex((b) => b?.id === btnId);
    const j = i + dir;
    if (i < 0 || j < 0 || j >= buttons.length) return;
    [buttons[i], buttons[j]] = [buttons[j], buttons[i]];
    this._setButtons(group, buttons);
  }
  _addButton(group) { const buttons = [...this._getButtons(group)]; buttons.push(DEFAULT_BUTTON()); this._setButtons(group, buttons); }
  _renderEntityPicker(label, value, onChange) {
    if (customElements.get("ha-selector")) return html`<ha-selector .hass=${this.hass} .label=${label} .selector=${{ entity: {} }} .value=${value || ""} @value-changed=${(e) => onChange(e.detail?.value ?? "")}></ha-selector>`;
    if (customElements.get("ha-entity-picker")) return html`<ha-entity-picker .hass=${this.hass} .label=${label} .value=${value || ""} allow-custom-entity @value-changed=${(e) => onChange(e.detail?.value ?? "")}></ha-entity-picker>`;
    return html`<ha-textfield .label=${label} .value=${value || ""} placeholder="light.kitchen" @change=${(e) => onChange(e.target.value)}></ha-textfield>`;
  }
  _renderNavigationPathPicker(label, value, onChange) {
    const val = value || "";
    if (customElements.get("ha-navigation-picker")) return html`<ha-navigation-picker .hass=${this.hass} .label=${label} .value=${val} @value-changed=${(e) => onChange(e.detail?.value ?? "")}></ha-navigation-picker>`;
    if (customElements.get("ha-selector")) return html`<ha-selector .hass=${this.hass} .label=${label} .selector=${{ navigation: {} }} .value=${val} @value-changed=${(e) => onChange(e.detail?.value ?? "")}></ha-selector>`;
    return html`<ha-textfield .label=${label} .value=${val} placeholder="/lovelace/0" @change=${(e) => onChange(e.target.value)}></ha-textfield>`;
  }
  _renderCodeEditor(label, value, onChange, errorKey) {
    const showError = !!this._yamlErrors[errorKey];
    const validate = (v) => {
      const t = safeString(v);
      if (!t.trim()) { delete this._yamlErrors[errorKey]; this.requestUpdate(); return; }
      try { parseYamlLite(t); delete this._yamlErrors[errorKey]; } catch (e) { this._yamlErrors[errorKey] = safeString(e?.message || e); }
      this.requestUpdate();
    };
    if (customElements.get("ha-yaml-editor")) return html`<div class="code-wrap"><div class="code-label">${label}</div><ha-yaml-editor .hass=${this.hass} .value=${value || ""} @value-changed=${(e) => { const v = e.detail?.value ?? ""; onChange(v); validate(v); }}></ha-yaml-editor>${showError ? html`<ha-alert alert-type="error">YAML error: ${this._yamlErrors[errorKey]}</ha-alert>` : html``}</div>`;
    if (customElements.get("ha-code-editor")) return html`<div class="code-wrap"><div class="code-label">${label}</div><ha-code-editor .hass=${this.hass} .mode=${"yaml"} .value=${value || ""} @value-changed=${(e) => { const v = e.detail?.value ?? ""; onChange(v); validate(v); }}></ha-code-editor>${showError ? html`<ha-alert alert-type="error">YAML error: ${this._yamlErrors[errorKey]}</ha-alert>` : html``}</div>`;
    return html`<ha-textarea .label=${label} .value=${value || ""} @change=${(e) => { const v = e.target.value; onChange(v); validate(v); }}></ha-textarea>${showError ? html`<ha-alert alert-type="error">YAML error: ${this._yamlErrors[errorKey]}</ha-alert>` : html``}`;
  }
  _renderActionEditor(btn, setBtnFn, which, title, errorKeyPrefix) {
    const act = btn?.[which] || { action: "none" };
    const type = act.action || "none";
    const errorKey = `${errorKeyPrefix}:${which}`;
    const update = (patch) => {
      const current = btn?.[which] || { action: "none" };
      let nextAction = { ...current, ...patch };
      // Clean up conflicts when action type changes
      if (patch.action) {
        nextAction = cleanupActionConflicts(nextAction);
      }
      const next = { ...btn, [which]: nextAction };
      if (which === "tap_action" && patch.action === "back") next.icon = "mdi:chevron-left";
      setBtnFn(next);
    };
    return html`
      <div class="subsection"><div class="subheader">${title}</div>
        <ha-select .label=${"Action type"} .value=${type} @selected=${(e) => update({ action: e.target.value })} @closed=${(e) => e.stopPropagation()}>${ACTIONS.map((a) => html`<mwc-list-item .value=${a.value}>${a.label}</mwc-list-item>`)}</ha-select>
        ${type === "navigate" ? html`${this._renderNavigationPathPicker("Navigation path", act.navigation_path || "", (v) => update({ navigation_path: v }))}` : html``}
        ${type === "url" ? html`<ha-textfield .label=${"URL"} .value=${act.url_path || ""} placeholder="https://example.com" @change=${(e) => update({ url_path: e.target.value })}></ha-textfield><ha-formfield .label=${"Open in new tab"}><ha-switch .checked=${act.new_tab !== false} @change=${(e) => update({ new_tab: e.target.checked })}></ha-switch></ha-formfield>` : html``}
        ${type === "toggle-group" ? html`<div class="grid2"><ha-select .label=${"Target group"} .value=${act.target || "vertical"} @selected=${(e) => update({ target: e.target.value })} @closed=${(e) => e.stopPropagation()}>${GROUP_TARGETS.map((g) => html`<mwc-list-item .value=${g.value}>${g.label}</mwc-list-item>`)}</ha-select><ha-select .label=${"Mode"} .value=${act.mode || "toggle"} @selected=${(e) => update({ mode: e.target.value })} @closed=${(e) => e.stopPropagation()}>${GROUP_ACTIONS.map((m) => html`<mwc-list-item .value=${m.value}>${m.label}</mwc-list-item>`)}</ha-select></div><div class="hint">Tip: Disable a group below, then use this action to open it temporarily. It auto-closes after pressing any other button.</div>` : html``}
        ${type === "perform-action" ? html`
          ${customElements.get("ha-service-picker") ? html`
            <ha-service-picker
              .hass=${this.hass}
              .label=${"Action (service)"}
              .value=${act.perform_action || ""}
              @value-changed=${(ev) => {
                ev.stopPropagation();
                const v = ev.detail?.value ?? ev.target?.value ?? "";
                update({ perform_action: safeString(v) });
              }}
              @click=${(e) => e.stopPropagation()}
            ></ha-service-picker>
          ` : html`
            ${(() => {
              const key = `${btn?.id || ''}:${which}`;
              const full = safeString(act.perform_action);
              const derivedDomain = full.includes('.') ? full.split('.')[0] : '';
              const cachedDomain = this._paDomainCache?.[key] || '';
              const domain = cachedDomain || derivedDomain;
              const derivedService = (full.includes('.') && derivedDomain === domain) ? (full.split('.')[1] || '') : '';
              const services = (domain && this.hass?.services?.[domain]) ? Object.keys(this.hass.services[domain]).sort() : [];
              return html`
                <div class="grid2">
                  <ha-select
                    .label=${"Domain"}
                    .value=${domain || undefined}
                    @selected=${(e) => {
                      const nextDomain = e.target.value || '';
                      this._paDomainCache[key] = nextDomain;
                      // Clear service when domain changes
                      update({ perform_action: '' });
                      this.requestUpdate();
                    }}
                    @closed=${(e) => e.stopPropagation()}
                  >
                    <mwc-list-item value=""></mwc-list-item>
                    ${Object.keys(this.hass?.services || {}).sort().map((d) => html`<mwc-list-item .value=${d}>${d}</mwc-list-item>`)}
                  </ha-select>

                  <ha-select
                    .label=${"Service"}
                    .value=${derivedService || undefined}
                    .disabled=${!domain}
                    @selected=${(e) => {
                      const service = e.target.value || '';
                      const d = this._paDomainCache[key] || domain;
                      update({ perform_action: (d && service) ? `${d}.${service}` : '' });
                    }}
                    @closed=${(e) => e.stopPropagation()}
                  >
                    <mwc-list-item value=""></mwc-list-item>
                    ${services.map((s) => html`<mwc-list-item .value=${s}>${s}</mwc-list-item>`)}
                  </ha-select>
                </div>
              `;
            })()}
          `}

          <ha-selector
            .hass=${this.hass}
            .selector=${{ target: {} }}
            .label=${"Target (optional)"}
            .value=${act.target || null}
            @value-changed=${(ev) => {
              ev.stopPropagation();
              const target = ev.detail?.value;
              if (JSON.stringify(act.target) !== JSON.stringify(target)) {
                if (target && Object.keys(target).length > 0) {
                  update({ target: target });
                } else {
                  const next = { ...act };
                  delete next.target;
                  setBtnFn({ ...btn, [which]: next });
                }
              }
            }}
            @click=${(e) => e.stopPropagation()}
          ></ha-selector>

          <ha-yaml-editor
            .hass=${this.hass}
            .label=${"Service Data (optional, YAML)"}
            .value=${act.data || null}
            @value-changed=${(ev) => {
              ev.stopPropagation();
              const data = ev.detail?.value;
              if (JSON.stringify(act.data) !== JSON.stringify(data)) {
                if (data && typeof data === 'object' && Object.keys(data).length > 0) {
                  update({ data: data });
                } else {
                  const next = { ...act };
                  delete next.data;
                  setBtnFn({ ...btn, [which]: next });
                }
              }
            }}
            @click=${(e) => e.stopPropagation()}
          ></ha-yaml-editor>
        ` : html``}
        ${type === "fire-dom-event" ? html`
          <ha-textfield .label=${"Event Name (optional)"} .value=${act.event_name || ""} @change=${(e) => update({ event_name: e.target.value || "" })}></ha-textfield>
          ${this._yamlEditor("Event Data (YAML/JSON text)", act.event_data || "", (v) => update({ event_data: v || "" }), `${errorKey}:event_data`)}
        ` : html``}

        ${type === "toggle" || type === "more-info" ? html`<div class="hint">Uses the buttonâ€™s <b>Entity</b> field (set above in Interaction & Data).</div>` : html``}
        ${type === "back" ? html`<div class="hint">Back uses browser history. (Tap action forces icon to mdi:chevron-left.)</div>` : html``}
      </div>`;
  }
  _renderConditions(btn, setBtnFn) {
    const conditions = Array.isArray(btn.conditions) ? btn.conditions : [];
    const mode = btn.conditions_mode === "any" ? "any" : "all";
    const add = () => { const next = { ...btn, conditions: [...conditions, { id: _uid(), type: "entity", entity: "", attribute: "", operator: "equals", value: "", invert: false }] }; setBtnFn(next); };
    const setCond = (id, patch) => { const nextConds = conditions.map((c) => (c.id === id ? { ...c, ...patch } : c)); setBtnFn({ ...btn, conditions: nextConds }); };
    const remove = (id) => { setBtnFn({ ...btn, conditions: conditions.filter((c) => c.id !== id) }); };
    const parseCsv = (s) => safeString(s).split(",").map((x) => x.trim()).filter(Boolean);
    const csvString = (arr) => (Array.isArray(arr) ? arr.join(", ") : "");
    return html`
      <div class="subsection">
        <div class="subheader row"><span>Visibility</span><mwc-button outlined @click=${add}><ha-icon icon="mdi:plus"></ha-icon>&nbsp;Add condition</mwc-button></div>
        <ha-select .label=${"Condition mode"} .value=${mode} @selected=${(e) => setBtnFn({ ...btn, conditions_mode: e.target.value })} @closed=${(e) => e.stopPropagation()}><mwc-list-item value="all">All conditions (AND)</mwc-list-item><mwc-list-item value="any">Any condition (OR)</mwc-list-item></ha-select>
        ${conditions.length === 0 ? html`<div class="hint">No conditions â†’ button is always visible.</div>` : html``}
        ${conditions.map((cond) => {
          const type = cond.type || "entity";
          const title = type === "entity" ? (cond.entity || "(entity)") : type === "user" ? "User" : type === "view" ? "View" : "Screen";
          return html`<div class="cond"><div class="cond-head"><div class="cond-title">${title}${cond.invert ? " â€¢ inverted" : ""}</div><mwc-icon-button title="Remove" @click=${() => remove(cond.id)}><ha-icon icon="mdi:trash-can-outline"></ha-icon></mwc-icon-button></div><div class="grid2"><ha-select .label=${"Condition type"} .value=${type} @selected=${(e) => setCond(cond.id, { type: e.target.value })} @closed=${(e) => e.stopPropagation()}>${CONDITION_TYPES.map((t) => html`<mwc-list-item .value=${t.value}>${t.label}</mwc-list-item>`)}</ha-select><ha-formfield .label=${"Invert result"}><ha-switch .checked=${!!cond.invert} @change=${(e) => setCond(cond.id, { invert: e.target.checked })}></ha-switch></ha-formfield></div>
              ${type === "entity" ? html`<div class="grid2">${this._renderEntityPicker("Entity", cond.entity || "", (v) => setCond(cond.id, { entity: v }))}<ha-textfield .label=${"Attribute (optional)"} .value=${cond.attribute || ""} placeholder="brightness" @change=${(e) => setCond(cond.id, { attribute: e.target.value })}></ha-textfield><ha-select .label=${"Operator"} .value=${cond.operator || "equals"} @selected=${(e) => setCond(cond.id, { operator: e.target.value })} @closed=${(e) => e.stopPropagation()}>${ENTITY_OPERATORS.map((o) => html`<mwc-list-item .value=${o.value}>${o.label}</mwc-list-item>`)}</ha-select>${(cond.operator === "exists" || cond.operator === "not_exists") ? html`<div></div>` : html`<ha-textfield .label=${"Value"} .value=${cond.value ?? ""} placeholder="on" @change=${(e) => setCond(cond.id, { value: e.target.value })}></ha-textfield>`}</div>` : html``}
              ${type === "user" ? html`<ha-textfield .label=${"Users (comma-separated names)"} .value=${csvString(cond.users)} placeholder="Jimmy Schings, Alex" @change=${(e) => setCond(cond.id, { users: parseCsv(e.target.value) })}></ha-textfield>` : html``}
              ${type === "view" ? html`<ha-textfield .label=${"Views (comma-separated paths)"} .value=${csvString(cond.views)} placeholder="/lovelace/0, /lovelace/home" @change=${(e) => setCond(cond.id, { views: parseCsv(e.target.value) })}></ha-textfield>` : html``}
              ${type === "screen" ? html`<ha-select .label=${"Screen mode"} .value=${cond.mode || "mobile"} @selected=${(e) => setCond(cond.id, { mode: e.target.value })} @closed=${(e) => e.stopPropagation()}><mwc-list-item value="mobile">Mobile</mwc-list-item><mwc-list-item value="desktop">Desktop</mwc-list-item></ha-select>` : html``}</div>`;
        })}
      </div>`;
  }
  _renderButtonPanel(btn, setBtnFn, errorKeyPrefix, allowConditions = true) {
    const hasIconPicker = !!customElements.get("ha-icon-picker");
    const effectiveType = (() => { const v = safeString(btn.button_type).trim(); if (v && BUTTON_TYPES.some((t) => t.value === v)) return v; return INHERIT; })();
    const pillTypeSelected = effectiveType === "pill" || effectiveType === "pill_label";
    return html`
    <div class="category-wrapper">
      <details><summary class="cat-head">Visual Customization</summary><div class="cat-content">
        ${hasIconPicker ? html`<ha-icon-picker .label=${"Icon"} .value=${btn.icon || ""} @value-changed=${(e) => setBtnFn({ ...btn, icon: e.detail.value })}></ha-icon-picker>` : html`<ha-textfield .label=${"Icon (mdi:...)"} .value=${btn.icon || ""} placeholder="mdi:home" @change=${(e) => setBtnFn({ ...btn, icon: e.target.value })}></ha-textfield>`}
        <div class="grid2">
            <ha-select .label=${"Button Type"} .value=${effectiveType} @selected=${(e) => { const v = e.target.value; setBtnFn({ ...btn, button_type: v === INHERIT ? "" : v }); }} @closed=${(e) => e.stopPropagation()}><mwc-list-item .value=${INHERIT}>(inherit default)</mwc-list-item>${BUTTON_TYPES.map((t) => html`<mwc-list-item .value=${t.value}>${t.label}</mwc-list-item>`)}</ha-select>
            <ha-textfield .label=${"Tooltip (optional)"} .value=${btn.tooltip || ""} @change=${(e) => setBtnFn({ ...btn, tooltip: e.target.value })}></ha-textfield>
        </div>
        <div class="subheader" style="margin: 10px 0 6px 0;">Button label</div>
                ${customElements.get("ha-code-editor") ? html`
                  <ha-code-editor
                    .hass=${this.hass}
                    .mode=${"yaml"}
                    autocomplete-entities
                    .autocompleteEntities=${true}
                    .label=${"Label (accepts jinja2 templates)"}
                    .value=${btn.label ?? ""}
                    @value-changed=${(ev) => {
                      ev.stopPropagation();
                      const raw = ev.detail?.value;
                      const newValue = typeof raw === "string" ? raw : "";
                      if (newValue !== (btn.label ?? "")) {
                        const updatedBtn = { ...btn };
                        const v = newValue;
                        // IMPORTANT: don't delete the property here.
                        // The editor's setBtnFn ultimately calls _setButtonById(),
                        // which merges patches into the existing button object.
                        // If we delete the property, the merge keeps the old label.
                        // Setting it to an empty string overwrites the old value,
                        // and _cleanupConfig() will remove the empty string before
                        // emitting the final config.
                        if (!v.trim()) updatedBtn.label = "";
                        else updatedBtn.label = v;
                        setBtnFn(updatedBtn);
                      }
                    }}
                    @click=${(e) => e.stopPropagation()}
                  ></ha-code-editor>
                ` : html`
                  <ha-textarea
                    .label=${"Label (accepts jinja2 templates)"}
                    .value=${btn.label ?? ""}
                    @change=${(ev) => {
                      const newValue = ev.target.value;
                      if (newValue !== (btn.label ?? "")) {
                        const updatedBtn = { ...btn };
                        if (!newValue || newValue.trim() === "") updatedBtn.label = "";
                        else updatedBtn.label = newValue;
                        setBtnFn(updatedBtn);
                      }
                    }}
                  ></ha-textarea>
                `}
                <div style="font-size: 11px; opacity: 0.7; margin: 4px 0 0 0;">Supports Jinja2 templates like: {{ states('sensor.temp') }}, {{ user }}, if/else, filters, etc.</div>
      </div></details>

      <details><summary class="cat-head">Style Overrides</summary><div class="cat-content">
        <div class="grid2">
            <ha-textfield .label=${"Background (optional override)"} .value=${btn.background || ""} placeholder="(blank = theme accent/primary)" @change=${(e) => setBtnFn({ ...btn, background: e.target.value })}></ha-textfield>
            <ha-textfield type="number" step="0.01" min="0" max="1" .label=${"Button background opacity override (0..1)"} .value=${btn.background_opacity ?? ""} @change=${(e) => setBtnFn({ ...btn, background_opacity: e.target.value })}></ha-textfield>
            <ha-textfield type="number" .label=${"Border radius override (px) â€” blank = inherit"} .value=${btn.border_radius ?? ""} @change=${(e) => setBtnFn({ ...btn, border_radius: e.target.value })}></ha-textfield>
            <ha-textfield type="number" .label=${"Border width override (px) â€” blank = inherit"} .value=${btn.border_width ?? ""} @change=${(e) => setBtnFn({ ...btn, border_width: e.target.value })}></ha-textfield>
            <ha-textfield .label=${"Border style override â€” blank = inherit"} .value=${btn.border_style || ""} placeholder="solid, dashed, dotted, ..." @change=${(e) => setBtnFn({ ...btn, border_style: e.target.value })}></ha-textfield>
            <ha-textfield .label=${"Border color override (CSS) â€” blank = inherit"} .value=${btn.border_color || ""} placeholder="(blank = inherit)" @change=${(e) => setBtnFn({ ...btn, border_color: e.target.value })}></ha-textfield>
            <ha-textfield .label=${"Icon color (optional override)"} .value=${btn.icon_color || ""} placeholder="(blank = theme text color)" @change=${(e) => setBtnFn({ ...btn, icon_color: e.target.value })}></ha-textfield>
        </div>
        <div class="grid2"><ha-textfield .label=${"Box-shadow (optional override)"} .value=${btn.box_shadow || ""} placeholder="(blank = global/default)" @change=${(e) => setBtnFn({ ...btn, box_shadow: e.target.value })}></ha-textfield><ha-textfield .label=${"Box-shadow hover (optional override)"} .value=${btn.box_shadow_hover || ""} placeholder="(blank = global/default)" @change=${(e) => setBtnFn({ ...btn, box_shadow_hover: e.target.value })}></ha-textfield></div>
        ${pillTypeSelected ? html`<div class="grid2"><ha-textfield type="number" .label=${`Pill width override (px) â€” blank = inherit global / auto (min ${MIN_PILL_WIDTH})`} .value=${btn.pill_width ?? ""} @change=${(e) => { const v = safeString(e.target.value).trim(); if (!v) return setBtnFn({ ...btn, pill_width: "" }); const n = Math.max(MIN_PILL_WIDTH, Number(v)); setBtnFn({ ...btn, pill_width: String(n) }); }}></ha-textfield><div class="hint">Fixed width keeps pills aligned and prevents awkward spacing.</div></div>` : html``}
        <div class="subsection"><div class="subheader">Label style overrides (optional)</div><div class="grid2">
            <ha-textfield type="number" .label=${"Font size (px) â€” blank = inherit"} .value=${btn.label_style?.font_size ?? ""} @change=${(e) => { const next = { ...(btn.label_style || {}) }; if (safeString(e.target.value).trim() === "") delete next.font_size; else next.font_size = Number(e.target.value); setBtnFn({ ...btn, label_style: next }); }}></ha-textfield>
            <ha-select .label=${"Font weight â€” blank = inherit"} .value=${btn.label_style?.font_weight !== undefined ? String(btn.label_style.font_weight) : INHERIT} @selected=${(e) => { const next = { ...(btn.label_style || {}) }; if (e.target.value === INHERIT) delete next.font_weight; else next.font_weight = Number(e.target.value); setBtnFn({ ...btn, label_style: next }); }} @closed=${(e) => e.stopPropagation()}><mwc-list-item .value=${INHERIT}>(inherit)</mwc-list-item>${FONT_WEIGHTS.map((fw) => html`<mwc-list-item .value=${String(fw.value)}>${fw.label}</mwc-list-item>`)}</ha-select>
            <ha-textfield .label=${"Text color â€” blank = inherit"} .value=${btn.label_style?.color ?? ""} placeholder="(blank = inherit)" @change=${(e) => { const next = { ...(btn.label_style || {}) }; if (safeString(e.target.value).trim() === "") delete next.color; else next.color = e.target.value; setBtnFn({ ...btn, label_style: next }); }}></ha-textfield>
            <ha-textfield .label=${"Label background â€” blank = inherit"} .value=${btn.label_style?.background ?? ""} placeholder="(blank = inherit)" @change=${(e) => { const next = { ...(btn.label_style || {}) }; if (safeString(e.target.value).trim() === "") delete next.background; else next.background = e.target.value; setBtnFn({ ...btn, label_style: next }); }}></ha-textfield>
            <ha-textfield type="number" .label=${"Label background opacity â€” blank = inherit"} .value=${btn.label_style?.background_opacity ?? ""} @change=${(e) => { const next = { ...(btn.label_style || {}) }; if (safeString(e.target.value).trim() === "") delete next.background_opacity; else next.background_opacity = Number(e.target.value); setBtnFn({ ...btn, label_style: next }); }}></ha-textfield>
        </div></div>
      </div></details>
      
      <details><summary class="cat-head">Interaction & Data</summary><div class="cat-content">
        ${this._renderEntityPicker("Entity (used for Toggle, More-info & State)", btn.entity || "", (v) => setBtnFn({ ...btn, entity: v }))}
        ${this._renderActionEditor(btn, setBtnFn, "tap_action", "Tap Action", errorKeyPrefix)}
        ${this._renderActionEditor(btn, setBtnFn, "hold_action", "Hold / Right click", errorKeyPrefix)}
        ${this._renderActionEditor(btn, setBtnFn, "double_tap_action", "Double tap", errorKeyPrefix)}
      </div></details>

      ${allowConditions ? html`<details><summary class="cat-head">Visibility (Conditions)</summary><div class="cat-content">
        ${this._renderConditions(btn, setBtnFn)}
      </div></details>` : html``}
    </div>`;
  }
  _renderBaseButtonPanel(asBoxContent = false) {
    const c = this._c;
    const btn = c.base.button || DEFAULT_BUTTON();
    const key = `base:${btn.id}`;
    const expanded = !!this._expanded[key];
    const setBtn = (nextBtn) => {
      const cfg = deepClone(this._c);
      cfg.base.button = { ...btn, ...nextBtn };
      this._emit(cfg);
    };

    const content = html`
      <ha-expansion-panel
        .expanded=${expanded}
        @expanded-changed=${(e) => {
          const next = e.detail?.value ?? e.detail?.expanded ?? e.target?.expanded ?? false;
          this._expanded[key] = !!next;
          this.requestUpdate();
        }}
      >
        <div slot="header" class="btn-header">
          <ha-icon .icon=${btn.icon || "mdi:home"}></ha-icon>
          <div class="btn-header-text">
            <div class="btn-title">${btn.label || btn.tooltip || "Base button"}</div>
            <div class="btn-sub">${btn.icon || ""}${btn.entity ? ` â€¢ ${btn.entity}` : ""}</div>
          </div>
        </div>
        <div class="panel">${this._renderButtonPanel(btn, setBtn, "base", false)}</div>
      </ha-expansion-panel>
    `;

    if (asBoxContent) return content;

    return html`
      <div class="section">
        <div class="section-title">Base button</div>
        ${content}
      </div>
    `;
  }
  _renderGroup(group, asBoxContent = false) {
    const c = this._c;
    const gKey = group === "vertical" ? "vertical" : "horizontal";
    const enabled = !!c[gKey].enabled;
    const buttons = this._getButtons(group);
    const centerHidden = c.position === "bottom-center" && group === "vertical";
    const tip = html`<ha-alert alert-type="info">Tip: If you disable this group, you can still configure its buttons and open it temporarily using the <b>Show/Hide Group</b> action. It auto-closes after a button is pressed.</ha-alert>`;
    const centerWarn = centerHidden ? html`<ha-alert alert-type="warning">Vertical group is <b>always hidden</b> when Position is <b>Bottom center</b>. You can still configure it, but it wonâ€™t be displayed.</ha-alert>` : html``;
    const content = html`
      <div class="row" style="justify-content: space-between; align-items: center;">
        <div class="section-title" style="padding: 0; background: none; box-shadow: none;">${group === "vertical" ? "Vertical group" : "Horizontal group"}</div>
        <mwc-button @click=${() => this._addButton(group)} outlined><ha-icon icon="mdi:plus"></ha-icon>&nbsp;Add button</mwc-button>
      </div>
        ${tip}${centerWarn}
        <div class="grid2"><ha-formfield .label=${"Enabled"}><ha-switch .checked=${!!enabled} @change=${(e) => this._setBool(`${gKey}.enabled`, e.target.checked)}></ha-switch></ha-formfield>
          ${group === "horizontal" ? html`<ha-textfield type="number" .label=${"Columns"} .value=${String(c.horizontal.columns)} @change=${(e) => { const cfg = deepClone(this._c); cfg.horizontal.columns = Math.max(1, Number(e.target.value)); this._emit(cfg); }}></ha-textfield>` : html`<ha-textfield type="number" .label=${"Rows"} .value=${String(c.vertical.rows)} @change=${(e) => { const cfg = deepClone(this._c); cfg.vertical.rows = Math.max(1, Number(e.target.value)); this._emit(cfg); }}></ha-textfield>`}
        </div>
        ${buttons.length === 0 ? html`<div class="empty">No buttons yet â€” click â€œAdd buttonâ€.</div>` : html``}
        ${buttons.map((btn, idx) => {
          const btnId = btn.id || "no_id";
          const key = `${group}:${btnId}`;
          const title = btn.label || btn.tooltip || `Button`;
          const expanded = !!this._expanded[key];
          const setBtn = (nextBtn) => this._setButtonById(group, btnId, nextBtn);
          return html`
            <ha-expansion-panel .expanded=${expanded} @expanded-changed=${(e) => { const next = e.detail?.value ?? e.detail?.expanded ?? e.target?.expanded ?? false; this._expanded[key] = !!next; this.requestUpdate(); }}>
              <div slot="header" class="btn-header"><ha-icon .icon=${btn.icon || "mdi:circle"}></ha-icon><div class="btn-header-text"><div class="btn-title">${title}</div><div class="btn-sub">${btn.icon || ""}${btn.entity ? ` â€¢ ${btn.entity}` : ""}</div></div><div class="btn-actions"><mwc-icon-button title="Move up" ?disabled=${idx === 0} @click=${(e) => { e.stopPropagation(); this._moveButtonById(group, btnId, -1); }}><ha-icon icon="mdi:chevron-up"></ha-icon></mwc-icon-button><mwc-icon-button title="Move down" ?disabled=${idx === buttons.length - 1} @click=${(e) => { e.stopPropagation(); this._moveButtonById(group, btnId, 1); }}><ha-icon icon="mdi:chevron-down"></ha-icon></mwc-icon-button><mwc-icon-button title="Delete" @click=${(e) => { e.stopPropagation(); this._removeButtonById(group, btnId); }}><ha-icon icon="mdi:trash-can-outline"></ha-icon></mwc-icon-button></div></div>
              <div class="panel">${this._renderButtonPanel(btn, setBtn, key, true)}</div>
            </ha-expansion-panel>`;
        })}
      `;

    if (asBoxContent) return content;

    return html`
      <div class="section">${content}</div>
    `;
  }
  render() {
    if (!this.hass || !this._config) return html``;
    const c = this._c;
    const showCenterOptions = c.position === "bottom-center";
    const showPillWidthGlobal = c.default_button_type === "pill" || c.default_button_type === "pill_label";
    return html`
      <div class="editor">
        <details class="box-section" open>
          <summary>Info</summary>
          <div class="box-content">
            <ha-alert alert-type="warning">
              <div class="doc-title">Warning</div>
              <div>This card uses fixed positions on your screen, to edit this card you will have to click on the placeholder card in the section where you have placed this card.<br><br>Please read the <a href="https://jimz011.github.io/hki-elements/" target="_blank" rel="noopener noreferrer">documentation</a> to set up this card.<br><br>This card may contain bugs. Use at your own risk!</div>
            </ha-alert>
          </div>
        </details>

        <details class="box-section">
          <summary>Position & Appearance</summary>
          <div class="box-content">
          <div class="grid2">
            <ha-formfield .label=${"Reserve bottom space"}><ha-switch .checked=${!!c.reserve_space} @change=${(e) => this._setBool("reserve_space", e.target.checked)}></ha-switch></ha-formfield>
            ${c.reserve_space ? html`<div class="hint" style="grid-column: 1/-1; margin-top: -6px;">â„¹ï¸ <b>Reserve bottom space</b> only works when this card is the <b>last card</b> on the view (so the spacer ends up at the bottom of the page).</div>` : html``}
            <ha-select .label=${"Position"} .value=${c.position} @selected=${(e) => this._setValue("position", e.target.value)} @closed=${(e) => e.stopPropagation()}><mwc-list-item value="bottom-left">Bottom left</mwc-list-item><mwc-list-item value="bottom-center">Bottom center</mwc-list-item><mwc-list-item value="bottom-right">Bottom right</mwc-list-item></ha-select>
            <ha-textfield type="number" .label=${"Offset X (px)"} .value=${String(c.offset_x)} @change=${(e) => this._setValue("offset_x", Number(e.target.value))}></ha-textfield>
            <ha-textfield type="number" .label=${"Offset Y (px)"} .value=${String(c.offset_y)} @change=${(e) => this._setValue("offset_y", Number(e.target.value))}></ha-textfield>
            <div style="grid-column: 1/-1; margin-top: 8px;"><details><summary style="cursor: pointer; user-select: none; padding: 8px 0; color: var(--primary-text-color); font-weight: 500;">âš™ï¸ Advanced: Screen-size-specific offsets (optional)</summary><div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; padding: 12px; background: rgba(var(--rgb-primary-text-color), 0.05); border-radius: 8px;"><div class="hint" style="grid-column: 1/-1; margin: 0 0 8px 0;">Override the base Offset X for specific screen sizes. Leave blank to use the base offset. This is probably only useful when buttons are positioned on the left.</div><ha-textfield type="number" .label=${"Mobile offset X (< 768px)"} .value=${c.offset_x_mobile !== undefined && c.offset_x_mobile !== null ? String(c.offset_x_mobile) : ""} placeholder="Uses base offset X" @change=${(e) => { const val = e.target.value.trim(); this._setValue("offset_x_mobile", val === "" ? null : Number(val)); }}></ha-textfield><ha-textfield type="number" .label=${"Tablet offset X (768-1024px)"} .value=${c.offset_x_tablet !== undefined && c.offset_x_tablet !== null ? String(c.offset_x_tablet) : ""} placeholder="Uses base offset X" @change=${(e) => { const val = e.target.value.trim(); this._setValue("offset_x_tablet", val === "" ? null : Number(val)); }}></ha-textfield><ha-textfield type="number" .label=${"Desktop offset X (> 1024px)"} .value=${c.offset_x_desktop !== undefined && c.offset_x_desktop !== null ? String(c.offset_x_desktop) : ""} placeholder="Uses base offset X" @change=${(e) => { const val = e.target.value.trim(); this._setValue("offset_x_desktop", val === "" ? null : Number(val)); }}></ha-textfield></div></details></div>
            <ha-textfield type="number" .label=${"Button size (px)"} .value=${String(c.button_size)} @change=${(e) => this._setValue("button_size", Number(e.target.value))}></ha-textfield>
            <ha-textfield type="number" .label=${"Horizontal gap (px)"} .value=${String(c.gap)} @change=${(e) => this._setValue("gap", Number(e.target.value))}></ha-textfield>
            <ha-textfield type="number" .label=${"Vertical gap (px)"} .value=${String(c.vertical_gap)} @change=${(e) => this._setValue("vertical_gap", Number(e.target.value))}></ha-textfield>
            <ha-textfield .label=${"Button box-shadow (CSS)"} .value=${c.button_box_shadow || ""} @change=${(e) => this._setValue("button_box_shadow", e.target.value)}></ha-textfield>
            <ha-textfield .label=${"Button box-shadow hover (CSS)"} .value=${c.button_box_shadow_hover || ""} @change=${(e) => this._setValue("button_box_shadow_hover", e.target.value)}></ha-textfield>
            <ha-textfield type="number" .label=${"Z-index"} .value=${String(c.z_index)} @change=${(e) => this._setValue("z_index", Number(e.target.value))}></ha-textfield>
          </div>
          ${showCenterOptions ? html`<div class="subsection"><div class="subheader">Center options</div><div class="grid2"><ha-formfield .label=${"Spread buttons across width"}><ha-switch .checked=${!!c.center_spread} @change=${(e) => this._setValue("center_spread", e.target.checked)}></ha-switch></ha-formfield><div class="hint">When enabled, the base + horizontal buttons spread across the full width.</div></div></div>` : html``}
          <div class="subsection"><div class="subheader">Bottom bar (cosmetic)<span style="margin-left: 8px; padding: 2px 8px; background: rgba(255, 165, 0, 0.2); color: orange; border-radius: 4px; font-size: 11px; font-weight: 600; vertical-align: middle;">âš ï¸ EXPERIMENTAL</span></div><div class="grid2"><ha-formfield .label=${"Enable bottom bar"}><ha-switch .checked=${!!c.bottom_bar_enabled} @change=${(e) => this._setBool("bottom_bar_enabled", e.target.checked)}></ha-switch></ha-formfield>
              ${c.bottom_bar_enabled ? html`${c.position === "bottom-center" ? html`<ha-formfield .label=${"Span full width"}><ha-switch .checked=${!!c.bottom_bar_full_width} @change=${(e) => this._setBool("bottom_bar_full_width", e.target.checked)}></ha-switch></ha-formfield>` : html`<div class="hint" style="padding: 8px; background: rgba(255, 165, 0, 0.1); border-radius: 8px;">â„¹ï¸ Non-full-width bar only available with center alignment. Bar will span full width.</div>`}
                <ha-textfield type="number" .label=${"Bottom bar height (px)"} .value=${String(c.bottom_bar_height)} @change=${(e) => this._setValue("bottom_bar_height", Number(e.target.value))}></ha-textfield><ha-textfield type="number" .label=${"Bottom bar bottom offset (px)"} .value=${String(c.bottom_bar_bottom_offset)} @change=${(e) => this._setValue("bottom_bar_bottom_offset", Number(e.target.value))}></ha-textfield><ha-textfield type="number" .label=${"Bottom bar border radius (px)"} .value=${String(c.bottom_bar_border_radius)} @change=${(e) => this._setValue("bottom_bar_border_radius", Number(e.target.value))}></ha-textfield><ha-textfield .label=${"Bottom bar box-shadow (CSS)"} .value=${c.bottom_bar_box_shadow || ""} @change=${(e) => this._setValue("bottom_bar_box_shadow", e.target.value)}></ha-textfield><ha-textfield .label=${"Bottom bar color (CSS)"} .value=${c.bottom_bar_color || ""} @change=${(e) => this._setValue("bottom_bar_color", e.target.value)}></ha-textfield><ha-textfield type="number" step="0.01" min="0" max="1" .label=${"Bottom bar opacity (0..1)"} .value=${String(c.bottom_bar_opacity ?? 1)} @change=${(e) => this._setValue("bottom_bar_opacity", Number(e.target.value))}></ha-textfield><ha-textfield type="number" .label=${"Inset left (px)"} .value=${String(c.bottom_bar_margin_left ?? 0)} @change=${(e) => this._setValue("bottom_bar_margin_left", Number(e.target.value))}></ha-textfield><ha-textfield type="number" .label=${"Inset right (px)"} .value=${String(c.bottom_bar_margin_right ?? 0)} @change=${(e) => this._setValue("bottom_bar_margin_right", Number(e.target.value))}></ha-textfield>
                ${!c.bottom_bar_full_width ? html`<ha-textfield type="number" .label=${"Border width (px)"} .value=${String(c.bottom_bar_border_width ?? 0)} @change=${(e) => this._setValue("bottom_bar_border_width", Number(e.target.value))}></ha-textfield>` : ''}${!c.bottom_bar_full_width ? html`<ha-textfield .label=${"Border style"} .value=${c.bottom_bar_border_style || "solid"} placeholder="solid, dashed, dotted, etc." @change=${(e) => this._setValue("bottom_bar_border_style", e.target.value)}></ha-textfield>` : ''}${!c.bottom_bar_full_width ? html`<ha-textfield .label=${"Border color (CSS)"} .value=${c.bottom_bar_border_color || ""} placeholder="(optional)" @change=${(e) => this._setValue("bottom_bar_border_color", e.target.value)}></ha-textfield>` : ''}
                <div class="hint">Purely visual. The bar wraps buttons (center alignment only) or spans full width (left/right). Positive inset values extend the bar beyond buttons when wrapping, or shrink it when full-width is enabled. Negative values do the opposite. Does not affect click behavior.</div>` : ''}</div></div>
          </div>
        </details>
        <details class="box-section" open>
          <summary>Defaults</summary>
          <div class="box-content">
            <ha-alert alert-type="info">
              <div><b>Defaults</b> apply to buttons that have values set to <b>inherit</b> (blank fields in the button config). This includes global label styling.</div>
            </ha-alert>

            <details open>
              <summary>Button styling defaults</summary>
              <div class="cat-content">
                <div class="grid2">
                  <ha-select .label=${"Default Button Type"} .value=${c.default_button_type} @selected=${(e) => this._setValue("default_button_type", e.target.value)} @closed=${(e) => e.stopPropagation()}>${BUTTON_TYPES.map((t) => html`<mwc-list-item .value=${t.value}>${t.label}</mwc-list-item>`)}</ha-select>
                  ${showPillWidthGlobal ? html`<ha-textfield type="number" .label=${`Global pill width (px) â€” 0 = auto (min ${MIN_PILL_WIDTH})`} .value=${String(c.pill_width || 0)} @change=${(e) => this._setGlobalPillWidth(Number(e.target.value))}></ha-textfield>` : html`<div class="hint">Global pill width appears when Default Button Type is a pill type.</div>`}
                  <ha-textfield .label=${"Default background (optional override)"} .value=${c.default_background || ""} placeholder="(blank = theme accent/primary)" @change=${(e) => this._setDefaultBackground(e.target.value)}></ha-textfield>
                  <ha-textfield type="number" step="0.01" min="0" max="1" .label=${"Default button background opacity (0..1)"} .value=${String(c.default_button_opacity ?? 1)} @change=${(e) => this._setDefaultButtonOpacity(e.target.value)}></ha-textfield>
                  <ha-textfield .label=${"Default icon color (optional override)"} .value=${c.default_icon_color || ""} placeholder="(blank = theme text color)" @change=${(e) => this._setDefaultIconColor(e.target.value)}></ha-textfield>
                  <ha-textfield type="number" .label=${"Default border radius (px)"} .value=${String(c.default_border_radius ?? DEFAULTS.default_border_radius)} @change=${(e) => this._setDefaultBorderRadius(e.target.value)}></ha-textfield>
                  <ha-textfield type="number" .label=${"Default border width (px)"} .value=${String(c.default_border_width ?? DEFAULTS.default_border_width)} @change=${(e) => this._setDefaultBorderWidth(e.target.value)}></ha-textfield>
                  <ha-textfield .label=${"Default border style"} .value=${c.default_border_style || DEFAULTS.default_border_style} placeholder="solid, dashed, dotted, ..." @change=${(e) => this._setDefaultBorderStyle(e.target.value)}></ha-textfield>
                  <ha-textfield .label=${"Default border color (CSS)"} .value=${c.default_border_color || ""} placeholder="(blank = theme divider color)" @change=${(e) => this._setDefaultBorderColor(e.target.value)}></ha-textfield>
                </div>
              </div>
            </details>

            <details>
              <summary>Label styling defaults</summary>
              <div class="cat-content">
                <div class="hint">These defaults are used when a button label style is left blank (inherit).</div>
                <div class="grid2">
                  <ha-textfield type="number" .label=${"Font size (px)"} .value=${String(c.label_style?.font_size ?? DEFAULT_LABEL_STYLE.font_size)} @change=${(e) => this._setLabelStyleGlobal("font_size", Number(e.target.value))}></ha-textfield>
                  <ha-select .label=${"Font weight"} .value=${String(c.label_style?.font_weight ?? DEFAULT_LABEL_STYLE.font_weight)} @selected=${(e) => this._setLabelStyleGlobal("font_weight", Number(e.target.value))} @closed=${(e) => e.stopPropagation()}>${FONT_WEIGHTS.map((fw) => html`<mwc-list-item .value=${String(fw.value)}>${fw.label}</mwc-list-item>`)}</ha-select>
                  <ha-textfield type="number" .label=${"Letter spacing (px)"} .value=${String(c.label_style?.letter_spacing ?? DEFAULT_LABEL_STYLE.letter_spacing)} @change=${(e) => this._setLabelStyleGlobal("letter_spacing", Number(e.target.value))}></ha-textfield>
                  <ha-select .label=${"Text transform"} .value=${c.label_style?.text_transform ?? "none"} @selected=${(e) => this._setLabelStyleGlobal("text_transform", e.target.value)} @closed=${(e) => e.stopPropagation()}><mwc-list-item value="none">None</mwc-list-item><mwc-list-item value="uppercase">Uppercase</mwc-list-item><mwc-list-item value="lowercase">Lowercase</mwc-list-item><mwc-list-item value="capitalize">Capitalize</mwc-list-item></ha-select>
                  <ha-textfield .label=${"Text color (optional)"} .value=${c.label_style?.color ?? ""} placeholder="(blank = theme/currentColor)" @change=${(e) => this._setLabelStyleGlobal("color", e.target.value)}></ha-textfield>
                  <ha-textfield .label=${"Label background (optional)"} .value=${c.label_style?.background ?? ""} placeholder="(blank = theme card rgba)" @change=${(e) => this._setLabelStyleGlobal("background", e.target.value)}></ha-textfield>
                  <ha-textfield type="number" .label=${"Label background opacity"} .value=${String(c.label_style?.background_opacity ?? DEFAULT_LABEL_STYLE.background_opacity)} @change=${(e) => this._setLabelStyleGlobal("background_opacity", Number(e.target.value))}></ha-textfield>
                </div>
              </div>
            </details>
          </div>
        </details>

        <details class="box-section" open>
          <summary>Buttons</summary>
          <div class="box-content">
            <details open>
              <summary>Base button</summary>
              <div class="cat-content">
                ${this._renderBaseButtonPanel(true)}
              </div>
            </details>

            <details>
              <summary>Horizontal group</summary>
              <div class="cat-content">
                ${this._renderGroup("horizontal", true)}
              </div>
            </details>

            <details>
              <summary>Vertical group</summary>
              <div class="cat-content">
                ${this._renderGroup("vertical", true)}
              </div>
            </details>
          </div>
        </details>

      </div>`;
  }
  static get styles() {
    return css`
      .editor { display: flex; flex-direction: column; gap: 16px; }
      .doc { border-radius: 14px; }
      .doc-title { font-weight: 800; margin-bottom: 8px; }
      .section { padding: 14px; border-radius: 14px; background: var(--card-background-color); box-shadow: 0 1px 0 rgba(0, 0, 0, 0.2); display: flex; flex-direction: column; gap: 12px; }
      .previewbox { position:relative; border-radius:14px; background: rgba(0,0,0,0.03); border: 1px solid rgba(0,0,0,0.08); overflow:hidden; }
      .pabs { position:absolute; }
      .pbtn { display:inline-flex; align-items:center; justify-content:center; gap:10px; border-radius:999px; background: var(--accent-color, var(--primary-color)); color: var(--text-primary-color, var(--primary-text-color)); box-shadow: 0 8px 24px rgba(0,0,0,0.22); padding: 0 14px; }
      .pbtn-pill { justify-content:flex-start; }
      .picon { --mdc-icon-size: 18px; }
      .plabel { font-weight:800; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:220px; }
      .prow { position:absolute; left:0; right:0; bottom:12px; display:flex; align-items:center; padding: 0 12px; }
      .section-title { font-weight: 800; display: flex; gap: 10px; align-items: center; justify-content: space-between; }
      .row { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
      .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
      .grid2 > * { min-width: 0; }
      .empty { opacity: 0.7; padding: 8px 2px; }
      ha-textfield, ha-select, ha-service-picker, ha-entity-picker, ha-selector, ha-yaml-editor { width: 100%; max-width: 100%; display: block; }
      ha-expansion-panel { border-radius: 14px; overflow: visible; margin-top: 10px; background: rgba(0, 0, 0, 0.06); }
      .btn-header { display: flex; align-items: center; gap: 10px; padding-right: 8px; }
      .btn-header-text { flex: 1; min-width: 0; }
      .btn-title { font-weight: 800; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .btn-sub { opacity: 0.75; font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .btn-actions { display: flex; align-items: center; gap: 2px; }
      .panel { padding: 12px; display: flex; flex-direction: column; gap: 12px; }
      .subsection { margin-top: 6px; padding-top: 10px; border-top: 1px solid rgba(0, 0, 0, 0.14); display: flex; flex-direction: column; gap: 10px; }
      .subheader { font-weight: 800; opacity: 0.9; }
      .hint { font-size: 12px; opacity: 0.7; }
      .cond { border-radius: 12px; padding: 10px; background: rgba(0, 0, 0, 0.06); display: flex; flex-direction: column; gap: 10px; }
      .cond-head { display: flex; align-items: center; justify-content: space-between; gap: 10px; }
      .cond-title { font-weight: 700; font-size: 12px; opacity: 0.9; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
      .code-wrap { display: flex; flex-direction: column; gap: 8px; }
      .code-label { font-weight: 700; opacity: 0.85; }
      ha-code-editor { border-radius: 12px; overflow: hidden; }
      
      /* Collapsible Section Styles - Matching Header Card */
      details.box-section {
        background: var(--secondary-background-color);
        border-radius: 4px;
        margin-bottom: 8px;
        overflow: visible;
        border: 1px solid var(--divider-color);
      }
      details.box-section > summary {
        padding: 12px;
        cursor: pointer;
        font-weight: 600;
        background: var(--primary-background-color);
        border-bottom: 1px solid var(--divider-color);
        list-style: none;
        display: flex;
        align-items: center;
        justify-content: space-between;
      }
      details.box-section > summary::-webkit-details-marker { display: none; }
      details.box-section > summary::after {
        content: '+'; 
        font-weight: bold;
        font-size: 1.2em;
      }
      details.box-section[open] > summary::after {
        content: '-';
      }
      .box-content {
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }
      
      /* Keep existing category styles for nested details */
      details { margin-bottom: 8px; border-radius: 8px; background: rgba(255, 255, 255, 0.03); border: 1px solid rgba(128, 128, 128, 0.15); overflow: visible; }
      details > summary { list-style: none; padding: 10px 12px; font-weight: 700; cursor: pointer; user-select: none; background: rgba(0,0,0,0.02); display: flex; align-items: center; outline: none; }
      details > summary::-webkit-details-marker { display: none; }
      details > summary::after { content: "â–¼"; font-size: 10px; margin-left: auto; opacity: 0.6; transition: transform 0.2s; }
      details[open] > summary::after { transform: rotate(180deg); }
      .cat-content { padding: 12px; display: flex; flex-direction: column; gap: 12px; border-top: 1px solid rgba(128, 128, 128, 0.1); }
      
      @media (max-width: 640px) { .grid2 { grid-template-columns: 1fr; } .previewbox { width: 100% !important; } }
    `;
  }
}

if (!customElements.get(CARD_TAG)) {
  customElements.define(CARD_TAG, HkiNavigationCard);
}
if (!customElements.get(EDITOR_TAG)) {
  customElements.define(EDITOR_TAG, HkiNavigationCardEditor);
}

HkiNavigationCard.getConfigElement = () => document.createElement(EDITOR_TAG);
HkiNavigationCard.getStubConfig = () => ({
  ...deepClone(DEFAULTS),
  base: { button: { ...DEFAULT_BUTTON(), icon: "mdi:home", tooltip: "Home", button_type: "icon", tap_action: { action: "navigate", navigation_path: "/lovelace/0" } } },
  horizontal: { enabled: true, columns: 6, buttons: [
      { ...DEFAULT_BUTTON(), icon: "mdi:view-grid", tooltip: "Overview", button_type: "icon", tap_action: { action: "navigate", navigation_path: "/" } },
      { ...DEFAULT_BUTTON(), icon: "mdi:menu", tooltip: "Menu", button_type: "pill", label: "Menu", double_tap_action: { action: "toggle-group", target: "both", mode: "show" } },
  ] },
  vertical: { enabled: false, rows: 6, buttons: [{ ...DEFAULT_BUTTON(), icon: "mdi:cog", tooltip: "Settings", button_type: "pill", label: "Settings", tap_action: { action: "navigate", navigation_path: "/config" } }] },
});

window.customCards = window.customCards || [];
window.customCards.push({
  type: CARD_TYPE,
  name: "HKI Navigation Card",
  description: "Highly Customizable Navigation Bar.",
  preview: true,
  documentationURL: "https://github.com/jimz011/hki-navigation-card",
});


})();

// ============================================================
// hki-settings-card
// ============================================================

(() => {
// HKI Settings Card

const { LitElement, html, css } = window.HKI.getLit();
const CARD_TYPE = "hki-settings-card";
const EDITOR_TAG = "hki-settings-card-editor";

const BORDER_STYLES = (window.HKI?.EDITOR_OPTIONS?.borderStyles || [
  { value: "solid", label: "solid" },
  { value: "dashed", label: "dashed" },
  { value: "dotted", label: "dotted" },
  { value: "double", label: "double" },
  { value: "none", label: "none" },
]).map((x) => ({ value: x.value, label: x.label }));

const FONT_FAMILIES = [
  { value: "inherit", label: "inherit" },
  { value: "system", label: "system" },
  { value: "roboto", label: "roboto" },
  { value: "inter", label: "inter" },
  { value: "arial", label: "arial" },
  { value: "georgia", label: "georgia" },
  { value: "mono", label: "mono" },
  { value: "custom", label: "custom" },
];

const FONT_WEIGHTS = [
  { value: "lighter", label: "lighter" },
  { value: "normal", label: "normal" },
  { value: "bold", label: "bold" },
  { value: "bolder", label: "bolder" },
  { value: "300", label: "300" },
  { value: "400", label: "400" },
  { value: "500", label: "500" },
  { value: "600", label: "600" },
  { value: "700", label: "700" },
  { value: "800", label: "800" },
];
const HEADER_WEIGHT_OPTIONS = [
  { value: "light", label: "light" },
  { value: "regular", label: "regular" },
  { value: "medium", label: "medium" },
  { value: "semibold", label: "semibold" },
  { value: "bold", label: "bold" },
  { value: "black", label: "black" },
];

const NAV_TEXT_TRANSFORM = [
  { value: "none", label: "none" },
  { value: "uppercase", label: "uppercase" },
  { value: "lowercase", label: "lowercase" },
  { value: "capitalize", label: "capitalize" },
];
const TEXT_ALIGN_OPTIONS = [
  { value: "left", label: "left" },
  { value: "center", label: "center" },
  { value: "right", label: "right" },
];
const ICON_ALIGN_OPTIONS = [
  { value: "left", label: "left" },
  { value: "center", label: "center" },
  { value: "right", label: "right" },
];
const POPUP_EDITOR_OPTIONS = window.HKI?.POPUP_EDITOR_OPTIONS || {};
const POPUP_WIDTH_OPTIONS = POPUP_EDITOR_OPTIONS.width || [
  { value: "auto", label: "Auto" },
  { value: "default", label: "Default" },
  { value: "custom", label: "Custom" },
];
const POPUP_HEIGHT_OPTIONS = POPUP_EDITOR_OPTIONS.height || [
  { value: "auto", label: "Auto" },
  { value: "default", label: "Default" },
  { value: "custom", label: "Custom" },
];
const POPUP_ANIMATION_OPTIONS = POPUP_EDITOR_OPTIONS.animations || [
  { value: "none", label: "None" },
  { value: "fade", label: "Fade" },
  { value: "scale", label: "Scale" },
];
const POPUP_TIME_FORMAT_OPTIONS = POPUP_EDITOR_OPTIONS.timeFormats || [
  { value: "auto", label: "Auto" },
  { value: "12", label: "12-Hour Clock" },
  { value: "24", label: "24-Hour Clock" },
];
const POPUP_DEFAULT_VIEW_OPTIONS = window.HKI?.EDITOR_OPTIONS?.popupDefaultViewOptions || [
  { value: "main", label: "Main (Group Controls)" },
  { value: "individual", label: "Individual Entities" },
];
const POPUP_DEFAULT_SECTION_OPTIONS = window.HKI?.EDITOR_OPTIONS?.popupDefaultSectionOptions || [
  { value: "last", label: "Last Used" },
  { value: "brightness", label: "Always Brightness" },
  { value: "color", label: "Always Color" },
  { value: "temperature", label: "Always Temperature" },
];
const POPUP_BOTTOM_BAR_ALIGN_OPTIONS = window.HKI?.EDITOR_OPTIONS?.popupBottomBarAlignOptions || [
  { value: "spread", label: "Spread" },
  { value: "start", label: "Start" },
  { value: "center", label: "Center" },
  { value: "end", label: "End" },
];

const DEFAULT_CONFIG = Object.freeze({
  type: `custom:${CARD_TYPE}`,
});
const HA_PRESERVE_KEYS = Object.freeze(["visibility", "grid_options"]);

const isUnset = window.HKI?.isUnsetValue || ((v) => v === undefined || v === null || (typeof v === "string" && v.trim() === ""));

function sanitizeScope(scopeObj) {
  const next = {};
  if (!scopeObj || typeof scopeObj !== "object") return next;
  Object.entries(scopeObj).forEach(([k, v]) => {
    if (isUnset(v)) return;
    next[k] = v;
  });
  return next;
}

function normalizeConfig(config) {
  const c = { ...DEFAULT_CONFIG, ...(config || {}) };
  if (typeof c.title !== "string" || !c.title.trim()) delete c.title;
  if (c.button && typeof c.button === "object") c.button = { ...c.button };
  else delete c.button;
  if (c.header && typeof c.header === "object") c.header = { ...c.header };
  else delete c.header;
  if (c.navigation && typeof c.navigation === "object") c.navigation = { ...c.navigation };
  else delete c.navigation;
  if (c.popup && typeof c.popup === "object") c.popup = { ...c.popup };
  else delete c.popup;
  return c;
}

class HkiSettingsBase extends LitElement {
  static get properties() {
    return {
      hass: {},
      _config: { state: true },
    };
  }

  constructor() {
    super();
    this._templateDrafts = {};
  }

  _tplFieldKey(scope, key) {
    return `${scope}.${key}`;
  }

  _objFieldKey(scope, key) {
    return `obj:${scope}.${key}`;
  }

  _getTemplateFieldValue(scope, key) {
    const k = this._tplFieldKey(scope, key);
    if (Object.prototype.hasOwnProperty.call(this._templateDrafts, k)) {
      return this._templateDrafts[k];
    }
    const current = this._config?.[scope]?.[key];
    return current !== undefined ? String(current) : "";
  }

  _onTemplateValueChanged(scope, key, value) {
    const k = this._tplFieldKey(scope, key);
    this._templateDrafts = {
      ...this._templateDrafts,
      [k]: String(value ?? ""),
    };
    this.requestUpdate();
  }

  _onTemplateBlur(scope, key) {
    const k = this._tplFieldKey(scope, key);
    const draft = Object.prototype.hasOwnProperty.call(this._templateDrafts, k)
      ? this._templateDrafts[k]
      : "";
    this._setText(scope, key, draft);
    const next = { ...this._templateDrafts };
    delete next[k];
    this._templateDrafts = next;
    this.requestUpdate();
  }

  _getObjectFieldValue(scope, key) {
    const k = this._objFieldKey(scope, key);
    if (Object.prototype.hasOwnProperty.call(this._templateDrafts, k)) {
      return this._templateDrafts[k];
    }
    const current = this._config?.[scope]?.[key];
    if (current === undefined || current === null) return "";
    try {
      if (window.jsyaml?.dump) return String(window.jsyaml.dump(current) || "").trim();
      return JSON.stringify(current, null, 2);
    } catch (_) {
      return "";
    }
  }

  _onObjectValueChanged(scope, key, value) {
    const k = this._objFieldKey(scope, key);
    this._templateDrafts = {
      ...this._templateDrafts,
      [k]: String(value ?? ""),
    };
    this.requestUpdate();
  }

  _onObjectBlur(scope, key) {
    const k = this._objFieldKey(scope, key);
    const raw = Object.prototype.hasOwnProperty.call(this._templateDrafts, k)
      ? this._templateDrafts[k]
      : "";
    const next = normalizeConfig(this._config);
    if (!next[scope] || typeof next[scope] !== "object") next[scope] = {};
    const text = String(raw ?? "").trim();
    if (!text) {
      delete next[scope][key];
    } else {
      try {
        const parsed = window.jsyaml?.load ? window.jsyaml.load(text) : JSON.parse(text);
        if (parsed && typeof parsed === "object") next[scope][key] = parsed;
      } catch (_) {
        // Keep existing value if parsing fails while user is still editing.
      }
    }
    if (!Object.keys(next[scope]).length) delete next[scope];
    this._emitChanged(next);
    const drafts = { ...this._templateDrafts };
    delete drafts[k];
    this._templateDrafts = drafts;
    this.requestUpdate();
  }

  _withPreservedHaKeys(next) {
    const out = normalizeConfig(next || {});
    const prev = this._config || {};
    HA_PRESERVE_KEYS.forEach((k) => {
      if (prev[k] !== undefined && out[k] === undefined) out[k] = prev[k];
    });
    return out;
  }

  setConfig(config) {
    const normalized = normalizeConfig(config);
    const persisted = window.HKI?.getGlobalSettings?.() || {};
    if (!normalized.button && persisted.button && Object.keys(persisted.button).length) {
      normalized.button = { ...persisted.button };
    }
    if (!normalized.header && persisted.header && Object.keys(persisted.header).length) {
      normalized.header = { ...persisted.header };
    }
    if (!normalized.navigation && persisted.navigation && Object.keys(persisted.navigation).length) {
      normalized.navigation = { ...persisted.navigation };
    }
    if (!normalized.popup && persisted.popup && Object.keys(persisted.popup).length) {
      normalized.popup = { ...persisted.popup };
    }
    this._config = normalized;
  }

  _commitTemplateDrafts(baseConfig) {
    const next = normalizeConfig(baseConfig || this._config || DEFAULT_CONFIG);
    Object.entries(this._templateDrafts || {}).forEach(([compound, value]) => {
      const dot = compound.indexOf(".");
      if (dot <= 0) return;
      const scope = compound.slice(0, dot);
      const key = compound.slice(dot + 1);
      if (scope.includes(":")) return;
      if (!scope || !key) return;
      if (!next[scope] || typeof next[scope] !== "object") next[scope] = {};
      const text = String(value ?? "").trim();
      if (!text) delete next[scope][key];
      else next[scope][key] = text;
      if (next[scope] && !Object.keys(next[scope]).length) delete next[scope];
    });
    this._templateDrafts = {};
    return next;
  }

  _saveNow() {
    const next = this._withPreservedHaKeys(this._commitTemplateDrafts(this._config));
    this._config = next;
    try {
      window.HKI?.setGlobalSettings?.({
        button: sanitizeScope(next.button || {}),
        header: sanitizeScope(next.header || {}),
        navigation: sanitizeScope(next.navigation || {}),
        popup: sanitizeScope(next.popup || {}),
      });
    } catch (_) {}
    try {
      this.dispatchEvent(new CustomEvent("config-changed", {
        detail: { config: next },
        bubbles: true,
        composed: true,
      }));
    } catch (_) {}
    this.requestUpdate();
  }

  _publishGlobals() {
    const cfg = this._config || DEFAULT_CONFIG;
    window.HKI?.setGlobalSettings?.({
      button: sanitizeScope(cfg.button || {}),
      header: sanitizeScope(cfg.header || {}),
      navigation: sanitizeScope(cfg.navigation || {}),
      popup: sanitizeScope(cfg.popup || {}),
    });
  }

  _emitChanged(next) {
    this._config = next;
    this._publishGlobals();
    this.dispatchEvent(new CustomEvent("config-changed", {
      detail: { config: next },
      bubbles: true,
      composed: true,
    }));
  }

  _setText(scope, key, value) {
    const next = normalizeConfig(this._config);
    if (!next[scope] || typeof next[scope] !== "object") next[scope] = {};
    if (!value || value.trim() === "") delete next[scope][key];
    else next[scope][key] = value.trim();
    if (!Object.keys(next[scope]).length) delete next[scope];
    this._emitChanged(next);
  }

  _setNumber(scope, key, value) {
    const next = normalizeConfig(this._config);
    if (!next[scope] || typeof next[scope] !== "object") next[scope] = {};
    const raw = String(value ?? "").trim();
    if (raw === "") delete next[scope][key];
    else {
      const n = Number(raw);
      if (Number.isFinite(n)) next[scope][key] = n;
      else delete next[scope][key];
    }
    if (!Object.keys(next[scope]).length) delete next[scope];
    this._emitChanged(next);
  }

  _setSelect(scope, key, value) {
    const next = normalizeConfig(this._config);
    if (!next[scope] || typeof next[scope] !== "object") next[scope] = {};
    if (!value || value === "__inherit__") delete next[scope][key];
    else next[scope][key] = value;
    if (!Object.keys(next[scope]).length) delete next[scope];
    this._emitChanged(next);
  }

  _setBool(scope, key, checked) {
    const next = normalizeConfig(this._config);
    if (!next[scope] || typeof next[scope] !== "object") next[scope] = {};
    if (checked === undefined || checked === null) delete next[scope][key];
    else next[scope][key] = !!checked;
    if (!Object.keys(next[scope]).length) delete next[scope];
    this._emitChanged(next);
  }

  _setList(scope, key, rawValue) {
    const next = normalizeConfig(this._config);
    if (!next[scope] || typeof next[scope] !== "object") next[scope] = {};
    const values = String(rawValue ?? "")
      .split(/\r?\n|,/)
      .map((x) => x.trim())
      .filter(Boolean);
    if (!values.length) delete next[scope][key];
    else next[scope][key] = values;
    if (!Object.keys(next[scope]).length) delete next[scope];
    this._emitChanged(next);
  }

  _resetScope(scope) {
    const next = this._withPreservedHaKeys(normalizeConfig(this._config));
    delete next[scope];
    this._emitChanged(next);
  }

  _resetAll() {
    const next = this._withPreservedHaKeys(normalizeConfig({ type: `custom:${CARD_TYPE}` }));
    this._emitChanged(next);
  }

  _renderSelect(scope, key, label, options) {
    const current = this._config?.[scope]?.[key];
    return html`
      <ha-select
        .label=${label}
        .value=${current !== undefined ? String(current) : "__inherit__"}
        @selected=${(e) => this._setSelect(scope, key, e.target.value)}
        @closed=${(e) => e.stopPropagation()}
      >
        <mwc-list-item .value=${"__inherit__"}>(inherit)</mwc-list-item>
        ${options.map((opt) => html`<mwc-list-item .value=${String(opt.value)}>${opt.label}</mwc-list-item>`)}
      </ha-select>
    `;
  }

  _renderInput(scope, key, label, type = "text", placeholder = "") {
    const current = this._config?.[scope]?.[key];
    return html`
      <ha-textfield
        .label=${label}
        .type=${type}
        .value=${current !== undefined ? String(current) : ""}
        .placeholder=${placeholder}
        @input=${(e) => (type === "number"
          ? this._setNumber(scope, key, e.target.value)
          : this._setText(scope, key, e.target.value))}
      ></ha-textfield>
    `;
  }

  _renderTemplateInput(scope, key, label) {
    return html`
      <div class="tpl-field">
        <div class="tpl-title">${label}</div>
        <ha-code-editor
          .hass=${this.hass}
          mode="yaml"
          autocomplete-entities
          autocomplete-icons
          .autocompleteEntities=${true}
          .autocompleteIcons=${true}
          .label=${label}
          .value=${this._getTemplateFieldValue(scope, key)}
          @value-changed=${(ev) => {
            ev.stopPropagation();
            this._onTemplateValueChanged(scope, key, ev.detail?.value ?? "");
          }}
          @blur=${() => this._onTemplateBlur(scope, key)}
          @click=${(e) => e.stopPropagation()}
        ></ha-code-editor>
      </div>
    `;
  }

  _renderSwitch(scope, key, label) {
    return html`
      <ha-formfield .label=${label}>
        <ha-switch
          .checked=${!!this._config?.[scope]?.[key]}
          @change=${(e) => this._setBool(scope, key, e.target.checked)}
        ></ha-switch>
      </ha-formfield>
    `;
  }

  _renderListInput(scope, key, label) {
    const value = this._config?.[scope]?.[key];
    const text = Array.isArray(value) ? value.join("\n") : "";
    return html`
      <div class="tpl-field">
        <div class="tpl-title">${label}</div>
        <ha-code-editor
          .hass=${this.hass}
          mode="yaml"
          .value=${text}
          @blur=${(e) => this._setList(scope, key, e.target?.value ?? text)}
        ></ha-code-editor>
      </div>
    `;
  }

  _renderObjectInput(scope, key, label) {
    return html`
      <div class="tpl-field">
        <div class="tpl-title">${label}</div>
        <ha-code-editor
          .hass=${this.hass}
          mode="yaml"
          autocomplete-entities
          autocomplete-icons
          .autocompleteEntities=${true}
          .autocompleteIcons=${true}
          .value=${this._getObjectFieldValue(scope, key)}
          @value-changed=${(ev) => {
            ev.stopPropagation();
            this._onObjectValueChanged(scope, key, ev.detail?.value ?? "");
          }}
          @blur=${() => this._onObjectBlur(scope, key)}
        ></ha-code-editor>
      </div>
    `;
  }

  _renderCategoryAccordion(title, fields, description = "") {
    return html`
      <details class="category-accordion">
        <summary>${title}</summary>
        <div class="category">
          ${description ? html`<div class="category-sub">${description}</div>` : ""}
          <div class="grid">${fields}</div>
        </div>
      </details>
    `;
  }

  _renderScopeHeader(title, scope, subtitle) {
    return html`
      <div class="scope-head">
        <div>
          <div class="scope-title">${title}</div>
          <div class="scope-sub">${subtitle}</div>
        </div>
        <button type="button" class="hki-reset-btn" @click=${() => this._resetScope(scope)}>
          <ha-icon icon="mdi:restore"></ha-icon>
          <span>Reset ${scope}</span>
        </button>
      </div>
    `;
  }

  _renderForm() {
    const cfg = this._config || DEFAULT_CONFIG;
    return html`
      <div class="wrap">
        <div class="intro">
          <div class="title">${cfg.title || "HKI Global Settings"}</div>
          <div class="sub">
            Global defaults for HKI Button, Header, and Navigation cards.
            Card-level values still win. Blank values inherit these globals.
          </div>
        </div>

        <details class="scope-accordion">
          <summary>Button Card Defaults</summary>
          <section class="scope">
            ${this._renderScopeHeader("Button Card Defaults", "button", "Applied to hki-button-card when a field is empty.")}
            ${this._renderCategoryAccordion("Card", html`
              ${this._renderTemplateInput("button", "card_color", "Card color (Template/CSS)")}
              ${this._renderTemplateInput("button", "card_opacity", "Card opacity (Template/CSS)")}
              ${this._renderTemplateInput("button", "border_radius", "Border radius (Template/CSS)")}
              ${this._renderTemplateInput("button", "box_shadow", "Box shadow (Template/CSS)")}
              ${this._renderTemplateInput("button", "border_width", "Border width (Template/CSS)")}
              ${this._renderSelect("button", "border_style", "Border style", BORDER_STYLES)}
              ${this._renderTemplateInput("button", "border_color", "Border color (Template/CSS)")}
            `, "Styles the outer button container.")}
            ${this._renderCategoryAccordion("Icon", html`
              ${this._renderTemplateInput("button", "icon_color", "Icon color (Template/CSS/Jinja)")}
              ${this._renderTemplateInput("button", "icon_animation", "Icon animation (Template/Jinja)")}
              ${this._renderSwitch("button", "enable_icon_animation", "Enable icon animation")}
              ${this._renderSelect("button", "icon_align", "Icon align", ICON_ALIGN_OPTIONS)}
              ${this._renderInput("button", "size_icon", "Icon size (px)", "number")}
            `, "Global icon style for button cards.")}
            ${this._renderCategoryAccordion("Icon Circle", html`
              ${this._renderTemplateInput("button", "icon_circle_bg", "Circle background (Template/CSS/Jinja)")}
              ${this._renderSelect("button", "icon_circle_border_style", "Circle border style", BORDER_STYLES)}
              ${this._renderTemplateInput("button", "icon_circle_border_width", "Circle border width (Template/CSS/Jinja)")}
              ${this._renderTemplateInput("button", "icon_circle_border_color", "Circle border color (Template/CSS/Jinja)")}
            `, "Styles for the optional icon circle.")}
            ${this._renderCategoryAccordion("Badge (Icon Badge)", html`
              ${this._renderTemplateInput("button", "badge_bg", "Badge background (Template/CSS/Jinja)")}
              ${this._renderSelect("button", "badge_border_style", "Badge border style", BORDER_STYLES)}
              ${this._renderTemplateInput("button", "badge_border_width", "Badge border width (Template/CSS/Jinja)")}
              ${this._renderTemplateInput("button", "badge_border_color", "Badge border color (Template/CSS/Jinja)")}
              ${this._renderInput("button", "badge_border_radius", "Badge border radius", "number")}
              ${this._renderInput("button", "badge_box_shadow", "Badge box shadow")}
              ${this._renderSwitch("button", "badge_circle", "Badge circle")}
              ${this._renderInput("button", "badge_size", "Badge size (px)", "number")}
              ${this._renderInput("button", "size_badge", "Badge font size", "number")}
              ${this._renderSelect("button", "badge_font_family", "Badge font family", FONT_FAMILIES)}
              ${this._renderSelect("button", "badge_font_weight", "Badge font weight", FONT_WEIGHTS)}
            `, "Styles for the small icon badge/chip.")}
            ${this._renderCategoryAccordion("Temperature Badge", html`
              ${this._renderInput("button", "temp_badge_size", "Temp badge size (px)", "number")}
              ${this._renderInput("button", "size_temp_badge", "Temp badge font size", "number")}
              ${this._renderInput("button", "temp_badge_text_color", "Temp badge text color")}
              ${this._renderInput("button", "temp_badge_border_color", "Temp badge border color")}
              ${this._renderSelect("button", "temp_badge_border_style", "Temp badge border style", BORDER_STYLES)}
              ${this._renderInput("button", "temp_badge_border_width", "Temp badge border width", "number")}
              ${this._renderInput("button", "temp_badge_border_radius", "Temp badge border radius", "number")}
              ${this._renderInput("button", "temp_badge_box_shadow", "Temp badge box shadow")}
              ${this._renderSelect("button", "temp_badge_font_family", "Temp badge font family", FONT_FAMILIES)}
              ${this._renderInput("button", "temp_badge_font_custom", "Temp badge custom font")}
              ${this._renderSelect("button", "temp_badge_font_weight", "Temp badge font weight", FONT_WEIGHTS)}
            `, "Climate temperature corner badge styling.")}
            ${this._renderCategoryAccordion("Name Typography", html`
              ${this._renderSelect("button", "name_font_family", "Name font family", FONT_FAMILIES)}
              ${this._renderInput("button", "name_font_custom", "Name custom font")}
              ${this._renderSelect("button", "name_font_weight", "Name font weight", FONT_WEIGHTS)}
              ${this._renderSelect("button", "name_text_align", "Name text align", TEXT_ALIGN_OPTIONS)}
              ${this._renderInput("button", "size_name", "Name size", "number")}
              ${this._renderTemplateInput("button", "name_color", "Name color (Template/CSS)")}
            `, "Applies to the entity name text.")}
            ${this._renderCategoryAccordion("State Typography", html`
              ${this._renderSelect("button", "state_font_family", "State font family", FONT_FAMILIES)}
              ${this._renderInput("button", "state_font_custom", "State custom font")}
              ${this._renderSelect("button", "state_font_weight", "State font weight", FONT_WEIGHTS)}
              ${this._renderSelect("button", "state_text_align", "State text align", TEXT_ALIGN_OPTIONS)}
              ${this._renderInput("button", "size_state", "State size", "number")}
              ${this._renderTemplateInput("button", "state_color", "State color (Template/CSS)")}
            `, "Applies to the entity state text.")}
            ${this._renderCategoryAccordion("Label Typography", html`
              ${this._renderSelect("button", "label_font_family", "Label font family", FONT_FAMILIES)}
              ${this._renderInput("button", "label_font_custom", "Label custom font")}
              ${this._renderSelect("button", "label_font_weight", "Label font weight", FONT_WEIGHTS)}
              ${this._renderSelect("button", "label_text_align", "Label text align", TEXT_ALIGN_OPTIONS)}
              ${this._renderInput("button", "size_label", "Label size", "number")}
              ${this._renderTemplateInput("button", "label_color", "Label color (Template/CSS)")}
            `, "Applies to optional label text.")}
            ${this._renderCategoryAccordion("Info/Brightness Typography", html`
              ${this._renderSelect("button", "brightness_font_family", "Info font family", FONT_FAMILIES)}
              ${this._renderInput("button", "brightness_font_custom", "Info custom font")}
              ${this._renderSelect("button", "brightness_font_weight", "Info font weight", FONT_WEIGHTS)}
              ${this._renderSelect("button", "brightness_text_align", "Info text align", TEXT_ALIGN_OPTIONS)}
              ${this._renderInput("button", "size_brightness", "Info size", "number")}
              ${this._renderTemplateInput("button", "brightness_color", "Info color (Template/CSS)")}
              ${this._renderTemplateInput("button", "brightness_color_on", "Info color (On) (Template/CSS)")}
              ${this._renderTemplateInput("button", "brightness_color_off", "Info color (Off) (Template/CSS)")}
            `, "Applies to info/brightness line text.")}
            ${this._renderCategoryAccordion("Tile", html`
              ${this._renderInput("button", "tile_height", "Tile height", "number")}
              ${this._renderSwitch("button", "show_tile_slider", "Show tile slider")}
              ${this._renderTemplateInput("button", "tile_slider_track_color", "Tile slider track color (Template/CSS/Jinja)")}
              ${this._renderTemplateInput("button", "tile_slider_fill_color", "Tile slider fill color (Template/CSS/Jinja)")}
            `, "Global defaults for hki_tile layout.")}
            ${this._renderCategoryAccordion("Offsets", html`
              ${this._renderInput("button", "name_offset_x", "Name offset X", "number")}
              ${this._renderInput("button", "name_offset_y", "Name offset Y", "number")}
              ${this._renderInput("button", "state_offset_x", "State offset X", "number")}
              ${this._renderInput("button", "state_offset_y", "State offset Y", "number")}
              ${this._renderInput("button", "label_offset_x", "Label offset X", "number")}
              ${this._renderInput("button", "label_offset_y", "Label offset Y", "number")}
              ${this._renderInput("button", "icon_offset_x", "Icon offset X", "number")}
              ${this._renderInput("button", "icon_offset_y", "Icon offset Y", "number")}
              ${this._renderInput("button", "icon_circle_offset_x", "Icon circle offset X", "number")}
              ${this._renderInput("button", "icon_circle_offset_y", "Icon circle offset Y", "number")}
              ${this._renderInput("button", "icon_badge_offset_x", "Icon badge offset X", "number")}
              ${this._renderInput("button", "icon_badge_offset_y", "Icon badge offset Y", "number")}
              ${this._renderInput("button", "badge_offset_x", "Badge offset X", "number")}
              ${this._renderInput("button", "badge_offset_y", "Badge offset Y", "number")}
              ${this._renderInput("button", "brightness_offset_x", "Info offset X", "number")}
              ${this._renderInput("button", "brightness_offset_y", "Info offset Y", "number")}
              ${this._renderInput("button", "temp_badge_offset_x", "Temp badge offset X", "number")}
              ${this._renderInput("button", "temp_badge_offset_y", "Temp badge offset Y", "number")}
            `, "Global element positioning offsets.")}
          </section>
        </details>

        <details class="scope-accordion">
          <summary>HKI Popup Defaults</summary>
          <section class="scope">
            ${this._renderScopeHeader("HKI Popup Defaults", "popup", "Shared popup styling defaults for all HKI cards that support popups.")}
            ${this._renderCategoryAccordion("Card", html`
              ${this._renderInput("popup", "popup_border_radius", "Popup border radius", "number")}
              ${this._renderSelect("popup", "popup_width", "Popup width mode", POPUP_WIDTH_OPTIONS)}
              ${this._renderInput("popup", "popup_width_custom", "Popup width custom (px)", "number")}
              ${this._renderSelect("popup", "popup_height", "Popup height mode", POPUP_HEIGHT_OPTIONS)}
              ${this._renderInput("popup", "popup_height_custom", "Popup height custom (px)", "number")}
              ${this._renderSwitch("popup", "popup_blur_enabled", "Popup backdrop blur enabled")}
              ${this._renderInput("popup", "popup_blur_amount", "Popup blur amount", "number")}
              ${this._renderSwitch("popup", "popup_card_blur_enabled", "Popup card blur enabled")}
              ${this._renderInput("popup", "popup_card_blur_amount", "Popup card blur amount", "number")}
              ${this._renderInput("popup", "popup_card_opacity", "Popup card opacity", "number")}
            `, "Container and glass styling for popup surfaces.")}
            ${this._renderCategoryAccordion("Animation", html`
              ${this._renderSelect("popup", "popup_open_animation", "Popup open animation", POPUP_ANIMATION_OPTIONS)}
              ${this._renderSelect("popup", "popup_close_animation", "Popup close animation", POPUP_ANIMATION_OPTIONS)}
              ${this._renderInput("popup", "popup_animation_duration", "Popup animation duration (ms)", "number")}
            `, "Open/close animation style for popup transitions.")}
            ${this._renderCategoryAccordion("Features", html`
              ${this._renderSwitch("popup", "popup_show_favorites", "Show favorites section")}
              ${this._renderSwitch("popup", "popup_show_effects", "Show effects section")}
              ${this._renderSwitch("popup", "popup_show_presets", "Show presets section")}
              ${this._renderSwitch("popup", "popup_hide_bottom_bar", "Hide popup bottom bar")}
              ${this._renderSwitch("popup", "popup_hide_top_bar", "Hide popup top bar")}
              ${(this._config?.popup?.popup_hide_top_bar === true)
                ? this._renderSwitch("popup", "popup_show_close_button", "Show close button when top bar is hidden")
                : ""}
              ${this._renderSwitch("popup", "popup_close_on_action", "Close popup after perform-action")}
              ${this._renderSelect("popup", "popup_bottom_bar_align", "Popup bottom bar align", POPUP_BOTTOM_BAR_ALIGN_OPTIONS)}
              ${this._renderSelect("popup", "popup_default_view", "Popup default view", POPUP_DEFAULT_VIEW_OPTIONS)}
              ${this._renderSelect("popup", "popup_default_section", "Popup default section", POPUP_DEFAULT_SECTION_OPTIONS)}
            `, "Global popup feature toggles and navigation behavior.")}
            ${this._renderCategoryAccordion("Typography", html`
              ${this._renderInput("popup", "popup_slider_radius", "Popup slider radius", "number")}
              ${this._renderSwitch("popup", "popup_hide_button_text", "Hide popup button text")}
              ${this._renderInput("popup", "popup_value_font_size", "Popup value font size", "number")}
              ${this._renderInput("popup", "popup_value_font_weight", "Popup value font weight", "number")}
              ${this._renderInput("popup", "popup_label_font_size", "Popup label font size", "number")}
              ${this._renderInput("popup", "popup_label_font_weight", "Popup label font weight", "number")}
              ${this._renderSelect("popup", "popup_time_format", "Popup time format", POPUP_TIME_FORMAT_OPTIONS)}
            `, "Text and slider display style inside popups.")}
            ${this._renderCategoryAccordion("Buttons", html`
              ${this._renderInput("popup", "popup_highlight_color", "Active button color")}
              ${this._renderInput("popup", "popup_highlight_text_color", "Active button text color")}
              ${this._renderInput("popup", "popup_highlight_radius", "Active button border radius", "number")}
              ${this._renderInput("popup", "popup_highlight_opacity", "Active button opacity", "number")}
              ${this._renderInput("popup", "popup_highlight_border_color", "Active button border color")}
              ${this._renderSelect("popup", "popup_highlight_border_style", "Active button border style", BORDER_STYLES)}
              ${this._renderInput("popup", "popup_highlight_border_width", "Active button border width", "number")}
              ${this._renderInput("popup", "popup_highlight_box_shadow", "Active button box shadow")}
              ${this._renderInput("popup", "popup_button_bg", "Inactive button background")}
              ${this._renderInput("popup", "popup_button_text_color", "Inactive button text color")}
              ${this._renderInput("popup", "popup_button_radius", "Inactive button border radius", "number")}
              ${this._renderInput("popup", "popup_button_opacity", "Inactive button opacity", "number")}
              ${this._renderInput("popup", "popup_button_border_color", "Inactive button border color")}
              ${this._renderSelect("popup", "popup_button_border_style", "Inactive button border style", BORDER_STYLES)}
              ${this._renderInput("popup", "popup_button_border_width", "Inactive button border width", "number")}
            `, "Styling for active/inactive popup action buttons.")}
            ${this._renderCategoryAccordion("Climate", html`
              ${this._renderSwitch("popup", "climate_use_circular_slider", "Climate circular slider")}
              ${this._renderSwitch("popup", "climate_show_plus_minus", "Climate show plus/minus")}
              ${this._renderSwitch("popup", "climate_show_gradient", "Climate show gradient")}
              ${this._renderSwitch("popup", "climate_show_target_range", "Climate show target range")}
              ${this._renderInput("popup", "climate_temp_step", "Climate temperature step", "number")}
            `, "Domain-specific climate popup display style.")}
            ${this._renderCategoryAccordion("Humidifier", html`
              ${this._renderSwitch("popup", "humidifier_use_circular_slider", "Humidifier circular slider")}
              ${this._renderSwitch("popup", "humidifier_show_plus_minus", "Humidifier show plus/minus")}
              ${this._renderSwitch("popup", "humidifier_show_gradient", "Humidifier show gradient")}
              ${this._renderInput("popup", "humidifier_humidity_step", "Humidifier humidity step", "number")}
            `, "Domain-specific humidifier popup display style.")}
            ${this._renderCategoryAccordion("Sensor", html`
              ${this._renderInput("popup", "sensor_graph_style", "Sensor graph style")}
              ${this._renderInput("popup", "sensor_graph_color", "Sensor graph color")}
              ${this._renderInput("popup", "sensor_line_width", "Sensor line width", "number")}
              ${this._renderInput("popup", "sensor_hours", "Sensor default range (hours)", "number")}
              ${this._renderSwitch("popup", "sensor_graph_gradient", "Sensor graph gradient")}
            `, "Domain-specific graph style for sensor/input_number popups.")}
            ${this._renderCategoryAccordion("Lock", html`
              ${this._renderInput("popup", "popup_button_radius", "Action button radius", "number")}
              ${this._renderInput("popup", "popup_highlight_radius", "Active action radius", "number")}
            `, "Lock popup uses the shared popup button styles.")}
          </section>
        </details>

        <details class="scope-accordion">
          <summary>Header Card Defaults</summary>
          <section class="scope">
            ${this._renderScopeHeader("Header Card Defaults", "header", "Applied to hki-header-card when a field is empty.")}
            ${this._renderCategoryAccordion("Card", html`
              ${this._renderTemplateInput("header", "card_border_radius", "Card border radius (Template/CSS)")}
              ${this._renderTemplateInput("header", "card_border_radius_top", "Top border radius (Template/CSS)")}
              ${this._renderTemplateInput("header", "card_border_radius_bottom", "Bottom border radius (Template/CSS)")}
              ${this._renderTemplateInput("header", "card_box_shadow", "Card box shadow (Template/CSS)")}
              ${this._renderInput("header", "card_border_width", "Card border width", "number")}
              ${this._renderSelect("header", "card_border_style", "Card border style", BORDER_STYLES)}
              ${this._renderTemplateInput("header", "card_border_color", "Card border color (Template/CSS)")}
            `, "Styles the header card frame and border.")}
            ${this._renderCategoryAccordion("Typography", html`
              ${this._renderSelect("header", "font_family", "Font family", FONT_FAMILIES)}
              ${this._renderInput("header", "font_family_custom", "Custom font")}
              ${this._renderSelect("header", "font_style", "Font style", [{ value: "normal", label: "normal" }, { value: "italic", label: "italic" }])}
              ${this._renderInput("header", "title_size_px", "Title size", "number")}
              ${this._renderInput("header", "subtitle_size_px", "Subtitle size", "number")}
              ${this._renderSelect("header", "title_weight", "Title weight", HEADER_WEIGHT_OPTIONS)}
              ${this._renderSelect("header", "subtitle_weight", "Subtitle weight", HEADER_WEIGHT_OPTIONS)}
              ${this._renderTemplateInput("header", "title_color", "Title color (Template/CSS)")}
              ${this._renderTemplateInput("header", "subtitle_color", "Subtitle color (Template/CSS)")}
            `, "Title/subtitle font and text color defaults.")}
          </section>
        </details>

        <details class="scope-accordion">
          <summary>Navigation Card Defaults</summary>
          <section class="scope">
            ${this._renderScopeHeader("Navigation Card Defaults", "navigation", "Applied to hki-navigation-card when a field is empty.")}
            ${this._renderCategoryAccordion("Button Surface", html`
              ${this._renderInput("navigation", "default_border_radius", "Default border radius", "number")}
              ${this._renderInput("navigation", "default_border_width", "Default border width", "number")}
              ${this._renderSelect("navigation", "default_border_style", "Default border style", BORDER_STYLES)}
              ${this._renderTemplateInput("navigation", "default_border_color", "Default border color (Template/CSS)")}
              ${this._renderTemplateInput("navigation", "button_box_shadow", "Button box shadow (Template/CSS)")}
              ${this._renderTemplateInput("navigation", "button_box_shadow_hover", "Button box shadow hover (Template/CSS)")}
              ${this._renderInput("navigation", "default_button_opacity", "Default button opacity (0-1)", "number")}
              ${this._renderTemplateInput("navigation", "default_background", "Default background (Template/CSS)")}
              ${this._renderTemplateInput("navigation", "default_icon_color", "Default icon color (Template/CSS)")}
            `, "Default look for navigation buttons.")}
            ${this._renderCategoryAccordion("Label Typography", html`
              ${this._renderInput("navigation", "label_font_size", "Label font size", "number")}
              ${this._renderInput("navigation", "label_font_weight", "Label font weight", "number")}
              ${this._renderInput("navigation", "label_letter_spacing", "Label letter spacing", "number")}
              ${this._renderSelect("navigation", "label_text_transform", "Label text transform", NAV_TEXT_TRANSFORM)}
              ${this._renderTemplateInput("navigation", "label_color", "Label color (Template/CSS)")}
            `, "Typography for navigation button labels.")}
            ${this._renderCategoryAccordion("Bottom Bar", html`
              ${this._renderInput("navigation", "bottom_bar_border_radius", "Bottom bar radius", "number")}
              ${this._renderTemplateInput("navigation", "bottom_bar_box_shadow", "Bottom bar box shadow (Template/CSS)")}
              ${this._renderInput("navigation", "bottom_bar_border_width", "Bottom bar border width", "number")}
              ${this._renderSelect("navigation", "bottom_bar_border_style", "Bottom bar border style", BORDER_STYLES)}
              ${this._renderTemplateInput("navigation", "bottom_bar_border_color", "Bottom bar border color (Template/CSS)")}
            `, "Style for the optional bottom bar container.")}
          </section>
        </details>

        <div class="footer">
          <button type="button" class="hki-reset-btn hki-reset-btn-danger" @click=${this._resetAll}>
            <ha-icon icon="mdi:restore-alert"></ha-icon>
            <span>Reset all globals</span>
          </button>
        </div>
      </div>
    `;
  }

  static get styles() {
    return css`
      .wrap {
        display: flex;
        flex-direction: column;
        gap: 14px;
        padding: 14px;
        overflow: visible;
      }
      :host, ha-card {
        overflow: visible;
      }
      .intro {
        border-radius: 12px;
        padding: 14px;
        background: linear-gradient(135deg, rgba(34, 49, 63, 0.9), rgba(33, 110, 160, 0.55));
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .title {
        font-size: 16px;
        font-weight: 700;
      }
      .sub {
        margin-top: 6px;
        font-size: 12px;
        opacity: 0.85;
      }
      .scope {
        display: flex;
        flex-direction: column;
        gap: 12px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.08);
        padding: 12px;
        overflow: visible;
      }
      .category {
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        padding: 10px;
        background: rgba(255, 255, 255, 0.03);
      }
      .category-accordion {
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.03);
        overflow: visible;
      }
      .category-accordion > summary {
        list-style: none;
        cursor: pointer;
        user-select: none;
        padding: 10px 12px;
        font-size: 12px;
        font-weight: 700;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        background: rgba(255, 255, 255, 0.03);
      }
      .category-accordion > summary::-webkit-details-marker {
        display: none;
      }
      .category-accordion > summary::after {
        content: "+";
        float: right;
        opacity: 0.8;
      }
      .category-accordion[open] > summary::after {
        content: "-";
      }
      .category-accordion > .category {
        border: none;
        border-radius: 0;
        background: transparent;
      }
      .category-title {
        font-size: 12px;
        font-weight: 700;
        letter-spacing: 0.02em;
        opacity: 0.9;
        margin-bottom: 8px;
      }
      .category-sub {
        font-size: 11px;
        opacity: 0.75;
        margin: 0 0 8px 0;
      }
      .scope-accordion {
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.06);
        overflow: visible;
      }
      .scope-accordion > summary {
        list-style: none;
        cursor: pointer;
        user-select: none;
        padding: 12px 14px;
        font-weight: 700;
        border-bottom: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.04);
      }
      .scope-accordion > summary::-webkit-details-marker {
        display: none;
      }
      .scope-accordion > summary::after {
        content: "+";
        float: right;
        opacity: 0.8;
      }
      .scope-accordion[open] > summary::after {
        content: "-";
      }
      .scope-accordion > .scope {
        border: none;
        border-radius: 0;
        background: transparent;
      }
      .scope-head {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 10px;
      }
      .scope-title {
        font-size: 14px;
        font-weight: 700;
      }
      .scope-sub {
        font-size: 11px;
        opacity: 0.75;
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }
      ha-textfield, ha-select, ha-code-editor {
        width: 100%;
      }
      ha-code-editor {
        border-radius: 8px;
        overflow: hidden;
      }
      .tpl-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .tpl-title {
        font-size: 12px;
        font-weight: 600;
        opacity: 0.9;
      }
      .hki-reset-btn{
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid var(--primary-color);
        background: var(--primary-color);
        color: var(--text-primary-color, #fff);
        cursor: pointer;
        font-size: 13px;
        font-weight: 600;
        line-height: 1;
        transition: background 120ms ease, border-color 120ms ease, transform 60ms ease;
      }
      .hki-reset-btn:hover{
        background: rgba(255,255,255,0.14);
        border-color: rgba(255,255,255,0.35);
      }
      .hki-reset-btn:active{
        transform: translateY(1px);
        background: rgba(255,255,255,0.18);
      }
      .hki-reset-btn ha-icon{
        width: 18px;
        height: 18px;
      }
      .hki-reset-btn-danger{
        border-color: var(--error-color, #d32f2f);
        background: var(--error-color, #d32f2f);
      }
      .footer {
        display: flex;
        justify-content: flex-end;
        gap: 10px;
      }
      @media (max-width: 720px) {
        .grid {
          grid-template-columns: 1fr;
        }
      }
    `;
  }
}

class HkiSettingsCard extends HkiSettingsBase {
  static getConfigElement() {
    return document.createElement(EDITOR_TAG);
  }

  render() {
    if (!this._config) this._config = normalizeConfig({});
    return html`<ha-card>${this._renderForm()}</ha-card>`;
  }
}

class HkiSettingsCardEditor extends HkiSettingsBase {
  render() {
    if (!this._config) this._config = normalizeConfig({});
    return this._renderForm();
  }
}

if (!customElements.get(CARD_TYPE)) {
  customElements.define(CARD_TYPE, HkiSettingsCard);
}
if (!customElements.get(EDITOR_TAG)) {
  customElements.define(EDITOR_TAG, HkiSettingsCardEditor);
}

window.customCards = window.customCards || [];
window.customCards.push({
  type: CARD_TYPE,
  name: "HKI Settings Card",
  description: "Global style defaults for HKI cards.",
  preview: false,
});

})();

// ============================================================
// hki-notification-card
// ============================================================

(() => {
// HKI Notification Card

const CARD_NAME = "hki-notification-card";

const { LitElement, html, css } = window.HKI.getLit();
const CARD_TYPE = "hki-notification-card";
const EDITOR_TAG = "hki-notification-card-editor";

const FONTS = [
  "system-ui, sans-serif",
  "Roboto, sans-serif",
  "Segoe UI, sans-serif",
  "Helvetica Neue, sans-serif",
  "Arial, sans-serif",
  "Verdana, sans-serif",
  "Open Sans, sans-serif",
  "Lato, sans-serif",
  "Montserrat, sans-serif",
  "Poppins, sans-serif",
  "Inter, sans-serif",
  "Nunito, sans-serif",
  "Raleway, sans-serif",
  "Ubuntu, sans-serif",
  "Source Sans Pro, sans-serif",
  "Oswald, sans-serif",
  "Playfair Display, serif",
  "Merriweather, serif",
  "Georgia, serif",
  "Times New Roman, serif",
  "Courier New, monospace",
  "Fira Code, monospace",
  "JetBrains Mono, monospace",
  "Custom"
];
const applyGlobalDefaultsToConfig = window.HKI?.applyGlobalDefaultsToConfig || (({ config }) => config);
const NOTIFICATION_POPUP_NESTED_KEYS = Object.freeze([
  ["popup_enabled", "enabled"],
  ["popup_title", "title"],
  ["popup_open_animation", "open_animation"],
  ["popup_close_animation", "close_animation"],
  ["popup_animation_duration", "animation_duration"],
  ["popup_blur_enabled", "blur_enabled"],
  ["popup_blur_amount", "blur_amount"],
  ["popup_card_blur_enabled", "card_blur_enabled"],
  ["popup_card_blur_amount", "card_blur_amount"],
  ["popup_card_opacity", "card_opacity"],
  ["popup_border_radius", "border_radius"],
  ["popup_width", "width"],
  ["popup_width_custom", "width_custom"],
  ["popup_height", "height"],
  ["popup_height_custom", "height_custom"],
  ["popup_hide_top_bar", "hide_top_bar"],
  ["popup_show_close_button", "show_close_button"],
  ["popup_close_on_action", "close_on_action"],
]);

function migrateNotificationConfig(config) {
  const next = { ...(config || {}) };
  const popup = (next.hki_popup && typeof next.hki_popup === "object") ? next.hki_popup : null;
  if (!popup) return next;
  NOTIFICATION_POPUP_NESTED_KEYS.forEach(([flatKey, nestedKey]) => {
    if (next[flatKey] !== undefined) return;
    if (popup[nestedKey] === undefined) return;
    next[flatKey] = popup[nestedKey];
  });
  return next;
}

function serializeNotificationConfig(config) {
  const output = { ...(config || {}) };
  const popup = (output.hki_popup && typeof output.hki_popup === "object") ? { ...output.hki_popup } : {};

  NOTIFICATION_POPUP_NESTED_KEYS.forEach(([flatKey, nestedKey]) => {
    const value = output[flatKey];
    if (value !== undefined && value !== null && !(typeof value === "string" && value.trim() === "")) {
      popup[nestedKey] = value;
    }
    delete output[flatKey];
  });

  if (Object.keys(popup).length) output.hki_popup = popup;
  else delete output.hki_popup;
  return output;
}

// --- MAIN CARD CLASS ---
class HkiNotificationCard extends LitElement {
  
  static getConfigElement() {
    return document.createElement(EDITOR_TAG);
  }

  static getStubConfig() {
    return {
      entity: "sensor.notifications",
      display_mode: "ticker",
      show_icon: true,
      interval: 3,
      auto_cycle: true,
      use_header_styling: false
    };
  }

  static get properties() {
    return {
      hass: {},
      _config: { state: true },
      _tickerIndex: { state: true },
      _animationClass: { state: true },
      _isInBadgeSlot: { state: true },
      _popupOpen: { state: true },
      _marqueeNeedsDuplicate: { state: true },
      _confirmationPending: { state: true }
    };
  }

  constructor() {
    super();
    this._tickerIndex = 0;
    this._tickerTimer = null;
    this._marqueeFrame = null;
    this._marqueeResumeTimer = null;
    this._scrollPos = 0;
    this._isPaused = false;
    this._dragStart = null;
    this._isDragging = false;
    this._wasDragged = false;
    this._animationClass = "";
    this._lastMsgCount = -1;
    this._lastMsgJSON = "";
    this._isInBadgeSlot = false;
    this._isInHeaderCard = false;
    this._popupOpen = false;
    this._popupPillSwipe = null;
    this._swipeHandlers = {};
    this._marqueeNeedsDuplicate = false;
    this._confirmationPending = null;
    // CSS animation drag tracking
    this._cssScrollOffset = 0;
    this._cssDragOffset = 0;
    // Popup portal container
    this._popupPortal = null;
    this._popupClosing = false;
  }

  setConfig(config) {
    if (!config) throw new Error("Invalid configuration");
    const flatInput = migrateNotificationConfig(config);
    this._config = {
      entity: "", 
      attribute: "messages",
      display_mode: "ticker",
      // Changed default to true to match Editor UI assumption
      show_empty: true,
      empty_message: "No Notifications",
      auto_cycle: true, 
      auto_scroll: true,
      marquee_speed: 1, 
      marquee_gap: 16,
      list_max_items: 3,
      interval: 3, 
      animation_duration: 0.5,
      animation: "slide",
      direction: "right",
      alignment: "left",
      full_width: false,
      // Header card integration - Disabled by default
      use_header_styling: false,
      // Appearance
      show_icon: true,
      icon_after: false,
      text_color: "var(--primary-text-color)",
      icon_color: "var(--primary-text-color)",
      bg_color: "rgba(var(--rgb-card-background-color, 30, 30, 30), 0.85)",
      bg_opacity: 1,
      show_background: true,
      border_color: "rgba(255,255,255,0.08)",
      border_width: 1,
      border_radius: 99,
      box_shadow: "0 4px 12px rgba(0,0,0,0.15)",
      font_size: 13,
      font_weight: "Semi Bold",
      font_family: FONTS[0],
      custom_font_family: "",
      popup_title: "Notifications",
      popup_enabled: true,
      popup_open_animation: "scale",
      popup_close_animation: "scale",
      popup_animation_duration: 300,
      tap_action_popup_only: false,
      confirm_tap_action: false,
      // Popup Backdrop & Card Styling (match hki-button-card defaults)
      popup_blur_enabled: true,
      popup_blur_amount: 10,
      popup_card_blur_enabled: true,
      popup_card_blur_amount: 40,
      popup_card_opacity: 0.4,
      popup_border_radius: 16,
      popup_width: "auto",
      popup_width_custom: 400,
      popup_height: "auto",
      popup_height_custom: 600,
      popup_hide_top_bar: false,
      popup_show_close_button: true,
      popup_close_on_action: false,
      // Timestamp options
      show_list_timestamp: false,
      show_popup_timestamp: true,
      // Timestamp formatting: 'auto' (system locale), '12', '24'
      time_format: "auto",
      // Button mode options
      button_icon: "mdi:bell",
      button_icon_color: "var(--primary-text-color)",
      button_bg_color: "rgba(var(--rgb-card-background-color, 30, 30, 30), 0.85)",
      button_size: 48,
      button_label: "",
      button_label_position: "below",
      button_show_badge: true,
      button_badge_color: "#ff4444",
      button_badge_text_color: "#ffffff",
      button_badge_size: 0, // 0 = auto (scales with button_size)
      // Pill button options (when label_position is "inside")
      button_pill_size: 14,
      button_pill_full_width: false,
      button_pill_bg_color: "rgba(var(--rgb-card-background-color, 30, 30, 30), 0.85)",
      button_pill_border_style: "solid",
      button_pill_border_width: 1,
      button_pill_border_color: "rgba(255,255,255,0.08)",
      button_pill_border_radius: 99,
      button_pill_badge_position: "inside",
      ...flatInput,
    };
    applyGlobalDefaultsToConfig({
      scope: "popup",
      config: this._config,
      sourceConfig: flatInput,
      fields: [
        "popup_border_radius",
        "popup_width",
        "popup_width_custom",
        "popup_height",
        "popup_height_custom",
        "popup_open_animation",
        "popup_close_animation",
        "popup_animation_duration",
        "popup_blur_enabled",
        "popup_blur_amount",
        "popup_card_blur_enabled",
        "popup_card_blur_amount",
        "popup_card_opacity",
        "popup_hide_top_bar",
        "popup_show_close_button",
        "popup_close_on_action",
      ],
    });
    this._resetTicker();
  }

  connectedCallback() {
    super.connectedCallback();
    
    this._detectBadgeSlot();
    
    this._resizeObserver = new ResizeObserver(() => {
        this._detectBadgeSlot();
        if (this._config.display_mode === 'marquee') {
            if (this._isInBadgeSlot) {
                this._checkMarqueeOverflow();
            } else {
                this._resetTicker();
                this._checkMarqueeOverflow();
            }
        }
    });
    this._resizeObserver.observe(this);
    this._resetTicker();
    
    if (this._config?.display_mode === 'marquee') {
        setTimeout(() => this._checkMarqueeOverflow(), 100);
        setTimeout(() => this._checkMarqueeOverflow(), 500);
    }
    
    this._boundMouseMove = this._onMove.bind(this);
    this._boundMouseUp = this._onEnd.bind(this);
    window.addEventListener("mousemove", this._boundMouseMove);
    window.addEventListener("mouseup", this._boundMouseUp);
  }

  _detectBadgeSlot() {
    let element = this;
    let depth = 0;
    const maxDepth = 15;
    
    this._isInHeaderCard = false;
    
    while (element && depth < maxDepth) {
      const tagName = element.tagName?.toLowerCase() || '';
      const className = element.className || '';
      const slot = element.getAttribute?.('slot') || '';
      
      if (tagName === 'hki-header-card') {
        this._isInBadgeSlot = true;
        this._isInHeaderCard = true;
        return;
      }
      
      if (
        tagName.includes('badge') ||
        className.includes('badge') ||
        slot.includes('badge') ||
        tagName === 'hui-badge' ||
        (className.includes('header') && className.includes('slot'))
      ) {
        this._isInBadgeSlot = true;
        return;
      }
      
      element = element.parentElement || element.getRootNode()?.host;
      depth++;
    }
    
    this._isInBadgeSlot = false;
  }

  _isEditMode() {
    try {
      const qs = new URLSearchParams(window.location.search || "");
      if (qs.get("edit") === "1") return true;
    } catch (_) {}
    try {
      if (document.body?.classList?.contains("edit-mode") || document.body?.classList?.contains("edit")) return true;
      if (document.querySelector("hui-dialog-edit-card")) return true;
      const huiRoot = document.querySelector("hui-root") || document.querySelector("home-assistant")?.shadowRoot?.querySelector("hui-root");
      if (huiRoot?.lovelace?.editMode || huiRoot?.editMode) return true;
    } catch (_) {}
    return false;
  }

  _getAutoColorEntity(msg = null) {
    const entityId = msg?.entity || msg?.entity_id || this._config?.entity || "";
    return entityId && this.hass?.states?.[entityId] ? this.hass.states[entityId] : null;
  }

  _getDefaultHaIconColor(entity = null) {
    if (!entity) return "var(--state-icon-color)";
    const state = String(entity.state || "").toLowerCase();
    if (state === "unavailable" || state === "unknown") return "var(--state-icon-unavailable-color)";
    const domain = String(entity.entity_id || "").split(".")[0];
    const isOn = ["on", "open", "unlocked", "playing", "home", "heat", "cool", "auto", "heat_cool", "dry", "fan_only", "triggered"].includes(state);
    if (domain === "climate") return this._getAutoEntityColor(entity) || "var(--state-icon-color)";
    return isOn ? "#ffc107" : "var(--state-icon-color)";
  }

  _getAutoEntityColor(entity = null) {
    if (!entity) return null;
    const domain = String(entity.entity_id || "").split(".")[0];
    const state = String(entity.state || "").toLowerCase();
    if (state === "unavailable" || state === "unknown") return "var(--state-icon-unavailable-color)";

    if (domain === "climate") {
      const hvacAction = String(entity.attributes?.hvac_action || entity.state || "").toLowerCase();
      if (hvacAction === "heating" || hvacAction === "heat") return "darkorange";
      if (hvacAction === "cooling" || hvacAction === "cool") return "#1E90FF";
      if (hvacAction === "drying" || hvacAction === "dry") return "#FFC107";
      if (hvacAction === "fan" || hvacAction === "fan_only") return "#9E9E9E";
      const hvacMode = state;
      if (hvacMode === "heat") return "darkorange";
      if (hvacMode === "cool") return "#1E90FF";
      if (hvacMode === "auto" || hvacMode === "heat_cool") return "#4CAF50";
      if (hvacMode === "dry") return "#FFC107";
      if (hvacMode === "fan_only") return "#9E9E9E";
      return "var(--state-icon-color)";
    }

    if (domain === "light" && state === "on") {
      const attrs = entity.attributes || {};
      if (Array.isArray(attrs.rgb_color) && attrs.rgb_color.length === 3) {
        return `rgb(${attrs.rgb_color[0]}, ${attrs.rgb_color[1]}, ${attrs.rgb_color[2]})`;
      }
      if (Array.isArray(attrs.hs_color) && attrs.hs_color.length >= 2) {
        return `hsl(${attrs.hs_color[0]}, ${attrs.hs_color[1]}%, 50%)`;
      }
      return "#ffc107";
    }

    return ["on", "open", "unlocked", "playing", "home"].includes(state) ? "#ffc107" : "var(--state-icon-color)";
  }

  _resolveAutoColorValue(value, msg = null, fallback = "") {
    if (value === undefined || value === null) return fallback;
    const str = String(value).trim();
    if (!str) return fallback;
    if (str.toLowerCase() !== "auto") return value;
    const entity = this._getAutoColorEntity(msg);
    return this._getAutoEntityColor(entity) || this._getDefaultHaIconColor(entity);
  }

  _resolveAutoShadowValue(value, msg = null, fallback = "") {
    if (value === undefined || value === null || value === "") return fallback;
    const str = String(value).trim().toLowerCase();
    if (str !== "auto") return value;
    const entity = this._getAutoColorEntity(msg);
    const autoColor = this._getAutoEntityColor(entity) || this._getDefaultHaIconColor(entity);
    return `0 8px 24px ${autoColor}`;
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this._stopTicker();
    this._stopMarquee();
    if (this._resizeObserver) this._resizeObserver.disconnect();
    window.removeEventListener("mousemove", this._boundMouseMove);
    window.removeEventListener("mouseup", this._boundMouseUp);
    this._removePopupPortal();
  }

  _stopTicker() {
    if (this._tickerTimer) clearInterval(this._tickerTimer);
    this._tickerTimer = null;
  }

  _stopMarquee() {
    if (this._marqueeFrame) cancelAnimationFrame(this._marqueeFrame);
    if (this._marqueeResumeTimer) clearTimeout(this._marqueeResumeTimer);
    this._marqueeFrame = null;
  }

  _resetTicker() {
    this._stopTicker();
    this._stopMarquee();
    
    if (this._config.display_mode === "marquee") {
        if (!this._isInBadgeSlot) {
            setTimeout(() => this._startMarquee(), 200);
        }
        return;
    }
    
    if (this._config.display_mode === "list" || this._config.auto_cycle === false) return;

    const intervalMs = (this._config?.interval || 3) * 1000;
    if (intervalMs <= 0) return;

    this._tickerTimer = setInterval(() => {
      const msgs = this._getMessages();
      if (this._isPaused || msgs.length <= 1) return;
      this._changeMessage("next", "auto");
    }, intervalMs);
  }

  _startMarquee() {
    const loop = () => {
        if (!this.isConnected) {
            this._stopMarquee();
            return;
        }

        const shouldScroll = this._config.auto_scroll !== false && !this._isPaused && !this._isDragging;

        if (shouldScroll) {
            const container = this.shadowRoot?.querySelector('.marquee-container');
            if (container) {
                const speed = parseFloat(this._config.marquee_speed) || 1;
                if (container.scrollWidth > container.clientWidth) {
                    this._scrollPos += speed;
                    if (this._scrollPos >= container.scrollWidth / 2) {
                        this._scrollPos = 0;
                    }
                    container.scrollLeft = this._scrollPos;
                }
            }
        }
        this._marqueeFrame = requestAnimationFrame(loop);
    };
    this._stopMarquee();
    this._marqueeFrame = requestAnimationFrame(loop);
  }

  _getMessages() {
    if (!this.hass || !this._config || !this._config.entity) return [];
    const stateObj = this.hass.states[this._config.entity];
    if (!stateObj || !stateObj.attributes) return [];
    const list = stateObj.attributes[this._config.attribute];
    return Array.isArray(list) ? list : [];
  }

  _changeMessage(dir, source) {
    const msgs = this._getMessages();
    if (msgs.length <= 1 && source === "auto") return; 

    this._animationClass = "";
    this.requestUpdate();

    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        if (dir === "next") this._tickerIndex++;
        else this._tickerIndex = this._tickerIndex > 0 ? this._tickerIndex - 1 : 0;
        
        const animType = this._config.animation || "slide";
        this._animationClass = `anim-${animType}`;
        this.requestUpdate();
      });
    });
  }
  
  _onStart(x, y) {
    this._isPaused = true;
    this._dragStart = { x, y };
    this._isDragging = false;
    this._wasDragged = false;
    if (this._marqueeResumeTimer) clearTimeout(this._marqueeResumeTimer);
    const container = this.shadowRoot?.querySelector('.marquee-container');
    if (container) this._scrollPos = container.scrollLeft;
    
    const content = this.shadowRoot?.querySelector('.marquee-content');
    if (content) {
        content.classList.add('paused');
        
        if (this._isInBadgeSlot && this._config.display_mode === 'marquee') {
            const computedStyle = window.getComputedStyle(content);
            const matrix = new DOMMatrix(computedStyle.transform);
            this._cssScrollOffset = matrix.m41; 
            this._cssDragOffset = this._cssScrollOffset;
            content.style.animation = 'none';
            content.style.transform = `translateX(${this._cssScrollOffset}px)`;
        }
    }
  }

  _onMove(e) {
    const x = e.clientX || (e.touches ? e.touches[0].clientX : 0);
    const y = e.clientY || (e.touches ? e.touches[0].clientY : 0);
    if (!this._dragStart) return;
    
    const diffX = Math.abs(this._dragStart.x - x);
    const diffY = Math.abs(this._dragStart.y - y);
    
    if (diffX > 5 || diffY > 5) {
        this._isDragging = true;
        this._wasDragged = true;
        if (this._config.display_mode === "marquee") {
            if (this._isInBadgeSlot) {
                const content = this.shadowRoot?.querySelector('.marquee-content');
                if (content) {
                    const deltaX = x - this._dragStart.x;
                    const currentOffset = this._cssScrollOffset || 0;
                    this._cssDragOffset = currentOffset + deltaX;
                    content.style.transform = `translateX(${this._cssDragOffset}px)`;
                }
            } else {
                const container = this.shadowRoot?.querySelector('.marquee-container');
                if (container) {
                    const deltaX = x - this._dragStart.x;
                    container.scrollLeft = this._scrollPos - deltaX;
                }
            }
        }
    }
  }

  _onEnd(e) {
    if (!this._dragStart) return;
    const x = e.clientX || (e.changedTouches ? e.changedTouches[0].clientX : 0);
    const y = e.clientY || (e.changedTouches ? e.changedTouches[0].clientY : 0);
    const startX = this._dragStart.x;
    const startY = this._dragStart.y;
    this._dragStart = null;
    this._isDragging = false;

    if (this._config.display_mode === "marquee") {
        if (this._isInBadgeSlot) {
            const content = this.shadowRoot?.querySelector('.marquee-content');
            if (content) {
                this._cssScrollOffset = this._cssDragOffset || 0;
                this._marqueeResumeTimer = setTimeout(() => { 
                    this._isPaused = false;
                    if (content) {
                        content.style.transform = '';
                        content.style.animation = '';
                        content.classList.remove('paused');
                        this._cssScrollOffset = 0;
                        this._cssDragOffset = 0;
                    }
                }, 3000);
            }
            return;
        }
        
        const container = this.shadowRoot?.querySelector('.marquee-container');
        if (container) this._scrollPos = container.scrollLeft;
        
        this._marqueeResumeTimer = setTimeout(() => { 
            this._isPaused = false;
            const content = this.shadowRoot?.querySelector('.marquee-content');
            if (content) content.classList.remove('paused');
        }, 3000);
        return;
    }
    
    this._isPaused = false;
    if (this._wasDragged && this._config.display_mode === "ticker") {
       const diffX = startX - x;
       const diffY = startY - y;
       const dir = this._config.direction || "right";
       const isVertical = dir === "top" || dir === "bottom";
       if (isVertical) {
         if (Math.abs(diffY) > 30) diffY > 0 ? this._changeMessage("next", "swipe") : this._changeMessage("prev", "swipe");
       } else {
         if (Math.abs(diffX) > 30) diffX > 0 ? this._changeMessage("next", "swipe") : this._changeMessage("prev", "swipe");
       }
    }
  }

  _handleClick(msg, e) {
    if (this._wasDragged) { this._wasDragged = false; return; }
    
    if (this._config.tap_action_popup_only && this._config.popup_enabled !== false && msg._real !== false) {
      this._openPopup();
      return;
    }
    
    if (msg.tap_action) {
      const needsConfirm = this._needsConfirmation(msg);
      if (needsConfirm) {
        this._showConfirmation(msg);
        return;
      }
      this._executeTapAction(msg.tap_action);
      return;
    }
    
    if (this._config.popup_enabled !== false && msg._real !== false) {
      this._openPopup();
    }
  }

  _executeTapAction(action) {
    if (!action) return;

    if (action.action === "navigate" && action.navigation_path) {
      history.pushState(null, "", action.navigation_path);
      const event = new Event("location-changed", { bubbles: true, composed: true });
      window.dispatchEvent(event);
      return;
    } 
    
    if (action.action === "url" && action.url_path) {
      window.open(action.url_path, "_blank");
      return;
    }
    
    if (action.action === "popup") {
      this._openPopup();
      return;
    }

    let serviceName = null;
    
    if (action.service) {
      serviceName = action.service;
    } else if (typeof action.action === "string" && action.action.includes(".")) {
      serviceName = action.action;
    } else if (action.action === "call-service" || action.action === "perform-action") {
      if (action.service) serviceName = action.service;
    }

    if (serviceName) {
      const [domain, service] = serviceName.split(".");
      if (domain && service) {
        const serviceData = { 
          ...(action.data || {}), 
          ...(action.service_data || {}), 
          ...(action.target || {}) 
        };
        this.hass.callService(domain, service, serviceData);
        if (this._config?.popup_close_on_action === true && this._popupOpen && (action.action === "perform-action" || action.action === "call-service")) {
          setTimeout(() => this._closePopup(), 0);
        }
      }
    }
  }

_openPopup() {
  if (this._isEditMode()) return;
  if (this._popupOpen) return;
  this._popupOpen = true;
  this._popupClosing = false;
  this._createPopupPortal();
  window.HKI?.animatePopupOpen?.({
    portal: this._popupPortal,
    config: this._config || {},
    selector: ".hki-popup-container",
  });
}

_closePopup(e) {
  if (e) e.stopPropagation();
  if (!this._popupOpen) return;
  if (this._popupClosing) return;
  this._popupClosing = true;

  const portal = this._popupPortal;
  if (!portal) {
    this._popupOpen = false;
    this._popupClosing = false;
    return;
  }

  const cleanup = () => {
    this._popupOpen = false;
    this._popupClosing = false;
    this._removePopupPortal();
  };
  window.HKI?.animatePopupClose?.({
    portal,
    config: this._config || {},
    selector: ".hki-popup-container",
    onDone: cleanup,
    fallbackDelayMs: 100,
  });
}
  _removePopupPortal() {
    if (this._popupPortal) {
      this._popupPortal.remove();
      this._popupPortal = null;
    }
  }

  // ===== Confirmation (tap_action) overlay =====
  _removeConfirmationPortal() {
    if (this._confirmationPortal) {
      this._confirmationPortal.remove();
      this._confirmationPortal = null;
    }
  }

  _needsConfirmation(msg) {
    // Message-level override (supports booleans and "true"/"false" strings)
    if (msg && msg.confirm !== undefined) {
      if (typeof msg.confirm === 'string') return msg.confirm.toLowerCase() === 'true';
      return !!msg.confirm;
    }

    // Home Assistant standard: tap_action.confirmation (bool or object)
    const conf = msg?.tap_action?.confirmation;
    if (conf !== undefined) {
      if (typeof conf === 'boolean') return conf;
      if (typeof conf === 'string') return conf.toLowerCase() === 'true';
      if (typeof conf === 'object') return true;
      return !!conf;
    }

    // Fallback to card-level default
    return !!this._config.confirm_tap_action;
  }

  _getConfirmationText(msg) {
    // Prefer explicit message confirm_message
    if (msg?.confirm_message) return String(msg.confirm_message);

    const conf = msg?.tap_action?.confirmation;
    // HA confirmation object often uses "text"
    if (conf && typeof conf === 'object') {
      if (conf.text) return String(conf.text);
      if (conf.message) return String(conf.message);
    }

    // Fallback: a readable action description
    return this._getActionDescription(msg?.tap_action);
  }

  _showConfirmation(msg, { closePopupFirst = false } = {}) {
    if (!msg?.tap_action) return;

    if (closePopupFirst) this._closePopup();

    this._confirmationPending = msg;
    this._removeConfirmationPortal();

    const icon = msg.icon || "mdi:bell";
    const actionDesc = this._getConfirmationText(msg);

    const portal = document.createElement("div");
    portal.className = "hki-confirmation-portal";
    portal.innerHTML = `
      <style>
        .hki-confirmation-portal {
          position: fixed;
          inset: 0;
          z-index: 10000;
          display: flex;
          align-items: center;
          justify-content: center;
          background: rgba(0,0,0,0.7);
          backdrop-filter: blur(10px);
          -webkit-backdrop-filter: blur(10px);
        }
        .hki-confirmation-container{
          width: min(92vw, 420px);
          background: rgba(28,28,28,0.65);
          border-radius: 16px;
          box-shadow: 0 8px 32px rgba(0,0,0,0.4);
          padding: 18px 18px 14px;
          color: var(--primary-text-color);
          border: 1px solid rgba(255,255,255,0.08);
        }
        .hki-confirmation-top{
          display:flex;
          align-items:center;
          gap:12px;
          margin-bottom: 10px;
        }
        .hki-confirmation-top ha-icon{
          --mdc-icon-size: 28px;
          opacity: 0.95;
        }
        .hki-confirmation-message{
          font-size: 15px;
          font-weight: 600;
          line-height: 1.25;
          margin: 0;
          word-break: break-word;
        }
        .hki-confirmation-action{
          margin-top: 8px;
          font-size: 13px;
          opacity: 0.8;
          line-height: 1.3;
          word-break: break-word;
        }
        .hki-confirmation-buttons{
          display:flex;
          gap:10px;
          margin-top: 14px;
          justify-content: flex-end;
        }
        .hki-confirmation-btn{
          border: none;
          border-radius: 10px;
          padding: 10px 14px;
          cursor: pointer;
          font-weight: 600;
          color: var(--primary-text-color);
        }
        .hki-confirmation-btn.cancel{
          background: rgba(255,255,255,0.08);
        }
        .hki-confirmation-btn.confirm{
          background: var(--primary-color);
          color: var(--text-primary-color, #fff);
        }
      </style>
      <div class="hki-confirmation-container" role="dialog" aria-modal="true">
        <div class="hki-confirmation-top">
          <ha-icon icon="${icon}"></ha-icon>
          <p class="hki-confirmation-message">${String(msg.message ?? "Confirm action")}</p>
        </div>
        <div class="hki-confirmation-action">${actionDesc}</div>
        <div class="hki-confirmation-buttons">
          <button class="hki-confirmation-btn cancel" data-action="cancel">Cancel</button>
          <button class="hki-confirmation-btn confirm" data-action="confirm">Confirm</button>
        </div>
      </div>
    `;

    portal.addEventListener("click", (e) => {
      // backdrop click cancels
      if (e.target === portal) {
        this._confirmationPending = null;
        this._removeConfirmationPortal();
      }
    });

    portal.querySelector('[data-action="cancel"]')?.addEventListener("click", (e) => {
      e.stopPropagation();
      this._confirmationPending = null;
      this._removeConfirmationPortal();
    });

    portal.querySelector('[data-action="confirm"]')?.addEventListener("click", (e) => {
      e.stopPropagation();
      const pending = this._confirmationPending;
      this._confirmationPending = null;
      this._removeConfirmationPortal();
      if (pending?.tap_action) {
        this._executeTapAction(pending.tap_action);
      }
    });

    document.body.appendChild(portal);
    this._confirmationPortal = portal;
  }



  // Helper to format timestamps
  _formatTime(msg) {
    const raw = msg.time || msg.timestamp || msg.created_at || msg.date;
    if (!raw) return "";
    
    // If it's a plain HH:MM(:SS) string, build a Date for today so we can
    // still apply locale + 12/24 overrides.
    if (typeof raw === 'string') {
      const m = raw.trim().match(/^([01]?\d|2[0-3]):([0-5]\d)(?::([0-5]\d))?$/);
      if (m) {
        const d = new Date();
        d.setHours(parseInt(m[1], 10), parseInt(m[2], 10), parseInt(m[3] || '0', 10), 0);
        return this._formatDateAsTime(d);
      }
    }
    
    try {
        const date = new Date(raw);
        if (isNaN(date.getTime())) return String(raw);
        return this._formatDateAsTime(date);
    } catch (e) {
        return "";
    }
  }

  _formatDateAsTime(date) {
    const fmt = (this._config && this._config.time_format) ? String(this._config.time_format) : 'auto';
    const opts = { hour: '2-digit', minute: '2-digit' };

    // 'auto' -> system locale decides 12/24
    if (fmt === '12') opts.hour12 = true;
    if (fmt === '24') opts.hour12 = false;

    // undefined locales => use system / browser locale
    return date.toLocaleTimeString(undefined, opts);
  }


  _getPopupPortalStyle() {
    return window.HKI?.getPopupBackdropStyle?.(this._config) || '';
  }

  _getPopupCardStyle() {
    return window.HKI?.getPopupCardStyle?.(this._config) || '';
  }

  _getPopupDimensions() {
    return window.HKI?.getPopupDimensions?.(this._config) || { width: '95vw; max-width: 500px', height: '90vh; max-height: 800px' };
  }

  _createPopupPortal() {
    this._removePopupPortal();
    
    
    // Ensure popup animations are available (shared in _bundle-header.js)
    window.HKI?.ensurePopupAnimations?.();
const messages = this._getMessages();
    const realMessages = messages.filter(m => m._real !== false);
    const count = realMessages.length;
    const c = this._config;
    const hideTopBar = c.popup_hide_top_bar === true;
    const showCloseWhenTopHidden = hideTopBar && c.popup_show_close_button !== false;
    
        const popupBorderRadius = c.popup_border_radius ?? 16;
    const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();
const portal = document.createElement('div');
    portal.className = 'hki-notification-popup-portal';

    portal.innerHTML = `
      <style>
        .hki-notification-popup-portal {
          position: fixed;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          ${this._getPopupPortalStyle()}
          
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 9999;
        }
        .hki-popup-container {
          ${this._getPopupCardStyle()}
          border-radius: ${popupBorderRadius}px;
          width: ${popupWidth};
          height: ${popupHeight};
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
          display: flex;
          flex-direction: column;
          position: relative;
          overflow: hidden;
          transition: height 0.2s;
        }
        .hki-popup-header {
          display: flex;
          align-items: center;
          justify-content: space-between;
          padding: 16px 20px;
          border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .hki-popup-title {
          font-size: 18px;
          font-weight: 600;
          color: var(--primary-text-color);
          display: flex;
          align-items: center;
          gap: 8px;
        }
        .hki-popup-count-badge {
          min-width: 22px;
          height: 22px;
          padding: 0 6px;
          border-radius: 11px;
          background: rgba(255, 255, 255, 0.15);
          color: var(--primary-text-color);
          font-size: 12px;
          font-weight: 600;
          display: flex;
          align-items: center;
          justify-content: center;
          box-sizing: border-box;
        }
        /* Updated Close Button Style */
        .hki-popup-close-btn {
          background: rgba(255, 255, 255, 0.1);
          border: 1px solid rgba(255, 255, 255, 0.08);
          border-radius: 50%;
          width: 32px;
          height: 32px;
          display: flex;
          align-items: center;
          justify-content: center;
          cursor: pointer;
          transition: all 0.2s;
          color: var(--primary-text-color);
        }
        .hki-popup-close-btn:hover {
          background: rgba(255, 255, 255, 0.2);
          transform: scale(1.05);
        }
        .hki-popup-close-btn ha-icon {
          --mdc-icon-size: 18px;
        }
        .hki-popup-content {
          flex: 1;
          overflow-y: auto;
          padding: 12px 16px;
          display: flex;
          flex-direction: column;
          gap: 8px;
        }
        .hki-popup-empty {
          display: flex;
          align-items: center;
          justify-content: center;
          height: 100%;
          color: var(--secondary-text-color);
        }
        .hki-popup-footer {
          padding: 12px 16px;
          border-top: 1px solid rgba(255, 255, 255, 0.1);
          margin-top: auto;
        }
        .hki-popup-clear-all-btn {
          width: 100%;
          background: rgba(255, 255, 255, 0.1);
          border: none;
          border-radius: 8px;
          padding: 12px;
          color: var(--primary-text-color);
          font-size: 14px;
          font-weight: 500;
          cursor: pointer;
          transition: background 0.2s;
        }
        .hki-popup-clear-all-btn:hover {
          background: rgba(255, 255, 255, 0.15);
        }
        .hki-popup-pill-wrapper {
          position: relative;
          overflow: hidden;
        }
        .hki-popup-pill-swipe-bg {
          position: absolute;
          right: 0;
          top: 0;
          bottom: 0;
          width: 80px;
          background: #ff4444;
          display: flex;
          align-items: center;
          justify-content: center;
          color: white;
          visibility: hidden;
          opacity: 0;
          border-radius: 12px;
          z-index: 1;
        }
        .hki-popup-pill-swipe-bg ha-icon {
          --mdc-icon-size: 24px;
        }
        .hki-popup-pill {
          box-sizing: border-box;
          display: flex;
          align-items: center;
          gap: 8px;
          width: 100%;
          background: rgba(255, 255, 255, 0.05);
          border: 1px solid rgba(255, 255, 255, 0.08);
          border-radius: 12px;
          padding: 12px 16px;
          padding-right: 70px;
          position: relative;
          z-index: 2;
          transition: transform 0.2s ease-out;
        }
        .hki-popup-pill.clickable {
          cursor: pointer;
          padding-right: 90px;
        }
        .hki-popup-pill.clickable:hover {
          filter: brightness(1.1);
        }
        .hki-popup-pill .icon {
          color: var(--primary-text-color);
          --mdc-icon-size: 20px;
          flex-shrink: 0;
        }
        .hki-popup-pill .icon.spinning {
          animation: hki-spin 2s linear infinite;
        }
        @keyframes hki-spin { 100% { transform: rotate(360deg); } }
        .hki-popup-pill .text-container {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
        }
        .hki-popup-pill .text {
          color: var(--primary-text-color);
          font-size: 14px;
          font-weight: 500;
          white-space: nowrap;
          overflow: hidden;
          text-overflow: ellipsis;
        }
        .hki-popup-pill .timestamp {
            font-size: 11px;
            opacity: 0.6;
            margin-top: 2px;
        }
        .hki-popup-pill .action-indicator {
          position: absolute;
          right: 36px;
          top: 50%;
          transform: translateY(-50%);
          --mdc-icon-size: 18px;
          color: var(--primary-text-color);
          opacity: 0.5;
        }
        .hki-popup-pill .dismiss-btn {
          position: absolute;
          right: 8px;
          top: 50%;
          transform: translateY(-50%);
          width: 24px;
          height: 24px;
          color: var(--primary-text-color);
          opacity: 0.5;
          cursor: pointer;
          background: none;
          border: none;
          padding: 0;
          display: flex;
          align-items: center;
          justify-content: center;
          border-radius: 50%;
          transition: opacity 0.2s, background 0.2s;
        }
        .hki-popup-pill .dismiss-btn:hover {
          opacity: 1;
          background: rgba(255,255,255,0.1);
        }
        .hki-popup-pill .dismiss-btn ha-icon {
          --mdc-icon-size: 16px;
        }
      </style>
      <div class="hki-popup-container">
        ${hideTopBar ? '' : `
          <div class="hki-popup-header">
            <span class="hki-popup-title">
              ${c.popup_title || 'Notifications'}
              <span class="hki-popup-count-badge">${count}</span>
            </span>
            <button class="hki-popup-close-btn">
              <ha-icon icon="mdi:close"></ha-icon>
            </button>
          </div>
        `}
        ${showCloseWhenTopHidden ? `
          <button class="hki-popup-close-btn" style="position:absolute;top:12px;right:12px;z-index:30;">
            <ha-icon icon="mdi:close"></ha-icon>
          </button>
        ` : ''}
        <div class="hki-popup-content">
          ${realMessages.length > 0 ? realMessages.map(msg => this._renderPopupPillHTML(msg)).join('') : `
            <div class="hki-popup-empty">No notifications</div>
          `}
        </div>
        ${realMessages.length > 0 ? `
          <div class="hki-popup-footer">
            <button class="hki-popup-clear-all-btn">Clear All</button>
          </div>
        ` : ''}
      </div>
    `;
    
    portal.addEventListener('click', (e) => {
      if (e.target === portal) {
        this._closePopup();
      }
    });
    
    const closeBtn = portal.querySelector('.hki-popup-close-btn');
    if (closeBtn) {
      closeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this._closePopup();
      });
    }
    
    const clearAllBtn = portal.querySelector('.hki-popup-clear-all-btn');
    if (clearAllBtn) {
      clearAllBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this._clearAllNotifications(e);
      });
    }
    
    const dismissBtns = portal.querySelectorAll('.dismiss-btn');
    dismissBtns.forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const msgId = btn.dataset.msgId;
        if (msgId) {
          this._dismissNotification(msgId, e);
          setTimeout(() => {
            if (this._popupOpen) {
              this._createPopupPortal();
            }
          }, 100);
        }
      });
    });
    
    const pills = portal.querySelectorAll('.hki-popup-pill.clickable');
    pills.forEach(pill => {
      pill.addEventListener('click', (e) => {
        if (e.target.closest('.dismiss-btn')) return;
        const msgIndex = pill.dataset.msgIndex;
        if (msgIndex !== undefined) {
          const msg = realMessages[parseInt(msgIndex)];
          if (msg?.tap_action) {
            const needsConfirm = this._needsConfirmation(msg);
            if (needsConfirm) {
              this._showConfirmation(msg, { closePopupFirst: true });
            } else {
              this._executeTapAction(msg.tap_action);
            }
          }
        }
      });
    });
    
    document.body.appendChild(portal);
    this._popupPortal = portal;
  }

  _renderPopupPillHTML(msg) {
    const icon = msg.icon || "mdi:bell";
    const showIcon = msg.show_icon !== undefined ? msg.show_icon : (this._config.show_icon !== false);
    const iconAfter = !!this._config.icon_after;
    const spinIcon = msg.icon_spin === true;
    const hasAction = !!msg.tap_action;
    const tapActionInPopupOnly = !!this._config.tap_action_popup_only;
    const isRealMsg = msg._real !== false;
    const messages = this._getMessages().filter(m => m._real !== false);
    const msgIndex = messages.indexOf(msg);
    
    // Timestamp Logic for Popup (Default True)
    const showTime = this._config.show_popup_timestamp !== false;
    const timeStr = showTime ? this._formatTime(msg) : "";

    return `
      <div class="hki-popup-pill-wrapper">
        <div class="hki-popup-pill-swipe-bg">
          <ha-icon icon="mdi:delete"></ha-icon>
        </div>
        <div class="hki-popup-pill ${hasAction ? 'clickable' : ''}" data-msg-index="${msgIndex}">
          ${showIcon && !iconAfter ? `<ha-icon class="icon ${spinIcon ? 'spinning' : ''}" icon="${icon}"></ha-icon>` : ''}
          <div class="text-container">
            <div class="text">${msg.message}</div>
            ${timeStr ? `<div class="timestamp">${timeStr}</div>` : ''}
          </div>
          ${showIcon && iconAfter ? `<ha-icon class="icon ${spinIcon ? 'spinning' : ''}" icon="${icon}"></ha-icon>` : ''}
          ${hasAction ? `<ha-icon class="action-indicator" icon="mdi:chevron-right"></ha-icon>` : ''}
          ${isRealMsg ? `
            <button class="dismiss-btn" data-msg-id="${msg.id}">
              <ha-icon icon="mdi:close"></ha-icon>
            </button>
          ` : ''}
        </div>
      </div>
    `;
  }

  _handlePopupBackdropClick(e) {
    if (e.target.classList.contains('popup-backdrop')) {
      this._closePopup();
    }
  }

  _confirmAction(e) {
    if (e) e.stopPropagation();
    if (this._confirmationPending?.tap_action) {
      this._executeTapAction(this._confirmationPending.tap_action);
    }
    this._confirmationPending = null;
  }

  _cancelConfirmation(e) {
    if (e) e.stopPropagation();
    this._confirmationPending = null;
  }

  _handleConfirmationBackdropClick(e) {
    if (e.target.classList.contains('confirmation-backdrop')) {
      this._cancelConfirmation();
    }
  }

  _handlePopupPillClick(msg) {
    if (!msg.tap_action) return;
    
    const needsConfirm = this._needsConfirmation(msg);
      if (needsConfirm) {
        this._showConfirmation(msg);
        return;
      }
    
    this._executeTapAction(msg.tap_action);
  }

  _getActionDescription(action) {
    if (!action) return "Perform action";
    
    if (action.action === "navigate" && action.navigation_path) {
      return `Maps to ${action.navigation_path}`;
    }
    if (action.action === "url" && action.url_path) {
      return `Open ${action.url_path}`;
    }
    
    let serviceName = action.service;
    if (!serviceName && typeof action.action === "string" && action.action.includes(".")) {
      serviceName = action.action;
    }
    if (serviceName) {
      return `Call ${serviceName}`;
    }
    
    return "Perform action";
  }

  _clearAllNotifications(e) {
    e.stopPropagation();
    if (!this.hass || !this._config.entity) return;
    
    this.hass.callService('hki_notify', 'dismiss_all', {
      entity_id: this._config.entity
    });
    
    this._closePopup();
  }

  _dismissNotification(msgId, e) {
    if (e) e.stopPropagation();
    if (!this.hass || !this._config.entity) return;
    
    this.hass.callService('hki_notify', 'dismiss', {
      entity_id: this._config.entity,
      id: msgId
    });
  }

  _getFontWeight(w) {
    const map = { "Light": 300, "Regular": 400, "Medium": 500, "Semi Bold": 600, "Bold": 700, "Extra Bold": 800 };
    return map[w] || 600;
  }

  _getEffectiveFontFamily() {
    const c = this._config;
    if (c.font_family === "Custom" && c.custom_font_family) {
      return c.custom_font_family;
    }
    return c.font_family || FONTS[0];
  }

  _getHeaderCardStyles() {
    try {
      const computedStyle = getComputedStyle(this);
      const fontSize = computedStyle.getPropertyValue('--hki-notify-font-size').trim();
      const fontWeight = computedStyle.getPropertyValue('--hki-notify-font-weight').trim();
      const color = computedStyle.getPropertyValue('--hki-notify-color').trim();
      const iconSize = computedStyle.getPropertyValue('--hki-notify-icon-size').trim();
      const fontFamily = computedStyle.getPropertyValue('--hki-notify-font-family').trim();
      const fontStyle = computedStyle.getPropertyValue('--hki-notify-font-style').trim();
      const pillEnabled = computedStyle.getPropertyValue('--hki-notify-pill-enabled').trim();
      const pillBg = computedStyle.getPropertyValue('--hki-notify-pill-bg').trim();
      const pillPaddingX = computedStyle.getPropertyValue('--hki-notify-pill-padding-x').trim();
      const pillPaddingY = computedStyle.getPropertyValue('--hki-notify-pill-padding-y').trim();
      const pillRadius = computedStyle.getPropertyValue('--hki-notify-pill-radius').trim();
      const pillBlur = computedStyle.getPropertyValue('--hki-notify-pill-blur').trim();
      const pillBorderStyle = computedStyle.getPropertyValue('--hki-notify-pill-border-style').trim();
      const pillBorderWidth = computedStyle.getPropertyValue('--hki-notify-pill-border-width').trim();
      const pillBorderColor = computedStyle.getPropertyValue('--hki-notify-pill-border-color').trim();
      
      const result = {};
      if (fontSize && fontSize !== '') result.fontSize = parseInt(fontSize);
      if (fontWeight && fontWeight !== '') result.fontWeight = fontWeight;
      if (color && color !== '') result.color = color;
      if (iconSize && iconSize !== '') result.iconSize = parseInt(iconSize);
      if (fontFamily && fontFamily !== '') result.fontFamily = fontFamily;
      if (fontStyle && fontStyle !== '') result.fontStyle = fontStyle;
      if (pillEnabled === '1') {
        result.pillEnabled = true;
        if (pillBg && pillBg !== '') result.pillBg = pillBg;
        if (pillPaddingX && pillPaddingX !== '') result.pillPaddingX = pillPaddingX;
        if (pillPaddingY && pillPaddingY !== '') result.pillPaddingY = pillPaddingY;
        if (pillRadius && pillRadius !== '') result.pillRadius = pillRadius;
        if (pillBlur && pillBlur !== '') result.pillBlur = pillBlur;
        if (pillBorderStyle && pillBorderStyle !== '') result.pillBorderStyle = pillBorderStyle;
        if (pillBorderWidth && pillBorderWidth !== '') result.pillBorderWidth = pillBorderWidth;
        if (pillBorderColor && pillBorderColor !== '') result.pillBorderColor = pillBorderColor;
      }
      
      return Object.keys(result).length > 0 ? result : null;
    } catch (e) {
      return null;
    }
  }

  _applyOpacityToColor(color, opacity) {
    if (!color || opacity >= 1) return color;
    
    const rgbaMatch = color.match(/rgba?\s*\(\s*([^)]+)\s*\)/i);
    if (rgbaMatch) {
      const parts = rgbaMatch[1].split(',').map(p => p.trim());
      if (parts.length >= 3) {
        const r = parts[0];
        const g = parts[1];
        const b = parts[2];
        const existingAlpha = parts.length >= 4 ? parseFloat(parts[3]) : 1;
        const newAlpha = (existingAlpha * opacity).toFixed(2);
        return `rgba(${r}, ${g}, ${b}, ${newAlpha})`;
      }
    }
    
    if (color.startsWith('#')) {
      const hex = color.slice(1);
      let r, g, b;
      if (hex.length === 3) {
        r = parseInt(hex[0] + hex[0], 16);
        g = parseInt(hex[1] + hex[1], 16);
        b = parseInt(hex[2] + hex[2], 16);
      } else if (hex.length === 6) {
        r = parseInt(hex.slice(0, 2), 16);
        g = parseInt(hex.slice(2, 4), 16);
        b = parseInt(hex.slice(4, 6), 16);
      } else {
        return color;
      }
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    }
    
    if (color.startsWith('var(')) {
      return color; 
    }
    
    return color;
  }

  willUpdate(changedProps) {
    super.willUpdate(changedProps);
    if (changedProps.has("hass")) {
      const msgs = this._getMessages();
      const currentJSON = JSON.stringify(msgs);
      if (currentJSON !== this._lastMsgJSON) {
        this._lastMsgJSON = currentJSON;
        if (this._lastMsgCount <= 0 && msgs.length > 0) this._tickerIndex = 0;
        this._lastMsgCount = msgs.length;
        if (this._config?.display_mode === 'marquee') {
          this._marqueeNeedsDuplicate = false;
        }
        this.requestUpdate();
      }
    }
  }

  updated(changedProps) {
    super.updated(changedProps);
    if (changedProps.has("hass") && this._popupOpen) {
      this._createPopupPortal();
    }
    if (this._config?.display_mode === 'marquee' && this._config?.auto_scroll !== false) {
      this._checkMarqueeOverflow();
    }
  }

  _checkMarqueeOverflow() {
    const container = this.shadowRoot?.querySelector('.marquee-container');
    const content = this.shadowRoot?.querySelector('.marquee-content');
    if (!container || !content) return;
    
    const messageCount = this._getMessages().length;
    if (messageCount === 0) return;
    
    if (this._isInBadgeSlot) {
      if (!this._marqueeNeedsDuplicate) {
        this._marqueeNeedsDuplicate = true;
      }
      return;
    }
    
    const pills = content.querySelectorAll('.pill');
    if (pills.length === 0 || container.clientWidth === 0) return;
    
    let originalWidth = 0;
    for (let i = 0; i < Math.min(pills.length, messageCount); i++) {
      if (pills[i].offsetWidth === 0) return;
      originalWidth += pills[i].offsetWidth;
    }
    const gap = parseFloat(this._config.marquee_gap) || 16;
    originalWidth += gap * messageCount;
    
    const needsDuplicate = originalWidth > container.clientWidth;
    
    if (needsDuplicate !== this._marqueeNeedsDuplicate) {
      this._marqueeNeedsDuplicate = needsDuplicate;
    }
  }

  _renderPill(msg, isSingle, mode) {
    const c = this._config;
    const isRealMsg = msg._real !== false; 
    const animClass = (mode === "ticker" && !isSingle && isRealMsg) ? this._animationClass : "";

    let headerStyles = null;
    const useHeaderStyling = this._isInHeaderCard && c.use_header_styling;
    if (useHeaderStyling) {
      headerStyles = this._getHeaderCardStyles();
    }

    const textColorRaw = msg.text_color || msg.color_text || (useHeaderStyling && headerStyles?.color) || c.text_color;
    const iconColorRaw = msg.icon_color || msg.color_icon || (useHeaderStyling && headerStyles?.color) || c.icon_color;
    const borderColorRaw = msg.border_color || msg.color_border || c.border_color;
    const textColor = this._resolveAutoColorValue(textColorRaw, msg, c.text_color);
    const iconColor = this._resolveAutoColorValue(iconColorRaw, msg, this._getDefaultHaIconColor(this._getAutoColorEntity(msg)));
    const borderColor = this._resolveAutoColorValue(borderColorRaw, msg, c.border_color);

    // Handle background & opacity
    // 1. Check message specific override first, then card config
    let showBg = msg.show_background !== undefined ? msg.show_background !== false : c.show_background !== false;
    
    let bgColor = this._resolveAutoColorValue(msg.bg_color || msg.color_bg || c.bg_color, msg, c.bg_color);
    let backdropBlur = 'blur(12px)';
    let pillPadding = null;
    let borderRadius = msg.border_radius ?? c.border_radius;
    let pillBorderStyle = null;
    let pillBorderWidth = null;
    let pillBorderColor = null;
    
    if (useHeaderStyling && headerStyles?.pillEnabled) {
      showBg = true;
      bgColor = headerStyles.pillBg || bgColor;
      backdropBlur = `blur(${headerStyles.pillBlur || '0px'})`;
      pillPadding = {
        x: headerStyles.pillPaddingX || '10px',
        y: headerStyles.pillPaddingY || '6px'
      };
      borderRadius = parseInt(headerStyles.pillRadius) || borderRadius;
      if (headerStyles.pillBorderStyle && headerStyles.pillBorderStyle !== 'none') {
        pillBorderStyle = headerStyles.pillBorderStyle;
        pillBorderWidth = headerStyles.pillBorderWidth || '0px';
        pillBorderColor = headerStyles.pillBorderColor || 'rgba(255,255,255,0.1)';
      }
    } else if (!showBg) {
      bgColor = "transparent";
    } else {
        // Apply Opacity
        const opacityVal = msg.bg_opacity !== undefined ? msg.bg_opacity : c.bg_opacity;
        if (opacityVal !== undefined && opacityVal < 1) {
            const opacity = Math.max(0, Math.min(1, parseFloat(opacityVal) || 1));
            bgColor = this._applyOpacityToColor(bgColor, opacity);
        }
    }

    const fontSize = msg.font_size || (useHeaderStyling && headerStyles?.fontSize) || c.font_size;
    const fontWeight = msg.font_weight ? this._getFontWeight(msg.font_weight) : ((useHeaderStyling && headerStyles?.fontWeight) || this._getFontWeight(c.font_weight));
    const fontFamily = msg.font_family || (useHeaderStyling && headerStyles?.fontFamily) || this._getEffectiveFontFamily();
    
    const effectiveBorderWidth = pillBorderWidth ? parseInt(pillBorderWidth) : (showBg ? (msg.border_width ?? c.border_width) : 0);
    const effectiveBorderColor = pillBorderColor || (showBg ? borderColor : 'transparent');
    const effectiveBorderStyle = pillBorderStyle || 'solid';
    const boxShadow = showBg ? this._resolveAutoShadowValue(msg.box_shadow || c.box_shadow, msg, "none") : "none";

    const msgAlignment = msg.alignment || c.alignment || "left";

    const styles = [
        `--pill-color: ${textColor}`,
        `--pill-icon-color: ${iconColor}`,
        `--pill-bg: ${bgColor}`,
        `--pill-border-color: ${effectiveBorderColor}`,
        `--pill-border-width: ${effectiveBorderWidth}px`,
        `--pill-border-style: ${effectiveBorderStyle}`,
        `--pill-radius: ${borderRadius}px`,
        `--pill-shadow: ${boxShadow}`,
        `--pill-backdrop: ${showBg ? backdropBlur : 'none'}`,
        `--pill-font-size: ${fontSize}px`,
        `--pill-font-weight: ${fontWeight}`,
        `--pill-font-family: ${fontFamily}`
    ];
    
    if (pillPadding) {
      styles.push(`--pill-padding-x: ${pillPadding.x}`);
      styles.push(`--pill-padding-y: ${pillPadding.y}`);
    }
    
    const stylesStr = styles.join(";");
    const useHeaderPill = useHeaderStyling && headerStyles?.pillEnabled;

    const icon = msg.icon || "mdi:bell";
    const showIcon = msg.show_icon !== undefined ? msg.show_icon : (c.show_icon !== false);
    const iconAfter = !!c.icon_after;
    const spinIcon = msg.icon_spin === true;
    const hasAction = !!msg.tap_action || (c.popup_enabled !== false && isRealMsg);
    const isFullWidth = c.full_width && mode !== 'marquee';
    const widthClass = isFullWidth ? "full" : "";
    const alignClass = isFullWidth ? `align-${msgAlignment}` : "";
    const noBgClass = !showBg ? "no-bg" : "";
    const headerPillClass = useHeaderPill ? "header-pill" : "";
    
    // Timestamp for List/Ticker (Default False)
    const showTime = c.show_list_timestamp === true;
    const timeStr = showTime ? this._formatTime(msg) : "";

    return html`
        <div class="pill ${animClass} ${widthClass} ${alignClass} ${noBgClass} ${headerPillClass} ${hasAction ? "clickable" : ""}" 
             style="${stylesStr}" 
             @click=${(e) => { e.stopPropagation(); this._handleClick(msg, e); }}>
          ${showIcon && !iconAfter ? html`<ha-icon class="icon ${spinIcon ? "spinning" : ""}" .icon=${icon}></ha-icon>` : ''}
          <div class="text-wrapper">
             <div class="text">${msg.message}</div>
             ${timeStr ? html`<div class="timestamp">${timeStr}</div>` : ''}
          </div>
          ${showIcon && iconAfter ? html`<ha-icon class="icon ${spinIcon ? "spinning" : ""}" .icon=${icon}></ha-icon>` : ''}
        </div>
    `;
  }

  _renderButton(messageCount) {
    const c = this._config;
    const labelPosition = c.button_label_position || "below";
    const isPill = labelPosition === "inside";
    const hasLabel = c.button_label && c.button_label.trim() !== "";
    const showBadge = c.button_show_badge !== false && messageCount > 0;
    const pillBadgePosition = c.button_pill_badge_position || "inside";
    const fullWidth = c.full_width || c.button_pill_full_width;
    
    let contentAlign = "center";
    if (c.alignment === "left") contentAlign = "flex-start";
    if (c.alignment === "right") contentAlign = "flex-end";
    
    // Calculate badge size - if 0 (auto), scale with button size
    const buttonSize = c.button_size || 48;
    const badgeSize = c.button_badge_size > 0 ? c.button_badge_size : Math.max(16, Math.round(buttonSize * 0.4));
    
    const buttonIconColor = this._resolveAutoColorValue(c.button_icon_color, null, "var(--state-icon-color)");
    const buttonBadgeColor = this._resolveAutoColorValue(c.button_badge_color, null, c.button_badge_color);
    const buttonBadgeTextColor = this._resolveAutoColorValue(c.button_badge_text_color, null, c.button_badge_text_color);
    const buttonBgColor = this._resolveAutoColorValue(c.button_bg_color, null, c.button_bg_color);
    const pillButtonBgColor = this._resolveAutoColorValue(c.button_pill_bg_color, null, c.button_pill_bg_color);
    const pillButtonBorderColor = this._resolveAutoColorValue(c.button_pill_border_color, null, c.button_pill_border_color);

    const iconButtonStyles = [
      `--button-size: ${buttonSize}px`,
      `--button-bg: ${buttonBgColor}`,
      `--button-icon-color: ${buttonIconColor}`,
      `--badge-color: ${buttonBadgeColor}`,
      `--badge-text-color: ${buttonBadgeTextColor}`,
      `--badge-size: ${badgeSize}px`,
      `--content-align: ${contentAlign}`
    ].join(";");
    
    const pillButtonStyles = [
      `--pill-button-size: ${c.button_pill_size || 14}px`,
      `--pill-button-bg: ${pillButtonBgColor}`,
      `--pill-button-border-style: ${c.button_pill_border_style || 'solid'}`,
      `--pill-button-border-width: ${c.button_pill_border_width ?? 1}px`,
      `--pill-button-border-color: ${pillButtonBorderColor}`,
      `--pill-button-border-radius: ${c.button_pill_border_radius ?? 99}px`,
      `--button-icon-color: ${buttonIconColor}`,
      `--badge-color: ${buttonBadgeColor}`,
      `--badge-text-color: ${buttonBadgeTextColor}`,
      `--badge-size: ${badgeSize}px`,
      `--content-align: ${contentAlign}`
    ].join(";");
    
    if (isPill && hasLabel) {
      const badgeOutside = pillBadgePosition === "outside";
      return html`
        <div class="notification-pill-wrapper ${fullWidth ? 'full-width' : ''}" style="${pillButtonStyles}">
          <div class="notification-pill-button ${fullWidth ? 'full-width' : ''} ${badgeOutside && showBadge ? 'has-outside-badge' : ''}" 
               @click=${() => this._openPopup()}>
            <ha-icon class="pill-button-icon" .icon=${c.button_icon || "mdi:bell"}></ha-icon>
            <span class="pill-button-label">${c.button_label}</span>
            ${showBadge && !badgeOutside ? html`
              <span class="pill-button-badge">${messageCount > 99 ? '99+' : messageCount}</span>
            ` : ''}
          </div>
          ${showBadge && badgeOutside ? html`
            <span class="pill-outside-badge">${messageCount > 99 ? '99+' : messageCount}</span>
          ` : ''}
        </div>
      `;
    }
    
    return html`
      <div class="notification-button ${hasLabel ? `with-label label-${labelPosition}` : ''} ${fullWidth ? 'full-width' : ''}" 
           style="${iconButtonStyles}"
           @click=${() => this._openPopup()}>
        ${hasLabel && labelPosition === 'left' ? html`<span class="button-label">${c.button_label}</span>` : ''}
        <div class="button-icon-container">
          <ha-icon class="button-icon" .icon=${c.button_icon || "mdi:bell"}></ha-icon>
          ${showBadge ? html`
            <span class="button-badge">${messageCount > 99 ? '99+' : messageCount}</span>
          ` : ''}
        </div>
        ${hasLabel && (labelPosition === 'right' || labelPosition === 'below') ? html`<span class="button-label">${c.button_label}</span>` : ''}
      </div>
    `;
  }

  _calculateScrollDuration(messages) {
    const baseWidth = messages.length * 150;
    const speed = parseFloat(this._config.marquee_speed) || 1;
    return Math.max(5, (baseWidth / 50) / speed);
  }

  _renderPopup(messages) {
    const c = this._config;
    const realMessages = messages.filter(m => m._real !== false);
    const count = realMessages.length;
    const hideTopBar = c.popup_hide_top_bar === true;
    const showCloseWhenTopHidden = hideTopBar && c.popup_show_close_button !== false;
    const popupBorderRadius = c.popup_border_radius ?? 16;
    const { width: popupWidth, height: popupHeight } = this._getPopupDimensions();
    const backdropStyle = this._getPopupPortalStyle();
    const containerStyle = `${this._getPopupCardStyle()} border-radius: ${popupBorderRadius}px; width: ${popupWidth}; height: ${popupHeight}; box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4); overflow: hidden; display: flex; flex-direction: column; position: relative;`;

    return html`
      <div class="popup-backdrop" style="${backdropStyle}" @click=${(e) => this._handlePopupBackdropClick(e)}>
        <div class="popup-container" style="${containerStyle}">
          ${hideTopBar ? '' : html`
            <div class="popup-header">
              <span class="popup-title">
                ${c.popup_title || 'Notifications'}
                <span class="popup-count-badge">${count}</span>
              </span>
              <button class="popup-close-btn" @click=${(e) => this._closePopup(e)}>
                <ha-icon icon="mdi:close"></ha-icon>
              </button>
            </div>
          `}
          ${showCloseWhenTopHidden ? html`
            <button class="popup-close-btn" style="position:absolute;top:12px;right:12px;z-index:30;" @click=${(e) => this._closePopup(e)}>
              <ha-icon icon="mdi:close"></ha-icon>
            </button>
          ` : ''}
          <div class="popup-content">
            ${realMessages.length > 0 ? realMessages.map(msg => this._renderPopupPill(msg)) : html`
              <div class="popup-empty">No notifications</div>
            `}
          </div>
          ${realMessages.length > 0 ? html`
            <div class="popup-footer">
              <button class="popup-clear-all-btn" @click=${(e) => this._clearAllNotifications(e)}>
                Clear All
              </button>
            </div>
          ` : ''}
        </div>
      </div>
    `;
  }

  _renderConfirmation(msg) {
    const icon = msg.icon || "mdi:bell";
    // Use custom confirm_message if provided, otherwise fall back to action description
    const actionDesc = msg.confirm_message || this._getActionDescription(msg.tap_action);
    
    return html`
      <div class="confirmation-backdrop" @click=${(e) => this._handleConfirmationBackdropClick(e)}>
        <div class="confirmation-container">
          <div class="confirmation-icon">
            <ha-icon icon=${icon}></ha-icon>
          </div>
          <div class="confirmation-message">${msg.message}</div>
          <div class="confirmation-action-desc">${actionDesc}</div>
          <div class="confirmation-buttons">
            <button class="confirmation-btn cancel" @click=${(e) => this._cancelConfirmation(e)}>
              Cancel
            </button>
            <button class="confirmation-btn confirm" @click=${(e) => this._confirmAction(e)}>
              Confirm
            </button>
          </div>
        </div>
      </div>
    `;
  }

  _renderPopupPill(msg) {
    const c = this._config;
    const isRealMsg = msg._real !== false;

    const textColor = msg.text_color || msg.color_text || "var(--primary-text-color)";
    const iconColor = msg.icon_color || msg.color_icon || "var(--primary-text-color)";
    const bgColor = msg.bg_color || msg.color_bg || "rgba(var(--rgb-card-background-color, 30, 30, 30), 0.85)";
    const borderColor = msg.border_color || msg.color_border || "rgba(255, 255, 255, 0.08)";
    
    const fontSize = 14; 
    const fontWeight = 600; 
    const fontFamily = FONTS[0];
    const borderRadius = 12; 
    const borderWidth = 1;
    const boxShadow = "none"; 

    const wrapperStyles = [
        `--pill-color: ${textColor}`,
        `--pill-icon-color: ${iconColor}`,
        `--pill-bg: ${bgColor}`,
        `--pill-border-color: ${borderColor}`,
        `--pill-border-width: ${borderWidth}px`,
        `--pill-radius: ${borderRadius}px`,
        `--pill-shadow: ${boxShadow}`,
        `--pill-font-size: ${fontSize}px`,
        `--pill-font-weight: ${fontWeight}`,
        `--pill-font-family: ${fontFamily}`
    ].join(";");

    const pillStyles = `transform: translateX(0px)`;

    const icon = msg.icon || "mdi:bell";
    const showIcon = c.show_icon !== false;
    const iconAfter = !!c.icon_after;
    const spinIcon = msg.icon_spin === true;
    const hasAction = !!msg.tap_action && !this._config.tap_action_popup_only;
    const tapActionInPopupOnly = !!this._config.tap_action_popup_only;
    
    // Timestamp Logic for Popup (Default True)
    const showTime = c.show_popup_timestamp !== false;
    const timeStr = showTime ? this._formatTime(msg) : "";

    return html`
      <div class="popup-pill-wrapper"
           style="${wrapperStyles}"
           @touchstart=${(e) => this._onPopupPillTouchStart(e, msg)}
           @touchmove=${(e) => this._onPopupPillTouchMove(e, msg)}
           @touchend=${(e) => this._onPopupPillTouchEnd(e, msg)}
           @mousedown=${(e) => this._onPopupPillMouseDown(e, msg)}>
        <div class="popup-pill-swipe-bg">
          <ha-icon icon="mdi:delete"></ha-icon>
        </div>
        <div class="pill popup-pill ${hasAction ? "clickable" : ""}" 
             style="${pillStyles}" 
             @click=${hasAction ? (e) => { e.stopPropagation(); this._handlePopupPillClick(msg); } : null}>
          ${showIcon && !iconAfter ? html`<ha-icon class="icon ${spinIcon ? "spinning" : ""}" .icon=${icon}></ha-icon>` : ''}
          <div class="text-wrapper">
             <div class="text">${msg.message}</div>
             ${timeStr ? html`<div class="timestamp">${timeStr}</div>` : ''}
          </div>
          ${showIcon && iconAfter ? html`<ha-icon class="icon ${spinIcon ? "spinning" : ""}" .icon=${icon}></ha-icon>` : ''}
          ${hasAction ? html`<ha-icon class="action-indicator" icon="mdi:chevron-right"></ha-icon>` : ''}
          ${isRealMsg ? html`
            <button class="dismiss-btn" @click=${(e) => this._dismissNotification(msg.id, e)}>
              <ha-icon icon="mdi:close"></ha-icon>
            </button>
          ` : ''}
        </div>
      </div>
    `;
  }

  // --- Touch Events ---
  _onPopupPillTouchStart(e, msg) {
    const touch = e.touches[0];
    this._startSwipe(touch.clientX, touch.clientY, e.currentTarget, msg);
  }

  _onPopupPillTouchMove(e, msg) {
    const touch = e.touches[0];
    this._moveSwipe(touch.clientX, touch.clientY, e, msg);
  }

  _onPopupPillTouchEnd(e, msg) {
    this._endSwipe(e, msg);
  }

  // --- Mouse Events ---
  _onPopupPillMouseDown(e, msg) {
    if (e.button !== 0) return; 
    this._isMouseSwiping = true;
    
    this._swipeHandlers.move = (ev) => this._onWindowMouseMove(ev, msg);
    this._swipeHandlers.up = (ev) => this._onWindowMouseUp(ev, msg);
    
    window.addEventListener('mousemove', this._swipeHandlers.move);
    window.addEventListener('mouseup', this._swipeHandlers.up);
    
    this._startSwipe(e.clientX, e.clientY, e.currentTarget, msg);
  }

  _onWindowMouseMove(e, msg) {
    if (!this._isMouseSwiping) return;
    this._moveSwipe(e.clientX, e.clientY, e, msg);
  }

  _onWindowMouseUp(e, msg) {
    if (!this._isMouseSwiping) return;
    this._isMouseSwiping = false;
    
    this._endSwipe(e, msg);
    
    window.removeEventListener('mousemove', this._swipeHandlers.move);
    window.removeEventListener('mouseup', this._swipeHandlers.up);
  }

  // --- Unified Swipe Logic ---
  _startSwipe(x, y, currentTarget, msg) {
    const swipeBg = currentTarget.querySelector('.popup-pill-swipe-bg');
    this._popupPillSwipe = {
      startX: x,
      startY: y,
      currentX: 0,
      msg: msg,
      element: currentTarget.querySelector('.popup-pill'),
      bgElement: swipeBg
    };
  }

  _moveSwipe(x, y, e, msg) {
    if (!this._popupPillSwipe || this._popupPillSwipe.msg !== msg) return;
    
    const diffX = x - this._popupPillSwipe.startX;
    const diffY = Math.abs(y - this._popupPillSwipe.startY);
    
    if (diffX < 0 && diffY < 30) {
      if (e.cancelable) e.preventDefault();
      
      if (this._popupPillSwipe.bgElement) {
        this._popupPillSwipe.bgElement.style.visibility = 'visible';
        this._popupPillSwipe.bgElement.style.opacity = '1';
      }
      
      const translateX = Math.max(diffX, -120);
      this._popupPillSwipe.currentX = translateX;
      this._popupPillSwipe.element.style.transform = `translateX(${translateX}px)`;
      this._popupPillSwipe.element.style.transition = 'none';
    }
  }

  _endSwipe(e, msg) {
    if (!this._popupPillSwipe || this._popupPillSwipe.msg !== msg) return;
    
    const element = this._popupPillSwipe.element;
    const bgElement = this._popupPillSwipe.bgElement;
    const currentX = this._popupPillSwipe.currentX;
    
    element.style.transition = 'transform 0.2s ease-out';
    
    if (currentX < -80) {
      element.style.transform = 'translateX(-100%)';
      setTimeout(() => {
        this._dismissNotification(msg.id, e);
      }, 200);
    } else {
      element.style.transform = 'translateX(0)';
      if (bgElement) {
        setTimeout(() => { 
            bgElement.style.opacity = '0'; 
            bgElement.style.visibility = 'hidden';
        }, 200);
      }
    }
    
    this._popupPillSwipe = null;
  }

  render() {
    if (!this._config || !this.hass) return html``;
    
    let messages = this._getMessages();
    let mode = this._config.display_mode || "ticker";
    const realMessageCount = messages.filter(m => m._real !== false).length;
    
    const c = this._config;
    let alignValue = "flex-start";
    if (c.alignment === "center") alignValue = "center";
    if (c.alignment === "right") alignValue = "flex-end";
    
    // When in header card, force list mode to marquee (list doesn't work well in header)
    // But keep button mode available
    if (this._isInHeaderCard && mode === 'list') {
      mode = 'marquee';
    }
    
    const containerStyles = [
        `--anim-duration: ${c.animation_duration || 0.5}s`,
        `--marquee-gap: ${c.marquee_gap || 16}px`,
        `--align-value: ${alignValue}`
    ].join(";");
    
    // Add class when in header card for badge overflow handling
    const headerClass = this._isInHeaderCard ? 'in-header-card' : '';
    
    if (mode === 'button') {
      this.style.display = "block";
      return html`
        <div class="wrapper button-mode-wrapper ${headerClass}" style="${containerStyles}">
          ${this._renderButton(realMessageCount)}
        </div>
        ${this._popupOpen ? this._renderPopup(messages) : ''}
        ${this._confirmationPending ? this._renderConfirmation(this._confirmationPending) : ''}
      `;
    }
    
    if (messages.length === 0) { 
        if (this._config.show_empty === true) {
            messages = [{
                message: this._config.empty_message || "No Notifications",
                icon: "mdi:bell-off",
                tap_action: null,
                _real: false 
            }];
            mode = "ticker"; 
        } else {
            this.style.display = "none"; 
            return html``; 
        }
    }
    this.style.display = "block";

    const dist = "30px";
    let startX = "0px"; let startY = "0px";
    switch(c.direction) {
        case "left": startX = `-${dist}`; break;
        case "top": startY = `-${dist}`; break;
        case "bottom": startY = dist; break;
        case "right": default: startX = dist; break;
    }
    
    const itemHeight = (c.font_size || 13) + 18 + 8;
    const listMaxHeight = (c.list_max_items || 3) * itemHeight;

    const scrollDuration = this._calculateScrollDuration(messages);
    // Only use CSS animation when in badge slot/nested AND duplicates are rendered
    // The -50% translateX animation requires duplicated content to loop properly
    const useCSSAnimation = this._isInBadgeSlot && c.auto_scroll !== false && this._marqueeNeedsDuplicate;

    const standardStyles = containerStyles + [
        `; --enter-x: ${startX}`, `--enter-y: ${startY}`,
        `--list-max-height: ${listMaxHeight}px`,
        `--scroll-duration: ${scrollDuration}s`
    ].join(";");

    return html`
      <div class="wrapper ${mode === 'marquee' ? 'marquee-mode' : ''}" style="${standardStyles}"
        @touchstart=${(e) => this._onStart(e.touches[0].clientX, e.touches[0].clientY)}
        @touchmove=${(e) => this._onMove(e)}
        @touchend=${(e) => this._onEnd(e)}
        @mousedown=${(e) => this._onStart(e.clientX, e.clientY)}
      >
        ${mode === 'marquee' ? html`
             <div class="marquee-container ${useCSSAnimation ? 'with-fade' : ''}">
                <div class="marquee-content ${useCSSAnimation ? 'css-scroll' : ''}">
                    ${messages.map(msg => this._renderPill(msg, false, "marquee"))}
                    ${c.auto_scroll !== false && this._marqueeNeedsDuplicate ? messages.map(msg => this._renderPill(msg, false, "marquee")) : ''}
                </div>
             </div>`
           : mode === 'list' ? html`
             <div class="list-container">${messages.map(msg => this._renderPill(msg, false, "list"))}</div>`
           : html`
             <div class="ticker-container">${this._renderPill(messages[this._tickerIndex % messages.length], messages.length === 1, "ticker")}</div>`
        }
      </div>
      ${this._popupOpen ? this._renderPopup(messages) : ''}
      ${this._confirmationPending ? this._renderConfirmation(this._confirmationPending) : ''}
    `;
  }

  static get styles() {
    return css`
      :host { display: block; touch-action: pan-y; }
      .wrapper { position: relative; display: flex; width: 100%; user-select: none; justify-content: var(--align-value, flex-start); }
      .wrapper.marquee-mode { touch-action: pan-y; cursor: grab; }
      .wrapper.marquee-mode:active { cursor: grabbing; }
      
      .wrapper.button-mode-wrapper {
        width: 100%;
        display: flex;
        justify-content: var(--align-value, flex-start);
      }
      
      /* When in header card, add padding to prevent badge from being clipped */
      .wrapper.button-mode-wrapper.in-header-card {
        padding: 8px;
        box-sizing: border-box;
      }
      
      .ticker-container { display: flex; overflow: hidden; justify-content: var(--align-value, flex-start); width: 100%; }
      .marquee-container { width: 100%; overflow: hidden; white-space: nowrap; }
      
      .marquee-container.with-fade {
        -webkit-mask-image: linear-gradient(to right, transparent 0%, black 5%, black 100%);
        mask-image: linear-gradient(to right, transparent 0%, black 5%, black 100%);
      }
      
      .marquee-content { display: inline-flex; gap: var(--marquee-gap); padding: 0 4px; }
      
      .marquee-content.css-scroll {
        animation: marquee-scroll var(--scroll-duration, 20s) linear infinite;
      }
      .marquee-content.css-scroll.paused {
        animation-play-state: paused;
      }
      @keyframes marquee-scroll {
        0% { transform: translateX(0); }
        100% { transform: translateX(-50%); }
      }
      
      .list-container { 
        display: flex; 
        flex-direction: column; 
        gap: 8px; 
        width: 100%; 
        max-height: var(--list-max-height); 
        overflow-y: auto; 
        padding-right: 4px; 
        align-items: var(--align-value, flex-start); 
      }
      .list-container::-webkit-scrollbar { width: 4px; }
      .list-container::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.2); border-radius: 4px; }
      
      .pill { 
        box-sizing: border-box; 
        display: inline-flex; 
        align-items: center; 
        gap: 8px; 
        flex-shrink: 0; 
        background: var(--pill-bg); 
        border-style: var(--pill-border-style, solid);
        border-width: var(--pill-border-width);
        border-color: var(--pill-border-color); 
        border-radius: var(--pill-radius); 
        box-shadow: var(--pill-shadow); 
        padding: 8px 16px; 
        backdrop-filter: var(--pill-backdrop, blur(12px)); 
        -webkit-backdrop-filter: var(--pill-backdrop, blur(12px)); 
        transform: translate3d(0,0,0); 
        transition: background 0.2s; 
      }
      /* When using header pill styling, use header's padding */
      .pill.header-pill {
        padding: var(--pill-padding-y, 8px) var(--pill-padding-x, 16px);
      }
      .list-container .pill:not(.popup-pill):not(.full) { width: auto; }
      .pill.full { width: 100%; }
      .pill.full.align-left { justify-content: flex-start; }
      .pill.full.align-center { justify-content: center; }
      .pill.full.align-right { justify-content: flex-end; }
      
      .text-wrapper {
         display: flex;
         flex-direction: column;
         flex: 1 1 auto;
         overflow: hidden;
      }
      
      .pill.clickable { cursor: pointer; }
      .pill.clickable:active { transform: scale(0.97); }
      
      .pill.popup-pill {
        width: 100%;
        position: relative;
        padding-right: 70px;
        z-index: 2; 
        background: var(--pill-bg); 
      }
      .pill.popup-pill.clickable {
        cursor: pointer;
        padding-right: 90px;
      }
      .pill.popup-pill.clickable:hover {
        background: var(--pill-bg);
        filter: brightness(1.1);
      }
      
      .popup-pill .action-indicator {
        position: absolute;
        right: 36px;
        top: 50%;
        transform: translateY(-50%);
        --mdc-icon-size: 18px;
        color: var(--pill-icon-color);
        opacity: 0.5;
      }
      
      .popup-pill .dismiss-btn {
        position: absolute;
        right: 8px;
        top: 50%;
        transform: translateY(-50%);
        width: 24px;
        height: 24px;
        color: var(--pill-icon-color);
        opacity: 0.5;
        cursor: pointer;
        background: none;
        border: none;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 50%;
        transition: opacity 0.2s, background 0.2s;
      }
      .popup-pill .dismiss-btn:hover {
        opacity: 1;
        background: rgba(255,255,255,0.1);
      }
      .popup-pill .dismiss-btn ha-icon {
        --mdc-icon-size: 16px;
      }
      
      .icon { color: var(--pill-icon-color); --mdc-icon-size: calc(var(--pill-font-size) + 5px); display: flex; flex-shrink: 0; }
      .icon.spinning { animation: spin 2s linear infinite; }
      @keyframes spin { 100% { transform: rotate(360deg); } }
      .text { color: var(--pill-color); font-size: var(--pill-font-size); font-weight: var(--pill-font-weight); font-family: var(--pill-font-family); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      
      .timestamp {
        font-size: 0.75em;
        opacity: 0.7;
        margin-top: 1px;
        white-space: nowrap;
        color: var(--pill-color);
      }
      
      /* When background is hidden, add text shadow like header weather/datetime */
      .pill.no-bg .icon {
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.6));
      }
      .pill.no-bg .text {
        text-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
      }
      
      .notification-pill-wrapper {
        display: inline-flex;
        align-items: center;
        position: relative;
      }
      .notification-pill-wrapper.full-width {
        width: 100%;
      }
      
      .pill-outside-badge {
        position: absolute;
        top: calc(var(--badge-size, 18px) * -0.33);
        right: calc(var(--badge-size, 18px) * -0.33);
        min-width: var(--badge-size, 18px);
        height: var(--badge-size, 18px);
        padding: 0 calc(var(--badge-size, 18px) * 0.28);
        border-radius: calc(var(--badge-size, 18px) * 0.5);
        background: var(--badge-color, #ff4444);
        color: var(--badge-text-color, #ffffff);
        font-size: calc(var(--badge-size, 18px) * 0.6);
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        box-sizing: border-box;
      }
      
      .popup-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        /* Styling provided via inline styles from config */
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 999;
      }
      
      .popup-container {
        /* Styling provided via inline styles from config */
        min-width: 320px;
        max-width: 90vw;
      }
      
      .popup-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 16px 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      
      .popup-title {
        font-size: 18px;
        font-weight: 600;
        color: var(--primary-text-color);
        display: flex;
        align-items: center;
        gap: 8px;
      }
      
      .popup-count-badge {
        min-width: 22px;
        height: 22px;
        padding: 0 6px;
        border-radius: 11px;
        background: rgba(255, 255, 255, 0.15);
        color: var(--primary-text-color);
        font-size: 12px;
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
      }
      
      .popup-close-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 50%;
        width: 32px;
        height: 32px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: all 0.2s;
        color: var(--primary-text-color);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
      }
      .popup-close-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: scale(1.05);
      }
      .popup-close-btn ha-icon {
        --mdc-icon-size: 18px;
      }
      
      .popup-clear-btn {
        background: rgba(255, 255, 255, 0.1);
        border: none;
        border-radius: 8px;
        padding: 8px 16px;
        color: var(--primary-text-color);
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
      }
      .popup-clear-btn:hover {
        background: rgba(255, 255, 255, 0.15);
      }
      
      .popup-content {
        padding: 16px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
        flex: 1;
      }
      
      .popup-footer {
        padding: 12px 16px 16px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        margin-top: auto;
      }
      
      .popup-clear-all-btn {
        width: 100%;
        background: rgba(255, 255, 255, 0.08);
        border: none;
        border-radius: 8px;
        padding: 12px 16px;
        color: var(--primary-text-color);
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
      }
      .popup-clear-all-btn:hover {
        background: rgba(255, 255, 255, 0.12);
      }
      
      .popup-pill-wrapper {
        position: relative;
        isolation: isolate; 
      }
      
      .popup-pill-swipe-bg {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        width: 80px;
        background: #c62828;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        border-radius: 0 var(--pill-radius, 12px) var(--pill-radius, 12px) 0;
        z-index: 1; 
        opacity: 0; 
        visibility: hidden; 
        transition: opacity 0.2s, visibility 0.2s;
      }
      .popup-pill-swipe-bg ha-icon {
        --mdc-icon-size: 22px;
      }
      
      .popup-empty {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100%;
        color: var(--secondary-text-color);
        font-size: 14px;
      }
      
      .popup-count {
        font-weight: 400;
        opacity: 0.7;
        font-size: 14px;
        margin-left: 4px;
      }
      
      .notification-button {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
        cursor: pointer;
        transition: transform 0.2s, filter 0.2s;
      }
      .notification-button.full-width {
        width: 100%;
        align-items: var(--content-align, center);
      }
      .notification-button.label-left,
      .notification-button.label-right {
        flex-direction: row;
        gap: 8px;
      }
      .notification-button.full-width.label-left {
        justify-content: var(--content-align, center);
        align-items: center;
      }
      .notification-button.full-width.label-right {
        justify-content: var(--content-align, center);
        align-items: center;
      }
      
      .notification-button:hover {
        filter: brightness(1.1);
      }
      .notification-button:active {
        transform: scale(0.95);
      }
      
      .button-icon-container {
        position: relative;
        width: var(--button-size, 48px);
        height: var(--button-size, 48px);
        border-radius: 50%;
        background: var(--button-bg);
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }
      
      .button-icon {
        --mdc-icon-size: calc(var(--button-size, 48px) * 0.5);
        color: var(--button-icon-color);
      }
      
      .button-badge {
        position: absolute;
        top: calc(var(--badge-size, 18px) * -0.25);
        right: calc(var(--badge-size, 18px) * -0.25);
        min-width: var(--badge-size, 18px);
        height: var(--badge-size, 18px);
        padding: 0 calc(var(--badge-size, 18px) * 0.28);
        border-radius: calc(var(--badge-size, 18px) * 0.5);
        background: var(--badge-color, #ff4444);
        color: var(--badge-text-color, #ffffff);
        font-size: calc(var(--badge-size, 18px) * 0.6);
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        box-sizing: border-box;
      }
      
      .button-label {
        font-size: 12px;
        color: var(--primary-text-color);
        font-weight: 500;
        max-width: calc(var(--button-size, 48px) + 40px);
        text-align: center;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .notification-button.label-left .button-label,
      .notification-button.label-right .button-label {
        max-width: none;
      }
      
      .notification-pill-button {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 8px 16px;
        background: var(--pill-button-bg);
        border-style: var(--pill-button-border-style, solid);
        border-width: var(--pill-button-border-width, 1px);
        border-color: var(--pill-button-border-color);
        border-radius: var(--pill-button-border-radius, 99px);
        cursor: pointer;
        transition: transform 0.2s, filter 0.2s;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
      }
      .notification-pill-button.full-width {
        width: 100%;
        justify-content: var(--content-align, center);
      }
      .notification-pill-button:hover {
        filter: brightness(1.1);
      }
      .notification-pill-button:active {
        transform: scale(0.97);
      }
      
      .pill-button-icon {
        --mdc-icon-size: calc(var(--pill-button-size, 14px) + 4px);
        color: var(--button-icon-color);
        flex-shrink: 0;
      }
      
      .pill-button-label {
        font-size: var(--pill-button-size, 14px);
        font-weight: 500;
        color: var(--primary-text-color);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      
      .pill-button-badge {
        min-width: var(--badge-size, 18px);
        height: var(--badge-size, 18px);
        padding: 0 calc(var(--badge-size, 18px) * 0.28);
        border-radius: calc(var(--badge-size, 18px) * 0.5);
        background: var(--badge-color, #ff4444);
        color: var(--badge-text-color, #ffffff);
        font-size: calc(var(--badge-size, 18px) * 0.6);
        font-weight: 600;
        display: flex;
        align-items: center;
        justify-content: center;
        box-sizing: border-box;
        flex-shrink: 0;
      }
      
      .anim-slide { animation: slide-in var(--anim-duration) cubic-bezier(0.2, 0.8, 0.2, 1) forwards; } @keyframes slide-in { 0% { opacity: 0; transform: translate(var(--enter-x), var(--enter-y)); } 100% { opacity: 1; transform: translate(0, 0); } }
      .anim-fade { animation: fade-in var(--anim-duration) ease-out forwards; } @keyframes fade-in { 0% { opacity: 0; } 100% { opacity: 1; } }
      .anim-scale { animation: scale-in var(--anim-duration) cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; } @keyframes scale-in { 0% { opacity: 0; transform: scale(0.8) translate(var(--enter-x), var(--enter-y)); } 100% { opacity: 1; transform: scale(1) translate(0,0); } }
      .anim-flip { animation: flip-in var(--anim-duration) cubic-bezier(0.2, 0.8, 0.2, 1) forwards; transform-origin: center; } @keyframes flip-in { 0% { opacity: 0; transform: perspective(400px) rotateX(90deg); } 100% { opacity: 1; transform: perspective(400px) rotateX(0deg); } }
      .anim-glitch { animation: glitch var(--anim-duration) steps(2, end) forwards; } @keyframes glitch { 0% { opacity: 0; transform: skew(20deg); } 20% { opacity: 1; transform: skew(-20deg); } 40% { transform: skew(0deg); } }
      .anim-wobble { animation: wobble var(--anim-duration) ease-in-out forwards; } @keyframes wobble { 0% { opacity: 0; transform: translateX(var(--enter-x)); } 40% { transform: rotate(-5deg); } 60% { transform: rotate(3deg); } 100% { opacity: 1; transform: rotate(0); } }
      .anim-bounce { animation: bounce-in var(--anim-duration) cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; } @keyframes bounce-in { 0% { opacity: 0; transform: translate(var(--enter-x), var(--enter-y)); } 60% { transform: translate(calc(var(--enter-x) * -0.1), calc(var(--enter-y) * -0.1)); } 100% { opacity: 1; transform: translate(0, 0); } }
      .anim-rotate { animation: rotate-in var(--anim-duration) ease-out forwards; transform-origin: center; } @keyframes rotate-in { 0% { opacity: 0; transform: rotate(90deg) scale(0.8); } 100% { opacity: 1; transform: rotate(0) scale(1); } }
      .anim-zoom { animation: zoom-in var(--anim-duration) cubic-bezier(0.34, 1.56, 0.64, 1) forwards; } @keyframes zoom-in { 0% { opacity: 0; transform: scale(0.5); } 100% { opacity: 1; transform: scale(1); } }
      .anim-blur { animation: blur-in var(--anim-duration) ease-out forwards; } @keyframes blur-in { 0% { opacity: 0; filter: blur(10px); } 100% { opacity: 1; filter: blur(0); } }
      .anim-elastic { animation: elastic-in var(--anim-duration) cubic-bezier(0.68, -0.55, 0.265, 1.55) forwards; } @keyframes elastic-in { 0% { opacity: 0; transform: scale(0.5) translate(var(--enter-x), var(--enter-y)); } 100% { opacity: 1; transform: scale(1) translate(0,0); } }
      .anim-swing { animation: swing-in var(--anim-duration) cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; transform-origin: top center; } @keyframes swing-in { 0% { opacity: 0; transform: rotateX(-100deg); } 100% { opacity: 1; transform: rotateX(0deg); } }
      
      /* Confirmation Popup Styles */
      .confirmation-backdrop {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        animation: fade-in 0.2s ease-out;
      }
      
      .confirmation-container {
        background: var(--card-background-color, #1c1c1c);
        border-radius: 16px;
        padding: 24px;
        min-width: 280px;
        max-width: 90vw;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 16px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        animation: scale-in 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      }
      
      .confirmation-icon {
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background: rgba(var(--rgb-primary-color, 3, 169, 244), 0.15);
        display: flex;
        align-items: center;
        justify-content: center;
      }
      .confirmation-icon ha-icon {
        --mdc-icon-size: 28px;
        color: var(--primary-color, #03a9f4);
      }
      
      .confirmation-message {
        font-size: 16px;
        font-weight: 600;
        color: var(--primary-text-color);
        text-align: center;
        max-width: 250px;
        word-wrap: break-word;
      }
      
      .confirmation-action-desc {
        font-size: 13px;
        color: var(--secondary-text-color);
        text-align: center;
        opacity: 0.8;
      }
      
      .confirmation-buttons {
        display: flex;
        gap: 12px;
        margin-top: 8px;
        width: 100%;
      }
      
      .confirmation-btn {
        flex: 1;
        padding: 12px 20px;
        border-radius: 12px;
        border: none;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
      }
      
      .confirmation-btn.cancel {
        background: rgba(255, 255, 255, 0.1);
        color: var(--primary-text-color);
      }
      .confirmation-btn.cancel:hover {
        background: rgba(255, 255, 255, 0.15);
      }
      .confirmation-btn.cancel:active {
        transform: scale(0.97);
      }
      
      .confirmation-btn.confirm {
        background: var(--primary-color, #03a9f4);
        color: var(--text-primary-color, #fff);
      }
      .confirmation-btn.confirm:hover {
        filter: brightness(1.1);
      }
      .confirmation-btn.confirm:active {
        transform: scale(0.97);
      }
    `;
  }
}

// --- EDITOR CLASS ---
class HkiNotificationCardEditor extends LitElement {
  static get properties() { return { hass: {}, _config: { state: true } }; }
  setConfig(config) { this._config = migrateNotificationConfig(config || {}); }
  
  render() {
    if (!this.hass || !this._config) return html``;
    const mode = this._config.display_mode || "ticker";
    const fontFamily = this._config.font_family || FONTS[0];
    const showCustomFont = fontFamily === "Custom";

    return html`
      <div class="card-config">
        
        <details class="box-section" open>
          <summary>Entity</summary>
          <div class="box-content">
            <ha-alert alert-type="info">
              <strong>Documentation</strong><br><br>
              This card requires the <a href="https://github.com/jimz011/hki-notify" target="_blank">HKI Notify</a> integration to function.<br>
              This card can also be placed in the header/badges section!<br>
              This card can be integrated into the <a href="https://jimz011.github.io/hki-elements/cards/hki-header-card/overview/" target="_blank">HKI Header Card</a><br><br>
              Please read the <a href="https://jimz011.github.io/hki-elements/" target="_blank" rel="noopener noreferrer">documentation</a> to set up this card.<br><br>
              <em>This card may contain bugs. Use at your own risk!</em>
            </ha-alert>
            
            ${this._renderEntityPicker("Notification Sensor", "entity", this._config.entity, "Select an HKI Notify sensor", ["sensor"], "hki_notify")}
          </div>
        </details>

        <details class="box-section">
          <summary>Notification Style & Behavior</summary>
          <div class="box-content">
            <ha-select label="Display Mode" .value=${mode} @selected=${(e) => this._modeChanged(e)} @closed=${(e) => e.stopPropagation()}>
               <mwc-list-item value="ticker">Ticker (Cycle One by One)</mwc-list-item>
               <mwc-list-item value="marquee">Marquee (Scrollable List)</mwc-list-item>
               <mwc-list-item value="list">List (Vertical Stack)</mwc-list-item>
               <mwc-list-item value="button">Button (Icon Only)</mwc-list-item>
            </ha-select>
            
            ${mode !== 'button' ? html`
            <div class="side-by-side">
                 ${this._renderSwitch("Show When Empty", "show_empty", this._config.show_empty)}
                 ${this._config.show_empty ? this._renderInput("Empty Message", "empty_message", this._config.empty_message) : ''}
            </div>
            ` : ''}
            
            ${mode === 'marquee' ? html`
                <div class="side-by-side">
                    ${this._renderInput("Scroll Speed", "marquee_speed", this._config.marquee_speed, "number", "0.1")}
                    ${this._renderInput("Gap (px)", "marquee_gap", this._config.marquee_gap, "number")}
                </div>
                ${this._renderSwitch("Auto Scroll", "auto_scroll", this._config.auto_scroll)}
            ` : mode === 'list' ? html`
                ${this._renderInput("Max Items Visible", "list_max_items", this._config.list_max_items, "number")}
            ` : mode === 'ticker' ? html`
                <div class="side-by-side">
                    ${this._renderInput("Interval (sec)", "interval", this._config.interval, "number", "0.1")}
                    ${this._renderInput("Anim Speed (sec)", "animation_duration", this._config.animation_duration, "number", "0.1")}
                </div>
                ${this._renderSwitch("Auto Cycle Messages", "auto_cycle", this._config.auto_cycle)}
                <div class="side-by-side">
                    <ha-select label="Animation" .value=${this._config.animation || "slide"} @selected=${(e) => this._valueChanged(e, "animation")} @closed=${(e) => e.stopPropagation()}>
                      ${["slide","scale","fade","flip","glitch","wobble","bounce","rotate","zoom","blur","elastic","swing"].map(a => html`<mwc-list-item .value=${a}>${a.charAt(0).toUpperCase() + a.slice(1)}</mwc-list-item>`)}
                    </ha-select>
                    <ha-select label="Direction" .value=${this._config.direction || "right"} @selected=${(e) => this._valueChanged(e, "direction")} @closed=${(e) => e.stopPropagation()}>
                      ${["left","right","top","bottom"].map(d => html`<mwc-list-item .value=${d}>From ${d.charAt(0).toUpperCase() + d.slice(1)}</mwc-list-item>`)}
                    </ha-select>
                </div>
            ` : ''}
          </div>
        </details>

        <details class="box-section">
          <summary>Popup Settings</summary>
          <div class="box-content">
            ${mode === 'button' ? html`
              ${this._renderInput("Popup Title", "popup_title", this._config.popup_title || "Notifications")}
              ${this._renderSwitch("Show Timestamps", "show_popup_timestamp", this._config.show_popup_timestamp !== false)}
              <ha-select label="Time Format" .value=${this._config.time_format || "auto"} @selected=${(e) => this._valueChanged(e, "time_format")} @closed=${(e) => e.stopPropagation()}>
                <mwc-list-item value="auto">Auto (System Locale)</mwc-list-item>
                <mwc-list-item value="24">24-hour</mwc-list-item>
                <mwc-list-item value="12">12-hour</mwc-list-item>
                            </ha-select>

              <div class="separator"></div>
              <strong>Popup Container</strong>
              ${this._renderInput("Border Radius (px)", "popup_border_radius", this._config.popup_border_radius ?? 16, "number")}
              <div class="side-by-side">
                <ha-select
                  label="Width"
                  .value=${this._config.popup_width || 'auto'}
                  @selected=${(ev) => this._valueChanged(ev, "popup_width")}
                  @closed=${(e) => e.stopPropagation()}
                  @click=${(e) => e.stopPropagation()}
                >
                  <mwc-list-item value="auto">Auto (Responsive) - Default</mwc-list-item>
                  <mwc-list-item value="default">Default (400px)</mwc-list-item>
                  <mwc-list-item value="custom">Custom</mwc-list-item>
                </ha-select>
                ${this._config.popup_width === 'custom'
                  ? this._renderInput("Custom Width (px)", "popup_width_custom", this._config.popup_width_custom ?? 400, "number")
                  : html`<div></div>`}
              </div>

              <div class="side-by-side">
                <ha-select
                  label="Height"
                  .value=${this._config.popup_height || 'auto'}
                  @selected=${(ev) => this._valueChanged(ev, "popup_height")}
                  @closed=${(e) => e.stopPropagation()}
                  @click=${(e) => e.stopPropagation()}
                >
                  <mwc-list-item value="auto">Auto (Responsive) - Default</mwc-list-item>
                  <mwc-list-item value="default">Default (600px)</mwc-list-item>
                  <mwc-list-item value="custom">Custom</mwc-list-item>
                </ha-select>
                ${this._config.popup_height === 'custom'
                  ? this._renderInput("Custom Height (px)", "popup_height_custom", this._config.popup_height_custom ?? 600, "number")
                  : html`<div></div>`}
              </div>

              <p class="helper-text" style="margin-top: 10px;">Background Blur (Backdrop)</p>
              ${this._renderSwitch("Enable Background Blur", "popup_blur_enabled", this._config.popup_blur_enabled !== false)}
              <ha-textfield
                label="Blur Amount (px)"
                type="number"
                .value=${this._config.popup_blur_amount ?? 10}
                @input=${(ev) => this._valueChanged(ev, "popup_blur_amount")}
                .disabled=${this._config.popup_blur_enabled === false}
              ></ha-textfield>

              <p class="helper-text" style="margin-top: 10px;">Card Glass Effect</p>
              ${this._renderSwitch("Enable Card Blur", "popup_card_blur_enabled", this._config.popup_card_blur_enabled !== false)}
              <div class="side-by-side">
                <ha-textfield
                  label="Card Blur (px)"
                  type="number"
                  .value=${this._config.popup_card_blur_amount ?? 40}
                  @input=${(ev) => this._valueChanged(ev, "popup_card_blur_amount")}
                  .disabled=${this._config.popup_card_blur_enabled === false}
                ></ha-textfield>
                <ha-textfield
                  label="Card Opacity (0-1)"
                  type="number"
                  step="0.05"
                  .value=${this._config.popup_card_opacity ?? 0.4}
                  @input=${(ev) => this._valueChanged(ev, "popup_card_opacity")}
                ></ha-textfield>
              </div>
<div class="separator"></div>
              <strong>Popup Animation</strong>
              <div class="side-by-side">
                <ha-select label="Open Animation" .value=${this._config.popup_open_animation || 'scale'}
                  @selected=${(ev) => this._valueChanged(ev, "popup_open_animation")}
                  @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                  <mwc-list-item value="none">None</mwc-list-item>
                  <mwc-list-item value="fade">Fade</mwc-list-item>
                  <mwc-list-item value="scale">Scale</mwc-list-item>
                  <mwc-list-item value="slide-up">Slide Up</mwc-list-item>
                  <mwc-list-item value="slide-down">Slide Down</mwc-list-item>
                  <mwc-list-item value="slide-left">Slide Left</mwc-list-item>
                  <mwc-list-item value="slide-right">Slide Right</mwc-list-item>
                  <mwc-list-item value="flip">Flip</mwc-list-item>
                  <mwc-list-item value="bounce">Bounce</mwc-list-item>
                  <mwc-list-item value="zoom">Zoom</mwc-list-item>
                  <mwc-list-item value="rotate">Rotate</mwc-list-item>
                  <mwc-list-item value="drop">Drop</mwc-list-item>
                  <mwc-list-item value="swing">Swing</mwc-list-item>
                </ha-select>
                <ha-select label="Close Animation" .value=${this._config.popup_close_animation || 'scale'}
                  @selected=${(ev) => this._valueChanged(ev, "popup_close_animation")}
                  @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                  <mwc-list-item value="none">None</mwc-list-item>
                  <mwc-list-item value="fade">Fade</mwc-list-item>
                  <mwc-list-item value="scale">Scale</mwc-list-item>
                  <mwc-list-item value="slide-up">Slide Up</mwc-list-item>
                  <mwc-list-item value="slide-down">Slide Down</mwc-list-item>
                  <mwc-list-item value="slide-left">Slide Left</mwc-list-item>
                  <mwc-list-item value="slide-right">Slide Right</mwc-list-item>
                  <mwc-list-item value="flip">Flip</mwc-list-item>
                  <mwc-list-item value="bounce">Bounce</mwc-list-item>
                  <mwc-list-item value="zoom">Zoom</mwc-list-item>
                  <mwc-list-item value="rotate">Rotate</mwc-list-item>
                  <mwc-list-item value="drop">Drop</mwc-list-item>
                  <mwc-list-item value="swing">Swing</mwc-list-item>
                </ha-select>
              </div>
              ${this._renderInput("Animation Duration (ms)", "popup_animation_duration", this._config.popup_animation_duration ?? 300, "number")}
              ${this._renderSwitch("Hide Top Bar", "popup_hide_top_bar", this._config.popup_hide_top_bar === true)}
              ${this._config.popup_hide_top_bar === true ? this._renderSwitch("Show Close Button", "popup_show_close_button", this._config.popup_show_close_button !== false) : ""}
              ${this._renderSwitch("Close Popup After Action", "popup_close_on_action", this._config.popup_close_on_action === true)}

              <div class="separator"></div>
              ${this._renderSwitch("Confirm Tap Actions", "confirm_tap_action", this._config.confirm_tap_action)}
              <p class="helper-text">Button mode always opens the popup when clicked. When "Confirm Tap Actions" is enabled, a confirmation dialog appears before executing any tap action.</p>
            ` : html`
            <div class="side-by-side">
              ${this._renderSwitch("Enable Popup", "popup_enabled", this._config.popup_enabled !== false)}
              ${this._renderInput("Popup Title", "popup_title", this._config.popup_title || "Notifications")}
            </div>
            ${this._config.popup_enabled !== false ? html`
              <div class="side-by-side">
                ${this._renderSwitch("Popup Timestamps", "show_popup_timestamp", this._config.show_popup_timestamp !== false)}
                ${this._renderSwitch("List Timestamps", "show_list_timestamp", this._config.show_list_timestamp)}
              </div>
              <ha-select label="Time Format" .value=${this._config.time_format || "auto"} @selected=${(e) => this._valueChanged(e, "time_format")} @closed=${(e) => e.stopPropagation()}>
                <mwc-list-item value="auto">Auto (System Locale)</mwc-list-item>
                <mwc-list-item value="24">24-hour</mwc-list-item>
                <mwc-list-item value="12">12-hour</mwc-list-item>
                            </ha-select>

              <div class="separator"></div>
              <strong>Popup Container</strong>
              ${this._renderInput("Border Radius (px)", "popup_border_radius", this._config.popup_border_radius ?? 16, "number")}
              <div class="side-by-side">
                <ha-select
                  label="Width"
                  .value=${this._config.popup_width || 'auto'}
                  @selected=${(ev) => this._valueChanged(ev, "popup_width")}
                  @closed=${(e) => e.stopPropagation()}
                  @click=${(e) => e.stopPropagation()}
                >
                  <mwc-list-item value="auto">Auto (Responsive) - Default</mwc-list-item>
                  <mwc-list-item value="default">Default (400px)</mwc-list-item>
                  <mwc-list-item value="custom">Custom</mwc-list-item>
                </ha-select>
                ${this._config.popup_width === 'custom'
                  ? this._renderInput("Custom Width (px)", "popup_width_custom", this._config.popup_width_custom ?? 400, "number")
                  : html`<div></div>`}
              </div>

              <div class="side-by-side">
                <ha-select
                  label="Height"
                  .value=${this._config.popup_height || 'auto'}
                  @selected=${(ev) => this._valueChanged(ev, "popup_height")}
                  @closed=${(e) => e.stopPropagation()}
                  @click=${(e) => e.stopPropagation()}
                >
                  <mwc-list-item value="auto">Auto (Responsive) - Default</mwc-list-item>
                  <mwc-list-item value="default">Default (600px)</mwc-list-item>
                  <mwc-list-item value="custom">Custom</mwc-list-item>
                </ha-select>
                ${this._config.popup_height === 'custom'
                  ? this._renderInput("Custom Height (px)", "popup_height_custom", this._config.popup_height_custom ?? 600, "number")
                  : html`<div></div>`}
              </div>

              <p class="helper-text" style="margin-top: 10px;">Background Blur (Backdrop)</p>
              ${this._renderSwitch("Enable Background Blur", "popup_blur_enabled", this._config.popup_blur_enabled !== false)}
              <ha-textfield
                label="Blur Amount (px)"
                type="number"
                .value=${this._config.popup_blur_amount ?? 10}
                @input=${(ev) => this._valueChanged(ev, "popup_blur_amount")}
                .disabled=${this._config.popup_blur_enabled === false}
              ></ha-textfield>

              <p class="helper-text" style="margin-top: 10px;">Card Glass Effect</p>
              ${this._renderSwitch("Enable Card Blur", "popup_card_blur_enabled", this._config.popup_card_blur_enabled !== false)}
              <div class="side-by-side">
                <ha-textfield
                  label="Card Blur (px)"
                  type="number"
                  .value=${this._config.popup_card_blur_amount ?? 40}
                  @input=${(ev) => this._valueChanged(ev, "popup_card_blur_amount")}
                  .disabled=${this._config.popup_card_blur_enabled === false}
                ></ha-textfield>
                <ha-textfield
                  label="Card Opacity (0-1)"
                  type="number"
                  step="0.05"
                  .value=${this._config.popup_card_opacity ?? 0.4}
                  @input=${(ev) => this._valueChanged(ev, "popup_card_opacity")}
                ></ha-textfield>
              </div>

              <div class="separator"></div>
              <strong>Popup Animation</strong>
              <div class="side-by-side">
                <ha-select label="Open Animation" .value=${this._config.popup_open_animation || 'scale'}
                  @selected=${(ev) => this._valueChanged(ev, "popup_open_animation")}
                  @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                  <mwc-list-item value="none">None</mwc-list-item>
                  <mwc-list-item value="fade">Fade</mwc-list-item>
                  <mwc-list-item value="scale">Scale</mwc-list-item>
                  <mwc-list-item value="slide-up">Slide Up</mwc-list-item>
                  <mwc-list-item value="slide-down">Slide Down</mwc-list-item>
                  <mwc-list-item value="slide-left">Slide Left</mwc-list-item>
                  <mwc-list-item value="slide-right">Slide Right</mwc-list-item>
                  <mwc-list-item value="flip">Flip</mwc-list-item>
                  <mwc-list-item value="bounce">Bounce</mwc-list-item>
                  <mwc-list-item value="zoom">Zoom</mwc-list-item>
                  <mwc-list-item value="rotate">Rotate</mwc-list-item>
                  <mwc-list-item value="drop">Drop</mwc-list-item>
                  <mwc-list-item value="swing">Swing</mwc-list-item>
                </ha-select>
                <ha-select label="Close Animation" .value=${this._config.popup_close_animation || 'scale'}
                  @selected=${(ev) => this._valueChanged(ev, "popup_close_animation")}
                  @closed=${(e) => e.stopPropagation()} @click=${(e) => e.stopPropagation()}>
                  <mwc-list-item value="none">None</mwc-list-item>
                  <mwc-list-item value="fade">Fade</mwc-list-item>
                  <mwc-list-item value="scale">Scale</mwc-list-item>
                  <mwc-list-item value="slide-up">Slide Up</mwc-list-item>
                  <mwc-list-item value="slide-down">Slide Down</mwc-list-item>
                  <mwc-list-item value="slide-left">Slide Left</mwc-list-item>
                  <mwc-list-item value="slide-right">Slide Right</mwc-list-item>
                  <mwc-list-item value="flip">Flip</mwc-list-item>
                  <mwc-list-item value="bounce">Bounce</mwc-list-item>
                  <mwc-list-item value="zoom">Zoom</mwc-list-item>
                  <mwc-list-item value="rotate">Rotate</mwc-list-item>
                  <mwc-list-item value="drop">Drop</mwc-list-item>
                  <mwc-list-item value="swing">Swing</mwc-list-item>
                </ha-select>
              </div>
              ${this._renderInput("Animation Duration (ms)", "popup_animation_duration", this._config.popup_animation_duration ?? 300, "number")}
              ${this._renderSwitch("Hide Top Bar", "popup_hide_top_bar", this._config.popup_hide_top_bar === true)}
              ${this._config.popup_hide_top_bar === true ? this._renderSwitch("Show Close Button", "popup_show_close_button", this._config.popup_show_close_button !== false) : ""}
              ${this._renderSwitch("Close Popup After Action", "popup_close_on_action", this._config.popup_close_on_action === true)}

              <div class="separator"></div>
              ${this._renderSwitch("Tap Actions in Popup Only", "tap_action_popup_only", this._config.tap_action_popup_only)}
              ${this._renderSwitch("Confirm Tap Actions", "confirm_tap_action", this._config.confirm_tap_action)}
              ${!this._config.tap_action_popup_only ? html`
                <p class="helper-text">When enabled, a confirmation dialog appears before executing any tap action on notifications.</p>
              ` : html`
                <p class="helper-text">When enabled, tapping always opens the popup first. Tap actions are available inside the popup. "Confirm Tap Actions" will also apply to actions inside the popup.</p>
              `}
              ` : html`
              <p class="helper-text">When enabled, tapping a notification opens a popup with all notifications and a clear button.</p>
            `}
            `}
          </div>
        </details>

        ${mode === 'button' ? html`
        <details class="box-section">
          <summary>Button Style</summary>
          <div class="box-content">
            <ha-select label="Alignment" .value=${this._config.alignment || "left"} @selected=${(e) => this._valueChanged(e, "alignment")} @closed=${(e) => e.stopPropagation()}>
              ${["left","center","right"].map(a => html`<mwc-list-item .value=${a}>${a.charAt(0).toUpperCase() + a.slice(1)}</mwc-list-item>`)}
            </ha-select>
            ${this._renderSwitch("Full Width", "full_width", this._config.full_width)}
            
            ${this._renderIconPicker("Button Icon", "button_icon", this._config.button_icon || "mdi:bell")}
            ${this._renderInput("Button Label (optional)", "button_label", this._config.button_label || "")}
            
            ${this._config.button_label ? html`
              <ha-select label="Label Position" .value=${this._config.button_label_position || "below"} @selected=${(e) => this._valueChanged(e, "button_label_position")} @closed=${(e) => e.stopPropagation()}>
                <mwc-list-item value="below">Below Icon</mwc-list-item>
                <mwc-list-item value="left">Left of Icon</mwc-list-item>
                <mwc-list-item value="right">Right of Icon</mwc-list-item>
                <mwc-list-item value="inside">Inside (Pill Style)</mwc-list-item>
              </ha-select>
            ` : ''}
            
            ${(this._config.button_label_position !== 'inside' || !this._config.button_label) ? html`
              <div class="section">Icon Button</div>
              ${this._renderInput("Button Size (px)", "button_size", this._config.button_size || 48, "number")}
              <div class="side-by-side">
                ${this._renderColorPicker("Icon Color", "button_icon_color", this._config.button_icon_color)}
                ${this._renderColorPicker("Background", "button_bg_color", this._config.button_bg_color)}
              </div>
            ` : html`
              <div class="section">Pill Button</div>
              ${this._renderInput("Font Size (px)", "button_pill_size", this._config.button_pill_size || 14, "number")}
              <div class="side-by-side">
                ${this._renderColorPicker("Icon Color", "button_icon_color", this._config.button_icon_color)}
                ${this._renderColorPicker("Background", "button_pill_bg_color", this._config.button_pill_bg_color)}
              </div>
              <div class="side-by-side">
                ${this._renderColorPicker("Border Color", "button_pill_border_color", this._config.button_pill_border_color)}
                ${this._renderInput("Border Radius", "button_pill_border_radius", this._config.button_pill_border_radius ?? 99, "number")}
              </div>
              <div class="side-by-side">
                <ha-select label="Border Style" .value=${this._config.button_pill_border_style || "solid"} @selected=${(e) => this._valueChanged(e, "button_pill_border_style")} @closed=${(e) => e.stopPropagation()}>
                  <mwc-list-item value="solid">Solid</mwc-list-item>
                  <mwc-list-item value="dashed">Dashed</mwc-list-item>
                  <mwc-list-item value="dotted">Dotted</mwc-list-item>
                  <mwc-list-item value="none">None</mwc-list-item>
                </ha-select>
                ${this._renderInput("Border Width", "button_pill_border_width", this._config.button_pill_border_width ?? 1, "number")}
              </div>
            `}
            
            <div class="section">Badge</div>
            ${this._renderSwitch("Show Badge", "button_show_badge", this._config.button_show_badge !== false)}
            ${this._config.button_show_badge !== false ? html`
              ${(this._config.button_label_position === 'inside' && this._config.button_label) ? html`
                <ha-select label="Badge Position" .value=${this._config.button_pill_badge_position || "inside"} @selected=${(e) => this._valueChanged(e, "button_pill_badge_position")} @closed=${(e) => e.stopPropagation()}>
                  <mwc-list-item value="inside">Inside Pill</mwc-list-item>
                  <mwc-list-item value="outside">Outside Pill (Corner)</mwc-list-item>
                </ha-select>
              ` : ''}
              <div class="side-by-side">
                ${this._renderColorPicker("Badge Color", "button_badge_color", this._config.button_badge_color || "#ff4444")}
                ${this._renderColorPicker("Badge Text", "button_badge_text_color", this._config.button_badge_text_color || "#ffffff")}
              </div>
              ${this._renderInput("Badge Size (0=auto)", "button_badge_size", this._config.button_badge_size ?? 0, "number")}
            ` : ''}
          </div>
        </details>
        ` : ''}

        ${mode !== 'button' ? html`
        <details class="box-section">
          <summary>Header Card Integration</summary>
          <div class="box-content">
            ${this._renderSwitch("Use Header Styling", "use_header_styling", this._config.use_header_styling === true)}
            ${this._config.use_header_styling ? html`
              <ha-alert alert-type="info">
                When inside hki-header-card, font size, weight, color, and pill styling will be inherited from the header card's Info Display settings.
              </ha-alert>
            ` : ''}
          </div>
        </details>
        
        ${!this._config.use_header_styling ? html`
        <details class="box-section">
          <summary>Appearance</summary>
          <div class="box-content">
            <ha-alert alert-type="info">
              These settings are defaults for the card. When creating notifications via the <code>hki_notify.create</code> service, you can override colors, fonts, and other styling per notification.
            </ha-alert>
            
            <div class="side-by-side ${mode === 'marquee' ? '' : 'three-col'}">
               ${this._renderSwitch("Show Icon", "show_icon", this._config.show_icon)}
               ${this._renderSwitch("Icon After Text", "icon_after", this._config.icon_after)}
               ${mode !== 'marquee' ? this._renderSwitch("Full Width", "full_width", this._config.full_width) : ''}
            </div>

            <ha-select label="Alignment" .value=${this._config.alignment || "left"} @selected=${(e) => this._valueChanged(e, "alignment")} @closed=${(e) => e.stopPropagation()}>
              ${["left","center","right"].map(a => html`<mwc-list-item .value=${a}>${a.charAt(0).toUpperCase() + a.slice(1)}</mwc-list-item>`)}
            </ha-select>

            <div class="side-by-side">
              ${this._renderColorPicker("Text Color", "text_color", this._config.text_color)}
              ${this._renderColorPicker("Icon Color", "icon_color", this._config.icon_color)}
            </div>
            
            ${this._renderSwitch("Show Background", "show_background", this._config.show_background !== false)}
            ${this._config.show_background !== false ? html`
              <div class="side-by-side">
                ${this._renderColorPicker("Background", "bg_color", this._config.bg_color)}
                ${this._renderInput("BG Opacity (0-1)", "bg_opacity", this._config.bg_opacity ?? 1, "number", "0.1")}
              </div>
              <div class="side-by-side">
                ${this._renderColorPicker("Border Color", "border_color", this._config.border_color)}
                ${this._renderInput("Border Width", "border_width", this._config.border_width, "number")}
              </div>
              ${this._renderInput("Box Shadow", "box_shadow", this._config.box_shadow)}
              ${this._renderInput("Border Radius", "border_radius", this._config.border_radius, "number")}
            ` : html`
              ${this._renderInput("Border Radius", "border_radius", this._config.border_radius, "number")}
            `}
          </div>
        </details>

        <details class="box-section">
          <summary>Typography</summary>
          <div class="box-content">
            <div class="side-by-side">
                ${this._renderInput("Size (px)", "font_size", this._config.font_size, "number")}
                <ha-select label="Weight" .value=${this._config.font_weight || "Semi Bold"} @selected=${(e) => this._valueChanged(e, "font_weight")} @closed=${(e) => e.stopPropagation()}>
                  ${["Light","Regular","Medium","Semi Bold","Bold","Extra Bold"].map(w => html`<mwc-list-item .value=${w}>${w}</mwc-list-item>`)}
                </ha-select>
            </div>
            
<ha-select label="Font Family" .value=${fontFamily} @selected=${(e) => this._valueChanged(e, "font_family")} @closed=${(e) => e.stopPropagation()}>
              ${FONTS.map(f => html`<mwc-list-item .value=${f}>${f === "Custom" ? "Custom..." : f.split(',')[0]}</mwc-list-item>`)}
            </ha-select>
            ${showCustomFont ? html`
              ${this._renderInput("Custom Font Family", "custom_font_family", this._config.custom_font_family || "", "text")}
              <p class="helper-text">Enter a CSS font-family value (e.g., "Comic Sans MS, cursive")</p>
            ` : ''}
          </div>
        </details>
        ` : ''}
        ` : ''}
      </div>
    `;
  }

  _modeChanged(ev) {
    const mode = ev.target.value;
    const newConfig = { ...this._config, display_mode: mode };
    if (mode === 'marquee') newConfig.full_width = false;
    this._fireChanged(newConfig);
  }

  _renderEntityPicker(label, field, value, helper = "", includeDomains = null, integration = null) {
      const selectorConfig = { entity: {} };
      if (includeDomains) selectorConfig.entity.domain = includeDomains;
      if (integration) selectorConfig.entity.integration = integration;
      return html`<ha-selector .hass=${this.hass} .selector=${selectorConfig} .value=${value || ""} .label=${label} .helper=${helper} @value-changed=${(ev) => this._fireChanged({ ...this._config, [field]: ev.detail.value })}></ha-selector>`;
  }

  _renderInput(label, field, value, type = "text", step = null) {
      return html`<ha-textfield .label=${label} .value=${value ?? ""} .type=${type} .step=${step || ""} @input=${(ev) => this._valueChanged(ev, field)}></ha-textfield>`;
  }

  _renderIconPicker(label, field, value) {
      return html`
        <ha-selector
          .hass=${this.hass}
          .selector=${{ icon: {} }}
          .value=${value || "mdi:bell"}
          .label=${label}
          @value-changed=${(ev) => this._fireChanged({ ...this._config, [field]: ev.detail.value })}
        ></ha-selector>
      `;
  }

  _renderSwitch(label, field, checked) {
      return html`<ha-formfield .label=${label}><ha-switch .checked=${checked !== false} @change=${(ev) => this._fireChanged({ ...this._config, [field]: ev.target.checked })}></ha-switch></ha-formfield>`;
  }

  _renderColorPicker(label, field, value) {
      return html`
        <div class="color-field">
          <label>${label}</label>
          <ha-selector
            .hass=${this.hass}
            .selector=${{ color_rgb: {} }}
            .value=${this._parseColor(value)}
            @value-changed=${(ev) => this._handleColorChange(ev, field)}
          ></ha-selector>
        </div>
      `;
  }

  _parseColor(value) {
    if (!value) return [128, 128, 128];
    
    if (value.startsWith('#')) {
      const hex = value.slice(1);
      if (hex.length === 3) {
        return [
          parseInt(hex[0] + hex[0], 16),
          parseInt(hex[1] + hex[1], 16),
          parseInt(hex[2] + hex[2], 16)
        ];
      } else if (hex.length === 6) {
        return [
          parseInt(hex.slice(0, 2), 16),
          parseInt(hex.slice(2, 4), 16),
          parseInt(hex.slice(4, 6), 16)
        ];
      }
    }
    
    const rgbMatch = value.match(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)/);
    if (rgbMatch) {
      return [parseInt(rgbMatch[1]), parseInt(rgbMatch[2]), parseInt(rgbMatch[3])];
    }
    
    return [128, 128, 128];
  }

  _handleColorChange(ev, field) {
    const rgb = ev.detail.value;
    if (rgb && Array.isArray(rgb)) {
      const hexColor = '#' + rgb.map(c => c.toString(16).padStart(2, '0')).join('');
      this._fireChanged({ ...this._config, [field]: hexColor });
    }
  }

  _valueChanged(ev, field) { this._fireChanged({ ...this._config, [field]: ev.target.value }); }

  _fireChanged(newConfig) {
    this._config = newConfig;
    this.dispatchEvent(new CustomEvent("config-changed", { detail: { config: serializeNotificationConfig(newConfig) }, bubbles: true, composed: true }));
  }

  static get styles() {
      return css`
          .card-config { display: flex; flex-direction: column; gap: 12px; padding: 8px; }
          .side-by-side { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
          .three-col { grid-template-columns: 1fr 1fr 1fr; }
          ha-textfield, ha-select, ha-selector { width: 100%; display: block; }
          ha-formfield { display: flex; align-items: center; height: 56px; }
          .helper-text { margin: -8px 0 8px 0; font-size: 12px; color: var(--secondary-text-color); }
          .color-field { display: flex; flex-direction: column; gap: 4px; }
          .color-field label { font-size: 12px; color: var(--secondary-text-color); margin-left: 4px; }
          code { background: var(--code-background-color, rgba(0,0,0,0.1)); padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
          .section { margin-top: 8px; font-weight: 600; }
          
          /* Collapsible Sections */
          details.box-section {
            background: var(--secondary-background-color);
            border-radius: 4px;
            margin-bottom: 8px;
            border: 1px solid var(--divider-color);
          }
          summary {
            padding: 12px;
            cursor: pointer;
            font-weight: 600;
            background: var(--primary-background-color);
            border-bottom: 1px solid var(--divider-color);
            list-style: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-radius: 4px 4px 0 0;
          }
          details:not([open]) summary {
            border-radius: 4px;
            border-bottom: none;
          }
          summary::-webkit-details-marker { display: none; }
          summary::after {
            content: '+'; 
            font-weight: bold;
            font-size: 1.2em;
          }
          details[open] summary::after {
            content: '-';
          }
          .box-content {
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            border-radius: 0 0 4px 4px;
          }
      `;
  }
}

if (!customElements.get(CARD_TYPE)) {
  customElements.define(CARD_TYPE, HkiNotificationCard);
}
if (!customElements.get(EDITOR_TAG)) {
  customElements.define(EDITOR_TAG, HkiNotificationCardEditor);
}
window.customCards = window.customCards || [];
window.customCards.push({ type: CARD_TYPE, name: "HKI Notification Card", description: "Animated notification ticker.", preview: true });

})();

// ============================================================
// hki-postnl-card
// ============================================================

(() => {
// HKI PostNL Card
const { LitElement, html, css } = window.HKI.getLit();
const CARD_VERSION = '1.0.2';

// Default External Assets
const DEFAULT_LOGO = "https://github.com/jimz011/hki-postnl-card/blob/main/images/postnl-logo.png?raw=true";
const DEFAULT_VAN = "https://github.com/jimz011/hki-postnl-card/blob/main/images/postnl-van.gif?raw=true";
const DEFAULT_BANNER = "https://github.com/jimz011/hki-postnl-card/blob/main/images/postnl-banner.jpg?raw=true";

class HKIPostNLCard extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this._activeTab = 'onderweg';
        this._selectedParcel = null;
        this._isRendered = false;
    }

    set hass(hass) {
        this._hass = hass;
        if (this.config && this._isRendered) {
            this.updateContent();
        } else if (this.config) {
            this.render();
        }
    }

    setConfig(config) {
        if (!config.entity) {
            // Allow render even if entity missing to show error state
        }
        this.config = {
            title: 'PostNL',
            days_back: 90,
            show_delivered: true,
            show_sent: true,
            show_animation: true,
            show_header: true,
            show_placeholder: true,
            logo_path: DEFAULT_LOGO,
            van_path: DEFAULT_VAN,
            header_color: '',
            header_text_color: '',
            placeholder_image: DEFAULT_BANNER,
            distribution_entity: '',
            layout_order: ['header', 'animation', 'tabs', 'list'],
            ...config
        };
        
        if (!Array.isArray(this.config.layout_order) || this.config.layout_order.length === 0) {
            this.config.layout_order = ['header', 'animation', 'tabs', 'list'];
        }

        this._logoSrc = this.config.logo_path || DEFAULT_LOGO;
        this._vanSrc = this.config.van_path || DEFAULT_VAN;
        
        if (this._hass) {
            this.render();
        }
    }

    static getConfigElement() {
        return document.createElement("hki-postnl-card-editor");
    }

    static getStubConfig() {
        return { 
            entity: "sensor.postnl_delivery",
            distribution_entity: "sensor.postnl_distribution",
            title: "PostNL",
            days_back: 90,
            show_delivered: true,
            show_sent: true,
            show_animation: true,
            show_header: true,
            show_placeholder: true,
            logo_path: DEFAULT_LOGO,
            van_path: DEFAULT_VAN,
            placeholder_image: DEFAULT_BANNER,
            header_color: '',
            header_text_color: '',
            layout_order: ['header', 'animation', 'tabs', 'list']
        };
    }

    getCardSize() {
        return 4;
    }

    formatDate(dateStr) {
        if (!dateStr) return "";
        return new Date(dateStr).toLocaleDateString('nl-NL', {
            day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit'
        });
    }

    getData() {
        if (!this.config.entity) return null;
        const entityId = this.config.entity;
        const stateObj = this._hass ? this._hass.states[entityId] : null;

        if (!stateObj) return null;

        const attrs = stateObj.attributes;
        let shipments = [];
        
        if (Array.isArray(attrs)) {
            shipments = attrs;
        } else if (attrs.enroute || attrs.en_route || attrs.delivered) {
            const enrouteArray = Array.isArray(attrs.enroute) ? attrs.enroute : (Array.isArray(attrs.en_route) ? attrs.en_route : []);
            const deliveredArray = Array.isArray(attrs.delivered) ? attrs.delivered : [];
            shipments = [...enrouteArray, ...deliveredArray];
        } else if (attrs.shipments) {
            shipments = attrs.shipments;
        } else if (attrs.parcels) {
            shipments = attrs.parcels;
        } else {
            shipments = Object.values(attrs).filter(item => item && item.key);
        }

        const cutoffDate = new Date();
        cutoffDate.setDate(cutoffDate.getDate() - (this.config.days_back || 90));

        shipments = shipments.filter(item => {
            if (!item.delivered) return true;
            const dDate = new Date(item.delivery_date || item.planned_date || 0);
            return dDate >= cutoffDate;
        });

        return shipments;
    }

    getDistributionData() {
        if (!this.config.distribution_entity) return [];
        
        const stateObj = this._hass ? this._hass.states[this.config.distribution_entity] : null;
        if (!stateObj) return [];

        const attrs = stateObj.attributes;
        let shipments = [];
        
        if (Array.isArray(attrs)) {
            shipments = attrs;
        } else if (attrs.en_route || attrs.delivered || attrs.Enroute || attrs.Delivered) {
            const enroute = attrs.en_route || attrs.Enroute || [];
            const delivered = attrs.delivered || attrs.Delivered || [];
            shipments = [...enroute, ...delivered];
        } else if (attrs.shipments) {
            shipments = attrs.shipments;
        } else if (attrs.parcels) {
            shipments = attrs.parcels;
        } else {
            shipments = Object.values(attrs).filter(item => item && item.key);
        }

        return shipments;
    }

    getFilteredShipments(shipments, distributionShipments) {
        let filtered = [];
        
        if (this._activeTab === 'onderweg') {
            filtered = shipments.filter(item => !item.delivered);
        } else if (this._activeTab === 'bezorgd') {
            filtered = shipments.filter(item => item.delivered);
        } else if (this._activeTab === 'verzonden') {
            filtered = distributionShipments;
        }

        filtered.sort((a, b) => {
            const dateA = new Date(a.delivery_date || a.planned_date || a.expected_datetime || 0);
            const dateB = new Date(b.delivery_date || b.planned_date || b.expected_datetime || 0);
            return dateB - dateA;
        });

        return filtered;
    }

    handleTabClick(e) {
        const tab = e.currentTarget.dataset.tab;
        if (tab === this._activeTab) return;
        
        this._activeTab = tab;
        this._selectedParcel = null;
        this.updateContent();
    }

    handleParcelClick(e) {
        const key = e.currentTarget.dataset.key;
        
        if (this._selectedParcel === key) {
            this._selectedParcel = null;
        } else {
            this._selectedParcel = key;
        }
        
        this.updateContent();
    }

    updateContent() {
        if (!this._isRendered) return;

        const shipments = this.getData();
        const distributionShipments = this.getDistributionData();
        if (!shipments) return;

        const displayedShipments = this.getFilteredShipments(shipments, distributionShipments);
        const activeCount = shipments.filter(s => !s.delivered).length;
        const recentCount = shipments.filter(s => s.delivered).length;

        const statsEl = this.shadowRoot.querySelector('.header-stats');
        const statsBarEl = this.shadowRoot.querySelector('.stats-text');
        
        const statsText = `${activeCount} onderweg â€¢ ${recentCount} recent`;
        if (statsEl) statsEl.textContent = statsText;
        if (statsBarEl) statsBarEl.textContent = statsText;

        this.shadowRoot.querySelectorAll('.tab').forEach(tab => {
            if (tab.dataset.tab === this._activeTab) {
                tab.classList.add('active');
            } else {
                tab.classList.remove('active');
            }
        });

        this.updateAnimation(displayedShipments);
        this.updateList(displayedShipments);
    }

    updateAnimation(displayedShipments) {
        const animationEl = this.shadowRoot.querySelector('.header-animation');
        if (!animationEl) return;

        const selectedParcelData = this._selectedParcel 
            ? displayedShipments.find(s => s.key === this._selectedParcel)
            : null;

        if (this.config.show_animation && selectedParcelData) {
            const vanPos = selectedParcelData.delivered ? '75%' : '25%';
            const statusText = selectedParcelData.delivered ? 'Bezorgd' : 'Onderweg';
            
            animationEl.classList.add('animation-active');
            
            animationEl.innerHTML = `
                <div class="visual-road">
                    <div class="house-bg">ðŸ </div>
                    <div class="road-line"></div>
                    <img class="van-img" src="${this._vanSrc}" style="margin-left: ${vanPos};" alt="PostNL Van">
                </div>
                <div class="animation-info">
                    <strong>${selectedParcelData.name}</strong> â€¢ ${statusText}
                </div>
            `;
        } else {
            animationEl.classList.remove('animation-active');
            
            if (this.config.show_placeholder) {
                if (!this.config.placeholder_image) {
                    animationEl.innerHTML = `
                        <div class="animation-placeholder">
                            <div class="placeholder-text">Selecteer een pakket voor animatie</div>
                        </div>
                    `;
                } else {
                    animationEl.innerHTML = '';
                }
            } else {
                animationEl.innerHTML = '';
            }
        }
    }

    updateList(displayedShipments) {
        const listEl = this.shadowRoot.querySelector('.list');
        if (!listEl) return;

        const currentKeys = Array.from(listEl.querySelectorAll('.parcel-header')).map(el => el.dataset.key);
        const newKeys = displayedShipments.map(s => s.key);
        const needsRebuild = JSON.stringify(currentKeys) !== JSON.stringify(newKeys);

        if (displayedShipments.length === 0) {
            listEl.innerHTML = `
                <div class="empty-state">
                    <ha-icon icon="mdi:package-variant-closed" style="width: 48px; height: 48px; margin-bottom: 10px;"></ha-icon>
                    <div>Geen pakketten in deze categorie</div>
                </div>`;
            return;
        }

        if (needsRebuild) {
            listEl.innerHTML = displayedShipments.map(item => {
                const isDelivered = item.delivered;
                const statusMsg = item.status_message || (isDelivered ? "Bezorgd" : "Onderweg");
                const dateLabel = this.formatDate(item.delivery_date || item.planned_date || item.planned_to);
                
                return `
                <div class="parcel" data-key="${item.key}">
                    <div class="parcel-header" data-key="${item.key}">
                        <div class="ph-left">
                            <span class="ph-name">${item.name || 'Onbekend'}</span>
                            <span class="ph-status">
                                <ha-icon class="ph-status-icon" icon="${isDelivered ? 'mdi:check-circle' : 'mdi:truck-delivery'}" style="width:16px;height:16px;"></ha-icon>
                                ${statusMsg}
                            </span>
                        </div>
                        <div class="ph-right">
                            <div class="ph-date">${dateLabel || ''}</div>
                            <ha-icon class="chevron" icon="mdi:chevron-down"></ha-icon>
                        </div>
                    </div>
                    
                    <div class="details-panel">
                        <div class="detail-row">
                            <strong>Track & Trace:</strong> ${item.key}
                        </div>
                        ${item.shipment_type ? `<div class="detail-row"><strong>Type:</strong> ${item.shipment_type === 'LetterboxParcel' ? 'Brievenbuspakje' : 'Pakket'}</div>` : ''}
                        ${item.delivery_address_type ? `<div class="detail-row"><strong>Bezorging:</strong> ${item.delivery_address_type === 'ServicePoint' ? 'Afhaalpunt' : 'Thuisbezorging'}</div>` : ''}
                        <a href="${item.url}" target="_blank" class="btn-track">OPEN TRACK & TRACE â†—</a>
                    </div>
                </div>`;
            }).join('');

            this.shadowRoot.querySelectorAll('.parcel-header').forEach(el => {
                el.addEventListener('click', this.handleParcelClick.bind(this));
            });
        } else {
            this.shadowRoot.querySelectorAll('.parcel').forEach(parcelEl => {
                const key = parcelEl.dataset.key;
                if (key === this._selectedParcel) {
                    parcelEl.classList.add('selected');
                } else {
                    parcelEl.classList.remove('selected');
                }
            });
        }
    }

    render() {
        const shipments = this.getData();
        const distributionShipments = this.getDistributionData();
        
        if (!shipments) {
            this.shadowRoot.innerHTML = `<ha-card style="padding:16px; color:red;">Entiteit niet gevonden of niet geconfigureerd.<br><br>Installeer a.u.b. de <a href="https://github.com/arjenbos/ha-postnl" target="_blank">arjenbos/ha-postnl</a> integratie.</ha-card>`;
            return;
        }

        const displayedShipments = this.getFilteredShipments(shipments, distributionShipments);
        const activeCount = shipments.filter(s => !s.delivered).length;
        const recentCount = shipments.filter(s => s.delivered).length;
        const headerColor = this.config.header_color || 'var(--card-background-color)';
        const headerTextColor = this.config.header_text_color || 'var(--primary-text-color)';
        const placeholderImage = this.config.placeholder_image || DEFAULT_BANNER;

        const css = `
        <style>
            :host { 
                --postnl-orange: #ed8c00; 
                --postnl-purple: ${headerColor};
                --header-text: ${headerTextColor};
                --placeholder-image: ${placeholderImage ? `url('${placeholderImage}')` : 'none'};
                --bg-color: var(--card-background-color, white); 
            }
            ha-card { 
                background: var(--bg-color); 
                color: var(--primary-text-color); 
                overflow: hidden; 
                border-radius: 12px; 
            }
            
            /* Header Block */
            .header { 
                background: var(--postnl-purple);
                padding: 16px; 
                color: var(--header-text); 
                display: flex; 
                align-items: center; 
                gap: 12px; 
            }
            .header img { 
                height: 36px; 
                border-radius: 6px; 
                background: white; 
                padding: 4px; 
            }
            .header-info { 
                display: flex; 
                flex-direction: column; 
                flex: 1;
            }
            .header-title { 
                font-weight: bold; 
                font-size: 1.1em; 
            }
            .header-stats { 
                font-size: 0.8em; 
                opacity: 0.9; 
            }
            .stats-bar {
                background: var(--secondary-background-color, #f5f5f5);
                padding: 8px 16px;
                border-bottom: 1px solid var(--divider-color, #eee);
                text-align: center;
            }
            .stats-text {
                font-size: 0.85em;
                color: var(--secondary-text-color);
                font-weight: 500;
            }

            /* Tabs Block */
            .tabs { 
                display: flex; 
                background: var(--secondary-background-color, #f5f5f5); 
                border-bottom: 1px solid var(--divider-color, #eee); 
            }
            .tab { 
                flex: 1; 
                text-align: center; 
                padding: 12px; 
                cursor: pointer; 
                font-size: 0.9em; 
                font-weight: 500; 
                color: var(--secondary-text-color); 
                position: relative; 
                transition: all 0.2s;
                user-select: none;
            }
            .tab:hover {
                background: rgba(237, 140, 0, 0.1);
            }
            .tab.active { 
                color: var(--postnl-orange); 
                font-weight: bold; 
            }
            .tab.active::after { 
                content: ''; 
                position: absolute; 
                bottom: 0; 
                left: 0; 
                right: 0; 
                height: 3px; 
                background: var(--postnl-orange); 
            }

            /* Animation Block */
            .header-animation {
                background-image: var(--placeholder-image);
                background-size: cover;
                background-position: center;
                background-repeat: no-repeat;
                padding: 16px;
                border-bottom: 1px solid var(--divider-color);
                height: 150px;
                box-sizing: border-box;
            }
            .header-animation.animation-active {
                background-image: none !important;
                background-color: var(--card-background-color);
            }
            .visual-road { 
                position: relative; 
                height: 80px; 
                display: flex; 
                align-items: center; 
                overflow: hidden;
                background: var(--card-background-color, white);
            }
            .road-line { 
                position: absolute; 
                bottom: 20px; 
                left: 0; 
                right: 0; 
                height: 3px; 
                background: repeating-linear-gradient(
                    to right,
                    #ccc 0px,
                    #ccc 15px,
                    transparent 15px,
                    transparent 30px
                );
                z-index: 1; 
            }
            .house-bg { 
                position: absolute; 
                right: 30px; 
                bottom: 15px; 
                font-size: 36px; 
                opacity: 0.3; 
                z-index: 0; 
            }
            .van-img { 
                height: 50px; 
                z-index: 2; 
                transition: margin-left 1.5s ease-in-out; 
                margin-bottom: 6px; 
                position: relative;
            }
            .animation-info {
                text-align: center;
                margin-top: 8px;
                font-size: 0.85em;
                color: var(--secondary-text-color);
                background: var(--card-background-color, white);
            }
            .animation-info strong {
                color: var(--primary-text-color);
            }
            .animation-placeholder {
                display: flex;
                align-items: center;
                justify-content: center;
                height: 118px;
            }
            .placeholder-text {
                color: var(--secondary-text-color);
                font-size: 0.9em;
                opacity: 0.6;
            }

            /* List Block */
            .list { 
                padding: 0; 
                margin: 0; 
                max-height: 500px;
                overflow-y: auto;
            }
            .empty-state { 
                padding: 40px; 
                text-align: center; 
                color: var(--secondary-text-color); 
                opacity: 0.7; 
            }
            
            .parcel { 
                border-bottom: 1px solid var(--divider-color, #eee); 
            }
            .parcel.selected {
                background: rgba(237, 140, 0, 0.05);
            }
            .parcel-header { 
                padding: 16px; 
                cursor: pointer; 
                display: flex; 
                justify-content: space-between; 
                align-items: center; 
                transition: background 0.2s;
                user-select: none;
            }
            .parcel-header:hover { 
                background: var(--secondary-background-color); 
            }
            
            .ph-left { 
                display: flex; 
                flex-direction: column;
                flex: 1;
            }
            .ph-name { 
                font-weight: 600; 
                font-size: 1em;
                margin-bottom: 4px;
            }
            .ph-status { 
                font-size: 0.85em; 
                color: var(--secondary-text-color); 
                display: flex; 
                align-items: center; 
                gap: 10px; 
            }
            .ph-status-icon { 
                color: var(--postnl-orange);
                flex-shrink: 0;
                display: flex;
                align-items: center;
            }

            .ph-right { 
                display: flex;
                flex-direction: column;
                align-items: flex-end;
                gap: 4px;
            }
            .ph-date {
                font-size: 0.85em; 
                color: var(--secondary-text-color); 
            }
            .chevron { 
                transition: transform 0.3s;
                margin-left: 8px;
            }
            .selected .chevron { 
                transform: rotate(180deg); 
                color: var(--postnl-orange);
            }

            .details-panel {
                padding: 12px 16px;
                background: var(--secondary-background-color);
                border-top: 1px solid var(--divider-color);
                font-size: 0.9em;
                color: var(--secondary-text-color);
                display: none;
                max-height: 0;
                overflow: hidden;
                transition: max-height 0.3s ease-out;
            }
            .selected .details-panel {
                display: block;
                max-height: 200px;
            }
            .detail-row {
                margin-bottom: 6px;
            }
            .detail-row strong {
                color: var(--primary-text-color);
            }
            .btn-track { 
                background: var(--postnl-orange); 
                color: white; 
                text-decoration: none; 
                padding: 8px 16px; 
                border-radius: 6px; 
                font-size: 0.9em; 
                font-weight: 600; 
                display: inline-block;
                margin-top: 8px;
                transition: all 0.2s;
            }
            .btn-track:hover {
                background: #d17a00;
                box-shadow: 0 2px 8px rgba(237, 140, 0, 0.3);
            }
            .list::-webkit-scrollbar {
                width: 6px;
            }
            .list::-webkit-scrollbar-track {
                background: transparent;
            }
            .list::-webkit-scrollbar-thumb {
                background: var(--divider-color);
                border-radius: 3px;
            }
        </style>
        `;

        // Pre-build list HTML
        let listHtml = '';
        if (displayedShipments.length === 0) {
            listHtml = `
            <div class="empty-state">
                <ha-icon icon="mdi:package-variant-closed" style="width: 48px; height: 48px; margin-bottom: 10px;"></ha-icon>
                <div>Geen pakketten in deze categorie</div>
            </div>`;
        } else {
            listHtml = displayedShipments.map(item => {
                const isDelivered = item.delivered;
                const statusMsg = item.status_message || (isDelivered ? "Bezorgd" : "Onderweg");
                const dateLabel = this.formatDate(item.delivery_date || item.planned_date || item.planned_to);
                
                return `
                <div class="parcel" data-key="${item.key}">
                    <div class="parcel-header" data-key="${item.key}">
                        <div class="ph-left">
                            <span class="ph-name">${item.name || 'Onbekend'}</span>
                            <span class="ph-status">
                                <ha-icon class="ph-status-icon" icon="${isDelivered ? 'mdi:check-circle' : 'mdi:truck-delivery'}" style="width:16px;height:16px;"></ha-icon>
                                ${statusMsg}
                            </span>
                        </div>
                        <div class="ph-right">
                            <div class="ph-date">${dateLabel || ''}</div>
                            <ha-icon class="chevron" icon="mdi:chevron-down"></ha-icon>
                        </div>
                    </div>
                    
                    <div class="details-panel">
                        <div class="detail-row">
                            <strong>Track & Trace:</strong> ${item.key}
                        </div>
                        ${item.shipment_type ? `<div class="detail-row"><strong>Type:</strong> ${item.shipment_type === 'LetterboxParcel' ? 'Brievenbuspakje' : 'Pakket'}</div>` : ''}
                        ${item.delivery_address_type ? `<div class="detail-row"><strong>Bezorging:</strong> ${item.delivery_address_type === 'ServicePoint' ? 'Afhaalpunt' : 'Thuisbezorging'}</div>` : ''}
                        <a href="${item.url}" target="_blank" class="btn-track">OPEN TRACK & TRACE â†—</a>
                    </div>
                </div>`;
            }).join('');
        }

        // Define Blocks
        const blocks = {
            header: this.config.show_header ? `
                <div class="header">
                    <img src="${this._logoSrc}" alt="PostNL Logo">
                    <div class="header-info">
                        <span class="header-title">${this.config.title || 'PostNL'}</span>
                        <span class="header-stats">${activeCount} onderweg â€¢ ${recentCount} recent</span>
                    </div>
                </div>
                ` : `
                <div class="stats-bar">
                    <span class="stats-text">${activeCount} onderweg â€¢ ${recentCount} recent</span>
                </div>
            `,
            animation: this.config.show_placeholder !== false ? `<div class="header-animation"></div>` : '',
            tabs: `
                <div class="tabs">
                    <div class="tab ${this._activeTab === 'onderweg' ? 'active' : ''}" data-tab="onderweg">Onderweg</div>
                    ${this.config.show_delivered ? `<div class="tab ${this._activeTab === 'bezorgd' ? 'active' : ''}" data-tab="bezorgd">Bezorgd</div>` : ''}
                    ${this.config.show_sent ? `<div class="tab ${this._activeTab === 'verzonden' ? 'active' : ''}" data-tab="verzonden">Verzonden</div>` : ''}
                </div>
            `,
            list: `<div class="list">${listHtml}</div>`
        };

        // Construct HTML based on layout order
        const layoutOrder = this.config.layout_order || ['header', 'animation', 'tabs', 'list'];
        const contentHtml = layoutOrder.map(blockName => blocks[blockName] || '').join('');

        this.shadowRoot.innerHTML = css + `<ha-card>${contentHtml}</ha-card>`;
        this._isRendered = true;
        
        this.shadowRoot.querySelectorAll('.tab').forEach(el => {
            el.addEventListener('click', this.handleTabClick.bind(this));
        });
        this.shadowRoot.querySelectorAll('.parcel-header').forEach(el => {
            el.addEventListener('click', this.handleParcelClick.bind(this));
        });
    }
}

// EDITOR CLASS
class HKIPostNLCardEditor extends LitElement {
    static get properties() {
        return {
            hass: { type: Object },
            _config: { attribute: false }
        };
    }

    constructor() {
        super();
        this._config = {};
    }

    setConfig(config) {
        this._config = {
            entity: 'sensor.postnl_delivery',
            distribution_entity: 'sensor.postnl_distribution',
            title: 'PostNL',
            days_back: 90,
            show_delivered: true,
            show_sent: true,
            show_animation: true,
            show_header: true,
            show_placeholder: true,
            logo_path: DEFAULT_LOGO,
            van_path: DEFAULT_VAN,
            header_color: '',
            header_text_color: '',
            placeholder_image: DEFAULT_BANNER,
            layout_order: ['header', 'animation', 'tabs', 'list'],
            ...config
        };
        // Ensure defaults if keys missing
        if (!this._config.layout_order) this._config.layout_order = ['header', 'animation', 'tabs', 'list'];
    }

    _renderEntityPicker(label, field, value, helper = "") {
        return html`
            <ha-selector
                .hass=${this.hass}
                .selector=${{ entity: {} }}
                .value=${value || ""}
                .label=${label}
                .helper=${helper}
                @value-changed=${(ev) => this._changed(ev, field)}
            ></ha-selector>
        `;
    }

    _val(ev) {
        return ev.detail?.value ?? ev.target?.value;
    }

    _changed(ev, explicitField = null) {
        ev.stopPropagation();
        const field = explicitField || ev.target?.dataset?.field;
        if (!field || !this._config) return;

        let value = this._val(ev);

        // Handle numeric fields
        const numeric = new Set(['days_back']);
        if (numeric.has(field)) {
            value = parseInt(value, 10);
        }

        // Handle boolean fields
        const bools = new Set(['show_delivered', 'show_sent', 'show_animation', 'show_header', 'show_placeholder']);
        if (bools.has(field)) {
            value = !!(ev.target?.checked ?? value);
        }

        const next = { ...this._config, [field]: value };
        this._config = next;

        this.dispatchEvent(new CustomEvent("config-changed", {
            detail: { config: next },
            bubbles: true,
            composed: true
        }));
    }

    _moveBlock(index, direction) {
        if (!this._config.layout_order) return;
        const newOrder = [...this._config.layout_order];
        
        if (direction === 'up' && index > 0) {
            [newOrder[index], newOrder[index - 1]] = [newOrder[index - 1], newOrder[index]];
        } else if (direction === 'down' && index < newOrder.length - 1) {
            [newOrder[index], newOrder[index + 1]] = [newOrder[index + 1], newOrder[index]];
        }
        
        this._config = { ...this._config, layout_order: newOrder };
        this.dispatchEvent(new CustomEvent("config-changed", {
            detail: { config: this._config },
            bubbles: true,
            composed: true
        }));
    }

    static get styles() {
        return css`
            .card-config {
                padding: 16px;
            }
            .section {
                margin-top: 24px;
                margin-bottom: 12px;
                font-weight: 600;
                font-size: 14px;
                color: var(--primary-text-color);
                text-transform: uppercase;
                letter-spacing: 0.5px;
                border-bottom: 2px solid var(--divider-color);
                padding-bottom: 8px;
            }
            .helper-text {
                font-size: 12px;
                color: var(--secondary-text-color);
                margin: 4px 0 16px 0;
                font-style: italic;
            }
            .inline-fields-2 {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 12px;
                margin-bottom: 16px;
            }
            ha-selector,
            ha-textfield {
                width: 100%;
                margin-bottom: 16px;
            }
            .switch-row {
                display: flex;
                align-items: center;
                gap: 16px;
                margin-bottom: 8px;
                width: 100%;
            }
            .switch-row ha-switch {
                flex-shrink: 0;
                margin-bottom: 0;
            }
            .switch-row span {
                font-size: 14px;
                color: var(--primary-text-color);
                flex: 1;
                line-height: 1.4;
            }
            /* Sortable list styling */
            .sort-item {
                display: flex;
                align-items: center;
                justify-content: space-between;
                background: var(--secondary-background-color);
                border: 1px solid var(--divider-color);
                padding: 8px 12px;
                margin-bottom: 8px;
                border-radius: 4px;
            }
            .sort-label {
                font-weight: 500;
                text-transform: capitalize;
            }
            .sort-actions ha-icon-button {
                color: var(--secondary-text-color);
            }
            .sort-actions ha-icon-button:hover {
                color: var(--primary-text-color);
            }
            /* Warning Box Styling */
            .warning-box {
                background-color: var(--secondary-background-color);
                border: 1px solid var(--divider-color);
                border-left: 4px solid #ed8c00;
                padding: 12px;
                margin-bottom: 24px;
                font-size: 13px;
                line-height: 1.4;
                border-radius: 4px;
                color: var(--primary-text-color);
            }
            .warning-title {
                font-weight: bold;
                font-size: 14px;
                margin-bottom: 8px;
                display: flex;
                align-items: center;
            }
            .warning-box a {
                color: var(--primary-color, #03a9f4);
                text-decoration: underline;
            }
            .warning-error {
                margin-top: 8px; 
                color: var(--error-color, red);
                font-weight: 500;
            }
        `;
    }

    render() {
        if (!this._config) return html``;
        
        const layoutLabels = {
            'header': 'Header (Logo/Titel)',
            'animation': 'Animatie / Afbeelding',
            'tabs': 'Navigatie Tabs',
            'list': 'Pakketten Lijst'
        };

        const currentLayout = this._config.layout_order || ['header', 'animation', 'tabs', 'list'];

        return html`
            <div class="card-config">
                <div class="warning-box">
                    <div class="warning-title">âš ï¸ Requirement</div>
                    <div><strong>This card requires the PostNL integration.</strong></div>
                    <div>You must install and configure the <a href="https://github.com/arjenbos/ha-postnl" target="_blank">PostNL Integration by Arjen Bos</a> before using this card.</div>
                    <div style="margin-top: 8px;">Please read the <a href="https://jimz011.github.io/hki-elements/" target="_blank" rel="noopener noreferrer">documentation</a> to set up this card.</div>
                    <div class="warning-error">This card may contain bugs. Use at your own risk!</div>
                </div>

                <div class="section">Basis Instellingen</div>
                
                ${this._renderEntityPicker(
                    "PostNL Ontvangst Entity",
                    "entity",
                    this._config.entity,
                    "De entity voor ontvangen pakketten (standaard: sensor.postnl_delivery)"
                )}

                ${this._renderEntityPicker(
                    "PostNL Verzending Entity (Optioneel)",
                    "distribution_entity",
                    this._config.distribution_entity || "",
                    "De entity voor verzonden pakketten (standaard: sensor.postnl_distribution)"
                )}

                <ha-textfield
                    label="Kaartnaam"
                    .value=${this._config.title || 'PostNL'}
                    placeholder="PostNL"
                    data-field="title"
                    @input=${this._changed}
                ></ha-textfield>

                <ha-textfield
                    label="Aantal dagen geschiedenis"
                    type="number"
                    .value=${String(this._config.days_back || 90)}
                    min="1"
                    max="365"
                    data-field="days_back"
                    @input=${this._changed}
                ></ha-textfield>

                <div class="section">Layout Volgorde</div>
                <div class="helper-text">Gebruik de pijltjes om de blokken te herschikken</div>
                ${currentLayout.map((item, index) => html`
                    <div class="sort-item">
                        <span class="sort-label">${layoutLabels[item] || item}</span>
                        <div class="sort-actions">
                            <ha-icon-button 
                                .path=${"M7.41,15.41L12,10.83L16.59,15.41L18,14L12,8L6,14L7.41,15.41Z"}
                                @click=${() => this._moveBlock(index, 'up')}
                                ?disabled=${index === 0}
                            ></ha-icon-button>
                            <ha-icon-button 
                                .path=${"M7.41,8.59L12,13.17L16.59,8.59L18,10L12,16L6,10L7.41,8.59Z"}
                                @click=${() => this._moveBlock(index, 'down')}
                                ?disabled=${index === currentLayout.length - 1}
                            ></ha-icon-button>
                        </div>
                    </div>
                `)}

                <div class="section">Weergave Opties</div>

                <div class="switch-row">
                    <ha-switch
                        .checked=${this._config.show_header !== false}
                        data-field="show_header"
                        @change=${this._changed}
                    ></ha-switch>
                    <span>Toon header</span>
                </div>

                <div class="switch-row">
                    <ha-switch
                        .checked=${this._config.show_delivered !== false}
                        data-field="show_delivered"
                        @change=${this._changed}
                    ></ha-switch>
                    <span>Toon "Bezorgd" tab</span>
                </div>

                <div class="switch-row">
                    <ha-switch
                        .checked=${this._config.show_sent !== false}
                        data-field="show_sent"
                        @change=${this._changed}
                    ></ha-switch>
                    <span>Toon "Verzonden" tab</span>
                </div>

                <div class="switch-row">
                    <ha-switch
                        .checked=${this._config.show_animation !== false}
                        data-field="show_animation"
                        @change=${this._changed}
                    ></ha-switch>
                    <span>Toon bezorganimatie</span>
                </div>

                <div class="switch-row">
                    <ha-switch
                        .checked=${this._config.show_placeholder !== false}
                        data-field="show_placeholder"
                        @change=${this._changed}
                    ></ha-switch>
                    <span>Toon placeholder</span>
                </div>

                <div class="section">Uiterlijk</div>

                <div class="inline-fields-2">
                    <ha-textfield
                        label="Header Kleur"
                        type="color"
                        .value=${this._config.header_color || '#f0f0f0'}
                        data-field="header_color"
                        @input=${this._changed}
                    ></ha-textfield>

                    <ha-textfield
                        label="Header Tekst Kleur"
                        type="color"
                        .value=${this._config.header_text_color || '#000000'}
                        data-field="header_text_color"
                        @input=${this._changed}
                    ></ha-textfield>
                </div>

                <ha-textfield
                    label="Placeholder Afbeelding (URL)"
                    .value=${this._config.placeholder_image || DEFAULT_BANNER}
                    placeholder="http://..."
                    data-field="placeholder_image"
                    @input=${this._changed}
                ></ha-textfield>

                <ha-textfield
                    label="PostNL Logo (URL)"
                    .value=${this._config.logo_path || DEFAULT_LOGO}
                    placeholder="http://..."
                    data-field="logo_path"
                    @input=${this._changed}
                ></ha-textfield>

                <ha-textfield
                    label="Bezorgbusje Afbeelding (URL)"
                    .value=${this._config.van_path || DEFAULT_VAN}
                    placeholder="http://..."
                    data-field="van_path"
                    @input=${this._changed}
                ></ha-textfield>
            </div>
        `;
    }
}

if (!customElements.get('hki-postnl-card')) {
    customElements.define('hki-postnl-card', HKIPostNLCard);
}
if (!customElements.get('hki-postnl-card-editor')) {
    customElements.define('hki-postnl-card-editor', HKIPostNLCardEditor);
}

window.customCards = window.customCards || [];
window.customCards.push({
    type: "hki-postnl-card",
    name: "HKI PostNL Card",
    description: "PostNL Track & Trace Card",
    preview: true
});

})();
